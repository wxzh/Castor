(let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) in (let u = true in (((\x: Unit .\y: Nat .x) 1 ) false))) , b = (fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) )) }.b) )) in (let u = ({a = (case <l = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = ({a = true , b = 1 }.b) in (iszero (fix (\x: Nat . 0 )))) }.b) in u))
({a = (pred ({a = (succ (let u = 0 in u)) , b = ({a = true , b = 0 }.a) }.a)) , b = (case <l = (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then (( \f: Unit .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) ) 1 ) ) (\a: Nat .\b: Unit .b)) else ({a = 1 , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(( \f: Bool .((f (if (( \f: Rec X. X .((f ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = false }.b) ) (let u = (((\x: Bool .\y: Nat .x) true ) true) in u) ) ) (\a: Unit .\b: Unit .b)) then (((\x: Bool .\y: Rec X. X .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) else (((\x: Nat .\y: Unit .x) (let u = 1 in false) ) (let u = false in true))) ) (( \f: Rec X. X .((f (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) (let u = false in u)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ))) ) ({a = ({a = 0 , b = true , c =  1 }.b) , b = (let u = 0 in u) }.a) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .a))
(( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (if (iszero 1) then true else false) )) ) ({a = (if ({a = (if true then false else true) , b = (let u = 1 in true) }.b) then ({a = 1 , b = ({a = 0 , b = true }.a) }.b) else (unfold [ Unit ] (fold [ Nat ] 0 ))) , b = (if (( \f: Nat .((f (if true then false else false) ) true ) ) (\a: Rec X. X .\b: Nat .b)) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) else (let u = 1 in true)) , c =  (( \f: Rec X. X .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in 1) ) ) (\a: Bool .\b: Unit .a)) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f ({a = (let u = 1 in u) , b = false , c =  (((\x: Bool .\y: Bool .x) 0 ) false) }.b) ) ({a = (((\x: Nat .\y: Nat .y) true ) 1) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) )) ))
(let u = (( \f: Bool .((f (let u = ({a = (((\x: Bool .\y: Nat .x) 1 ) true) , b = false }.b) in ({a = false , b = 0 }.b)) ) (pred ({a = (case <r = ({a = true , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = true , c = 1 }.c) ) false) }.b)) ) ) (\a: Bool .\b: Unit .b)) in (let u = (( \f: Unit .((f false ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Bool .b)) in u))
(fix (\x: Unit . ({a = (((\x: Unit .\y: Rec X. X .x) (case <l = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b))) , b = (let u = (let u = (( \f: Rec X. X .((f ({a = 1 , b = true , c = 1 }.c) ) ({a = 1 , b = 0 }.b) ) ) (\a: Nat .\b: Unit .a)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false ))) in u) }.a) ))
({a = (((\x: Nat .\y: Unit .y) (iszero (fix (\x: Bool . (pred 0) ))) ) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = (let u = 0 in true) , c = (((\x: Rec X. X .\y: Bool .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Nat .x) 1 ) true)) }.c)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) in u) )) }.a)
({a = (( \f: Bool .((f (pred (((\x: Nat .\y: Unit .y) ({a = false , b = 0 }.a) ) 0)) ) (((\x: Bool .\y: Rec X. X .x) (if ({a = 1 , b = true }.b) then (if false then 0 else 1) else ({a = 1 , b = 0 }.b)) ) ({a = (let u = false in 0) , b = (if false then true else false) }.b)) ) ) (\a: Bool .\b: Unit .a)) , b = (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) }.b)
(pred (((\x: Nat .\y: Rec X. X .x) (( \f: Unit .((f (let u = 0 in 0) ) ({a = 1 , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Nat .\y: Nat .x) false ) true)))
(let u = (fix (\x: Nat . ({a = (if false then false else false) , b = 0 }.b) )) in (iszero (let u = (let u = true in false) in ({a = 1 , b = 1 }.b))))
(let u = (let u = (((\x: Unit .\y: Unit .x) (let u = (iszero 1) in u) ) (((\x: Rec X. X .\y: Nat .x) ({a = false , b = 1 }.a) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )))) in (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Bool ] true )) ))) in ({a = (let u = (let u = ({a = 1 , b = false , c = 0 }.c) in true) in (((\x: Unit .\y: Bool .y) false ) 0)) , b = (unfold [ Bool ] (fold [ Unit ] (if (if false then false else true) then (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) else (case <r = true > as Bool of < l = x > => x | < r = y > => y)) )) , c =  (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in 1) )) }.b))
(iszero (( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = false , b = 1 }.a) in 1) )) ) (let u = (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a)) in ({a = ({a = true , b = 0 }.a) , b = (((\x: Nat .\y: Bool .y) true ) 0) }.b)) ) ) (\a: Rec X. X .\b: Nat .b)))
(((\x: Rec X. X .\y: Bool .x) (pred ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = ({a = 1 , b = (unfold [ Nat ] (fold [ Bool ] false )) , c = (if false then 0 else 1) }.c) }.b)) ) ({a = (if (unfold [ Bool ] (fold [ Nat ] true )) then (( \f: Unit .((f false ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Rec X. X .a)) else ({a = 0 , b = true }.b)) , b = (let u = (let u = false in u) in (let u = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) in u)) }.a))
(unfold [ Bool ] (fold [ Nat ] (case <l = ({a = ({a = (succ 1) , b = 1 }.b) , b = (let u = (let u = false in 1) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(let u = (iszero ({a = (succ 1) , b = true , c = 0 }.c)) in (unfold [ Rec X. X ] (fold [ Bool ] (case <l = ({a = 1 , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .a)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) )))
({a = ({a = ({a = ({a = ({a = true , b = 1 }.a) , b = ({a = 1 , b = true , c = 0 }.c) }.b) , b = ({a = (succ 1) , b = 1 }.b) }.b) , b = (let u = ({a = 1 , b = 0 }.b) in ({a = 1 , b = (let u = false in false) }.b)) , c =  (let u = ({a = (if true then 1 else 0) , b = (((\x: Bool .\y: Bool .y) false ) true) , c = (let u = (unfold [ Unit ] (fold [ Unit ] 0 )) in 1) }.c) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Nat .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in 1) ) ) (\a: Bool .\b: Nat .a)) )) }.a)
(( \f: Unit .((f (( \f: Bool .((f ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = (let u = 0 in true) }.b) ) (((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Bool .y) true ) ({a = true , b = true }.b)) ) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a))) ) ) (\a: Nat .\b: Unit .b)) ) (let u = (let u = (if ({a = false , b = 1 }.a) then (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) else (fix (\x: Rec X. X . ({a = 0 , b = true }.b) ))) in u) in u) ) ) (\a: Bool .\b: Unit .b))
({a = (((\x: Nat .\y: Nat .x) (( \f: Nat .((f ({a = ({a = true , b = 0 }.b) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b)) , c =  0 }.b) ) (fix (\x: Nat . (iszero 1) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u)) , b = ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .b)) , b = ({a = (let u = 1 in (let u = true in 0)) , b = (( \f: Nat .((f false ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Unit .a)) , c =  ({a = 1 , b = true }.a) }.b) }.b) }.b)
(fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (let u = 1 in u) , b = ({a = 0 , b = false }.b) , c =  (pred (pred 0)) }.b) )) ))
({a = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Rec X. X .((f (pred 1) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) , b = ({a = (fix (\x: Nat . (( \f: Unit .((f ({a = 1 , b = 0 }.b) ) (pred 0) ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = (let u = false in u) }.b) , c =  ({a = ({a = ({a = 0 , b = 0 }.b) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (((\x: Bool .\y: Unit .y) true ) 0) }.b) , b = (( \f: Bool .((f 0 ) (if false then 0 else 0) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) }.b)
(( \f: Unit .((f (if (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Nat . false )) )) then (case <r = (((\x: Nat .\y: Rec X. X .y) (fix (\x: Rec X. X . true )) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a))) > as Bool of < l = x > => x | < r = y > => y) else (( \f: Unit .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (iszero 0) ) ) (\a: Rec X. X .\b: Nat .a))) ) (((\x: Bool .\y: Unit .x) (let u = true in (let u = false in false)) ) (iszero ({a = 1 , b = 1 }.b))) ) ) (\a: Bool .\b: Nat .a))
({a = (let u = (let u = ({a = 0 , b = false , c = 1 }.c) in u) in (( \f: Nat .((f ({a = 0 , b = true }.a) ) ({a = 0 , b = true , c = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.c) ) ) (\a: Unit .\b: Bool .b))) , b = ({a = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .b)) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c) , b = (((\x: Nat .\y: Rec X. X .y) (let u = 1 in false) ) (if true then true else false)) }.a) }.b)
(( \f: Nat .((f (fix (\x: Bool . ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .y) true ) false) )) , b = (succ (let u = 0 in 1)) }.a) )) ) (let u = (let u = 1 in u) in ({a = 0 , b = true , c =  1 }.b)) ) ) (\a: Rec X. X .\b: Nat .a))
({a = (( \f: Rec X. X .((f (fix (\x: Bool . ({a = (let u = 1 in u) , b = ({a = true , b = true }.b) }.a) )) ) (fix (\x: Rec X. X . ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = 1 }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (iszero (unfold [ Unit ] (fold [ Unit ] (succ 1) ))) }.b)
(( \f: Rec X. X .((f (if (case <r = (((\x: Bool .\y: Nat .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = (((\x: Rec X. X .\y: Bool .x) 1 ) false) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , c =  1 }.b) else (if (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = true }.b) )) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) else (fix (\x: Nat . (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b)) )))) ) (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f (((\x: Unit .\y: Unit .x) false ) false) ) (fix (\x: Nat . true )) ) ) (\a: Rec X. X .\b: Unit .b)) )) ) ) (\a: Bool .\b: Unit .b))
(((\x: Unit .\y: Unit .x) (let u = (((\x: Nat .\y: Rec X. X .x) ({a = false , b = true }.b) ) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .b))) in (succ 0)) ) (( \f: Unit .((f (( \f: Rec X. X .((f (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) (fix (\x: Rec X. X . (if true then true else false) )) ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Nat .((f (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) )) ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)))
(pred (if (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) true ) true) )) then (unfold [ Nat ] (fold [ Nat ] (succ 0) )) else (( \f: Bool .((f ({a = 1 , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .a)) }.a) ) (succ 0) ) ) (\a: Nat .\b: Bool .b))))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Rec X. X . (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 1 in true) ) ) (\a: Unit .\b: Rec X. X .b)) )) )) ))
(if (iszero (pred ({a = true , b = (((\x: Unit .\y: Nat .y) false ) 1) }.b))) then ({a = (if (iszero 1) then (( \f: Unit .((f (fix (\x: Bool . 0 )) ) (let u = false in 1) ) ) (\a: Bool .\b: Nat .b)) else (if false then 0 else 1)) , b = (unfold [ Bool ] (fold [ Unit ] (if true then true else (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .a))) )) }.a) else (pred ({a = 0 , b = true }.a)))
(unfold [ Unit ] (fold [ Rec X. X ] (let u = (pred (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .a)) in (let u = true in 1))) in (let u = (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Unit ] false )) )) in (unfold [ Unit ] (fold [ Rec X. X ] (let u = ({a = 1 , b = true , c = 1 }.c) in (let u = 1 in false)) )))) ))
(pred ({a = (( \f: Rec X. X .((f ({a = 1 , b = (iszero 0) , c =  1 }.b) ) ({a = ({a = true , b = 1 }.b) , b = true , c =  (let u = 1 in 0) }.b) ) ) (\a: Bool .\b: Bool .b)) , b = (unfold [ Nat ] (fold [ Unit ] (let u = 1 in u) )) }.b))
(let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = false }.b) )) )) in (case <l = ({a = (let u = true in true) , b = (fix (\x: Rec X. X . 1 )) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (let u = (let u = (pred 1) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a))) in u) in u)
({a = (let u = (( \f: Rec X. X .((f 0 ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Bool .b)) in u) , b = (fix (\x: Bool . ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) )) )) }.a)
(((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (if false then false else (((\x: Unit .\y: Bool .x) true ) true)) )) ) (let u = ({a = false , b = 0 }.b) in (iszero (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)))) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (fix (\x: Bool . ({a = 1 , b = (pred 0) }.b) )) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = (succ 1) in (let u = (((\x: Nat .\y: Bool .y) true ) 1) in true)) ) (case <r = (((\x: Bool .\y: Unit .x) true ) false) > as Nat of < l = x > => x | < r = y > => y)) , c = (let u = (if (((\x: Rec X. X .\y: Unit .y) false ) true) then (case <r = true > as Nat of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Bool .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) ) ({a = false , b = true }.b))) in (pred (succ 1))) }.c))
(let u = (((\x: Nat .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Rec X. X . (let u = 1 in false) )) )) ) (( \f: Bool .((f ({a = (let u = 0 in true) , b = (let u = (((\x: Unit .\y: Rec X. X .x) 1 ) true) in 1) }.b) ) (let u = false in (succ 1)) ) ) (\a: Nat .\b: Rec X. X .b))) in u)
(unfold [ Bool ] (fold [ Nat ] (( \f: Nat .((f ({a = (let u = 0 in 1) , b = false , c = 1 }.c) ) ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Bool .\y: Bool .x) false ) true) , c = (succ ({a = 1 , b = true , c = 1 }.c)) }.c) ) ) (\a: Bool .\b: Bool .a)) ))
(fix (\x: Nat . (( \f: Rec X. X .((f ({a = ({a = true , b = 1 }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = true , b = 1 }.a) )) }.a) ) ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = (unfold [ Nat ] (fold [ Unit ] 1 )) }.b) ) ) (\a: Bool .\b: Unit .b)) ))
(((\x: Nat .\y: Unit .y) ({a = ({a = 0 , b = false }.b) , b = (unfold [ Nat ] (fold [ Unit ] true )) }.b) ) ({a = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ({a = 1 , b = (let u = false in u) }.a) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = ({a = false , b = 1 }.a) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ))) , c =  (( \f: Nat .((f (fix (\x: Nat . (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) ) (let u = ({a = 0 , b = 0 }.b) in u) ) ) (\a: Nat .\b: Nat .a)) }.b))
(let u = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (pred ({a = false , b = 0 }.b)) ) ({a = 0 , b = false }.b)) , b = ({a = (let u = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b)) in u) , b = (((\x: Bool .\y: Nat .x) true ) true) }.b) , c = ({a = ({a = ({a = 1 , b = 0 }.b) , b = ({a = true , b = 0 }.a) , c = (unfold [ Nat ] (fold [ Bool ] 1 )) }.c) , b = (let u = false in u) , c = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) in 1) }.c) }.c) in (unfold [ Nat ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Bool .((f (let u = true in u) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .a)) )) )))
(( \f: Unit .((f (case <l = (fix (\x: Bool . (let u = 0 in 0) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (if false then 0 else 0) ))) in u) ) ) (\a: Bool .\b: Nat .a))
(if (let u = (let u = (let u = false in true) in ({a = true , b = true }.b)) in u) then (let u = ({a = ({a = (if true then 0 else 1) , b = false , c = 1 }.c) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , c = (let u = true in (let u = false in 0)) }.c) in (pred (if true then 0 else 1))) else (let u = (if ({a = false , b = false }.b) then ({a = false , b = false }.b) else (if false then false else true)) in (let u = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (pred 1) }.b) in (if true then (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) else 0))))
(let u = (let u = (case <l = (let u = 1 in 1) > as Unit of < l = x > => x | < r = y > => y) in u) in (( \f: Bool .((f ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .b)) , b = (((\x: Nat .\y: Bool .y) false ) 0) }.a) ) (let u = true in u) ) ) (\a: Bool .\b: Bool .b)))
({a = ({a = ({a = (fix (\x: Unit . (pred 1) )) , b = (fix (\x: Nat . false )) , c = (unfold [ Bool ] (fold [ Unit ] 0 )) }.c) , b = (unfold [ Unit ] (fold [ Unit ] (let u = false in 0) )) }.b) , b = ({a = ({a = ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = true , b = 0 }.b) }.b) , b = (let u = (let u = (let u = 0 in u) in 1) in (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) }.a) , b = (case <l = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) }.a) }.b)
(((\x: Unit .\y: Nat .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = (let u = 1 in u) in 0) )) )) ) (fix (\x: Unit . ({a = (let u = 1 in 1) , b = false , c =  (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) )))
(let u = ({a = (iszero (let u = true in 0)) , b = (let u = (((\x: Bool .\y: Nat .y) false ) 0) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) }.b) in u)
(iszero ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Nat .((f (let u = ({a = (let u = true in 1) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.b) in (((\x: Nat .\y: Bool .x) 1 ) false)) ) (unfold [ Bool ] (fold [ Unit ] 1 )) ) ) (\a: Rec X. X .\b: Unit .a)) )))
(unfold [ Rec X. X ] (fold [ Bool ] (case <r = (( \f: Bool .((f true ) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) ))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = ({a = 1 , b = 0 }.b) , b = true , c = (pred 1) }.c) , b = (fix (\x: Unit . false )) }.b) )) , b = ({a = ({a = (let u = false in false) , b = 1 }.b) , b = ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = (iszero (let u = 0 in u)) , c = (if true then 0 else 1) }.c) }.b) }.a)
({a = (case <l = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 0 , b = true , c = 0 }.c) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (pred (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ))) }.a) , c = (if (case <r = (let u = (let u = 0 in u) in (iszero 1)) > as Unit of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f (if true then 0 else 1) ) (if (fix (\x: Bool . true )) then 1 else (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Bool .\b: Bool .a)) else ({a = ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (if true then true else true) , c = (fix (\x: Nat . 1 )) }.c) , b = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Rec X. X .\y: Nat .y) true ) true) )) }.a)) }.c)
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (iszero ({a = 1 , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) }.a)) )) ))
(let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) )) in (succ (unfold [ Bool ] (fold [ Bool ] (succ 0) ))))
(( \f: Nat .((f (unfold [ Nat ] (fold [ Bool ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) )) ) ({a = (if (fix (\x: Unit . true )) then 0 else 0) , b = (let u = (let u = 0 in true) in false) , c = ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = true , c = 1 }.c) }.c) ) ) (\a: Nat .\b: Bool .b))
(case <l = ({a = (let u = (let u = ({a = 1 , b = (((\x: Rec X. X .\y: Unit .y) true ) false) , c = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) }.c) in u) in u) , b = ({a = ({a = ({a = 1 , b = 0 }.b) , b = (let u = true in false) , c = ({a = false , b = 0 }.b) }.c) , b = (( \f: Bool .((f (let u = 1 in true) ) (let u = 0 in true) ) ) (\a: Nat .\b: Unit .a)) }.b) , c = (let u = (iszero 0) in ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = 0 }.b)) }.c) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Bool .y) (iszero ({a = ({a = false , b = 1 }.b) , b = (( \f: Rec X. X .((f ({a = 0 , b = true }.a) ) 0 ) ) (\a: Unit .\b: Bool .a)) }.b)) ) (pred ({a = (((\x: Unit .\y: Rec X. X .y) true ) 0) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b)))
(( \f: Rec X. X .((f (succ (fix (\x: Nat . 1 ))) ) ({a = (fix (\x: Bool . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) , b = (( \f: Bool .((f 1 ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Bool .b)) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Nat .x) (let u = true in u) ) (fix (\x: Rec X. X . false ))) )) , b = (((\x: Bool .\y: Bool .x) (unfold [ Nat ] (fold [ Nat ] (((\x: Nat .\y: Nat .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) 1) )) ) (if (iszero 0) then (((\x: Bool .\y: Nat .x) true ) true) else false)) }.a)
(pred (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) in ({a = (fix (\x: Bool . false )) , b = (unfold [ Bool ] (fold [ Nat ] 1 )) }.b)))
({a = (( \f: Nat .((f (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) )) in (( \f: Nat .((f ({a = true , b = 1 }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Bool .b))) ) (pred ({a = false , b = 1 }.b)) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (case <r = (let u = (let u = 0 in true) in ({a = false , b = 0 }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (let u = (( \f: Nat .((f (((\x: Bool .\y: Nat .x) 0 ) true) ) (if true then 0 else 1) ) ) (\a: Rec X. X .\b: Nat .a)) in u) }.b)
(if ({a = ({a = (( \f: Rec X. X .((f (pred 0) ) (((\x: Nat .\y: Unit .y) true ) 0) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (unfold [ Rec X. X ] (fold [ Bool ] false )) }.b) , b = (let u = (pred 1) in u) }.a) then (if ({a = (let u = false in 0) , b = ({a = (iszero 1) , b = false }.b) , c =  ({a = 1 , b = false }.a) }.b) then (fix (\x: Unit . (if (unfold [ Bool ] (fold [ Unit ] true )) then ({a = 0 , b = true }.b) else ({a = 0 , b = false , c =  0 }.b)) )) else (fix (\x: Nat . (if false then false else false) ))) else ({a = ({a = (((\x: Unit .\y: Nat .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Rec X. X ] true ))) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) , b = 0 }.b) )) }.b) , b = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . true )) , c =  (if false then 0 else 1) }.b) }.b))
(if (((\x: Unit .\y: Unit .y) ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .a)) , b = (let u = false in true) }.b) ) ({a = (( \f: Nat .((f (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .b)) ) (let u = 0 in true) ) ) (\a: Unit .\b: Bool .a)) , b = (case <l = (((\x: Unit .\y: Bool .y) false ) 1) > as Nat of < l = x > => x | < r = y > => y) }.a)) then (((\x: Bool .\y: Nat .x) (let u = (((\x: Unit .\y: Nat .x) true ) false) in (let u = 0 in u)) ) ({a = (pred (((\x: Bool .\y: Rec X. X .x) 1 ) false)) , b = ({a = ({a = 1 , b = false , c = 1 }.c) , b = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.b) }.b)) else (if ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = (if false then false else false) in ({a = 0 , b = false }.b)) )) then ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = (fix (\x: Bool . false )) , c = ({a = (let u = 1 in 1) , b = ({a = 1 , b = true , c =  1 }.b) , c = 0 }.c) }.c) else (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) ) (\a: Unit .\b: Rec X. X .a))))
(( \f: Bool .((f (( \f: Unit .((f (let u = 0 in u) ) (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (succ 0) )) ) (if false then 1 else 1) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .a)) ) (let u = (unfold [ Unit ] (fold [ Bool ] 0 )) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (let u = (( \f: Nat .((f (succ 1) ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) in u) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] true )) )) , c = (let u = (((\x: Unit .\y: Bool .x) true ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b))) in (if (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) then 0 else 0)) }.c) )))
(let u = (((\x: Bool .\y: Bool .y) (let u = (if true then 0 else (unfold [ Rec X. X ] (fold [ Nat ] 0 ))) in ({a = (let u = 1 in u) , b = false }.b)) ) (if ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = true in u) )) then ({a = false , b = ({a = 0 , b = true , c = 0 }.c) }.a) else (if true then true else false))) in u)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .x) ({a = (pred 1) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) }.b) ) (let u = true in u)) )) ))
({a = (( \f: Unit .((f (((\x: Nat .\y: Unit .y) ({a = true , b = ({a = 0 , b = 0 }.b) }.a) ) ({a = 1 , b = 0 }.b)) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .b)) , b = (fix (\x: Bool . (succ 1) )) }.b)
(( \f: Nat .((f ({a = (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) in u) , b = ({a = ({a = false , b = 1 }.b) , b = (((\x: Rec X. X .\y: Bool .x) false ) false) }.a) }.a) ) (( \f: Rec X. X .((f ({a = ({a = 1 , b = true }.a) , b = (iszero 1) }.b) ) (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Unit .a)) )) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .a))
(unfold [ Bool ] (fold [ Unit ] ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Rec X. X .x) false ) true) ) (let u = 0 in false)) )) ))
({a = (((\x: Rec X. X .\y: Rec X. X .y) ({a = (iszero 1) , b = ({a = false , b = 1 }.a) }.b) ) ({a = (let u = 1 in u) , b = false , c = 0 }.c)) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] (if true then true else false) )) , b = (fix (\x: Bool . ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = false }.b) )) }.b) , c =  (let u = ({a = ({a = (((\x: Bool .\y: Bool .y) (fix (\x: Bool . true )) ) 1) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) in (let u = 1 in true)) }.a) in ({a = ({a = (unfold [ Bool ] (fold [ Unit ] true )) , b = 1 }.b) , b = (succ (succ 1)) }.b)) }.b)
(( \f: Bool .((f ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) 1 ) (((\x: Nat .\y: Bool .x) false ) false)) )) , b = (( \f: Rec X. X .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = ({a = false , b = false }.b) , c = 0 }.c) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) ) (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) ))) ) ) (\a: Nat .\b: Bool .b))
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (((\x: Unit .\y: Rec X. X .x) (case <l = (pred 0) > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = true , c =  1 }.b)) , b = (let u = ({a = (let u = true in u) , b = (pred 0) }.a) in u) , c =  ({a = (let u = ({a = 0 , b = false , c = (succ 1) }.c) in u) , b = (unfold [ Unit ] (fold [ Nat ] ({a = true , b = 1 }.b) )) }.b) }.b) ))
(succ (pred (pred (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))))
({a = (((\x: Rec X. X .\y: Nat .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . true )) )) ) (((\x: Rec X. X .\y: Nat .y) (if true then false else false) ) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = true , c =  0 }.b))) , b = ({a = (let u = (((\x: Rec X. X .\y: Nat .y) false ) 1) in u) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Unit .x) true ) false) )) }.b) }.b)
(fix (\x: Bool . (unfold [ Bool ] (fold [ Bool ] (succ 1) )) ))
(if ({a = (if (( \f: Unit .((f (let u = false in false) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) then (( \f: Nat .((f (unfold [ Unit ] (fold [ Rec X. X ] false )) ) (let u = 0 in false) ) ) (\a: Nat .\b: Unit .b)) else (if ({a = false , b = true }.b) then (unfold [ Bool ] (fold [ Nat ] false )) else (let u = 0 in true))) , b = (fix (\x: Nat . (iszero 0) )) }.b) then ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (case <r = ({a = false , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Nat ] (fold [ Rec X. X ] true ))) , c = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.c) else (( \f: Unit .((f (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (if false then 0 else 0) in u) ) ) (\a: Nat .\b: Bool .a)))
(( \f: Rec X. X .((f (case <r = (( \f: Bool .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) ({a = false , b = 1 }.a) ) ) (\a: Nat .\b: Nat .a)) ) (( \f: Rec X. X .((f (let u = true in u) ) (((\x: Bool .\y: Nat .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) ) true) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in ({a = 0 , b = true }.a)) )) in (case <r = ({a = false , b = false }.b) > as Bool of < l = x > => x | < r = y > => y)) in (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .a))
({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in true) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) (let u = 1 in (if false then true else false)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (unfold [ Nat ] (fold [ Unit ] (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f false ) (let u = true in u) ) ) (\a: Nat .\b: Bool .a)) )) )) }.b)
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) ) ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = true , c = (((\x: Rec X. X .\y: Unit .x) 1 ) false) }.c)) ) (fix (\x: Bool . (( \f: Rec X. X .((f 1 ) (let u = 1 in 0) ) ) (\a: Nat .\b: Nat .b)) )) ) ) (\a: Nat .\b: Unit .a))
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (iszero 1) )) )) , b = (case <l = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ))
(case <l = (succ (fix (\x: Bool . (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) > as Nat of < l = x > => x | < r = y > => y)
(iszero (( \f: Unit .((f (( \f: Nat .((f (if false then (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) else ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 ))) ) (let u = 1 in u) ) ) (\a: Unit .\b: Nat .b)) ) ({a = 1 , b = false , c = 1 }.c) ) ) (\a: Unit .\b: Bool .b)))
(((\x: Rec X. X .\y: Unit .y) ({a = (let u = ({a = true , b = 0 }.b) in ({a = false , b = false }.b)) , b = ({a = ({a = 1 , b = true , c = 0 }.c) , b = (iszero 0) }.a) }.a) ) (let u = (( \f: Unit .((f ({a = ({a = 1 , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , c = ({a = 0 , b = true }.a) }.c) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Rec X. X . true )) )) , c =  (fix (\x: Nat . 1 )) }.b) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if true then true else false) )) ) ) (\a: Rec X. X .\b: Unit .a)) in (((\x: Bool .\y: Rec X. X .y) (case <r = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .y) true ) (((\x: Rec X. X .\y: Rec X. X .x) false ) false)))))
({a = ({a = (pred (fix (\x: Rec X. X . 1 ))) , b = (iszero (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a))) , c = (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] 0 )) ) ({a = true , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) }.c) , b = (fix (\x: Rec X. X . (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] true )) )) )) , c = (fix (\x: Nat . (let u = (succ 1) in (pred 1)) )) }.c)
({a = (((\x: Bool .\y: Bool .x) (case <r = ({a = 1 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f (iszero 0) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Bool .a))) , b = (unfold [ Bool ] (fold [ Nat ] (( \f: Nat .((f (( \f: Unit .((f (let u = false in true) ) (((\x: Bool .\y: Rec X. X .y) false ) true) ) ) (\a: Rec X. X .\b: Unit .b)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) )) ) ) (\a: Nat .\b: Unit .a)) )) }.b)
(( \f: Nat .((f ({a = (unfold [ Bool ] (fold [ Bool ] (let u = false in 0) )) , b = (((\x: Rec X. X .\y: Nat .y) (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Nat .a)) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b))) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (case <r = (( \f: Rec X. X .((f false ) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b))
(if (case <r = (if (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) > as Nat of < l = x > => x | < r = y > => y) then (( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] false )) ) ({a = true , b = (((\x: Nat .\y: Unit .y) false ) 1) }.a) ) ) (\a: Unit .\b: Bool .b)) else (( \f: Bool .((f (let u = (unfold [ Nat ] (fold [ Bool ] false )) in true) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a))) > as Bool of < l = x > => x | < r = y > => y) then ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . ({a = false , b = 1 }.b) )) )) else ({a = (case <l = (let u = (fix (\x: Unit . false )) in (fix (\x: Unit . 1 ))) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = ({a = 0 , b = true , c = 0 }.c) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.b) in (pred (succ 0))) }.b))
(case <r = (((\x: Unit .\y: Nat .y) (let u = (fix (\x: Rec X. X . 0 )) in ({a = false , b = true }.b)) ) (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) (let u = true in false) ) ) (\a: Nat .\b: Rec X. X .a))) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in u) ) ({a = (( \f: Unit .((f (succ ({a = false , b = 1 }.b)) ) (((\x: Nat .\y: Rec X. X .x) 0 ) true) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (if true then true else ({a = 1 , b = true , c =  1 }.b)) }.b) ) ) (\a: Bool .\b: Unit .a))
(let u = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Bool .x) (if true then false else (unfold [ Rec X. X ] (fold [ Bool ] true ))) ) (( \f: Unit .((f ({a = true , b = 1 }.a) ) (if false then ({a = true , b = 1 }.a) else false) ) ) (\a: Bool .\b: Unit .b))) )) in u)
(((\x: Unit .\y: Rec X. X .y) ({a = (fix (\x: Bool . 0 )) , b = ({a = (if false then 0 else 0) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) }.b) , c =  (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = false }.a) )) }.b) ) ({a = (fix (\x: Nat . (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) in false) )) , b = (iszero ({a = (fix (\x: Unit . ({a = true , b = 1 }.b) )) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b)) }.b))
(let u = ({a = (iszero ({a = 1 , b = 0 }.b)) , b = (let u = (((\x: Bool .\y: Unit .y) true ) false) in (iszero ({a = 1 , b = true }.a))) }.b) in (let u = (unfold [ Unit ] (fold [ Nat ] (pred 0) )) in (( \f: Bool .((f (( \f: Bool .((f (((\x: Bool .\y: Bool .y) false ) 0) ) 1 ) ) (\a: Unit .\b: Nat .a)) ) (fix (\x: Unit . 0 )) ) ) (\a: Rec X. X .\b: Unit .b))))
({a = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (case <l = ({a = 0 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) true ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) )) , c = ({a = ({a = 0 , b = true , c =  1 }.b) , b = (fix (\x: Unit . 0 )) }.b) }.c) )) , b = (let u = (((\x: Nat .\y: Nat .y) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .y) true ) true) )) in u) ) (case <r = (( \f: Unit .((f false ) (((\x: Rec X. X .\y: Bool .x) true ) true) ) ) (\a: Unit .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y)) in (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) (iszero 1)) ) ({a = (let u = true in true) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Rec X. X .\b: Bool .b))) }.a)
(( \f: Nat .((f (let u = (let u = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .y) false ) 1) ) (fix (\x: Unit . 0 )) ) ) (\a: Rec X. X .\b: Bool .a)) in ({a = (let u = false in ({a = true , b = true }.b)) , b = (let u = true in 0) }.b)) in (( \f: Nat .((f (let u = (let u = false in u) in u) ) ({a = true , b = (fix (\x: Unit . true )) }.b) ) ) (\a: Nat .\b: Rec X. X .b))) ) ({a = ({a = (let u = 0 in 0) , b = (if true then true else false) , c = (((\x: Rec X. X .\y: Bool .y) false ) (pred 1)) }.c) , b = ({a = (let u = false in u) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .a)) }.b) , c =  ({a = 1 , b = 1 }.b) }.b) ) ) (\a: Bool .\b: Bool .b))
(let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Bool .x) (let u = (unfold [ Unit ] (fold [ Bool ] true )) in u) ) ({a = 1 , b = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) , c =  (((\x: Unit .\y: Rec X. X .y) true ) 0) }.b)) )) in (unfold [ Rec X. X ] (fold [ Bool ] ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) , b = (succ 1) }.a) )))
(unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Nat . (((\x: Unit .\y: Nat .y) false ) (succ 0)) )) ))
(case <l = (( \f: Unit .((f (pred 0) ) (( \f: Nat .((f 0 ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Unit .y) (let u = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) in u) ) ({a = false , b = true }.b)) ) (((\x: Nat .\y: Bool .x) (case <r = (if (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) then (unfold [ Nat ] (fold [ Nat ] true )) else (((\x: Bool .\y: Nat .x) true ) false)) > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Unit ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) ))))
(let u = ({a = (case <l = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (if (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .a)) then (let u = false in 1) else (let u = true in 1)) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) }.b) in (iszero (succ (succ 1))))
({a = (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) 1 ) false) ) (((\x: Unit .\y: Nat .x) (if false then 1 else 0) ) ({a = (if false then 1 else 0) , b = (let u = 1 in false) , c =  1 }.b)) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (unfold [ Unit ] (fold [ Nat ] ({a = (let u = 0 in u) , b = (((\x: Unit .\y: Bool .x) true ) false) }.b) )) }.b)
(pred (let u = (case <l = ({a = (((\x: Bool .\y: Unit .x) 1 ) true) , b = (succ 1) }.b) > as Unit of < l = x > => x | < r = y > => y) in u))
({a = (fix (\x: Nat . (( \f: Rec X. X .((f (case <l = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (let u = true in 1) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) ) ) (\a: Bool .\b: Bool .b)) )) , b = (((\x: Rec X. X .\y: Unit .y) (unfold [ Bool ] (fold [ Unit ] ({a = ({a = 1 , b = false }.b) , b = (let u = 1 in u) }.a) )) ) ({a = (let u = (unfold [ Bool ] (fold [ Bool ] (((\x: Unit .\y: Unit .y) false ) true) )) in u) , b = (( \f: Bool .((f ({a = false , b = true }.b) ) (let u = 1 in true) ) ) (\a: Nat .\b: Unit .a)) }.b)) }.a)
(case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) , b = (fix (\x: Nat . 1 )) }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(succ ({a = (let u = ({a = 1 , b = true , c = 0 }.c) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) , b = ({a = ({a = 0 , b = true }.b) , b = ({a = true , b = true }.b) }.b) }.a))
({a = ({a = (let u = (iszero 0) in 0) , b = (pred 0) }.b) , b = (( \f: Unit .((f ({a = (iszero (if false then 0 else 1)) , b = ({a = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = (pred 1) in 1) }.b) }.a) ) (fix (\x: Unit . (let u = (let u = 0 in 0) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) )) ) ) (\a: Unit .\b: Bool .b)) }.a)
(if (( \f: Bool .((f (let u = (((\x: Nat .\y: Bool .y) true ) false) in (let u = 0 in false)) ) (let u = false in true) ) ) (\a: Rec X. X .\b: Bool .b)) then (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .x) (let u = ({a = 0 , b = true }.a) in (let u = true in u)) ) ({a = 1 , b = false }.b)) ) (iszero ({a = true , b = 1 }.b)) ) ) (\a: Bool .\b: Rec X. X .b)) else (let u = ({a = (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) in 0) , b = (((\x: Rec X. X .\y: Nat .x) true ) false) }.a) in (((\x: Unit .\y: Bool .y) (let u = true in u) ) (fix (\x: Nat . true )))))
(let u = ({a = ({a = ({a = false , b = 1 }.a) , b = (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) ) ({a = 0 , b = 1 }.b) ) ) (\a: Nat .\b: Nat .b)) }.b) , b = (((\x: Nat .\y: Bool .y) (fix (\x: Nat . (if false then false else true) )) ) (( \f: Bool .((f ({a = 0 , b = false , c =  0 }.b) ) false ) ) (\a: Bool .\b: Rec X. X .b))) }.a) in ({a = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) in u) , b = ({a = (let u = true in false) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) , c = (unfold [ Unit ] (fold [ Nat ] 1 )) }.c) , b = (iszero ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = true , c = (let u = false in 1) }.c)) }.a))
(unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f (if ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . true )) , c =  0 }.b) then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = false , b = true }.b)) ) ({a = (((\x: Unit .\y: Bool .y) ({a = false , b = false }.b) ) false) , b = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = (iszero ({a = 1 , b = true }.a)) }.a) }.a) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(fix (\x: Nat . (case <r = (let u = ({a = false , b = (let u = 1 in u) }.a) in u) > as Nat of < l = x > => x | < r = y > => y) ))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (succ (((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Rec X. X .x) false ) false) ) 0)) , b = (iszero (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = (succ 0) }.b) ))) }.a) ))
(fix (\x: Nat . ({a = (fix (\x: Rec X. X . (let u = 0 in u) )) , b = ({a = ({a = 0 , b = false }.a) , b = false , c =  0 }.b) , c = (fix (\x: Bool . 1 )) }.c) ))
(let u = (let u = (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Bool .y) false ) 1) )) in u) in u)
(unfold [ Unit ] (fold [ Bool ] ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . true )) )) , b = (fix (\x: Unit . (case <l = (((\x: Nat .\y: Rec X. X .y) false ) 0) > as Bool of < l = x > => x | < r = y > => y) )) }.b) ))
(fix (\x: Rec X. X . ({a = (if ({a = 0 , b = true , c =  0 }.b) then (case <r = true > as Unit of < l = x > => x | < r = y > => y) else (((\x: Unit .\y: Nat .y) false ) false)) , b = ({a = true , b = 0 }.a) }.b) ))
(( \f: Nat .((f (fix (\x: Unit . (let u = (if (case <r = (let u = false in false) > as Unit of < l = x > => x | < r = y > => y) then (iszero (succ 0)) else (( \f: Unit .((f false ) (if false then false else false) ) ) (\a: Bool .\b: Nat .b))) in (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .x) true ) false) ))) )) ) (((\x: Nat .\y: Bool .x) ({a = ({a = (pred 1) , b = (((\x: Unit .\y: Nat .x) true ) true) , c = 0 }.c) , b = ({a = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .a)) , b = 1 }.a) }.b) ) (let u = ({a = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = false }.b) in u)) ) ) (\a: Nat .\b: Unit .a))
({a = (( \f: Unit .((f (fix (\x: Unit . (( \f: Unit .((f true ) (if true then false else false) ) ) (\a: Rec X. X .\b: Nat .b)) )) ) (if (((\x: Bool .\y: Nat .y) true ) true) then (((\x: Unit .\y: Rec X. X .x) false ) (fix (\x: Rec X. X . true ))) else ({a = 1 , b = false , c =  1 }.b)) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (if (( \f: Bool .((f ({a = 1 , b = false }.b) ) (fix (\x: Nat . false )) ) ) (\a: Unit .\b: Rec X. X .b)) then (let u = true in (let u = false in 0)) else (let u = (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) in (((\x: Nat .\y: Unit .x) 0 ) false))) }.a)
(iszero (if (( \f: Unit .((f ({a = 1 , b = false }.b) ) true ) ) (\a: Unit .\b: Nat .a)) then ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true }.a) }.b) else ({a = ({a = (let u = 1 in 0) , b = (fix (\x: Nat . false )) }.a) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a)))
(((\x: Nat .\y: Nat .y) (case <r = (let u = (unfold [ Nat ] (fold [ Unit ] (let u = 1 in 0) )) in (((\x: Nat .\y: Bool .y) true ) true)) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . (let u = (pred (pred 0)) in (fix (\x: Bool . false ))) )))
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = (unfold [ Rec X. X ] (fold [ Bool ] (pred 1) )) in u) ))
(let u = (if (iszero ({a = (let u = 0 in 1) , b = true , c = 1 }.c)) then (let u = (unfold [ Rec X. X ] (fold [ Nat ] false )) in (((\x: Bool .\y: Nat .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) ) false)) else (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Bool . (((\x: Unit .\y: Nat .y) false ) false) )) ))) in ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) }.b))
(( \f: Rec X. X .((f ({a = (let u = ({a = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .a)) , b = (if true then 1 else 0) }.b) in (if ({a = true , b = false }.b) then false else true)) , b = (let u = ({a = (let u = 1 in 0) , b = (((\x: Bool .\y: Rec X. X .x) false ) false) , c =  ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (fix (\x: Unit . 0 )) }.b) }.b) in (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) true ) true) ))) }.b) ) (( \f: Nat .((f (( \f: Bool .((f (if ({a = (let u = 0 in u) , b = (let u = true in u) , c =  0 }.b) then (iszero (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b))) else ({a = ({a = true , b = 1 }.a) , b = (((\x: Unit .\y: Rec X. X .x) false ) false) }.b)) ) (( \f: Nat .((f (let u = true in u) ) (( \f: Bool .((f (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = ({a = true , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a)) }.b) , b = (let u = (unfold [ Unit ] (fold [ Nat ] true )) in ({a = 1 , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c =  0 }.b)) }.b) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .b))
(let u = (let u = (((\x: Bool .\y: Nat .y) true ) (let u = false in 0)) in ({a = (let u = true in false) , b = (( \f: Bool .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Nat .b)) }.a)) in u)
({a = (( \f: Rec X. X .((f (if true then 0 else (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a))) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) 1 ) false) ) (((\x: Unit .\y: Nat .x) 0 ) true) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .b)) , b = (fix (\x: Nat . ({a = (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) ) true) , b = (case <r = ({a = 0 , b = true , c =  1 }.b) > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = ({a = (succ 1) , b = false , c = 0 }.c) , b = (unfold [ Nat ] (fold [ Nat ] 1 )) }.b) }.b) )) }.b)
({a = (case <r = (( \f: Rec X. X .((f ({a = true , b = true }.b) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Unit .x) (pred (pred 1)) ) (((\x: Bool .\y: Bool .x) ({a = 1 , b = false }.b) ) (let u = false in false))) }.b)
(((\x: Rec X. X .\y: Nat .y) ({a = ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b)) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.a) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) }.b) ) ({a = (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) (let u = (let u = 1 in 0) in u) ) ) (\a: Unit .\b: Bool .a)) , b = (unfold [ Nat ] (fold [ Bool ] (let u = false in u) )) , c =  (unfold [ Bool ] (fold [ Bool ] (pred ({a = false , b = 1 }.b)) )) }.b))
({a = (fix (\x: Unit . (fix (\x: Nat . true )) )) , b = (let u = (((\x: Rec X. X .\y: Bool .y) false ) 1) in u) }.b)
(let u = (iszero ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .y) false ) ({a = 1 , b = true }.b)) )) , b = (((\x: Unit .\y: Nat .x) ({a = 1 , b = false , c = 0 }.c) ) (if true then true else true)) }.b)) in ({a = (((\x: Bool .\y: Bool .y) (unfold [ Nat ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) false ) true) )) ) ({a = 0 , b = false }.b)) , b = (( \f: Nat .((f (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .b)) ) ({a = true , b = 1 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) }.b))
(((\x: Unit .\y: Bool .y) (((\x: Nat .\y: Nat .x) (let u = ({a = false , b = false }.b) in true) ) (iszero ({a = 1 , b = false , c = 1 }.c))) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = false , b = ({a = true , b = 1 }.b) }.a) )))
({a = (let u = (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Unit .x) true ) true) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) in u) , b = (((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Bool .y) true ) false) ) (case <r = ({a = 1 , b = false }.b) > as Unit of < l = x > => x | < r = y > => y)) }.a)
(unfold [ Bool ] (fold [ Rec X. X ] (let u = (case <l = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) , b = ({a = true , b = (if false then 0 else 1) }.b) }.b) > as Nat of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = false }.b) ) (((\x: Unit .\y: Unit .x) true ) false))) ))
(if (unfold [ Unit ] (fold [ Nat ] ({a = (let u = false in 0) , b = ({a = 0 , b = true }.b) }.b) )) then ({a = (let u = (let u = true in false) in (if true then false else false)) , b = ({a = 1 , b = (let u = 1 in false) , c = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.c) }.b) else (succ (let u = (if ({a = true , b = 0 }.a) then (let u = 1 in u) else ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 ))) in (let u = 1 in u))))
(unfold [ Rec X. X ] (fold [ Bool ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) (succ 0) ) (( \f: Rec X. X .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b))) )) )) ))
(( \f: Nat .((f (((\x: Bool .\y: Rec X. X .y) (fix (\x: Unit . (fix (\x: Bool . false )) )) ) (let u = (let u = ({a = 0 , b = 1 }.b) in true) in u)) ) (fix (\x: Bool . (((\x: Bool .\y: Bool .x) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) ({a = 0 , b = true , c =  1 }.b)) )) ) ) (\a: Nat .\b: Bool .a))
(((\x: Unit .\y: Bool .y) ({a = ({a = 0 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  0 }.b) , b = (case <r = (( \f: Nat .((f true ) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ({a = ({a = (pred (succ 0)) , b = (let u = true in false) }.a) , b = (((\x: Unit .\y: Bool .y) (let u = true in u) ) ({a = 1 , b = false , c = 0 }.c)) }.b))
(iszero (case <l = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) in u) > as Unit of < l = x > => x | < r = y > => y))
(succ (let u = (if (let u = true in u) then true else ({a = false , b = 0 }.a)) in (let u = ({a = false , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) }.b) in u)))
({a = (( \f: Rec X. X .((f (fix (\x: Nat . false )) ) ({a = (pred 1) , b = (unfold [ Unit ] (fold [ Rec X. X ] (let u = 1 in false) )) , c =  ({a = 1 , b = ({a = true , b = false }.b) }.a) }.b) ) ) (\a: Bool .\b: Nat .a)) , b = (fix (\x: Unit . (let u = ({a = (if false then 0 else 0) , b = false , c =  (let u = 1 in u) }.b) in ({a = (((\x: Unit .\y: Bool .y) false ) 1) , b = true }.b)) )) }.b)
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = (case <r = (( \f: Rec X. X .((f (let u = false in u) ) false ) ) (\a: Nat .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <l = (pred (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in u)) > as Unit of < l = x > => x | < r = y > => y) }.a) ))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = (pred 0) in u) )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in 0) )) , b = (let u = 1 in 0) }.b) )) }.b)
(fix (\x: Unit . ({a = (((\x: Rec X. X .\y: Unit .y) (fix (\x: Bool . true )) ) (fix (\x: Unit . false ))) , b = (let u = (let u = 1 in true) in ({a = false , b = true }.b)) }.b) ))
({a = (fix (\x: Nat . ({a = (pred 0) , b = true , c = ({a = false , b = 0 }.b) }.c) )) , b = (iszero (case <l = (unfold [ Bool ] (fold [ Nat ] 0 )) > as Bool of < l = x > => x | < r = y > => y)) , c =  (fix (\x: Rec X. X . (pred ({a = 0 , b = false }.a)) )) }.b)
(pred (let u = (( \f: Rec X. X .((f 0 ) (unfold [ Bool ] (fold [ Nat ] 1 )) ) ) (\a: Unit .\b: Nat .a)) in u))
({a = (( \f: Nat .((f (let u = ({a = 1 , b = true }.b) in (let u = true in u)) ) (let u = (let u = (let u = 0 in true) in 0) in ({a = (pred 1) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  ({a = true , b = 0 }.b) }.b)) ) ) (\a: Unit .\b: Unit .a)) , b = (case <l = (let u = ({a = false , b = 0 }.b) in u) > as Bool of < l = x > => x | < r = y > => y) }.b)
(pred (let u = (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Unit .b)) in (if (iszero 0) then (unfold [ Bool ] (fold [ Nat ] 1 )) else ({a = 1 , b = false }.a))))
({a = ({a = (if (( \f: Bool .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = 0 in true) ) ) (\a: Nat .\b: Nat .a)) then ({a = true , b = 0 }.b) else ({a = 1 , b = false , c = 0 }.c)) , b = ({a = 1 , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] (let u = (fix (\x: Rec X. X . (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) )) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) )) , c = (((\x: Nat .\y: Unit .y) (let u = ({a = 0 , b = true , c =  0 }.b) in (((\x: Unit .\y: Nat .x) false ) true)) ) (((\x: Unit .\y: Unit .x) (let u = true in 1) ) (( \f: Bool .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b)))) }.c)
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] (let u = true in false) )) )) , b = (fix (\x: Nat . (pred 1) )) }.a)
(let u = (( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f (let u = true in 1) ) 0 ) ) (\a: Nat .\b: Unit .a)) )) ) (case <l = (case <l = (if true then 1 else 1) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) in u)
(((\x: Nat .\y: Unit .y) (( \f: Bool .((f (unfold [ Bool ] (fold [ Bool ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ) ({a = (succ (let u = 1 in u)) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.b) ) ) (\a: Nat .\b: Unit .b)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) > as Nat of < l = x > => x | < r = y > => y) )))
(succ (case <l = (unfold [ Bool ] (fold [ Unit ] (if false then 0 else ({a = 0 , b = true }.a)) )) > as Nat of < l = x > => x | < r = y > => y))
(if (let u = (((\x: Rec X. X .\y: Unit .y) (iszero 0) ) ({a = false , b = true }.b)) in u) then (let u = (( \f: Rec X. X .((f (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a)) ) true ) ) (\a: Rec X. X .\b: Bool .a)) in ({a = (let u = 0 in 1) , b = 1 }.b)) else (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) (let u = 0 in false) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ({a = (if false then 1 else 1) , b = (if ({a = false , b = false }.b) then (let u = 1 in true) else ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true ))) }.a) ) ) (\a: Nat .\b: Rec X. X .a)) in (fix (\x: Nat . ({a = 0 , b = 1 }.b) ))))
(unfold [ Nat ] (fold [ Rec X. X ] ({a = (succ ({a = 0 , b = false }.a)) , b = ({a = ({a = false , b = 1 }.a) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) }.a) }.b) ))
(case <l = ({a = ({a = (let u = 1 in ({a = true , b = true }.b)) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .a)) }.b) , b = (let u = (pred ({a = false , b = 1 }.b)) in u) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = (let u = ({a = (let u = 0 in 0) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.b) in u) , b = (let u = (( \f: Rec X. X .((f (( \f: Nat .((f true ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Unit .b)) in u) }.b)
(( \f: Bool .((f (if (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Bool . true )) )) then ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = 0 }.b) else (((\x: Rec X. X .\y: Nat .y) (fix (\x: Nat . false )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )))) ) (fix (\x: Nat . (( \f: Bool .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) ) (pred (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) ) ) (\a: Nat .\b: Bool .a)) )) ) ) (\a: Unit .\b: Bool .b))
({a = (( \f: Unit .((f ({a = 1 , b = false , c =  (((\x: Bool .\y: Rec X. X .y) false ) 0) }.b) ) (if ({a = 0 , b = (((\x: Bool .\y: Unit .x) true ) false) , c =  1 }.b) then ({a = ({a = 0 , b = false }.a) , b = true }.b) else ({a = true , b = (if true then 1 else 0) }.a)) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (if (let u = (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (unfold [ Rec X. X ] (fold [ Unit ] 1 )) else (if false then 1 else 0)) in ({a = 0 , b = false , c =  (succ 1) }.b)) then (let u = (( \f: Nat .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = true , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) in ({a = 0 , b = (let u = 1 in false) }.b)) else (((\x: Nat .\y: Bool .x) (unfold [ Nat ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Bool ] false )) )) ) ({a = 1 , b = true , c =  ({a = 0 , b = true }.a) }.b))) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) (if (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = false , c =  0 }.b) )) then (let u = (( \f: Rec X. X .((f (let u = true in u) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) in u) else (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Unit .y) false ) false) ) (fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .x) true ) true) )))) ) (if (let u = false in u) then ({a = true , b = 1 }.b) else (if ({a = 1 , b = true , c =  1 }.b) then 1 else 1))) ))
(let u = (let u = (((\x: Nat .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] true )) ) (let u = true in u)) in ({a = (let u = false in true) , b = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) in true) }.b)) in (let u = (if (if true then false else true) then (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) else (fix (\x: Unit . (succ 0) ))) in u))
({a = (pred (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = true }.a) ))) , b = (let u = (if (fix (\x: Rec X. X . false )) then (unfold [ Nat ] (fold [ Unit ] true )) else (fix (\x: Nat . true ))) in u) }.a)
(let u = (let u = ({a = 0 , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.b) in ({a = 1 , b = false }.b)) in (((\x: Bool .\y: Nat .x) (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) in u) ) (( \f: Nat .((f ({a = true , b = true }.b) ) true ) ) (\a: Bool .\b: Unit .a))))
(unfold [ Bool ] (fold [ Unit ] (iszero ({a = (let u = (let u = true in 1) in (((\x: Unit .\y: Bool .y) false ) false)) , b = ({a = (succ 1) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) }.a) }.b)) ))
(let u = (fix (\x: Rec X. X . (let u = ({a = 0 , b = true }.b) in true) )) in (((\x: Bool .\y: Rec X. X .y) (let u = (((\x: Bool .\y: Bool .x) false ) false) in ({a = (if false then true else true) , b = (let u = 1 in 0) }.a)) ) (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) (case <r = ({a = 1 , b = false , c =  1 }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b))))
(((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] false )) ) (let u = true in true) ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = (if false then true else true) in ({a = false , b = true }.b)) ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = (( \f: Unit .((f (let u = 0 in u) ) (if true then 0 else 0) ) ) (\a: Bool .\b: Unit .b)) in u))
(( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = 0 , b = ({a = true , b = 0 }.a) }.a)) ) (((\x: Rec X. X .\y: Bool .x) (succ ({a = (let u = false in 0) , b = (pred 0) }.b)) ) (let u = ({a = (fix (\x: Bool . false )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) }.b) in u)) ) ) (\a: Nat .\b: Nat .a))
(fix (\x: Bool . (unfold [ Nat ] (fold [ Bool ] (let u = (case <l = (((\x: Rec X. X .\y: Unit .x) 0 ) true) > as Bool of < l = x > => x | < r = y > => y) in u) )) ))
(let u = (((\x: Nat .\y: Nat .y) ({a = false , b = false }.b) ) (unfold [ Bool ] (fold [ Rec X. X ] false ))) in ({a = (unfold [ Nat ] (fold [ Nat ] ({a = ({a = true , b = 0 }.b) , b = true , c = (if true then 0 else 1) }.c) )) , b = (iszero (( \f: Unit .((f (if false then 0 else 0) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Unit .a))) , c = (((\x: Unit .\y: Unit .x) (let u = (if ({a = 0 , b = false }.b) then 0 else 0) in (let u = false in 1)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .x) true ) false) ))) }.c))
(((\x: Nat .\y: Unit .y) ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] false )) ) (let u = true in u) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) (( \f: Nat .((f (( \f: Bool .((f ({a = (succ 0) , b = 1 }.b) ) (let u = (pred 0) in u) ) ) (\a: Nat .\b: Nat .b)) ) (case <l = (((\x: Nat .\y: Bool .y) (unfold [ Unit ] (fold [ Bool ] false )) ) (let u = 1 in u)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)))
(iszero (((\x: Rec X. X .\y: Nat .x) (((\x: Rec X. X .\y: Nat .x) (succ 0) ) ({a = false , b = 0 }.a)) ) (((\x: Nat .\y: Bool .x) ({a = 0 , b = false }.b) ) (if (let u = 1 in false) then true else false))))
({a = (((\x: Unit .\y: Nat .y) (( \f: Bool .((f (let u = true in true) ) (iszero (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Bool .\y: Unit .x) (let u = true in false) ) ({a = false , b = true }.b))) , b = (pred ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .y) ({a = 0 , b = false , c =  1 }.b) ) (fix (\x: Bool . 1 ))) ))) }.a)
((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] (succ 0) )) )) ))
(((\x: Nat .\y: Bool .y) (let u = (( \f: Rec X. X .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = true , b = (let u = true in 0) }.a) ) ) (\a: Nat .\b: Nat .a)) in (((\x: Rec X. X .\y: Unit .x) (( \f: Unit .((f ({a = true , b = 1 }.a) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = ({a = true , b = false }.b) in (fix (\x: Bool . true ))))) ) (let u = (let u = (fix (\x: Bool . 1 )) in ({a = 0 , b = true }.b)) in (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in u) ) ({a = false , b = 0 }.b))))
(fix (\x: Nat . (unfold [ Unit ] (fold [ Unit ] ({a = ({a = (if true then 1 else 0) , b = false }.a) , b = ({a = 0 , b = false }.b) }.b) )) ))
(unfold [ Bool ] (fold [ Nat ] ({a = (fix (\x: Unit . (if ({a = true , b = false }.b) then (fix (\x: Unit . true )) else (let u = 1 in false)) )) , b = (fix (\x: Unit . ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) )) }.b) ))
({a = ({a = (pred 0) , b = (((\x: Unit .\y: Bool .x) (iszero 1) ) (let u = ({a = false , b = true }.b) in false)) , c = (succ 1) }.c) , b = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) (case <r = (((\x: Bool .\y: Unit .y) false ) false) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  (case <l = (fix (\x: Rec X. X . (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) )) > as Bool of < l = x > => x | < r = y > => y) }.b)
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Nat . ({a = (let u = 0 in 1) , b = (( \f: Nat .((f false ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .b)) , c =  (let u = (let u = ({a = 0 , b = true , c =  0 }.b) in (if true then 0 else 1)) in ({a = 1 , b = (unfold [ Nat ] (fold [ Bool ] 0 )) }.b)) }.b) )) ))
(unfold [ Nat ] (fold [ Bool ] (fix (\x: Nat . (( \f: Rec X. X .((f (succ ({a = ({a = 0 , b = 0 }.b) , b = 1 }.b)) ) (((\x: Nat .\y: Bool .x) (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Unit ] 0 )) )) ) (let u = (let u = 0 in 1) in (iszero 0))) ) ) (\a: Unit .\b: Nat .b)) )) ))
(iszero ({a = (pred (let u = 1 in 0)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) false ) 1) )) }.b))
(fix (\x: Nat . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (((\x: Bool .\y: Rec X. X .x) false ) false) in ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 ))) )) ))
(fix (\x: Bool . (let u = (unfold [ Bool ] (fold [ Bool ] ({a = ({a = true , b = 1 }.b) , b = (( \f: Rec X. X .((f ({a = true , b = true }.b) ) true ) ) (\a: Nat .\b: Unit .b)) , c = (( \f: Nat .((f ({a = 0 , b = false , c = 0 }.c) ) (succ 0) ) ) (\a: Nat .\b: Nat .b)) }.c) )) in (let u = (case <l = ({a = 1 , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)))) ))
(succ (case <l = ({a = (let u = 0 in 0) , b = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .a)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y))
(if ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = (pred 0) , b = false }.b) )) , b = ({a = (let u = (fix (\x: Rec X. X . 1 )) in 1) , b = ({a = ({a = 1 , b = 1 }.b) , b = (let u = false in u) , c =  0 }.b) , c = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = false in 1) )) }.c) }.a) then (unfold [ Bool ] (fold [ Bool ] (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then ({a = 0 , b = true , c =  0 }.b) else (((\x: Unit .\y: Rec X. X .x) true ) true)) )) else (unfold [ Rec X. X ] (fold [ Rec X. X ] (if (case <r = (unfold [ Unit ] (fold [ Unit ] (iszero 0) )) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Unit .((f (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) (( \f: Bool .((f (let u = true in true) ) (let u = 0 in true) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .a)) else (fix (\x: Nat . true ))) )))
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (if ({a = (unfold [ Unit ] (fold [ Bool ] ({a = true , b = 1 }.b) )) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) then ({a = true , b = ({a = 1 , b = true }.a) }.a) else (if ({a = 0 , b = true }.b) then false else (((\x: Nat .\y: Nat .x) false ) true))) ))
(let u = (let u = (if true then 1 else (((\x: Unit .\y: Bool .y) true ) 0)) in ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) true) , b = ({a = false , b = false }.b) , c = (succ (((\x: Nat .\y: Unit .x) 0 ) false)) }.c)) in ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (if (((\x: Unit .\y: Nat .x) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .b)) ) true) then (let u = false in false) else ({a = true , b = false }.b)) )))
(unfold [ Nat ] (fold [ Nat ] (let u = (fix (\x: Unit . (iszero ({a = 1 , b = true }.a)) )) in u) ))
({a = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Nat . 1 )) )) ) (let u = ({a = false , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.a) in (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = (let u = false in false) }.a) ))) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = (case <r = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (let u = false in u)) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (let u = ({a = true , b = true }.b) in 0) , b = (((\x: Nat .\y: Bool .y) ({a = true , b = false }.b) ) ({a = (let u = false in u) , b = false }.b)) }.b) }.b) }.a)
(((\x: Nat .\y: Nat .y) (((\x: Bool .\y: Bool .y) ({a = ({a = 1 , b = ({a = 0 , b = false , c = 1 }.c) }.b) , b = ({a = 0 , b = ({a = 0 , b = false , c =  1 }.b) , c =  ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) }.b) }.b) ) (((\x: Bool .\y: Unit .y) ({a = true , b = false }.b) ) ({a = false , b = true }.b))) ) ({a = (let u = (((\x: Nat .\y: Bool .y) false ) true) in u) , b = (fix (\x: Rec X. X . ({a = 1 , b = false }.b) )) }.b))
({a = (succ (if ({a = 0 , b = false }.b) then ({a = 0 , b = true , c = 1 }.c) else ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (pred 1) )))) , b = (case <r = (( \f: Unit .((f true ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = (let u = 1 in true) in ({a = true , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b)) )) , b = (( \f: Bool .((f (( \f: Bool .((f (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Rec X. X .a)) ) (( \f: Bool .((f (if false then true else false) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) , b = true }.b) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .a)) , c =  (pred ({a = (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) ({a = 1 , b = true , c =  1 }.b)) , b = ({a = ({a = 1 , b = true }.a) , b = 0 }.b) }.b)) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f ({a = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .a)) , b = (((\x: Unit .\y: Bool .x) 1 ) false) }.a) ) (( \f: Unit .((f true ) (fix (\x: Bool . false )) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Unit .b)) , b = (if (fix (\x: Rec X. X . false )) then ({a = false , b = 0 }.b) else (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a))) }.a) ))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (case <r = (if (let u = (succ 0) in (let u = 1 in true)) then (fix (\x: Unit . (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b)) )) else ({a = (if true then 0 else 0) , b = true , c =  (if false then 0 else 1) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) ))
({a = (((\x: Bool .\y: Bool .x) (fix (\x: Unit . ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) )) ) (((\x: Unit .\y: Unit .x) (let u = true in false) ) true)) , b = (let u = (let u = (let u = true in 0) in ({a = (let u = false in 1) , b = false , c =  (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.b)) in (( \f: Nat .((f (let u = true in false) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) , c = (let u = (let u = ({a = false , b = 1 }.a) in 0) in (( \f: Bool .((f ({a = false , b = 0 }.b) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Nat .a))) }.c)
(( \f: Nat .((f (let u = (unfold [ Nat ] (fold [ Nat ] (let u = 1 in u) )) in u) ) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) (let u = true in u) ) ) (\a: Rec X. X .\b: Unit .b)) ) (( \f: Nat .((f (iszero 0) ) true ) ) (\a: Nat .\b: Nat .b))) ) ({a = (let u = ({a = 1 , b = false }.b) in (unfold [ Bool ] (fold [ Unit ] true ))) , b = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) }.b)) ) ) (\a: Nat .\b: Unit .b))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f (if (let u = 1 in false) then ({a = false , b = 0 }.a) else (let u = false in u)) ) (iszero (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) ) ) (\a: Unit .\b: Bool .a)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f ({a = true , b = 0 }.a) ) (((\x: Unit .\y: Unit .x) false ) true) ) ) (\a: Nat .\b: Unit .b)) ))) ))
(let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (pred ({a = 1 , b = 1 }.b)) , b = (let u = ({a = true , b = 0 }.a) in u) }.a) )) in (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ))))
(pred (((\x: Nat .\y: Rec X. X .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (pred 0) )) ) (((\x: Unit .\y: Unit .x) (let u = true in u) ) ({a = (let u = 0 in true) , b = (((\x: Bool .\y: Unit .y) false ) 0) }.a))))
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (if (iszero 1) then (( \f: Rec X. X .((f true ) (iszero 0) ) ) (\a: Unit .\b: Bool .b)) else (let u = true in true)) )) , b = (case <l = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) }.a)
(((\x: Rec X. X .\y: Nat .x) ({a = (let u = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .a))) , b = (case <l = ({a = false , b = (((\x: Bool .\y: Unit .x) 1 ) false) }.b) > as Unit of < l = x > => x | < r = y > => y) }.b) ) (fix (\x: Bool . (if (((\x: Bool .\y: Nat .y) false ) false) then (let u = false in false) else (fix (\x: Nat . true ))) )))
({a = ({a = (( \f: Rec X. X .((f ({a = (let u = 1 in 0) , b = (let u = true in 1) }.b) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Unit .\b: Nat .b)) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = 1 in u) )) }.b) , b = ({a = (let u = ({a = 1 , b = 1 }.b) in ({a = true , b = false }.b)) , b = ({a = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) in ({a = 1 , b = (let u = 1 in true) }.b)) , b = (((\x: Rec X. X .\y: Unit .y) true ) 0) }.b) }.a) , c = ({a = (((\x: Nat .\y: Unit .y) ({a = true , b = 0 }.a) ) (pred 1)) , b = (( \f: Rec X. X .((f (let u = false in u) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) , c = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Rec X. X .b)) }.c) }.c)
(((\x: Unit .\y: Bool .y) (let u = (((\x: Rec X. X .\y: Bool .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) (let u = false in true)) in (let u = ({a = false , b = 1 }.b) in ({a = 0 , b = true , c =  0 }.b))) ) (iszero (let u = 0 in u)))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = (pred 0) , b = (let u = true in (iszero 0)) , c =  (if false then 0 else 1) }.b) )) in (fix (\x: Rec X. X . (( \f: Nat .((f (let u = true in false) ) (let u = true in false) ) ) (\a: Nat .\b: Nat .a)) )))
(fix (\x: Rec X. X . ({a = (unfold [ Rec X. X ] (fold [ Bool ] ({a = 0 , b = true }.a) )) , b = (if ({a = ({a = 0 , b = false , c = 1 }.c) , b = true , c =  0 }.b) then (((\x: Bool .\y: Rec X. X .y) true ) false) else (fix (\x: Rec X. X . false ))) , c =  (pred (let u = 1 in u)) }.b) ))
(pred (fix (\x: Nat . (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )))
({a = (let u = (( \f: Rec X. X .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Bool ] false )) ) (fix (\x: Rec X. X . true )) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Bool .b)) in (case <l = (fix (\x: Rec X. X . 1 )) > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = (succ (fix (\x: Unit . 1 ))) in ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . true )) ))) }.a)
({a = (let u = (unfold [ Unit ] (fold [ Unit ] ({a = ({a = false , b = 0 }.a) , b = (unfold [ Nat ] (fold [ Bool ] ({a = 0 , b = true , c =  1 }.b) )) }.b) )) in ({a = (let u = 1 in true) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .b)) }.b)) , b = (if (fix (\x: Rec X. X . (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Unit ] true )) )) )) then (unfold [ Unit ] (fold [ Rec X. X ] ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (pred 0) }.b) )) else (((\x: Nat .\y: Unit .x) ({a = 1 , b = false }.a) ) ({a = (pred 0) , b = true , c =  (((\x: Unit .\y: Rec X. X .y) false ) 1) }.b))) }.b)
(( \f: Nat .((f (((\x: Unit .\y: Bool .x) ({a = (let u = (pred 1) in (let u = false in 1)) , b = ({a = (( \f: Bool .((f ({a = 1 , b = false }.a) ) (fix (\x: Bool . 0 )) ) ) (\a: Unit .\b: Bool .a)) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) }.a) ) ({a = (( \f: Unit .((f (((\x: Nat .\y: Unit .y) false ) 1) ) (((\x: Nat .\y: Nat .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) ) 1) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Bool .((f ({a = false , b = true }.b) ) true ) ) (\a: Bool .\b: Bool .a)) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) )) }.b)) ) (let u = (( \f: Rec X. X .((f (if false then (unfold [ Nat ] (fold [ Unit ] 1 )) else (if false then 0 else 1)) ) ({a = (((\x: Bool .\y: Unit .x) ({a = 0 , b = 0 }.b) ) false) , b = (let u = 0 in u) }.b) ) ) (\a: Bool .\b: Nat .b)) in u) ) ) (\a: Nat .\b: Bool .b))
(unfold [ Bool ] (fold [ Nat ] (let u = ({a = (let u = 1 in false) , b = 1 }.b) in (let u = (unfold [ Bool ] (fold [ Bool ] 0 )) in ({a = 1 , b = true , c = 0 }.c))) ))
({a = (( \f: Nat .((f (let u = (((\x: Rec X. X .\y: Unit .x) 1 ) false) in u) ) (let u = (((\x: Unit .\y: Unit .x) 1 ) false) in u) ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Unit .\y: Bool .y) (let u = (if true then false else false) in false) ) (if (((\x: Nat .\y: Rec X. X .y) false ) false) then ({a = false , b = 1 }.a) else (((\x: Unit .\y: Rec X. X .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (iszero 1)))) , c = (case <l = (let u = (unfold [ Nat ] (fold [ Nat ] (pred 0) )) in u) > as Nat of < l = x > => x | < r = y > => y) }.c)
(( \f: Bool .((f ({a = (fix (\x: Bool . (pred 1) )) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , b = (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = false }.b) ) 1) }.a) }.b) ) (((\x: Nat .\y: Unit .x) (iszero 0) ) (case <r = ({a = 1 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .a))
(((\x: Bool .\y: Unit .x) ({a = (let u = ({a = false , b = 1 }.a) in u) , b = (( \f: Bool .((f (fix (\x: Bool . 1 )) ) (succ ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 ))) ) ) (\a: Rec X. X .\b: Bool .a)) }.a) ) (((\x: Bool .\y: Rec X. X .x) (let u = (let u = true in u) in u) ) ({a = (let u = false in u) , b = ({a = true , b = 0 }.b) }.a)))
(((\x: Unit .\y: Bool .y) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = false , b = true }.b) )) , b = (let u = ({a = (fix (\x: Unit . 0 )) , b = true , c = 1 }.c) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.b) ) (let u = (((\x: Rec X. X .\y: Bool .x) (case <r = ({a = 0 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) in (let u = ({a = 0 , b = ({a = 1 , b = true , c =  1 }.b) }.a) in ({a = 1 , b = true , c = 1 }.c))))
(case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . false )) )) > as Nat of < l = x > => x | < r = y > => y)
(if (let u = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = ({a = false , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a)) }.b) , c =  ({a = (((\x: Unit .\y: Nat .x) false ) true) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) }.b) }.b) in (( \f: Bool .((f (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Bool .x) (if true then true else false) ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)))) ) (fix (\x: Bool . (fix (\x: Unit . true )) )) ) ) (\a: Unit .\b: Rec X. X .a))) then ({a = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) false) , b = (let u = true in 1) }.a) , b = (((\x: Rec X. X .\y: Unit .y) (fix (\x: Bool . ({a = true , b = 0 }.a) )) ) (if ({a = false , b = false }.b) then false else ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )))) }.b) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Bool .x) true ) (((\x: Nat .\y: Bool .x) true ) true)) )) )))
(((\x: Bool .\y: Bool .y) (( \f: Bool .((f (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) ) (let u = (let u = 1 in 1) in (let u = false in u)) ) ) (\a: Unit .\b: Nat .a)) ) (let u = (let u = (( \f: Nat .((f 0 ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) in u) in ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Nat .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) (let u = 0 in false)) , c = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.c)))
(let u = (let u = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (((\x: Nat .\y: Bool .x) true ) false) }.b) in (let u = 1 in u)) in (let u = (( \f: Rec X. X .((f (case <l = ({a = 1 , b = false , c = 1 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = true }.a) , b = (let u = false in u) }.a) ) ) (\a: Unit .\b: Nat .a)) in (((\x: Unit .\y: Nat .y) (unfold [ Nat ] (fold [ Bool ] false )) ) (let u = false in u))))
({a = (let u = (((\x: Bool .\y: Unit .x) (((\x: Rec X. X .\y: Bool .y) false ) true) ) ({a = false , b = 0 }.a)) in u) , b = (pred (fix (\x: Bool . ({a = (succ 1) , b = (if false then 0 else 1) }.b) ))) }.a)
(pred ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) (iszero 0) ) (((\x: Bool .\y: Rec X. X .y) false ) 0)) )))
(((\x: Bool .\y: Bool .x) (fix (\x: Unit . (if (let u = false in false) then (let u = 0 in false) else ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = ({a = 1 , b = true }.b) }.b)) )) ) (fix (\x: Unit . (( \f: Bool .((f (case <r = ({a = true , b = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a)) }.b) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (let u = 1 in false) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Unit .a)) )))
(((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Nat .x) (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) (if (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Bool .b)) then ({a = 0 , b = false }.b) else (((\x: Unit .\y: Unit .y) true ) (iszero 0)))) ) ({a = (fix (\x: Bool . (if false then 1 else ({a = 1 , b = false , c = 0 }.c)) )) , b = (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .y) false ) true) )) }.b))
(let u = (fix (\x: Rec X. X . (( \f: Rec X. X .((f (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) in true) ) ) (\a: Nat .\b: Rec X. X .b)) )) in u)
(fix (\x: Unit . ({a = (succ ({a = 1 , b = false }.a)) , b = (let u = (if true then 1 else 0) in u) }.b) ))
(succ (( \f: Bool .((f (if ({a = (if false then false else false) , b = (pred (((\x: Nat .\y: Rec X. X .y) true ) 1)) }.a) then ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = (let u = 1 in (fix (\x: Nat . false ))) , c = (succ 1) }.c) else ({a = ({a = 0 , b = false , c = 1 }.c) , b = 0 }.b)) ) (let u = (if false then (((\x: Unit .\y: Bool .y) false ) true) else true) in (let u = 0 in 0)) ) ) (\a: Nat .\b: Bool .b)))
(let u = (if (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 1 )) in (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) false ) true) ) (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) in false) ) ) (\a: Rec X. X .\b: Nat .a))) then ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , b = (if true then true else true) }.b) else (((\x: Bool .\y: Bool .x) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = 1 , b = true }.b))) in (((\x: Nat .\y: Nat .x) ({a = (let u = 1 in u) , b = (((\x: Bool .\y: Bool .y) true ) (if false then false else true)) }.b) ) ({a = true , b = 0 }.a)))
(( \f: Bool .((f (let u = ({a = (((\x: Bool .\y: Nat .x) false ) false) , b = (let u = false in 0) }.b) in u) ) (if (((\x: Bool .\y: Nat .y) ({a = (pred 0) , b = ({a = 0 , b = false }.b) }.b) ) (fix (\x: Unit . (let u = false in u) ))) then (( \f: Bool .((f ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Nat ] (fix (\x: Rec X. X . true )) )) }.a) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) in (if true then 1 else 1)) ) ) (\a: Rec X. X .\b: Bool .b)) else (let u = (let u = (fix (\x: Unit . 1 )) in ({a = false , b = 1 }.b)) in u)) ) ) (\a: Unit .\b: Rec X. X .a))
(( \f: Unit .((f (let u = (unfold [ Nat ] (fold [ Nat ] (iszero 0) )) in u) ) (fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .x) (if false then true else true) ) (( \f: Unit .((f (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) true ) ) (\a: Bool .\b: Bool .b))) )) ) ) (\a: Bool .\b: Bool .a))
({a = (((\x: Rec X. X .\y: Bool .x) (let u = (let u = false in (let u = false in 0)) in (( \f: Bool .((f true ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .a))) ) ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) }.b)) , b = ({a = (fix (\x: Nat . (fix (\x: Bool . 0 )) )) , b = ({a = ({a = 1 , b = true , c =  0 }.b) , b = (let u = false in 0) }.a) }.a) }.a)
(let u = (( \f: Rec X. X .((f (let u = (( \f: Bool .((f ({a = false , b = (fix (\x: Nat . true )) }.b) ) (let u = ({a = 1 , b = false }.b) in (let u = 0 in false)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (((\x: Nat .\y: Rec X. X .y) ({a = false , b = false }.b) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)))) ) (if (if ({a = 0 , b = false , c =  0 }.b) then (let u = true in true) else (unfold [ Nat ] (fold [ Rec X. X ] false ))) then ({a = (let u = false in 0) , b = (unfold [ Nat ] (fold [ Unit ] 1 )) }.b) else (let u = (let u = true in true) in ({a = 1 , b = (let u = 0 in u) }.b))) ) ) (\a: Bool .\b: Nat .a)) in u)
(let u = (pred (if ({a = false , b = (((\x: Bool .\y: Nat .x) false ) true) }.b) then ({a = true , b = 0 }.b) else ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )))) in ({a = (case <r = (let u = true in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . (succ 1) )) }.b))
(let u = (if (( \f: Unit .((f (fix (\x: Rec X. X . false )) ) (let u = false in u) ) ) (\a: Bool .\b: Unit .b)) then ({a = ({a = (let u = 1 in 0) , b = 0 }.b) , b = (if true then false else true) }.a) else ({a = (let u = (((\x: Bool .\y: Bool .y) false ) false) in 1) , b = (succ 0) }.b)) in (if (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) in (unfold [ Unit ] (fold [ Unit ] false ))) then (( \f: Nat .((f ({a = ({a = false , b = 1 }.b) , b = (iszero 1) }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) )) ) ) (\a: Unit .\b: Unit .a)) else (case <r = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true )) > as Nat of < l = x > => x | < r = y > => y)))
(((\x: Nat .\y: Unit .x) (iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = 0 , b = true , c = 0 }.c) , b = false }.a) ))) ) ({a = ({a = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = ({a = 0 , b = 1 }.b) }.b) , b = ({a = 0 , b = false , c =  (((\x: Nat .\y: Unit .x) 1 ) false) }.b) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) false ) true) )) }.b))
(((\x: Unit .\y: Bool .y) (unfold [ Bool ] (fold [ Bool ] ({a = (((\x: Unit .\y: Unit .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) false) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.b) )) ) (( \f: Unit .((f (let u = 1 in u) ) (case <l = (((\x: Nat .\y: Unit .y) (let u = 1 in false) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b))) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)))
({a = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (iszero (fix (\x: Rec X. X . 0 ))) , b = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (pred 0) }.b) }.b) )) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Bool . 1 )) )) , b = (let u = (let u = false in (fix (\x: Unit . true ))) in u) , c =  (let u = ({a = 0 , b = true , c = 1 }.c) in (let u = true in ({a = 1 , b = 1 }.b))) }.b) }.b)
(( \f: Nat .((f (let u = ({a = (fix (\x: Unit . ({a = false , b = false }.b) )) , b = ({a = 0 , b = false }.b) }.b) in (fix (\x: Rec X. X . (let u = ({a = 1 , b = true }.b) in (let u = 0 in true)) ))) ) ({a = (fix (\x: Unit . ({a = 0 , b = ({a = true , b = true }.b) , c =  1 }.b) )) , b = ({a = (let u = (fix (\x: Unit . true )) in true) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) , b = false , c = 1 }.c) }.a) }.b) ) ) (\a: Nat .\b: Nat .a))
(((\x: Bool .\y: Rec X. X .y) (unfold [ Bool ] (fold [ Nat ] (let u = ({a = false , b = (unfold [ Bool ] (fold [ Bool ] false )) }.b) in (let u = (fix (\x: Rec X. X . true )) in true)) )) ) (case <l = (if ({a = 1 , b = true }.b) then 1 else (if true then 0 else 0)) > as Nat of < l = x > => x | < r = y > => y))
({a = (iszero ({a = (((\x: Unit .\y: Rec X. X .y) true ) (let u = 1 in u)) , b = (let u = true in u) , c = (((\x: Unit .\y: Rec X. X .x) 1 ) (let u = true in u)) }.c)) , b = (unfold [ Unit ] (fold [ Bool ] ({a = (let u = (let u = true in true) in (let u = false in 1)) , b = (((\x: Nat .\y: Unit .x) (let u = 0 in 0) ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b))) }.b) )) }.a)
(let u = (( \f: Bool .((f (( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) )) ) (fix (\x: Rec X. X . (let u = 0 in false) )) ) ) (\a: Rec X. X .\b: Unit .b)) ) (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Rec X. X .\b: Bool .a)) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) (fix (\x: Rec X. X . false )) ) ({a = 0 , b = (iszero 0) , c =  1 }.b)) )))
(fix (\x: Nat . (case <r = (unfold [ Unit ] (fold [ Nat ] (if (let u = true in false) then (((\x: Nat .\y: Rec X. X .y) false ) (unfold [ Unit ] (fold [ Nat ] false ))) else (let u = true in true)) )) > as Bool of < l = x > => x | < r = y > => y) ))
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Unit .x) true ) (if false then false else false)) ) (((\x: Bool .\y: Rec X. X .x) 1 ) true)) in ({a = true , b = true }.b)) ))
({a = (pred (pred (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)))) , b = (iszero (((\x: Bool .\y: Unit .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) ) (fix (\x: Bool . ({a = 1 , b = true , c =  0 }.b) )))) }.b)
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Bool .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) )) ) ({a = (if ({a = false , b = 1 }.a) then (((\x: Unit .\y: Unit .y) true ) 1) else 1) , b = (let u = 0 in true) , c =  (succ 0) }.b)) ))
(((\x: Bool .\y: Bool .y) (if (unfold [ Nat ] (fold [ Nat ] false )) then (fix (\x: Rec X. X . (let u = true in u) )) else ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in u) , c =  (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.b)) ) (if (let u = (let u = 0 in true) in ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = true in u) ))) then (fix (\x: Bool . ({a = 0 , b = 1 }.b) )) else ({a = 0 , b = ({a = 1 , b = true , c =  1 }.b) , c = (pred 0) }.c)))
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Unit .y) ({a = ({a = 0 , b = false , c = 0 }.c) , b = true }.b) ) (succ (case <l = (((\x: Bool .\y: Nat .x) 0 ) false) > as Bool of < l = x > => x | < r = y > => y))) ))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (succ (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) )) , b = (unfold [ Rec X. X ] (fold [ Nat ] (if ({a = false , b = 1 }.a) then (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) else (let u = false in (unfold [ Rec X. X ] (fold [ Bool ] false )))) )) }.a)
({a = (let u = (unfold [ Nat ] (fold [ Nat ] (let u = ({a = 1 , b = true }.b) in u) )) in (pred (((\x: Bool .\y: Bool .x) 1 ) ({a = 0 , b = false , c =  1 }.b)))) , b = (fix (\x: Bool . (( \f: Nat .((f ({a = ({a = true , b = false }.b) , b = (iszero 0) }.b) ) (case <r = ({a = true , b = 0 }.a) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b)) )) , c =  ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (succ (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .b)) in ({a = (let u = 1 in u) , b = true , c = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) }.c))) )) }.b)
({a = (( \f: Nat .((f (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) ({a = false , b = false }.b) ) (unfold [ Unit ] (fold [ Bool ] true ))) ) (fix (\x: Bool . (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) in u) )) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = (succ (((\x: Bool .\y: Nat .x) ({a = true , b = 1 }.b) ) (let u = true in false))) , b = ({a = (let u = 1 in u) , b = false }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f (((\x: Bool .\y: Unit .y) false ) 1) ) (((\x: Nat .\y: Unit .y) true ) 1) ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) true ) false) ) false ) ) (\a: Nat .\b: Unit .b)) , b = (if true then 0 else 0) }.a)) }.a)
(let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) true ) ({a = 1 , b = false }.b)) )) in ({a = (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) true ) true) ) (case <r = (let u = 0 in true) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Bool .\y: Unit .y) (if false then false else true) ) ({a = 0 , b = true , c =  0 }.b)) }.b))
(succ (((\x: Nat .\y: Nat .x) (fix (\x: Bool . 1 )) ) (((\x: Rec X. X .\y: Unit .y) false ) true)))
(let u = (pred ({a = (( \f: Nat .((f false ) (((\x: Nat .\y: Bool .y) false ) false) ) ) (\a: Unit .\b: Nat .a)) , b = (let u = (fix (\x: Bool . 1 )) in (fix (\x: Rec X. X . 1 ))) }.b)) in ({a = ({a = (unfold [ Bool ] (fold [ Bool ] (succ 1) )) , b = (let u = (let u = 0 in u) in (unfold [ Nat ] (fold [ Rec X. X ] true ))) }.b) , b = (pred (let u = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = true , b = 1 }.a) }.a) in (if true then 1 else ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 ))))) }.a))
({a = ({a = (((\x: Unit .\y: Rec X. X .y) true ) true) , b = (let u = false in 0) }.b) , b = (((\x: Unit .\y: Unit .x) (unfold [ Nat ] (fold [ Bool ] (iszero 1) )) ) (let u = ({a = ({a = 0 , b = false , c = 1 }.c) , b = (let u = 1 in true) , c =  (((\x: Bool .\y: Bool .y) true ) (if true then 1 else 0)) }.b) in (if (let u = 1 in false) then (let u = true in true) else (unfold [ Bool ] (fold [ Unit ] true ))))) , c =  (( \f: Unit .((f (fix (\x: Unit . (unfold [ Unit ] (fold [ Bool ] 1 )) )) ) (unfold [ Bool ] (fold [ Nat ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
(case <l = (if ({a = (((\x: Nat .\y: Rec X. X .y) false ) false) , b = (iszero ({a = 0 , b = true , c = 0 }.c)) }.b) then ({a = 1 , b = (let u = false in true) , c = 1 }.c) else (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) in (succ 0))) > as Unit of < l = x > => x | < r = y > => y)
({a = (pred (pred ({a = (let u = 0 in u) , b = 0 }.b))) , b = (let u = ({a = (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (fix (\x: Nat . true )) , c = ({a = (iszero (if true then 1 else 1)) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.c) in (let u = (((\x: Rec X. X .\y: Bool .y) false ) true) in u)) , c =  (fix (\x: Rec X. X . (case <l = ({a = 0 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) )) }.b)
(let u = (fix (\x: Bool . (fix (\x: Rec X. X . (let u = true in u) )) )) in u)
(((\x: Nat .\y: Unit .y) (case <r = ({a = 1 , b = false , c =  (let u = 1 in 1) }.b) > as Unit of < l = x > => x | < r = y > => y) ) (iszero (case <l = (if (if true then true else false) then 0 else 0) > as Unit of < l = x > => x | < r = y > => y)))
(let u = ({a = (let u = (let u = 0 in u) in (((\x: Nat .\y: Nat .y) false ) true)) , b = ({a = false , b = 0 }.a) }.b) in (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) )) in (pred (let u = 1 in u))))
(((\x: Rec X. X .\y: Nat .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = (unfold [ Bool ] (fold [ Nat ] true )) , b = (let u = 1 in true) }.b) )) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) false ) (iszero 1)) )))
({a = (let u = (((\x: Rec X. X .\y: Unit .y) (fix (\x: Rec X. X . true )) ) (succ 0)) in u) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .x) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) )) , c = (((\x: Rec X. X .\y: Unit .x) (if (fix (\x: Rec X. X . true )) then (((\x: Bool .\y: Rec X. X .y) false ) 1) else (pred (((\x: Unit .\y: Bool .y) false ) 0))) ) (( \f: Rec X. X .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = true in u) ) ) (\a: Nat .\b: Rec X. X .a))) }.c)
(unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Bool .y) (((\x: Bool .\y: Bool .x) false ) false) ) (fix (\x: Bool . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ))) )) ))
(let u = (fix (\x: Bool . (( \f: Bool .((f ({a = false , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) in (unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) 1 ) false) ) (( \f: Unit .((f ({a = true , b = 1 }.b) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )))
({a = (let u = (( \f: Unit .((f (succ 1) ) (if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) then ({a = false , b = 0 }.b) else (((\x: Rec X. X .\y: Unit .y) false ) 0)) ) ) (\a: Rec X. X .\b: Bool .a)) in u) , b = ({a = (( \f: Unit .((f (unfold [ Nat ] (fold [ Bool ] ({a = (let u = false in 0) , b = false , c = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) }.c) )) ) (((\x: Unit .\y: Nat .x) (pred 0) ) ({a = 1 , b = ({a = false , b = false }.b) , c =  ({a = true , b = 1 }.b) }.b)) ) ) (\a: Bool .\b: Unit .b)) , b = ({a = (succ (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f true ) (fix (\x: Unit . false )) ) ) (\a: Unit .\b: Nat .a)) , c =  (let u = true in 1) }.b) }.b) }.b)
(iszero (if (( \f: Unit .((f false ) (((\x: Bool .\y: Unit .x) false ) false) ) ) (\a: Bool .\b: Rec X. X .b)) then (let u = (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true ) ) (\a: Nat .\b: Rec X. X .a)) in (((\x: Bool .\y: Unit .x) (let u = true in 1) ) false)) else (( \f: Rec X. X .((f ({a = 0 , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) ) ({a = 0 , b = 1 }.b) ) ) (\a: Bool .\b: Unit .b))))
(( \f: Unit .((f (let u = (fix (\x: Nat . (((\x: Nat .\y: Nat .x) false ) false) )) in ({a = (if false then 0 else 1) , b = (let u = true in ({a = false , b = 1 }.a)) , c = (if true then 0 else 0) }.c)) ) (succ (( \f: Rec X. X .((f (fix (\x: Unit . (((\x: Nat .\y: Unit .y) (let u = 1 in true) ) 1) )) ) ({a = ({a = false , b = 1 }.b) , b = ({a = 0 , b = false , c =  1 }.b) }.a) ) ) (\a: Bool .\b: Unit .a))) ) ) (\a: Unit .\b: Rec X. X .b))
(((\x: Bool .\y: Rec X. X .x) (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f 0 ) (succ 0) ) ) (\a: Bool .\b: Unit .a)) )) )) ) (fix (\x: Rec X. X . ({a = (( \f: Bool .((f ({a = true , b = 1 }.a) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = (let u = (((\x: Nat .\y: Bool .x) true ) true) in (pred 1)) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)) , c = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.c) }.a) )))
(let u = (let u = (succ (unfold [ Unit ] (fold [ Rec X. X ] 0 ))) in u) in ({a = ({a = (succ 0) , b = (let u = false in false) , c = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) in u) }.c) , b = (if (let u = true in u) then (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) else ({a = true , b = true }.b)) , c = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b))) }.c))
(fix (\x: Unit . (let u = ({a = (let u = true in 0) , b = (let u = false in true) , c = (((\x: Nat .\y: Unit .y) true ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) }.c) in u) ))
(let u = (let u = (fix (\x: Nat . (((\x: Unit .\y: Nat .y) true ) false) )) in (case <l = (let u = false in 0) > as Unit of < l = x > => x | < r = y > => y)) in u)
(let u = (let u = (fix (\x: Bool . (((\x: Unit .\y: Bool .y) false ) 1) )) in (let u = (if false then ({a = 1 , b = true }.b) else true) in (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)))) in (case <l = (((\x: Bool .\y: Rec X. X .y) (fix (\x: Unit . (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) )) ) (pred 0)) > as Bool of < l = x > => x | < r = y > => y))
(iszero (if (iszero (unfold [ Nat ] (fold [ Nat ] ({a = true , b = 1 }.b) ))) then (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Nat ] (if false then 0 else 1) )) )) else (pred (case <l = (((\x: Nat .\y: Nat .y) true ) 0) > as Unit of < l = x > => x | < r = y > => y))))
(let u = (case <l = (succ ({a = (if true then 0 else 1) , b = (((\x: Bool .\y: Bool .x) false ) true) }.a)) > as Bool of < l = x > => x | < r = y > => y) in u)
(((\x: Bool .\y: Unit .x) (unfold [ Unit ] (fold [ Unit ] (let u = ({a = ({a = 1 , b = true , c = 0 }.c) , b = true }.a) in (let u = (let u = ({a = 1 , b = false }.b) in (let u = true in u)) in ({a = 0 , b = (let u = true in u) }.b))) )) ) (fix (\x: Unit . ({a = 0 , b = ({a = false , b = false }.b) }.b) )))
(let u = (( \f: Rec X. X .((f ({a = (( \f: Nat .((f (fix (\x: Rec X. X . 1 )) ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = (pred (succ 1)) }.b) ) (unfold [ Nat ] (fold [ Bool ] ({a = ({a = 0 , b = false }.a) , b = false }.a) )) ) ) (\a: Bool .\b: Nat .a)) in ({a = (let u = ({a = (fix (\x: Nat . 1 )) , b = (((\x: Bool .\y: Unit .y) true ) 0) }.b) in ({a = 1 , b = ({a = 1 , b = false }.b) }.a)) , b = (fix (\x: Nat . ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) )) }.a))
(pred (let u = (case <l = (((\x: Rec X. X .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Nat .x) 0 ) false) in 0) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true ))) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = (((\x: Bool .\y: Nat .y) true ) true) in (((\x: Bool .\y: Nat .x) 0 ) true))))
(iszero (succ (pred ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.b) )))))
(unfold [ Bool ] (fold [ Nat ] (let u = (((\x: Nat .\y: Nat .y) ({a = ({a = false , b = true }.b) , b = (pred 1) }.a) ) (fix (\x: Bool . 1 ))) in ({a = (unfold [ Unit ] (fold [ Bool ] 1 )) , b = (let u = true in ({a = true , b = true }.b)) }.a)) ))
(let u = (if (((\x: Nat .\y: Rec X. X .x) (if true then false else true) ) (if true then false else true)) then (unfold [ Nat ] (fold [ Nat ] (let u = 1 in u) )) else ({a = (case <l = (let u = true in 0) > as Bool of < l = x > => x | < r = y > => y) , b = (iszero (((\x: Rec X. X .\y: Unit .x) 1 ) true)) }.a)) in u)
(if (iszero (((\x: Nat .\y: Rec X. X .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) ) (((\x: Nat .\y: Nat .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (((\x: Unit .\y: Nat .y) true ) false)))) then (let u = (if (let u = 1 in true) then (if false then 0 else 1) else ({a = 0 , b = true }.a)) in (((\x: Unit .\y: Rec X. X .x) 1 ) ({a = 1 , b = true , c =  0 }.b))) else (( \f: Nat .((f ({a = (pred (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b))) , b = ({a = (pred 1) , b = (((\x: Nat .\y: Bool .y) false ) false) , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) }.a) ) (( \f: Unit .((f (((\x: Bool .\y: Nat .y) true ) 0) ) (let u = 0 in (unfold [ Unit ] (fold [ Nat ] 1 ))) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .a)))
(unfold [ Rec X. X ] (fold [ Bool ] (let u = (if false then 0 else 0) in u) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Unit .y) (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then (unfold [ Unit ] (fold [ Nat ] true )) else (unfold [ Unit ] (fold [ Unit ] false ))) ) (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)) ))
(( \f: Unit .((f (fix (\x: Rec X. X . (let u = (let u = 1 in u) in ({a = 0 , b = true }.a)) )) ) ({a = (let u = (let u = false in false) in ({a = 1 , b = false }.a)) , b = (unfold [ Bool ] (fold [ Bool ] (let u = true in false) )) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(( \f: Unit .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Rec X. X .((f (if false then 0 else 1) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) )) ) (let u = (fix (\x: Unit . (((\x: Rec X. X .\y: Bool .y) ({a = 0 , b = false }.b) ) (( \f: Bool .((f (if true then true else true) ) false ) ) (\a: Rec X. X .\b: Unit .a))) )) in ({a = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) in (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .a))) , b = ({a = ({a = 1 , b = 0 }.b) , b = (pred (let u = 1 in 1)) }.b) }.b)) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (iszero (unfold [ Bool ] (fold [ Unit ] (( \f: Nat .((f (( \f: Bool .((f (((\x: Nat .\y: Unit .y) true ) 1) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .b)) ))) in ({a = (pred (succ 1)) , b = ({a = (unfold [ Rec X. X ] (fold [ Nat ] false )) , b = ({a = 0 , b = (((\x: Rec X. X .\y: Nat .y) false ) true) , c = 0 }.c) }.b) }.b))
(( \f: Nat .((f (( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = false , b = true }.b) )) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = 1 in true) )) ) ) (\a: Unit .\b: Bool .b)) ) (let u = (((\x: Rec X. X .\y: Unit .x) ({a = 0 , b = true }.b) ) (let u = 1 in (iszero 1))) in (( \f: Unit .((f (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Unit .x) true ) (iszero 1)) ) ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b)) , b = (((\x: Bool .\y: Rec X. X .x) 1 ) true) }.a)) ) (( \f: Bool .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) (let u = (let u = false in true) in u) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .b))) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(((\x: Nat .\y: Nat .y) (( \f: Unit .((f (case <r = (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .y) false ) false) ) true ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Bool .\b: Rec X. X .b)) ) (( \f: Nat .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ({a = false , b = 1 }.b) , b = (((\x: Bool .\y: Unit .y) true ) true) }.b) )) ) (let u = (unfold [ Nat ] (fold [ Bool ] true )) in u) ) ) (\a: Rec X. X .\b: Bool .b)))
(iszero (unfold [ Rec X. X ] (fold [ Unit ] (case <l = ({a = (((\x: Nat .\y: Nat .x) false ) true) , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) )))
(((\x: Bool .\y: Nat .x) (((\x: Rec X. X .\y: Unit .x) (let u = ({a = 0 , b = false , c = 1 }.c) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 ))) ) (((\x: Unit .\y: Bool .y) (let u = true in true) ) true)) ) ({a = (( \f: Nat .((f ({a = false , b = false }.b) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) , c = (fix (\x: Unit . 0 )) }.c) }.a))
({a = (let u = ({a = (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = true }.b) )) ) (let u = 1 in false) ) ) (\a: Nat .\b: Nat .b)) , b = ({a = 1 , b = 0 }.b) }.b) in ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Rec X. X .x) ({a = 0 , b = false }.b) ) (fix (\x: Nat . false ))) , c =  ({a = (((\x: Bool .\y: Bool .x) true ) true) , b = (unfold [ Nat ] (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) )) }.b) }.b)) , b = (fix (\x: Bool . (unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = 0 , b = false , c = 1 }.c) , b = true }.b) )) )) }.b)
({a = (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) (pred 0) ) (if false then false else true)) ) ({a = (((\x: Unit .\y: Nat .y) ({a = 1 , b = true , c =  0 }.b) ) 0) , b = (fix (\x: Nat . true )) , c = (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.c) ) ) (\a: Unit .\b: Unit .a)) , b = (case <l = (( \f: Unit .((f (((\x: Bool .\y: Nat .x) ({a = true , b = 0 }.b) ) (let u = (fix (\x: Nat . false )) in true)) ) ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = ({a = 1 , b = false }.b) , c = ({a = 1 , b = 0 }.b) }.c) ) ) (\a: Bool .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) }.b)
(if ({a = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) , b = (let u = (let u = 0 in (if false then true else true)) in ({a = true , b = false }.b)) }.b) then ({a = (let u = ({a = (fix (\x: Unit . 1 )) , b = (let u = 0 in 0) }.b) in u) , b = ({a = (case <l = (((\x: Unit .\y: Nat .y) true ) 0) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  ({a = 1 , b = true , c = 1 }.c) }.b) , c = (let u = (succ 1) in 1) }.c) else (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) )) ) ({a = ({a = true , b = 0 }.b) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) ) ) (\a: Bool .\b: Nat .a)))
(unfold [ Bool ] (fold [ Nat ] (let u = ({a = ({a = (((\x: Unit .\y: Unit .x) 0 ) true) , b = true , c = 0 }.c) , b = (((\x: Unit .\y: Nat .x) false ) false) , c =  (case <l = (((\x: Bool .\y: Nat .y) true ) 0) > as Bool of < l = x > => x | < r = y > => y) }.b) in (let u = (succ 1) in u)) ))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = ({a = 0 , b = true , c = 1 }.c) , b = (unfold [ Rec X. X ] (fold [ Nat ] (let u = true in u) )) , c =  (case <l = (let u = 1 in u) > as Unit of < l = x > => x | < r = y > => y) }.b) ))
(succ (pred (( \f: Nat .((f ({a = 1 , b = true , c = 0 }.c) ) 0 ) ) (\a: Bool .\b: Unit .b))))
(let u = (unfold [ Unit ] (fold [ Unit ] (let u = true in (let u = true in true)) )) in u)
(let u = (unfold [ Unit ] (fold [ Bool ] (let u = ({a = 0 , b = 0 }.b) in u) )) in (succ (((\x: Rec X. X .\y: Bool .y) ({a = (if false then ({a = true , b = false }.b) else false) , b = (( \f: Rec X. X .((f false ) ({a = true , b = 1 }.a) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) ({a = 0 , b = false , c =  0 }.b)))))
(pred (unfold [ Nat ] (fold [ Nat ] (case <l = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) , b = ({a = 0 , b = true , c = 1 }.c) }.b) > as Bool of < l = x > => x | < r = y > => y) )))
(( \f: Unit .((f (case <r = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) in ({a = true , b = 0 }.a)) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Nat .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (fix (\x: Nat . false ))) ) (let u = (((\x: Rec X. X .\y: Bool .x) 0 ) true) in (((\x: Nat .\y: Nat .y) false ) false))) ) ) (\a: Nat .\b: Rec X. X .b))
(let u = (let u = (( \f: Unit .((f (((\x: Bool .\y: Unit .y) true ) true) ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .b)) in u) in u)
(( \f: Rec X. X .((f (let u = ({a = 1 , b = (fix (\x: Unit . true )) , c = ({a = 1 , b = true }.a) }.c) in u) ) (succ (let u = 0 in 0)) ) ) (\a: Unit .\b: Unit .a))
({a = (let u = (succ (((\x: Unit .\y: Unit .x) (( \f: Rec X. X .((f 1 ) (pred 1) ) ) (\a: Nat .\b: Nat .a)) ) ({a = true , b = (succ 1) }.a))) in (let u = (((\x: Rec X. X .\y: Nat .x) (if true then false else true) ) (let u = 1 in false)) in u)) , b = ({a = ({a = ({a = 0 , b = false , c =  1 }.b) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in 0) }.b) , b = (( \f: Nat .((f ({a = 0 , b = true , c =  0 }.b) ) ({a = false , b = (((\x: Unit .\y: Rec X. X .y) false ) 1) }.a) ) ) (\a: Rec X. X .\b: Nat .b)) , c = (( \f: Nat .((f ({a = (succ 1) , b = (let u = false in false) , c = 0 }.c) ) ({a = (fix (\x: Rec X. X . 1 )) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .a)) , c = (pred (let u = 0 in 1)) }.c) ) ) (\a: Rec X. X .\b: Unit .b)) }.c) }.b)
(( \f: Bool .((f (( \f: Bool .((f (((\x: Unit .\y: Unit .x) (iszero (let u = true in 0)) ) ({a = true , b = ({a = true , b = 0 }.a) }.b)) ) (let u = (fix (\x: Unit . false )) in (let u = true in (((\x: Nat .\y: Bool .x) false ) true))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (iszero (case <l = (pred 1) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Bool .a))
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = (let u = (((\x: Nat .\y: Unit .x) (if false then 1 else 0) ) true) in u) , b = (fix (\x: Bool . 0 )) }.b) ))
(((\x: Nat .\y: Rec X. X .y) (((\x: Bool .\y: Nat .y) (let u = ({a = (fix (\x: Rec X. X . 1 )) , b = true }.b) in (let u = ({a = 0 , b = true , c =  0 }.b) in u)) ) (( \f: Nat .((f (let u = true in u) ) (let u = false in false) ) ) (\a: Unit .\b: Unit .b))) ) ({a = (let u = (unfold [ Nat ] (fold [ Unit ] (iszero 1) )) in (iszero 0)) , b = ({a = (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (if true then ({a = true , b = 0 }.b) else 1) }.b) }.a))
({a = ({a = (let u = (fix (\x: Rec X. X . false )) in u) , b = (((\x: Bool .\y: Nat .y) (let u = false in u) ) ({a = 0 , b = 1 }.b)) }.b) , b = (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Bool .y) (let u = 1 in false) ) (( \f: Bool .((f (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) false ) ) (\a: Bool .\b: Unit .a))) ) (((\x: Unit .\y: Bool .x) (((\x: Unit .\y: Rec X. X .x) true ) (((\x: Bool .\y: Bool .x) false ) false)) ) (let u = 1 in true))) , c =  (( \f: Nat .((f (let u = 0 in u) ) (((\x: Unit .\y: Bool .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (pred 0) , b = (((\x: Unit .\y: Bool .y) true ) true) , c =  (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.b)) ) ) (\a: Nat .\b: Rec X. X .a)) }.b)
(if (( \f: Nat .((f (iszero (fix (\x: Nat . ({a = ({a = 1 , b = false , c = 0 }.c) , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) }.a) ))) ) (if (( \f: Unit .((f (let u = true in true) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Bool .b)) then (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) else (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .a)) then (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) )) ) (fix (\x: Nat . (((\x: Unit .\y: Nat .y) true ) false) ))) else (((\x: Rec X. X .\y: Nat .x) ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = (((\x: Bool .\y: Rec X. X .y) false ) 1) }.a) ) ({a = (( \f: Nat .((f ({a = false , b = 1 }.a) ) (if false then true else true) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (unfold [ Bool ] (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] true )) )) }.b)))
(((\x: Bool .\y: Unit .y) (( \f: Bool .((f ({a = 0 , b = true }.b) ) ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false , c =  0 }.b) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (if (((\x: Nat .\y: Rec X. X .x) (( \f: Bool .((f true ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Bool .b)) ) (fix (\x: Rec X. X . false ))) then (((\x: Bool .\y: Unit .y) true ) 1) else (( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) (succ 1) ) ) (\a: Bool .\b: Nat .a))))
({a = (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = 0 , b = 0 }.b) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) )) )) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = ({a = 1 , b = ({a = true , b = 0 }.b) }.b) , b = (let u = (let u = 0 in true) in u) , c =  ({a = true , b = 1 }.b) }.b) , c =  (( \f: Bool .((f (fix (\x: Bool . (succ 1) )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) )) ) ) (\a: Bool .\b: Bool .a)) }.b)
(( \f: Nat .((f (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Unit .y) (((\x: Nat .\y: Nat .y) true ) true) ) (succ 1)) ) (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .y) true ) true) ) (if false then true else false) ) ) (\a: Unit .\b: Rec X. X .b)) ))) ) (((\x: Bool .\y: Rec X. X .x) (let u = ({a = 1 , b = false , c = 0 }.c) in u) ) (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = true , c =  1 }.b) ) false))) ) ) (\a: Bool .\b: Nat .b))
(let u = (fix (\x: Bool . ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (if (fix (\x: Bool . false )) then 1 else ({a = 0 , b = 0 }.b)) }.b) )) in u)
(( \f: Rec X. X .((f ({a = (case <l = (succ (let u = 0 in u)) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Bool .y) false ) true) )) }.b) ) (iszero (( \f: Bool .((f (succ (((\x: Nat .\y: Rec X. X .x) 1 ) false)) ) ({a = 1 , b = true }.a) ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(case <l = (fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .x) ({a = 0 , b = true , c = 1 }.c) ) true) )) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (if (if (((\x: Bool .\y: Rec X. X .y) false ) true) then true else (unfold [ Bool ] (fold [ Rec X. X ] true ))) then (( \f: Bool .((f ({a = 1 , b = true , c = 0 }.c) ) (unfold [ Bool ] (fold [ Nat ] 0 )) ) ) (\a: Rec X. X .\b: Unit .a)) else (pred (succ 1))) , b = (let u = (((\x: Unit .\y: Unit .x) false ) ({a = 1 , b = false , c =  1 }.b)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false ))) }.b) , b = ({a = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .a)) , b = ({a = ({a = false , b = 0 }.b) , b = true , c = (let u = 0 in u) }.c) }.b) }.a)
(((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Rec X. X ] (let u = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) in u) in ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = true , c =  0 }.b)) )) ) (pred ({a = false , b = 1 }.b)))
(let u = (case <l = (let u = (let u = false in true) in (pred 0)) > as Bool of < l = x > => x | < r = y > => y) in u)
(let u = (((\x: Unit .\y: Unit .y) (let u = (iszero 1) in (iszero 1)) ) (((\x: Nat .\y: Rec X. X .y) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in false) ) (( \f: Unit .((f (let u = 0 in false) ) false ) ) (\a: Bool .\b: Unit .b)))) in (( \f: Rec X. X .((f (( \f: Bool .((f ({a = 1 , b = false }.a) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = false }.a) )) ) ) (\a: Rec X. X .\b: Unit .a)) ) (unfold [ Unit ] (fold [ Unit ] (let u = 1 in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) ) ) (\a: Rec X. X .\b: Nat .b)))
({a = (succ (succ (pred 0))) , b = (if (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) true ) true) ) ({a = 1 , b = true }.b)) then (pred (succ 0)) else ({a = (pred 0) , b = ({a = 1 , b = ({a = true , b = true }.b) , c =  (let u = 0 in 1) }.b) }.a)) }.b)
(if (fix (\x: Nat . ({a = (let u = true in false) , b = ({a = 0 , b = false }.b) }.b) )) then (((\x: Rec X. X .\y: Bool .x) (pred (succ 0)) ) (fix (\x: Unit . ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ))) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (((\x: Rec X. X .\y: Bool .x) true ) true) in (fix (\x: Rec X. X . 1 ))) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred (( \f: Unit .((f (if ({a = false , b = true }.b) then (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) else ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 ))) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.b) )) ) ) (\a: Unit .\b: Nat .b))) ))
({a = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) (( \f: Unit .((f (unfold [ Bool ] (fold [ Bool ] true )) ) (((\x: Rec X. X .\y: Bool .y) false ) false) ) ) (\a: Bool .\b: Unit .b)) ) ({a = 0 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (succ 1) }.b)) ) (let u = (if false then 0 else 1) in u)) , b = (( \f: Unit .((f (( \f: Unit .((f (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = false , b = false }.b) ) ) (\a: Nat .\b: Bool .a)) ) (iszero ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 ))) ) ) (\a: Nat .\b: Bool .b)) }.a)
(( \f: Unit .((f (( \f: Nat .((f (succ (if false then 0 else 0)) ) (succ (let u = false in 0)) ) ) (\a: Unit .\b: Bool .a)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = 0 }.b) ) (((\x: Unit .\y: Bool .x) false ) false)) )) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (let u = ({a = (((\x: Unit .\y: Rec X. X .x) true ) false) , b = (let u = 0 in u) }.b) in u) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .x) true ) true) )) , b = (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) false ) 1) )) }.a) , c = ({a = (( \f: Unit .((f (( \f: Unit .((f (pred 1) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (pred 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = (unfold [ Rec X. X ] (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] false )) )) in u) }.a) }.c)
(let u = (fix (\x: Unit . (unfold [ Unit ] (fold [ Unit ] ({a = (if false then 0 else 1) , b = true , c = ({a = 0 , b = true , c = 0 }.c) }.c) )) )) in (succ (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) in u)))
(let u = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = 1 }.b) )) in ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = true , b = true }.b) }.a)) in (case <l = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) > as Bool of < l = x > => x | < r = y > => y))
({a = ({a = (let u = (let u = true in u) in ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) , b = (if ({a = (let u = 1 in false) , b = false }.b) then (succ 0) else (((\x: Unit .\y: Rec X. X .x) (let u = true in 0) ) true)) }.b) , b = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (iszero ({a = 0 , b = 0 }.b)) , b = ({a = 1 , b = false }.a) }.b) )) , b = (case <r = (unfold [ Unit ] (fold [ Nat ] true )) > as Bool of < l = x > => x | < r = y > => y) }.b) }.b)
(unfold [ Unit ] (fold [ Nat ] (pred (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) in (case <l = ({a = 0 , b = true }.a) > as Nat of < l = x > => x | < r = y > => y))) ))
(let u = ({a = (succ (let u = true in 0)) , b = ({a = false , b = ({a = 1 , b = true }.a) }.a) }.b) in ({a = (( \f: Rec X. X .((f (( \f: Unit .((f (let u = false in false) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Unit .y) false ) true) ) ) (\a: Bool .\b: Unit .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] ({a = false , b = 0 }.b) )) }.b))
({a = (( \f: Rec X. X .((f (if (let u = false in true) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Rec X. X .x) false ) false)) ) (let u = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) in (((\x: Unit .\y: Unit .x) false ) false)) ) ) (\a: Bool .\b: Nat .a)) , b = (let u = (fix (\x: Nat . (let u = (unfold [ Unit ] (fold [ Nat ] 0 )) in ({a = true , b = 0 }.b)) )) in (let u = (let u = 0 in u) in (unfold [ Unit ] (fold [ Unit ] 1 )))) }.b)
(iszero (((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Unit .y) ({a = (if false then true else false) , b = (((\x: Bool .\y: Bool .y) true ) true) }.b) ) (let u = (iszero (let u = 1 in u)) in (( \f: Unit .((f 0 ) ({a = true , b = 0 }.b) ) ) (\a: Rec X. X .\b: Bool .b)))) ) (if ({a = 1 , b = true }.b) then ({a = false , b = false }.b) else (let u = false in true))))
(let u = (unfold [ Nat ] (fold [ Nat ] ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) in u)
(unfold [ Bool ] (fold [ Bool ] (fix (\x: Nat . ({a = (if true then (if true then true else true) else true) , b = (((\x: Unit .\y: Unit .x) (pred 0) ) (iszero (fix (\x: Bool . 1 )))) }.a) )) ))
(let u = (succ (unfold [ Bool ] (fold [ Nat ] (let u = ({a = true , b = 1 }.b) in 0) ))) in (succ (if (if true then false else false) then (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) else (unfold [ Rec X. X ] (fold [ Bool ] 0 )))))
({a = (fix (\x: Unit . ({a = (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 ))) , b = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , b = false }.b) }.b) )) , b = (if ({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) in false) , b = ({a = false , b = true }.b) }.b) then (iszero 0) else ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in true) ))) }.b)
(let u = ({a = (((\x: Nat .\y: Bool .y) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) , c =  (if false then (unfold [ Rec X. X ] (fold [ Unit ] 0 )) else (let u = 1 in u)) }.b) ) (fix (\x: Bool . (succ 1) ))) , b = (((\x: Rec X. X .\y: Nat .x) (( \f: Bool .((f (fix (\x: Nat . false )) ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Nat .\b: Unit .b)) ) (let u = (fix (\x: Nat . (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) )) in u)) , c =  (let u = (if true then (unfold [ Bool ] (fold [ Unit ] 1 )) else 0) in u) }.b) in (fix (\x: Nat . (pred ({a = 1 , b = 1 }.b)) )))
(if (( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) , b = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) in (unfold [ Unit ] (fold [ Unit ] true ))) }.b) ) (( \f: Rec X. X .((f ({a = true , b = true }.b) ) (( \f: Unit .((f (let u = true in u) ) true ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Bool .b)) then (case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (iszero (let u = false in 0)) )) > as Unit of < l = x > => x | < r = y > => y) else (( \f: Rec X. X .((f (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) ) (unfold [ Unit ] (fold [ Unit ] (if false then false else true) )) ) ) (\a: Bool .\b: Rec X. X .a)))
(( \f: Bool .((f (let u = ({a = ({a = false , b = 1 }.b) , b = (fix (\x: Bool . true )) }.b) in (((\x: Rec X. X .\y: Unit .y) false ) (fix (\x: Nat . 0 )))) ) (( \f: Bool .((f (((\x: Nat .\y: Bool .y) (unfold [ Nat ] (fold [ Unit ] (if (unfold [ Nat ] (fold [ Nat ] true )) then (iszero 1) else true) )) ) (let u = (fix (\x: Nat . 1 )) in u)) ) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Unit .y) false ) true) ) ({a = true , b = (fix (\x: Rec X. X . 0 )) }.b)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (( \f: Bool .((f (( \f: Rec X. X .((f (let u = 0 in 1) ) ({a = 1 , b = 1 }.b) ) ) (\a: Bool .\b: Nat .a)) ) (let u = false in (((\x: Rec X. X .\y: Nat .y) false ) 0)) ) ) (\a: Unit .\b: Bool .b)) , b = (case <r = (( \f: Bool .((f (let u = 0 in true) ) false ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
({a = (( \f: Unit .((f (let u = (unfold [ Bool ] (fold [ Unit ] (pred 1) )) in u) ) (let u = ({a = false , b = 0 }.a) in (let u = 0 in u)) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (((\x: Bool .\y: Rec X. X .x) (let u = 1 in true) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true ))) , b = (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) true ) 1) )) }.a) }.b)
({a = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Bool ] ({a = true , b = true }.b) )) ) ({a = (((\x: Rec X. X .\y: Unit .y) false ) 0) , b = (let u = false in u) , c =  (succ 1) }.b) ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = (case <l = (((\x: Nat .\y: Nat .y) true ) 0) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (( \f: Unit .((f false ) (let u = true in u) ) ) (\a: Unit .\b: Unit .a)) ) (fix (\x: Nat . true )) ) ) (\a: Nat .\b: Unit .b)) }.a) }.b)
(((\x: Nat .\y: Nat .x) (if (((\x: Unit .\y: Rec X. X .x) (let u = false in u) ) (unfold [ Bool ] (fold [ Unit ] false ))) then (((\x: Bool .\y: Nat .y) ({a = false , b = false }.b) ) ({a = ({a = true , b = 1 }.a) , b = (let u = false in true) }.b)) else ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in u) )) , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) , c =  (unfold [ Unit ] (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) }.b)) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <r = (let u = false in false) > as Unit of < l = x > => x | < r = y > => y) )))
({a = (let u = (pred (succ 0)) in u) , b = (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] ({a = false , b = false }.b) )) )) , c =  ({a = (case <l = (( \f: Nat .((f (pred (let u = 1 in u)) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Nat .y) false ) false) ) true) , b = ({a = ({a = false , b = true }.b) , b = ({a = false , b = false }.b) }.b) }.b) }.a) }.b)
({a = (let u = (let u = (((\x: Bool .\y: Rec X. X .x) true ) false) in u) in (( \f: Unit .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a))) , b = ({a = (if (if (iszero 1) then (iszero 0) else (((\x: Nat .\y: Nat .y) false ) false)) then (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in u) else (let u = (if true then 0 else 0) in (let u = true in true))) , b = ({a = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) in false) , b = (if (let u = false in false) then ({a = ({a = 0 , b = true , c = 1 }.c) , b = (((\x: Unit .\y: Nat .x) true ) false) }.a) else (succ 0)) }.b) }.b) }.b)
({a = (fix (\x: Bool . (let u = 1 in u) )) , b = (let u = (if ({a = 0 , b = false , c =  0 }.b) then ({a = true , b = 1 }.a) else false) in u) }.b)
(if (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Unit ] (if (fix (\x: Nat . false )) then (let u = false in false) else false) )) ) (( \f: Nat .((f (iszero ({a = 1 , b = 1 }.b)) ) (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .a)) then (if ({a = ({a = false , b = 1 }.a) , b = ({a = true , b = 0 }.b) }.a) then (( \f: Unit .((f (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .a)) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .b)) else (fix (\x: Unit . (((\x: Unit .\y: Unit .y) (let u = 1 in false) ) true) ))) else (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .y) ({a = 1 , b = true , c =  ({a = false , b = 0 }.b) }.b) ) (case <r = ({a = false , b = false }.b) > as Bool of < l = x > => x | < r = y > => y)) ) (if (if false then true else true) then (fix (\x: Bool . true )) else (((\x: Rec X. X .\y: Unit .y) false ) (((\x: Bool .\y: Rec X. X .x) true ) true))) ) ) (\a: Rec X. X .\b: Bool .a)))
(((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Bool .y) ({a = false , b = false }.b) ) (( \f: Nat .((f false ) (((\x: Bool .\y: Rec X. X .x) true ) false) ) ) (\a: Nat .\b: Bool .a))) ) ({a = (((\x: Bool .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Unit ] 1 )) ) (let u = 1 in false)) , b = (( \f: Bool .((f (if false then (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) else 0) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b))
(((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] (let u = 1 in false) )) )) ) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Bool .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = false , b = 1 }.a) )) ) ({a = 0 , b = (fix (\x: Rec X. X . true )) , c = 1 }.c)) }.b))
(((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Rec X. X .x) ({a = (succ 0) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = true in true) )) }.b) ) (if true then false else (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)))) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = (let u = 0 in u) , b = true , c = 1 }.c) )) in (pred ({a = false , b = 0 }.b))))
(unfold [ Unit ] (fold [ Bool ] ({a = (if (if true then false else false) then true else ({a = 1 , b = false , c =  1 }.b)) , b = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) in u) }.a) ))
(((\x: Bool .\y: Unit .x) (succ (( \f: Rec X. X .((f (let u = 0 in u) ) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = 1 }.b) ) ) (\a: Unit .\b: Unit .b))) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (unfold [ Bool ] (fold [ Rec X. X ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) }.b) )))
(case <l = (let u = ({a = (((\x: Rec X. X .\y: Unit .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) true ) 1) )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = 1 in false) ))) , b = (((\x: Rec X. X .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ) (let u = (fix (\x: Nat . true )) in u)) }.b) in u) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Unit .x) (unfold [ Unit ] (fold [ Bool ] true )) ) (iszero 1)) ) (if (let u = 1 in false) then ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) else (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .a)))) ))
({a = (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) (pred 0) ) ) (\a: Unit .\b: Unit .a)) , b = (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Bool .y) ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = (if false then true else false) , c =  ({a = 0 , b = 1 }.b) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) )) , c = (case <l = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.c)
(pred (if ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = 0 , b = true }.b) }.b) then ({a = (pred 0) , b = (fix (\x: Rec X. X . (succ 0) )) }.b) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ))))
(unfold [ Bool ] (fold [ Rec X. X ] ({a = (let u = (iszero (fix (\x: Unit . 1 ))) in u) , b = (let u = (let u = (succ 0) in 1) in (succ ({a = false , b = 1 }.b))) }.a) ))
({a = (unfold [ Unit ] (fold [ Bool ] ({a = (fix (\x: Rec X. X . 0 )) , b = true }.b) )) , b = ({a = (( \f: Nat .((f (let u = ({a = 1 , b = 1 }.b) in false) ) (iszero (succ 0)) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) }.a)
(((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Bool .x) (let u = (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) in u) in u) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Rec X. X . ({a = (let u = 1 in u) , b = (fix (\x: Bool . false )) , c =  1 }.b) )) ))) ) (let u = (succ ({a = 1 , b = false }.a)) in u))
({a = (( \f: Unit .((f (let u = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ({a = 1 , b = (let u = 1 in false) , c =  (if false then 1 else 1) }.b)) ) (fix (\x: Bool . ({a = 1 , b = true }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (if (iszero 0) then (let u = false in ({a = true , b = 1 }.b)) else (succ 1)) ) (((\x: Unit .\y: Nat .x) ({a = (fix (\x: Unit . false )) , b = false }.b) ) (iszero (((\x: Nat .\y: Bool .x) 1 ) false)))) }.a)
({a = ({a = (let u = false in 0) , b = ({a = (fix (\x: Nat . 0 )) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) }.a) }.b) , b = (pred (( \f: Rec X. X .((f ({a = (fix (\x: Nat . 0 )) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .b)) }.a) ) ({a = ({a = false , b = 1 }.a) , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .b))) }.b)
(( \f: Nat .((f ({a = (succ 1) , b = (iszero ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Rec X. X .\y: Nat .y) false ) 1) }.b)) }.a) ) ({a = (((\x: Bool .\y: Unit .x) ({a = (succ 1) , b = 1 }.b) ) ({a = 0 , b = true }.b)) , b = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) )) ) (let u = ({a = false , b = 0 }.b) in 1) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))
({a = (let u = (let u = ({a = false , b = 1 }.b) in u) in ({a = (pred 0) , b = (let u = true in u) }.a)) , b = (let u = (let u = (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) ({a = 1 , b = true }.b)) in (( \f: Unit .((f false ) (iszero 0) ) ) (\a: Rec X. X .\b: Unit .a))) in (let u = (iszero 1) in (let u = true in (let u = false in false)))) , c =  ({a = (let u = ({a = ({a = 0 , b = true }.a) , b = true , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.b) in (unfold [ Nat ] (fold [ Rec X. X ] true ))) , b = ({a = (succ 0) , b = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = true }.a) }.b) }.b) }.b)
({a = (succ (let u = (let u = false in true) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )))) , b = (((\x: Bool .\y: Rec X. X .y) (let u = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (case <l = (let u = 1 in u) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in u) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if ({a = false , b = true }.b) then ({a = true , b = 0 }.a) else (((\x: Unit .\y: Rec X. X .y) true ) true)) ))) }.a)
(((\x: Rec X. X .\y: Unit .y) (unfold [ Unit ] (fold [ Unit ] ({a = (let u = true in u) , b = ({a = true , b = 1 }.a) }.b) )) ) (case <r = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Unit . (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) )) )) > as Unit of < l = x > => x | < r = y > => y))
({a = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) (fix (\x: Unit . (( \f: Unit .((f (let u = true in false) ) (((\x: Nat .\y: Unit .y) false ) (let u = true in u)) ) ) (\a: Bool .\b: Nat .b)) )) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (if false then 1 else 1) )) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = ({a = 0 , b = true }.a) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) }.a)
(pred (fix (\x: Unit . ({a = (let u = 1 in u) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .a)) , c = (if false then 1 else 1) }.c) )))
(( \f: Rec X. X .((f (((\x: Bool .\y: Bool .x) (fix (\x: Unit . ({a = false , b = 1 }.a) )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) ) (fix (\x: Bool . (fix (\x: Nat . (fix (\x: Unit . false )) )) )) ) ) (\a: Nat .\b: Nat .a))
(( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (iszero (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) )) ) (if (if (let u = (((\x: Nat .\y: Nat .y) false ) false) in false) then ({a = (if true then 0 else 0) , b = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b)) }.b) else ({a = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Rec X. X .\y: Bool .x) 0 ) true) }.a)) then (fix (\x: Rec X. X . (fix (\x: Bool . false )) )) else (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) in (if (if false then true else false) then ({a = false , b = true }.b) else (let u = true in true)))) ) ) (\a: Bool .\b: Unit .a))
(( \f: Rec X. X .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Unit .x) true ) true) ) false) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . 1 )) )) }.b) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) ({a = (iszero 0) , b = (if true then 1 else 1) }.a) ) (succ (fix (\x: Unit . 1 )))) )) ) ) (\a: Bool .\b: Rec X. X .a))
(( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (( \f: Rec X. X .((f ({a = 0 , b = 0 }.b) ) 1 ) ) (\a: Unit .\b: Bool .a)) in u) )) ) (case <l = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a))
(((\x: Nat .\y: Nat .x) (( \f: Rec X. X .((f (let u = ({a = false , b = 1 }.a) in u) ) ({a = (if (((\x: Bool .\y: Nat .x) ({a = true , b = 1 }.a) ) false) then (let u = true in u) else ({a = true , b = (let u = 0 in 1) }.a)) , b = ({a = 1 , b = 0 }.b) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (unfold [ Nat ] (fold [ Bool ] (let u = 1 in u) )) , b = (((\x: Bool .\y: Nat .x) (fix (\x: Bool . true )) ) (unfold [ Rec X. X ] (fold [ Unit ] true ))) }.b))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = true }.a) )) ) ({a = 0 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ))
(((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Nat .y) (iszero (let u = (let u = false in true) in ({a = false , b = 1 }.b))) ) (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f (((\x: Nat .\y: Unit .y) false ) false) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) ))) ) (( \f: Bool .((f ({a = false , b = (if true then 1 else 0) }.b) ) (((\x: Bool .\y: Bool .x) (unfold [ Nat ] (fold [ Nat ] 0 )) ) ({a = false , b = false }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
({a = (fix (\x: Bool . ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.b) )) , b = (if (( \f: Bool .((f (let u = 1 in false) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) then (if (((\x: Rec X. X .\y: Nat .x) false ) true) then true else false) else (((\x: Unit .\y: Nat .y) false ) (((\x: Rec X. X .\y: Nat .y) false ) true))) , c =  (pred ({a = ({a = (((\x: Bool .\y: Nat .x) true ) true) , b = ({a = 0 , b = true }.a) }.b) , b = ({a = (let u = 0 in 1) , b = false }.b) , c = (pred ({a = 0 , b = 0 }.b)) }.c)) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Rec X. X .x) 0 ) false) )) )) ))
(((\x: Nat .\y: Nat .x) (let u = (unfold [ Bool ] (fold [ Bool ] (let u = false in false) )) in (((\x: Unit .\y: Bool .y) ({a = ({a = 1 , b = true }.b) , b = (let u = true in false) }.b) ) (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Unit .a)))) ) (let u = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) ({a = false , b = true }.b)) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ({a = (fix (\x: Unit . 1 )) , b = (( \f: Nat .((f true ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Nat .a)) }.b)))
(case <l = (pred (((\x: Rec X. X .\y: Nat .x) (((\x: Rec X. X .\y: Nat .x) (((\x: Nat .\y: Bool .x) 0 ) true) ) true) ) (unfold [ Nat ] (fold [ Unit ] true )))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (case <r = (fix (\x: Rec X. X . (fix (\x: Nat . false )) )) > as Bool of < l = x > => x | < r = y > => y) in (( \f: Bool .((f ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = true , b = 1 }.a) )) , c =  (fix (\x: Nat . 0 )) }.b) ) (iszero (succ 1)) ) ) (\a: Unit .\b: Bool .b)))
(((\x: Bool .\y: Bool .x) (( \f: Bool .((f (let u = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b) in u) ) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) , b = ({a = 1 , b = false , c =  (fix (\x: Rec X. X . 1 )) }.b) , c = (pred (succ 1)) }.c) ) ) (\a: Nat .\b: Bool .b)) ) ({a = (((\x: Unit .\y: Nat .y) (let u = false in false) ) (succ 0)) , b = (let u = (((\x: Rec X. X .\y: Unit .y) false ) false) in u) , c =  (let u = (iszero 1) in (( \f: Rec X. X .((f (fix (\x: Bool . 0 )) ) 0 ) ) (\a: Nat .\b: Unit .b))) }.b))
(pred ({a = (((\x: Nat .\y: Nat .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true ))) , b = (( \f: Unit .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Nat .b)) }.b))
(succ (( \f: Rec X. X .((f (( \f: Bool .((f (pred 1) ) (((\x: Bool .\y: Rec X. X .x) 1 ) false) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Nat .\y: Unit .y) (iszero (fix (\x: Rec X. X . 1 ))) ) (let u = false in 0)) ) ) (\a: Nat .\b: Bool .a)))
(fix (\x: Bool . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in u) )) ))
({a = ({a = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a)) , b = ({a = ({a = 0 , b = true , c = 1 }.c) , b = ({a = (succ 0) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .b)) }.b) }.a) }.b) , b = (case <r = (let u = (let u = true in 0) in false) > as Unit of < l = x > => x | < r = y > => y) , c = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 1 in true) )) in (case <l = (if false then 0 else 0) > as Bool of < l = x > => x | < r = y > => y)) }.c)
(unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .y) (case <r = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in 1) }.a) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . (iszero 0) ))) ))
(fix (\x: Nat . (fix (\x: Unit . (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) in (if true then 1 else 0)) )) ))
(let u = (( \f: Nat .((f (if ({a = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.a) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)) ) (let u = (fix (\x: Unit . ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) )) in (let u = 0 in false)) ) ) (\a: Bool .\b: Bool .b)) in u)
({a = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) (let u = 0 in u) ) (unfold [ Unit ] (fold [ Rec X. X ] true ))) ) (fix (\x: Unit . ({a = 0 , b = 1 }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = (let u = (( \f: Rec X. X .((f false ) (let u = true in u) ) ) (\a: Bool .\b: Bool .a)) in u) , b = (unfold [ Bool ] (fold [ Nat ] (iszero 1) )) }.b) )) }.b)
(fix (\x: Bool . (case <l = ({a = (fix (\x: Unit . 1 )) , b = (((\x: Bool .\y: Nat .y) false ) 1) }.b) > as Nat of < l = x > => x | < r = y > => y) ))
({a = (let u = (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in u) , b = ({a = (let u = (let u = 0 in true) in (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b))) , b = (case <r = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) }.a) }.a)
(( \f: Rec X. X .((f (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) )) ) ({a = ({a = true , b = 1 }.a) , b = (succ 0) }.a) ) ) (\a: Nat .\b: Bool .b)) ) (iszero ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Nat . 0 )) ))) ) ) (\a: Bool .\b: Rec X. X .b))
(iszero (if (unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f ({a = true , b = 0 }.a) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Nat .b)) )) then ({a = (case <l = ({a = 0 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = false , b = 0 }.b) }.b) else (( \f: Rec X. X .((f (( \f: Unit .((f ({a = 0 , b = 1 }.b) ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Bool .a)) ) (succ ({a = 1 , b = true , c = 0 }.c)) ) ) (\a: Bool .\b: Bool .b))))
(((\x: Rec X. X .\y: Unit .x) (case <l = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Bool . 1 )) )) > as Bool of < l = x > => x | < r = y > => y) ) (if (( \f: Rec X. X .((f ({a = 1 , b = false , c =  0 }.b) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in true) )) ) ) (\a: Bool .\b: Bool .b)) then (if true then false else false) else (let u = ({a = 0 , b = true }.a) in ({a = 0 , b = false , c =  1 }.b))))
({a = (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) ) (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) in u) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f (succ (succ 0)) ) (succ (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Unit .y) true ) true) ) 1)) ) ) (\a: Bool .\b: Bool .a)) }.b)
({a = (((\x: Nat .\y: Bool .x) (pred (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) ) (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (case <l = (( \f: Unit .((f (fix (\x: Rec X. X . 0 )) ) 1 ) ) (\a: Unit .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (let u = false in u) in (( \f: Bool .((f (let u = 1 in false) ) false ) ) (\a: Unit .\b: Bool .a))) , c = (if (((\x: Rec X. X .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .b))) then (let u = false in 0) else ({a = 1 , b = false , c = 0 }.c)) }.c) }.b)
(((\x: Rec X. X .\y: Bool .y) (iszero (((\x: Bool .\y: Unit .x) ({a = 1 , b = true }.a) ) (iszero 1))) ) ({a = ({a = (case <r = (if true then (let u = 0 in false) else (iszero 0)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Nat .x) (let u = false in 0) ) (( \f: Nat .((f (if false then false else true) ) false ) ) (\a: Bool .\b: Nat .b))) }.a) , b = (let u = (let u = true in u) in ({a = (fix (\x: Unit . (succ 1) )) , b = ({a = false , b = 0 }.b) }.b)) }.b))
({a = (case <r = (fix (\x: Unit . (( \f: Bool .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) (iszero 0) ) ) (\a: Unit .\b: Unit .a)) )) > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Nat ] (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) )) }.b)
(unfold [ Nat ] (fold [ Nat ] (((\x: Unit .\y: Unit .y) (let u = ({a = false , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.a) in (((\x: Rec X. X .\y: Unit .x) true ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)))) ) (let u = (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) in (if ({a = 0 , b = true }.b) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) else (((\x: Unit .\y: Nat .x) 0 ) true))) in u)) ))
(if (iszero (unfold [ Nat ] (fold [ Unit ] ({a = false , b = 0 }.b) ))) then ({a = (fix (\x: Nat . (fix (\x: Rec X. X . ({a = 0 , b = true }.a) )) )) , b = (let u = (unfold [ Unit ] (fold [ Unit ] (let u = 1 in true) )) in (if (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .b)) then false else (((\x: Rec X. X .\y: Bool .x) false ) false))) , c =  (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .x) 0 ) false) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Bool .\b: Unit .b)) in u) }.b) else (let u = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) in (iszero (unfold [ Nat ] (fold [ Unit ] 1 )))))
(if (iszero (( \f: Bool .((f (pred 1) ) (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in u) ) ) (\a: Nat .\b: Bool .b))) then (((\x: Bool .\y: Nat .x) (fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .x) 1 ) false) )) ) ({a = true , b = false }.b)) else (fix (\x: Nat . ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = (let u = true in true) , c = (if false then 1 else 0) }.c) )))
({a = (( \f: Bool .((f (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = ({a = 0 , b = false , c =  0 }.b) , c =  ({a = true , b = 0 }.b) }.b) )) ) ) (\a: Bool .\b: Unit .a)) , b = (((\x: Bool .\y: Unit .y) ({a = (((\x: Bool .\y: Rec X. X .y) false ) 1) , b = (((\x: Unit .\y: Bool .x) true ) true) , c =  (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .y) false ) 0) ) (pred 1) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) (case <l = ({a = 0 , b = (((\x: Nat .\y: Bool .x) true ) false) , c = (((\x: Bool .\y: Rec X. X .x) 1 ) true) }.c) > as Unit of < l = x > => x | < r = y > => y)) }.b)
(unfold [ Nat ] (fold [ Unit ] (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .x) (let u = 1 in true) ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a))) )) ))
(( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = ({a = 0 , b = false , c =  1 }.b) , b = (fix (\x: Bool . 1 )) }.a) ) (let u = (( \f: Bool .((f (let u = 0 in false) ) true ) ) (\a: Rec X. X .\b: Nat .a)) in ({a = false , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .a)) }.b)) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = (pred (pred 0)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) then (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) else ({a = 0 , b = true }.b)) )) , c =  ({a = ({a = ({a = false , b = false }.b) , b = ({a = 0 , b = false , c = 1 }.c) }.a) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
(unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) , b = 1 }.b) )) ))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (case <l = ({a = 0 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in u) ))) ))
(let u = (let u = ({a = (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) false ) 1) )) , b = ({a = (let u = (unfold [ Bool ] (fold [ Bool ] 1 )) in (fix (\x: Bool . 0 ))) , b = (((\x: Bool .\y: Nat .x) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) false) , c =  (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) }.b) }.a) in u) in (pred ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) true ) true) }.a)))
(( \f: Unit .((f ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) , b = (let u = (((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Unit .y) false ) 1) ) ({a = 1 , b = false , c =  1 }.b)) in (( \f: Nat .((f (if true then false else false) ) (let u = 0 in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .b))) }.a) ) (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Nat . true )) ) true) in (let u = false in 0)) in ({a = (((\x: Unit .\y: Nat .y) true ) 0) , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = (( \f: Bool .((f (( \f: Bool .((f ({a = true , b = 0 }.a) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Unit .\y: Bool .x) ({a = true , b = (if true then true else true) }.b) ) (let u = true in ({a = false , b = false }.b))) ) ) (\a: Nat .\b: Bool .a)) in (if ({a = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) , b = true }.b) , b = (let u = false in u) }.b) then (let u = (fix (\x: Nat . true )) in ({a = false , b = 0 }.b)) else (((\x: Rec X. X .\y: Nat .y) (iszero 0) ) (let u = (((\x: Nat .\y: Bool .y) false ) 1) in u))))
(( \f: Nat .((f (let u = (pred 0) in (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = 1 }.b) )) in (let u = ({a = 0 , b = 1 }.b) in 0))) ) ({a = (let u = (((\x: Rec X. X .\y: Unit .y) false ) 1) in ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = 0 , b = true , c =  0 }.b) , c = 0 }.c)) , b = (((\x: Rec X. X .\y: Bool .x) (if false then false else (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) ({a = 0 , b = (let u = 0 in true) }.b)) , c = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c = 1 }.c) )) in ({a = ({a = true , b = (pred 0) }.a) , b = (if true then 1 else 1) }.b)) }.c) ) ) (\a: Rec X. X .\b: Bool .a))
({a = (iszero ({a = ({a = true , b = true }.b) , b = ({a = 0 , b = 0 }.b) }.b)) , b = (let u = (( \f: Rec X. X .((f true ) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .b)) in (( \f: Unit .((f ({a = false , b = false }.b) ) (let u = 0 in false) ) ) (\a: Bool .\b: Unit .b))) }.b)
(case <r = (((\x: Bool .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) (let u = true in true) ) false) )) ) (((\x: Rec X. X .\y: Nat .y) ({a = false , b = true }.b) ) (let u = ({a = 1 , b = false , c =  0 }.b) in (let u = true in true)))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Nat .y) ({a = (( \f: Unit .((f ({a = true , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) }.b) ) (let u = (case <r = ({a = false , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) in u) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (((\x: Unit .\y: Unit .y) ({a = (iszero 0) , b = (fix (\x: Unit . false )) }.b) ) (( \f: Unit .((f ({a = ({a = 1 , b = false }.a) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) }.a) ) (if (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .b)) then ({a = 0 , b = false , c = 0 }.c) else 0) ) ) (\a: Nat .\b: Nat .b))) }.a) ) (if ({a = false , b = 0 }.a) then (let u = (if false then true else false) in u) else (( \f: Rec X. X .((f (fix (\x: Unit . false )) ) false ) ) (\a: Bool .\b: Nat .b))))
(((\x: Unit .\y: Bool .y) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in false) )) , b = (((\x: Unit .\y: Unit .y) (let u = false in u) ) (let u = true in false)) }.b) ) (((\x: Bool .\y: Rec X. X .x) (succ (let u = 1 in (fix (\x: Unit . 1 )))) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (let u = true in true) , b = 0 }.a) ))))
(((\x: Unit .\y: Bool .y) (iszero (succ (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) ) ({a = (let u = 0 in u) , b = (((\x: Nat .\y: Bool .y) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , b = 1 }.a) ) (((\x: Rec X. X .\y: Bool .x) false ) true)) }.b))
({a = (( \f: Unit .((f (succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) ) (((\x: Unit .\y: Unit .x) ({a = 1 , b = 1 }.b) ) ({a = (case <l = ({a = 1 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true , c =  (((\x: Bool .\y: Nat .x) 0 ) true) }.b) , c =  (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (( \f: Bool .((f ({a = (((\x: Nat .\y: Bool .x) (if true then false else true) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false ))) , b = (let u = (( \f: Unit .((f 0 ) (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) ) (\a: Nat .\b: Bool .b)) in (unfold [ Rec X. X ] (fold [ Bool ] false ))) }.b) ) (iszero (((\x: Unit .\y: Nat .x) ({a = 1 , b = true , c = 0 }.c) ) (let u = 0 in true))) ) ) (\a: Bool .\b: Bool .b)) , c =  ({a = (case <r = (let u = 0 in true) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ({a = (let u = false in true) , b = (pred 0) }.b) , b = (((\x: Nat .\y: Bool .y) (iszero ({a = true , b = 0 }.b)) ) (((\x: Unit .\y: Bool .y) false ) false)) }.a) }.b) }.b)
(let u = (let u = (let u = ({a = 0 , b = false }.b) in (iszero ({a = true , b = 1 }.b))) in u) in u)
(let u = (if (( \f: Unit .((f (let u = 0 in true) ) (unfold [ Nat ] (fold [ Unit ] ({a = false , b = 0 }.a) )) ) ) (\a: Nat .\b: Nat .a)) then (let u = (let u = 1 in u) in u) else ({a = (((\x: Nat .\y: Rec X. X .y) ({a = true , b = false }.b) ) 1) , b = (fix (\x: Unit . false )) }.a)) in (let u = ({a = (if false then 0 else 0) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) , c =  (let u = false in 1) }.b) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = ({a = 0 , b = true }.a) }.a) ))))
(let u = (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Bool .y) ({a = 1 , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.b) ) (( \f: Bool .((f ({a = 0 , b = true }.a) ) 0 ) ) (\a: Nat .\b: Bool .a))) )) in u)
(( \f: Bool .((f (if ({a = (succ ({a = 0 , b = false , c = 0 }.c)) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) then (if ({a = 1 , b = true , c =  1 }.b) then (let u = false in u) else (( \f: Bool .((f true ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .b))) else (unfold [ Bool ] (fold [ Bool ] (if false then (let u = false in false) else ({a = true , b = true }.b)) ))) ) ({a = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Rec X. X . 0 )) )) in (succ 1)) , b = (if (fix (\x: Bool . (((\x: Unit .\y: Nat .x) true ) false) )) then (fix (\x: Unit . (let u = false in u) )) else (fix (\x: Nat . (let u = true in false) ))) , c =  (( \f: Nat .((f ({a = 0 , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) ) (let u = (let u = true in 1) in u) ) ) (\a: Bool .\b: Nat .a)) }.b) ) ) (\a: Bool .\b: Unit .a))
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) (unfold [ Bool ] (fold [ Rec X. X ] true )) ) ({a = false , b = true }.b)) )) ))
(if ({a = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Bool .a)) , b = (( \f: Unit .((f (let u = false in u) ) (let u = false in true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) then ({a = (((\x: Nat .\y: Unit .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) ) (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = ({a = (fix (\x: Bool . true )) , b = (let u = ({a = 1 , b = true }.b) in true) }.b) in ({a = (((\x: Bool .\y: Nat .y) true ) 0) , b = true , c =  ({a = 1 , b = false , c = 0 }.c) }.b)) , c =  ({a = (unfold [ Bool ] (fold [ Unit ] ({a = 1 , b = (succ 1) }.b) )) , b = (((\x: Bool .\y: Rec X. X .y) ({a = true , b = false }.b) ) (pred ({a = 1 , b = false }.a))) }.b) }.b) else ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = (((\x: Bool .\y: Nat .y) (let u = false in u) ) (if (let u = 1 in false) then (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) else ({a = 1 , b = false }.a))) }.a))
({a = ({a = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (let u = false in u) )) , b = (let u = (((\x: Bool .\y: Nat .y) false ) 1) in (fix (\x: Bool . false ))) }.b) , b = (if (let u = (let u = 0 in u) in false) then (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) else (( \f: Unit .((f ({a = true , b = 1 }.b) ) 0 ) ) (\a: Unit .\b: Nat .b))) }.b) , b = (unfold [ Nat ] (fold [ Nat ] (let u = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (if false then 1 else 1) }.b) in (( \f: Unit .((f (iszero (fix (\x: Rec X. X . 1 ))) ) (let u = 1 in true) ) ) (\a: Nat .\b: Rec X. X .b))) )) }.a)
(succ (let u = (if true then ({a = 1 , b = true , c = 0 }.c) else ({a = 0 , b = true }.a)) in (fix (\x: Nat . (succ 0) ))))
(( \f: Unit .((f (unfold [ Bool ] (fold [ Bool ] (let u = (fix (\x: Rec X. X . 1 )) in u) )) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Nat . (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) )) ) ) (\a: Unit .\b: Nat .b))
({a = (( \f: Unit .((f ({a = (fix (\x: Bool . (((\x: Nat .\y: Unit .y) false ) 1) )) , b = (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) , c =  (let u = false in (fix (\x: Rec X. X . 0 ))) }.b) ) ({a = (pred 1) , b = (((\x: Unit .\y: Bool .y) true ) true) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (( \f: Bool .((f ({a = (case <r = (let u = false in false) > as Nat of < l = x > => x | < r = y > => y) , b = (succ (let u = 0 in u)) }.b) ) (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) in (succ 0)) ) ) (\a: Bool .\b: Bool .b)) }.a)
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (case <l = (pred 1) > as Bool of < l = x > => x | < r = y > => y) )) in u)
(case <l = ({a = (((\x: Rec X. X .\y: Bool .y) ({a = ({a = (iszero 1) , b = (fix (\x: Unit . 0 )) }.b) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) ) (fix (\x: Unit . 0 ))) , b = (((\x: Rec X. X .\y: Nat .y) ({a = ({a = 1 , b = false , c =  0 }.b) , b = (fix (\x: Nat . true )) }.b) ) (fix (\x: Rec X. X . (case <r = false > as Nat of < l = x > => x | < r = y > => y) ))) , c = (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 )) )) )) }.c) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Unit .x) (let u = (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) )) > as Bool of < l = x > => x | < r = y > => y) in u) ) (let u = (((\x: Bool .\y: Nat .y) ({a = false , b = 1 }.a) ) (iszero 1)) in u))
(let u = ({a = (let u = 1 in 0) , b = (case <r = (((\x: Rec X. X .\y: Nat .x) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in (let u = (succ (if (((\x: Unit .\y: Unit .y) false ) false) then 0 else 1)) in (succ ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )))))
(let u = ({a = (fix (\x: Unit . 1 )) , b = ({a = (let u = true in u) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) }.a) , c =  (let u = ({a = (let u = false in 0) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in (fix (\x: Nat . 1 ))) }.b) in (iszero (let u = ({a = 1 , b = 1 }.b) in ({a = 1 , b = true , c = 0 }.c))))
({a = (case <l = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (unfold [ Unit ] (fold [ Unit ] (unfold [ Bool ] (fold [ Unit ] (case <r = ({a = 0 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) )) )) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = true , b = 0 }.b) )) }.a) , c =  (case <l = (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) (fix (\x: Bool . 1 )) ) ) (\a: Nat .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) }.b)
(case <l = (pred (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) in (case <l = (if false then 0 else 1) > as Nat of < l = x > => x | < r = y > => y))) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Nat . (iszero (((\x: Unit .\y: Bool .y) ({a = 1 , b = true , c =  1 }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )))) ))
(let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (succ 0) )) , b = (( \f: Bool .((f 1 ) (if false then 1 else 1) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) in (fix (\x: Rec X. X . (( \f: Nat .((f (((\x: Unit .\y: Bool .y) true ) 0) ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Nat .a)) )))
({a = (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .x) (let u = true in 1) ) (iszero 0)) ) (( \f: Nat .((f ({a = 1 , b = 1 }.b) ) (let u = (((\x: Nat .\y: Nat .x) 0 ) true) in u) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (fix (\x: Unit . (let u = (fix (\x: Nat . true )) in (unfold [ Unit ] (fold [ Rec X. X ] false ))) )) }.a)
({a = (((\x: Bool .\y: Unit .y) ({a = (fix (\x: Nat . (succ 1) )) , b = (case <r = (if true then false else false) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) 0 ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .a))) ) (let u = 1 in 1) ) ) (\a: Bool .\b: Bool .a))) , b = ({a = (let u = (let u = 0 in false) in ({a = (fix (\x: Rec X. X . 1 )) , b = (fix (\x: Bool . false )) , c = 1 }.c)) , b = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = (if false then true else true) , c =  (let u = false in 0) }.b) }.b) }.b)
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = 0 , b = true , c =  1 }.b) ) ({a = (let u = false in 0) , b = ({a = false , b = 0 }.a) }.b) ) ) (\a: Nat .\b: Bool .b)) )) in (((\x: Unit .\y: Unit .y) (if ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) then ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in u) )) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) ) (unfold [ Unit ] (fold [ Bool ] (iszero (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) ))))
(( \f: Nat .((f (case <r = (let u = (fix (\x: Unit . (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) )) in u) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (iszero (((\x: Bool .\y: Nat .x) 1 ) ({a = 0 , b = true , c =  0 }.b))) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(( \f: Unit .((f (fix (\x: Bool . (case <l = (let u = 1 in u) > as Unit of < l = x > => x | < r = y > => y) )) ) ({a = (succ ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = 1 }.b)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = 1 , b = 1 }.b) )) )) }.b) ) ) (\a: Nat .\b: Nat .a))
({a = ({a = (pred ({a = 0 , b = 1 }.b)) , b = (( \f: Bool .((f (let u = false in true) ) (iszero 1) ) ) (\a: Unit .\b: Unit .a)) }.b) , b = (let u = (( \f: Bool .((f (((\x: Nat .\y: Nat .y) (unfold [ Bool ] (fold [ Bool ] false )) ) 1) ) ({a = 0 , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) , c = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Nat .\b: Bool .b)) in u) }.b)
(case <r = (let u = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) in u) > as Nat of < l = x > => x | < r = y > => y)
(let u = (((\x: Unit .\y: Nat .x) ({a = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = 0 , b = (fix (\x: Rec X. X . 1 )) }.b) }.a) ) (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) false ) true) ) false ) ) (\a: Unit .\b: Bool .b))) in ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = ({a = 0 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y) )) , b = (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Unit .x) false ) true) )) , c =  (let u = 1 in u) }.b))
(fix (\x: Unit . (fix (\x: Unit . (succ (case <l = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a)) ) (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) > as Nat of < l = x > => x | < r = y > => y)) )) ))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (let u = 0 in 0) )) , b = (case <r = (fix (\x: Nat . true )) > as Bool of < l = x > => x | < r = y > => y) }.b)
({a = (let u = (case <l = ({a = (succ 1) , b = (let u = 1 in u) }.b) > as Bool of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) (unfold [ Rec X. X ] (fold [ Nat ] true )))) , b = (( \f: Bool .((f ({a = (((\x: Nat .\y: Rec X. X .x) false ) false) , b = (let u = 0 in 1) }.b) ) (let u = (let u = 1 in u) in u) ) ) (\a: Unit .\b: Unit .a)) }.a)
(let u = (((\x: Unit .\y: Bool .y) (if (((\x: Nat .\y: Bool .y) false ) false) then (unfold [ Unit ] (fold [ Rec X. X ] (iszero (let u = 1 in u)) )) else (iszero (let u = true in (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))))) ) (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )))) in u)
(fix (\x: Bool . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Nat .x) ({a = 0 , b = false , c =  1 }.b) ) true) in (( \f: Bool .((f 1 ) ({a = 1 , b = false }.a) ) ) (\a: Nat .\b: Unit .a))) )) ))
(iszero (let u = (((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Rec X. X . false )) )) )) ) (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) ) 1 ) ) (\a: Nat .\b: Nat .b))) in (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) (succ 1) ) ) (\a: Bool .\b: Unit .a))))
(( \f: Unit .((f ({a = (fix (\x: Rec X. X . (fix (\x: Rec X. X . false )) )) , b = (iszero (let u = true in ({a = false , b = 0 }.b))) }.b) ) (( \f: Nat .((f (let u = (if true then 1 else 1) in (unfold [ Nat ] (fold [ Nat ] true ))) ) (iszero (((\x: Nat .\y: Rec X. X .y) true ) (let u = 0 in u))) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .a))
(case <l = (( \f: Bool .((f (let u = (let u = true in 1) in u) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) )) ) ) (\a: Bool .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y)
({a = (( \f: Unit .((f (if ({a = 1 , b = true }.b) then (fix (\x: Bool . false )) else (let u = false in u)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .y) ({a = false , b = false }.b) ) (((\x: Unit .\y: Unit .x) true ) false)) )) ) ) (\a: Bool .\b: Nat .a)) , b = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = (case <l = (let u = 1 in u) > as Nat of < l = x > => x | < r = y > => y) }.b) }.a)
(let u = (((\x: Rec X. X .\y: Nat .y) (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (unfold [ Unit ] (fold [ Nat ] false )) in (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)))) in (((\x: Unit .\y: Unit .y) (fix (\x: Rec X. X . true )) ) (iszero 0)))
(fix (\x: Unit . (if ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.a) then (let u = ({a = 0 , b = false }.a) in (if false then false else true)) else (case <r = (unfold [ Bool ] (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y)) ))
(unfold [ Nat ] (fold [ Nat ] (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f ({a = ({a = 0 , b = 0 }.b) , b = (let u = 1 in true) }.a) ) (fix (\x: Unit . 0 )) ) ) (\a: Nat .\b: Nat .b)) ))) ))
(case <l = (case <l = ({a = (( \f: Unit .((f (pred 0) ) (( \f: Bool .((f (let u = 1 in u) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = ({a = 0 , b = true }.b) , b = ({a = 0 , b = true , c =  0 }.b) }.b) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(case <l = (( \f: Bool .((f (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 )) in (let u = (if false then 1 else 0) in u)) ) (pred ({a = (let u = true in false) , b = 1 }.b)) ) ) (\a: Bool .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = ({a = true , b = false }.b) , c = ({a = 0 , b = false , c = 1 }.c) }.c) , b = (if (let u = (((\x: Nat .\y: Rec X. X .y) false ) true) in u) then ({a = (fix (\x: Nat . true )) , b = (let u = 1 in u) }.a) else (iszero (((\x: Rec X. X .\y: Rec X. X .y) false ) 1))) , c = (let u = (let u = 1 in u) in (unfold [ Rec X. X ] (fold [ Unit ] ({a = true , b = 0 }.b) ))) }.c) in (((\x: Unit .\y: Unit .x) (( \f: Bool .((f ({a = true , b = true }.b) ) (unfold [ Nat ] (fold [ Unit ] false )) ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Unit .\y: Nat .x) (let u = true in false) ) false)))
({a = (((\x: Bool .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Unit ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) , b = ({a = (let u = 1 in (fix (\x: Unit . 0 ))) , b = ({a = 0 , b = (let u = false in u) , c =  1 }.b) , c = (let u = (let u = 0 in true) in (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = 1 }.b) ))) }.c) }.a)
({a = (( \f: Nat .((f ({a = (( \f: Unit .((f (fix (\x: Nat . false )) ) true ) ) (\a: Bool .\b: Unit .b)) , b = ({a = false , b = (fix (\x: Rec X. X . 1 )) }.b) }.b) ) (fix (\x: Unit . 0 )) ) ) (\a: Bool .\b: Nat .b)) , b = (pred ({a = (fix (\x: Nat . 1 )) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) }.b)) }.b)
(unfold [ Nat ] (fold [ Unit ] (succ (( \f: Bool .((f 1 ) (fix (\x: Nat . 1 )) ) ) (\a: Rec X. X .\b: Bool .a))) ))
(((\x: Nat .\y: Rec X. X .x) ({a = (iszero ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.a)) , b = (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Bool .x) (unfold [ Unit ] (fold [ Bool ] true )) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) true)) ) (((\x: Bool .\y: Nat .x) 0 ) false)) }.a) ) (let u = ({a = ({a = false , b = 1 }.b) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  (let u = (let u = 1 in 1) in u) }.b) in u))
({a = (pred (( \f: Unit .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = false , b = 0 }.b) in u) )) ) (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (((\x: Rec X. X .\y: Bool .x) (let u = false in (((\x: Rec X. X .\y: Bool .x) false ) false)) ) (iszero ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (pred 1) }.b))) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f (( \f: Unit .((f (let u = 1 in u) ) (case <l = (succ 0) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) ) (fix (\x: Bool . 1 )) ) ) (\a: Nat .\b: Bool .a)) )) }.b)
({a = (let u = (succ ({a = 0 , b = false }.a)) in (((\x: Bool .\y: Bool .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 1 , b = true , c =  1 }.b) )) ) (let u = ({a = 0 , b = false }.a) in false))) , b = (let u = ({a = ({a = true , b = (((\x: Bool .\y: Bool .x) false ) false) }.b) , b = (fix (\x: Unit . 1 )) }.a) in u) }.b)
(iszero ({a = (((\x: Nat .\y: Rec X. X .x) true ) false) , b = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.b))
(let u = ({a = (((\x: Nat .\y: Unit .x) (if true then ({a = 0 , b = false , c =  1 }.b) else (iszero 1)) ) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = (if false then 0 else 0) }.a)) , b = (((\x: Nat .\y: Nat .x) (((\x: Rec X. X .\y: Bool .y) true ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b))) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (if false then false else (unfold [ Nat ] (fold [ Bool ] false ))) ))) }.b) in u)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Rec X. X .x) (succ (succ 1)) ) (iszero ({a = 1 , b = false , c = 0 }.c))) , b = (case <r = (((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) ) true) > as Bool of < l = x > => x | < r = y > => y) , c = (((\x: Rec X. X .\y: Rec X. X .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (succ 0)) }.c) ))
({a = (unfold [ Rec X. X ] (fold [ Unit ] ({a = (((\x: Unit .\y: Rec X. X .x) (iszero (succ 1)) ) (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Bool .x) true ) false) ) (let u = true in true))) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = false , b = 0 }.a) , b = 1 }.b) )) }.b) )) , b = (if (((\x: Nat .\y: Unit .y) (let u = ({a = 0 , b = false }.b) in u) ) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in ({a = 1 , b = false , c =  0 }.b))) then ({a = ({a = (if false then false else false) , b = 0 }.b) , b = (unfold [ Unit ] (fold [ Bool ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) )) }.b) else (( \f: Bool .((f (let u = 1 in u) ) ({a = false , b = 1 }.b) ) ) (\a: Unit .\b: Unit .a))) }.b)
(succ (if (let u = (let u = false in 1) in (if true then true else false)) then (fix (\x: Nat . ({a = (iszero 1) , b = (if false then 1 else 1) }.b) )) else (let u = (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Bool .b)) in (pred 0))))
(((\x: Rec X. X .\y: Nat .y) (((\x: Nat .\y: Unit .x) ({a = (let u = 1 in 0) , b = false , c =  1 }.b) ) (((\x: Rec X. X .\y: Nat .y) true ) true)) ) ({a = (pred ({a = (let u = false in u) , b = 1 }.b)) , b = (if (( \f: Bool .((f false ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Nat .a)) then ({a = true , b = ({a = 0 , b = true }.b) }.b) else (let u = true in u)) }.a))
({a = (((\x: Nat .\y: Unit .x) (if ({a = true , b = true }.b) then (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) else (((\x: Nat .\y: Bool .x) false ) false)) ) ({a = (let u = true in u) , b = ({a = 1 , b = (let u = true in false) }.b) }.b)) , b = ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) in u) , b = (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . (let u = false in false) )) )) }.a) }.a)
(((\x: Bool .\y: Bool .y) (let u = (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Nat .y) true ) true) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b))) in u) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = (let u = false in u) , b = (iszero ({a = 1 , b = false , c = 0 }.c)) }.b) )))
({a = ({a = (let u = ({a = 0 , b = true }.b) in u) , b = (let u = (let u = (case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) > as Bool of < l = x > => x | < r = y > => y) in u) in (if (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .b)) then (let u = false in false) else ({a = false , b = false }.b))) }.b) , b = (let u = ({a = (((\x: Nat .\y: Nat .y) (let u = 1 in (unfold [ Nat ] (fold [ Bool ] true ))) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) ({a = false , b = 1 }.b) ) ) (\a: Unit .\b: Nat .b))) , b = (let u = ({a = false , b = 1 }.b) in u) }.b) in ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .b)) , b = ({a = (fix (\x: Nat . false )) , b = (succ 1) }.b) }.a)) }.b)
(let u = (fix (\x: Bool . (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) in u) )) in u)
(( \f: Nat .((f (if (((\x: Unit .\y: Bool .x) (case <r = ({a = true , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Unit .y) false ) true)) then (let u = ({a = 0 , b = true }.b) in (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .b))) else (let u = ({a = ({a = 0 , b = true }.a) , b = true , c = 1 }.c) in (let u = 0 in true))) ) (let u = (pred (unfold [ Nat ] (fold [ Bool ] (fix (\x: Nat . 1 )) ))) in (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) in (fix (\x: Rec X. X . (let u = false in u) )))) ) ) (\a: Rec X. X .\b: Nat .a))
(fix (\x: Rec X. X . (if (if ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) then (let u = 0 in true) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) then (((\x: Unit .\y: Bool .x) (((\x: Unit .\y: Unit .x) 0 ) true) ) (((\x: Bool .\y: Nat .y) (let u = true in u) ) true)) else (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false , c = (succ 0) }.c) ))) ))
(( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) (if (iszero 0) then (let u = true in false) else (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .b))) ) (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .y) true ) true) ) (fix (\x: Nat . false )))) ) (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) (if true then true else true) ) ({a = ({a = 0 , b = false }.a) , b = true }.b)) ) ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = false }.b) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Bool .b))
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = 1 }.b)) )) )) , b = (case <r = (( \f: Bool .((f (fix (\x: Bool . (if true then false else false) )) ) (if (fix (\x: Unit . true )) then (let u = 1 in true) else (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b))) ) ) (\a: Unit .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) , c = (unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) )) }.c)
({a = (fix (\x: Unit . (case <l = (unfold [ Nat ] (fold [ Nat ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f (let u = (case <l = (let u = 1 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b))) ) (case <r = (( \f: Rec X. X .((f true ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) ) (\a: Nat .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) , c =  (let u = (( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = true , b = false }.b) )) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = ({a = true , b = 1 }.a) }.b) ) ) (\a: Bool .\b: Bool .a)) in ({a = (fix (\x: Bool . true )) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b)) }.b)
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) (let u = (((\x: Nat .\y: Unit .y) ({a = false , b = true }.b) ) ({a = true , b = 0 }.b)) in u) ) (let u = (if (((\x: Bool .\y: Bool .x) true ) false) then (((\x: Nat .\y: Bool .x) false ) true) else ({a = true , b = 0 }.a)) in (((\x: Nat .\y: Bool .y) true ) true))) ) ({a = (( \f: Unit .((f (pred (((\x: Unit .\y: Unit .x) 1 ) true)) ) (((\x: Rec X. X .\y: Bool .y) true ) 0) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (fix (\x: Rec X. X . (let u = (let u = false in u) in u) )) , c = (fix (\x: Nat . (pred 0) )) }.c) ) ) (\a: Rec X. X .\b: Bool .b))
({a = ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = (let u = (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) in (let u = false in false)) , c =  (((\x: Bool .\y: Bool .y) (unfold [ Bool ] (fold [ Bool ] false )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 ))) }.b) , b = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (pred 1) in false) }.a) }.a)
({a = (( \f: Bool .((f (if true then 1 else 0) ) ({a = (let u = false in 1) , b = true , c = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.c) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .x) ({a = 0 , b = false , c =  0 }.b) ) (if false then false else true)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Unit .b)) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Rec X. X .\y: Bool .x) false ) true) , c = (fix (\x: Nat . 1 )) }.c) )) }.b)
(case <l = (fix (\x: Nat . (let u = (case <r = ({a = false , b = 1 }.a) > as Nat of < l = x > => x | < r = y > => y) in (succ 0)) )) > as Unit of < l = x > => x | < r = y > => y)
(if (( \f: Bool .((f (let u = ({a = true , b = 0 }.b) in (unfold [ Nat ] (fold [ Nat ] false ))) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (iszero (if true then 0 else 0)) )) ) ) (\a: Rec X. X .\b: Nat .a)) then (let u = (case <r = (let u = (((\x: Bool .\y: Bool .x) 1 ) false) in ({a = 1 , b = true }.b)) > as Unit of < l = x > => x | < r = y > => y) in u) else ({a = (let u = (iszero 0) in ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false ))) , b = (unfold [ Nat ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) }.a))
(((\x: Rec X. X .\y: Nat .x) (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) (iszero 0) ) true) )) ) (( \f: Unit .((f (unfold [ Bool ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) )) ) ({a = ({a = 0 , b = 0 }.b) , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b)))
(let u = (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) (let u = true in u) ) (succ 1)) ) (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) (pred 0) ) (iszero 1)) ) ({a = 1 , b = true }.a) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .a)) in u)
({a = (if (case <r = ({a = true , b = (fix (\x: Nat . 0 )) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) then (unfold [ Nat ] (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] false )) )) )) else (let u = (let u = (succ (fix (\x: Nat . 1 ))) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in (let u = (fix (\x: Unit . (if false then false else false) )) in u))) , b = ({a = ({a = ({a = true , b = 1 }.b) , b = false }.a) , b = (( \f: Nat .((f ({a = 0 , b = false , c =  1 }.b) ) (let u = 0 in true) ) ) (\a: Nat .\b: Nat .b)) , c = (pred (if false then (let u = 1 in 1) else 1)) }.c) }.b)
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (if (fix (\x: Unit . ({a = true , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) }.b) )) then (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) true ) false) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Bool .a)) else (fix (\x: Nat . (fix (\x: Bool . true )) ))) )) ))
(let u = (( \f: Nat .((f ({a = 1 , b = (let u = true in u) , c =  (fix (\x: Nat . 1 )) }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Rec X. X .b)) in (let u = (( \f: Bool .((f false ) (((\x: Bool .\y: Bool .y) false ) false) ) ) (\a: Nat .\b: Bool .b)) in (let u = false in u)))
(unfold [ Unit ] (fold [ Nat ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (iszero (succ 1)) )) ))
({a = (let u = (let u = 0 in u) in u) , b = ({a = (pred ({a = true , b = 0 }.b)) , b = ({a = (let u = 0 in u) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.a) }.b) }.b)
(case <r = (let u = (let u = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .a)) in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b))) in (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) ))) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) (pred 0) ) (iszero 0)) )) , b = (let u = (let u = (iszero 1) in (fix (\x: Rec X. X . true ))) in (iszero 1)) , c = (let u = (if true then false else false) in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.c) , b = (let u = (unfold [ Unit ] (fold [ Unit ] (if false then false else false) )) in (iszero (((\x: Rec X. X .\y: Nat .x) (pred 1) ) false))) , c =  (let u = (let u = (( \f: Bool .((f (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in (let u = 1 in u)) ) (pred 0) ) ) (\a: Bool .\b: Rec X. X .a)) in (fix (\x: Unit . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) ))) in u) }.b)
(( \f: Nat .((f (( \f: Bool .((f (let u = (let u = (pred 1) in (( \f: Bool .((f 1 ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Bool .\b: Unit .a))) in ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = false }.a)) ) (let u = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (iszero 1) }.a) in (( \f: Rec X. X .((f ({a = 1 , b = true }.a) ) (((\x: Unit .\y: Nat .y) false ) 1) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Rec X. X .\b: Bool .a)) ) (pred (if ({a = (((\x: Unit .\y: Unit .y) false ) 1) , b = true }.b) then (let u = (let u = true in 0) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b))) else ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 )))) ) ) (\a: Nat .\b: Rec X. X .b))
(( \f: Unit .((f (unfold [ Nat ] (fold [ Bool ] ({a = (((\x: Nat .\y: Nat .x) 1 ) true) , b = (fix (\x: Bool . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) }.b) )) ) (let u = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = false , b = 1 }.b) )) , b = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) in (if false then ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) else true)) }.a) in u) ) ) (\a: Unit .\b: Unit .a))
(succ (unfold [ Unit ] (fold [ Rec X. X ] (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = (unfold [ Unit ] (fold [ Rec X. X ] false )) , b = 0 }.b)) )))
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) false ) false) )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false ))) ) (fix (\x: Rec X. X . (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) in true) )) ) ) (\a: Bool .\b: Rec X. X .b)) ))
(let u = (let u = (((\x: Nat .\y: Nat .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) (iszero 1)) in (let u = ({a = 1 , b = 1 }.b) in (if false then 1 else 0))) in u)
(( \f: Unit .((f (pred (fix (\x: Nat . (let u = false in 0) ))) ) (case <l = (((\x: Nat .\y: Rec X. X .y) (let u = 1 in ({a = 0 , b = false , c =  0 }.b)) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = true in false) }.a)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a))
(( \f: Nat .((f (( \f: Unit .((f ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = false , c = 1 }.c) ) (( \f: Unit .((f ({a = (let u = false in true) , b = 1 }.b) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .b)) ) (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) (let u = 0 in 1) ) ({a = 0 , b = false }.b)) ) (if ({a = false , b = false }.b) then 1 else (fix (\x: Unit . 1 ))) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Unit .b))
(case <r = (unfold [ Bool ] (fold [ Bool ] (((\x: Nat .\y: Unit .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) ) (let u = true in false)) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f true ) ({a = true , b = 1 }.a) ) ) (\a: Nat .\b: Rec X. X .b)) )) in (let u = (if false then (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b)) else ({a = 1 , b = false , c =  1 }.b)) in u)) in ({a = (unfold [ Bool ] (fold [ Unit ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f (( \f: Nat .((f ({a = 1 , b = true }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = false in u) ) ) (\a: Unit .\b: Rec X. X .a)) }.b))
(pred ({a = (( \f: Rec X. X .((f (( \f: Bool .((f (let u = 0 in 0) ) (fix (\x: Unit . 1 )) ) ) (\a: Rec X. X .\b: Unit .a)) ) (case <l = (((\x: Rec X. X .\y: Bool .y) false ) 0) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (succ (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a))) , b = ({a = true , b = 0 }.b) }.b) }.b))
(pred ({a = ({a = ({a = 0 , b = true , c = 0 }.c) , b = (((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Rec X. X .y) true ) true) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .b))) }.b) , b = ({a = ({a = (fix (\x: Nat . true )) , b = ({a = 1 , b = ({a = true , b = true }.b) , c = (succ 1) }.c) }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Unit .\y: Rec X. X .x) ({a = true , b = true }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) )) }.a) }.b))
(let u = (case <l = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (if false then 0 else 0) )) > as Unit of < l = x > => x | < r = y > => y) in (let u = ({a = (if (iszero 0) then ({a = 1 , b = 1 }.b) else (let u = 0 in u)) , b = (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) (if false then false else false) ) ) (\a: Bool .\b: Rec X. X .a)) , c = (if (((\x: Unit .\y: Unit .x) (if false then false else false) ) true) then ({a = 1 , b = (let u = 0 in false) , c = 0 }.c) else (if false then 1 else 0)) }.c) in u))
({a = ({a = (let u = ({a = (iszero 0) , b = (succ 0) }.a) in ({a = false , b = false }.b)) , b = (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.a) )) }.a) , b = (((\x: Unit .\y: Bool .x) ({a = (case <r = ({a = 1 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . true )) }.b) ) (iszero (let u = (if false then 1 else 0) in 1))) }.b)
(((\x: Unit .\y: Bool .x) (let u = ({a = ({a = 1 , b = true }.b) , b = true }.b) in u) ) (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Bool ] (let u = ({a = false , b = true }.b) in (fix (\x: Bool . true ))) )) ) (case <r = ({a = (if false then true else true) , b = ({a = 0 , b = false , c =  1 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)))
(unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .x) (let u = (let u = false in true) in (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .b))) ) (iszero 0)) ) ) (\a: Nat .\b: Rec X. X .b)) ) (case <r = (( \f: Bool .((f ({a = 0 , b = false , c =  0 }.b) ) true ) ) (\a: Unit .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y)) ))
(succ ({a = (( \f: Nat .((f ({a = 1 , b = true , c = 1 }.c) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = (if true then false else true) , b = (fix (\x: Nat . 1 )) }.a) , c = (let u = (if (fix (\x: Nat . true )) then ({a = 1 , b = false , c = 0 }.c) else 0) in u) }.c))
(case <r = (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Unit .y) ({a = true , b = true }.b) ) (((\x: Bool .\y: Rec X. X .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) true)) ) (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in (((\x: Rec X. X .\y: Unit .x) true ) true))) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Unit . ({a = (let u = (let u = true in u) in 1) , b = (( \f: Bool .((f (pred 0) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Unit .\b: Unit .a)) }.b) ))
(((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Nat .y) (iszero 1) ) (fix (\x: Bool . (fix (\x: Nat . false )) ))) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f (let u = (succ 0) in u) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )))
({a = (let u = (succ (if (let u = (let u = false in u) in true) then ({a = 0 , b = (fix (\x: Rec X. X . false )) , c = 0 }.c) else (let u = false in 1))) in ({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) (fix (\x: Rec X. X . false )) ) ) (\a: Bool .\b: Bool .a)) , b = (((\x: Rec X. X .\y: Bool .x) true ) true) }.b)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (pred (let u = 0 in u)) , b = (let u = (unfold [ Bool ] (fold [ Unit ] 0 )) in (succ (let u = 0 in 1))) }.b) )) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = (((\x: Bool .\y: Nat .y) false ) 1) , b = (let u = (if false then false else true) in false) }.b) ))
(iszero ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = 0 , b = 0 }.b) in (succ (fix (\x: Bool . 1 )))) )))
(case <l = (fix (\x: Bool . ({a = (fix (\x: Unit . (if true then true else false) )) , b = (( \f: Nat .((f ({a = 0 , b = 0 }.b) ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (( \f: Nat .((f (pred (unfold [ Bool ] (fold [ Bool ] 0 ))) ) (((\x: Bool .\y: Rec X. X .y) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) , b = true }.b) ) ({a = 1 , b = true , c = 1 }.c)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = ({a = ({a = (((\x: Nat .\y: Unit .y) false ) 0) , b = (fix (\x: Rec X. X . false )) , c = (((\x: Unit .\y: Nat .x) (let u = 0 in u) ) (((\x: Rec X. X .\y: Unit .y) false ) false)) }.c) , b = (pred (case <l = (if true then 0 else 0) > as Nat of < l = x > => x | < r = y > => y)) }.b) , b = (case <r = (unfold [ Bool ] (fold [ Bool ] (case <r = (((\x: Rec X. X .\y: Nat .y) false ) true) > as Unit of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y) , c =  (((\x: Rec X. X .\y: Nat .x) (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = true in u)) }.b) }.a)
(( \f: Rec X. X .((f (((\x: Bool .\y: Bool .y) (let u = false in u) ) (( \f: Nat .((f (let u = false in true) ) (let u = true in false) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (iszero ({a = (let u = 1 in ({a = 0 , b = false , c =  1 }.b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.b)) ) ) (\a: Unit .\b: Unit .a))
(let u = ({a = (if ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) then ({a = (fix (\x: Unit . 1 )) , b = true , c = 0 }.c) else (let u = 0 in (let u = true in 0))) , b = (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) }.b) in u)
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = (( \f: Unit .((f ({a = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .a)) , b = true }.b) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Bool .b)) in (((\x: Bool .\y: Unit .x) (fix (\x: Nat . 0 )) ) ({a = false , b = true }.b))) )) , b = (let u = (iszero (case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) > as Unit of < l = x > => x | < r = y > => y)) in u) }.b)
({a = (case <r = ({a = (let u = (let u = (fix (\x: Unit . 1 )) in (if false then 1 else 0)) in u) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in u) )) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (pred (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) in (fix (\x: Unit . (if true then (fix (\x: Unit . 1 )) else 0) )))) }.a)
(( \f: Bool .((f ({a = ({a = 0 , b = ({a = true , b = 0 }.a) }.a) , b = (let u = ({a = 0 , b = true , c = 1 }.c) in u) }.b) ) (let u = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) , b = 1 }.b) in u) ) ) (\a: Nat .\b: Unit .b))
(fix (\x: Rec X. X . (fix (\x: Nat . (let u = false in u) )) ))
({a = (let u = (case <r = ({a = true , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) in (fix (\x: Nat . (( \f: Rec X. X .((f ({a = 1 , b = true , c = 0 }.c) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ))) , b = (fix (\x: Rec X. X . (iszero (let u = true in 0)) )) }.a)
(succ (((\x: Bool .\y: Nat .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = true , c =  (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b)))
(( \f: Nat .((f (succ (( \f: Nat .((f ({a = false , b = 1 }.b) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b))) ) (case <l = (((\x: Bool .\y: Rec X. X .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) ) (((\x: Rec X. X .\y: Unit .x) (let u = true in u) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .b)))) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(let u = ({a = (succ (let u = ({a = 0 , b = 0 }.b) in ({a = 0 , b = false , c = 1 }.c))) , b = (unfold [ Unit ] (fold [ Unit ] (( \f: Bool .((f (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)) ) true ) ) (\a: Rec X. X .\b: Bool .b)) )) }.b) in (iszero (let u = (unfold [ Nat ] (fold [ Nat ] false )) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )))))
(let u = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Bool .((f (let u = ({a = false , b = false }.b) in 0) ) (pred 1) ) ) (\a: Bool .\b: Nat .a)) )) in u)
(iszero (( \f: Unit .((f (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Nat .y) true ) (unfold [ Unit ] (fold [ Nat ] true ))) ) ({a = 1 , b = false , c = 0 }.c)) ) (pred 1) ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <l = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in 1) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)))
(( \f: Unit .((f (let u = (case <r = (let u = true in true) > as Nat of < l = x > => x | < r = y > => y) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ({a = ({a = 1 , b = ({a = 0 , b = false }.b) , c = 1 }.c) , b = (let u = (iszero 1) in false) , c = (((\x: Nat .\y: Rec X. X .y) (let u = false in false) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 ))) }.c) ) ) (\a: Nat .\b: Bool .a))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = (if (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) then (let u = false in u) else ({a = 0 , b = false , c =  0 }.b)) in u) ))
({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) (if true then false else false) ) (((\x: Nat .\y: Rec X. X .x) false ) (let u = true in true))) ) (iszero (if (unfold [ Nat ] (fold [ Unit ] true )) then ({a = false , b = (let u = true in 1) }.b) else ({a = 1 , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b))) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = (succ ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = 1 }.b)) in ({a = ({a = (let u = false in 1) , b = (succ 0) }.b) , b = (let u = 0 in u) }.b)) }.a)
(fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Rec X. X . 0 )) )) ))
({a = (case <r = (let u = ({a = 0 , b = true , c =  0 }.b) in ({a = 1 , b = false }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (let u = (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Unit .a)) in (((\x: Rec X. X .\y: Nat .x) 1 ) ({a = 0 , b = true , c =  0 }.b))) in u) }.a)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] ({a = (pred (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b))) , b = (fix (\x: Unit . (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) )) }.a) )) ) ({a = (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (((\x: Bool .\y: Bool .y) true ) ({a = true , b = 1 }.a))) , b = ({a = (let u = 1 in u) , b = (( \f: Rec X. X .((f (let u = true in u) ) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ) (\a: Bool .\b: Unit .a)) , c = (fix (\x: Rec X. X . 1 )) }.c) }.b) ) ) (\a: Unit .\b: Unit .b))
({a = (( \f: Rec X. X .((f (fix (\x: Unit . ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = (if false then false else true) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) )) )) ) (case <l = ({a = ({a = (unfold [ Nat ] (fold [ Unit ] true )) , b = 0 }.b) , b = (let u = (let u = false in 0) in u) }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f ({a = 1 , b = true , c =  0 }.b) ) (((\x: Nat .\y: Unit .y) true ) true) ) ) (\a: Nat .\b: Unit .b)) )) , c =  (fix (\x: Nat . (let u = ({a = (unfold [ Nat ] (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) )) , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .b)) , c = ({a = 1 , b = false }.a) }.c) in (case <l = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y)) )) }.b)
(unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) (if false then true else (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ) (unfold [ Unit ] (fold [ Unit ] ({a = (fix (\x: Unit . 1 )) , b = (if true then false else false) , c =  0 }.b) ))) ))
({a = ({a = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) , b = (let u = 1 in (((\x: Unit .\y: Nat .y) true ) 0)) }.b) , b = (unfold [ Bool ] (fold [ Nat ] ({a = (succ 1) , b = (if false then true else false) }.b) )) , c =  (unfold [ Unit ] (fold [ Unit ] (let u = (((\x: Unit .\y: Bool .x) 1 ) (iszero 1)) in u) )) }.b)
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = false , c = 1 }.c) ))) ))
(((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Bool . ({a = 1 , b = ({a = false , b = 1 }.b) }.b) )) ) (( \f: Unit .((f (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) ) ({a = false , b = ({a = false , b = false }.b) }.b) ) ) (\a: Unit .\b: Bool .b)))
((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = (((\x: Bool .\y: Bool .y) (let u = (let u = 1 in true) in true) ) (let u = false in u)) , b = ({a = ({a = true , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b) , b = (if (let u = true in u) then false else ({a = 0 , b = true }.b)) }.a) }.a) ))
(if (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) true ) ({a = true , b = true }.b)) )) then (let u = (fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 1 , b = true }.b) )) )) in u) else ({a = (((\x: Bool .\y: Unit .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) true) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] true )) , b = ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) true ) true) , c =  1 }.b) }.b) , c =  (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = 1 }.b) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .a))) }.b))
({a = ({a = (case <l = (if true then 0 else 0) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . ({a = false , b = 0 }.a) )) }.b) , b = (( \f: Nat .((f (case <r = ({a = true , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (pred 0) , b = ({a = (let u = true in 0) , b = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) , c =  0 }.b) , c =  (let u = ({a = 1 , b = true }.a) in u) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)
({a = (case <l = ({a = 1 , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = 0 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (let u = (((\x: Rec X. X .\y: Nat .y) false ) (((\x: Nat .\y: Rec X. X .y) false ) true)) in (let u = (fix (\x: Rec X. X . 0 )) in 1)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = false in u) )) , c = (((\x: Bool .\y: Nat .y) ({a = (fix (\x: Nat . false )) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 ))) }.c) }.b)
({a = (let u = (if (unfold [ Unit ] (fold [ Nat ] true )) then true else (let u = false in u)) in (let u = ({a = 1 , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) }.a) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (if true then 0 else 1) )))) , b = (let u = ({a = (iszero 1) , b = (((\x: Nat .\y: Bool .x) true ) false) }.b) in (if (((\x: Nat .\y: Bool .y) false ) true) then (unfold [ Bool ] (fold [ Nat ] false )) else false)) }.a)
(((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Nat .x) ({a = ({a = (((\x: Rec X. X .\y: Nat .y) true ) 0) , b = (case <r = (if true then false else false) > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) }.a) ) ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Nat .x) true ) true) ) true) }.b)) ) ({a = (((\x: Unit .\y: Rec X. X .y) (if true then (let u = false in true) else true) ) ({a = 1 , b = false , c =  0 }.b)) , b = ({a = ({a = (( \f: Unit .((f ({a = 1 , b = true , c = 0 }.c) ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = true , b = 0 }.a) }.a) , b = (let u = false in false) , c = ({a = (iszero 1) , b = (fix (\x: Nat . 0 )) }.b) }.c) }.a))
(let u = ({a = (fix (\x: Rec X. X . (( \f: Unit .((f false ) (((\x: Rec X. X .\y: Bool .x) false ) true) ) ) (\a: Bool .\b: Rec X. X .a)) )) , b = (( \f: Unit .((f ({a = ({a = 1 , b = 0 }.b) , b = (( \f: Unit .((f (if false then true else true) ) false ) ) (\a: Unit .\b: Unit .a)) }.b) ) ({a = (let u = ({a = 1 , b = true }.b) in u) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .b)) )) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) in (unfold [ Unit ] (fold [ Rec X. X ] (if ({a = 0 , b = false }.b) then (let u = ({a = true , b = 1 }.b) in u) else (((\x: Bool .\y: Nat .x) 0 ) false)) )))
(let u = (let u = ({a = (iszero 0) , b = (pred (unfold [ Bool ] (fold [ Bool ] 0 ))) }.a) in (unfold [ Unit ] (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (if false then 0 else 0) in (if true then 0 else 1)) )) ))) in u)
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = (( \f: Unit .((f (let u = 0 in 0) ) 1 ) ) (\a: Bool .\b: Bool .b)) in u) ))
(case <r = ({a = (let u = (((\x: Unit .\y: Bool .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) 0) in u) , b = (( \f: Nat .((f (let u = (let u = false in 0) in (((\x: Rec X. X .\y: Bool .y) true ) false)) ) (((\x: Nat .\y: Rec X. X .y) (fix (\x: Nat . false )) ) (fix (\x: Rec X. X . false ))) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(unfold [ Nat ] (fold [ Bool ] (let u = (let u = true in 1) in (let u = 0 in (let u = false in u))) ))
(let u = (case <r = (((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .a)) ) ({a = true , b = 0 }.a)) > as Unit of < l = x > => x | < r = y > => y) in (fix (\x: Nat . (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .y) ({a = false , b = true }.b) ) (let u = 1 in (if false then false else true))) ) (let u = (((\x: Unit .\y: Unit .y) true ) 1) in u)) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Unit ] (let u = (((\x: Bool .\y: Bool .x) 1 ) false) in ({a = ({a = 0 , b = true }.a) , b = true }.a)) )) )) ))
(let u = (if (( \f: Unit .((f (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , b = ({a = true , b = 0 }.a) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) then (((\x: Nat .\y: Bool .y) ({a = ({a = 0 , b = false , c =  0 }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.a) ) (unfold [ Rec X. X ] (fold [ Bool ] true ))) else (unfold [ Unit ] (fold [ Bool ] true ))) in (fix (\x: Rec X. X . (case <r = (( \f: Unit .((f false ) (let u = true in false) ) ) (\a: Rec X. X .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) )))
(fix (\x: Rec X. X . (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) false ) false) )) ) (( \f: Bool .((f (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .a)) ) (let u = (fix (\x: Bool . 0 )) in false) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(((\x: Unit .\y: Unit .x) (((\x: Unit .\y: Bool .y) (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) ) false) ) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) ) (\a: Nat .\b: Nat .a)) ) (let u = (let u = ({a = true , b = true }.b) in u) in (let u = (succ 1) in (let u = false in false)))) ) (if (fix (\x: Rec X. X . (let u = ({a = true , b = false }.b) in (let u = true in true)) )) then (( \f: Unit .((f (fix (\x: Bool . false )) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) ) ) (\a: Nat .\b: Bool .b)) else (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) (unfold [ Unit ] (fold [ Unit ] false ))) ) (((\x: Unit .\y: Unit .y) (((\x: Nat .\y: Unit .y) ({a = false , b = false }.b) ) (let u = false in true)) ) (((\x: Bool .\y: Rec X. X .y) (let u = 0 in false) ) (unfold [ Bool ] (fold [ Unit ] true )))))))
(let u = (case <l = ({a = ({a = 1 , b = true , c =  (succ 1) }.b) , b = (unfold [ Unit ] (fold [ Unit ] 0 )) }.b) > as Nat of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Bool .y) ({a = (((\x: Nat .\y: Bool .y) (iszero 1) ) ({a = false , b = 0 }.a)) , b = (fix (\x: Unit . 0 )) }.a) ) (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = (fix (\x: Unit . false )) }.b) ))))
(fix (\x: Unit . (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f ({a = 1 , b = true , c =  1 }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Unit .b)) ) (let u = false in (((\x: Bool .\y: Bool .x) 0 ) false))) )) ) (((\x: Unit .\y: Unit .y) (if ({a = 0 , b = false }.b) then (((\x: Rec X. X .\y: Bool .x) false ) false) else ({a = false , b = ({a = 0 , b = true }.a) }.a)) ) ({a = (pred 0) , b = (let u = 1 in u) }.b)) ) ) (\a: Bool .\b: Bool .b)) ))
(( \f: Rec X. X .((f (( \f: Bool .((f (( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] 0 )) ) (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (pred (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b))) ) ) (\a: Nat .\b: Nat .b)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) (let u = (let u = 1 in true) in (if false then true else false)) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) ) ) (\a: Bool .\b: Rec X. X .a))
(fix (\x: Bool . ({a = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (if false then 0 else 1) }.b) , b = ({a = false , b = (fix (\x: Nat . true )) }.b) }.a) ))
(((\x: Bool .\y: Bool .y) (( \f: Nat .((f (iszero (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) in 1)) ) (if (((\x: Rec X. X .\y: Nat .y) true ) true) then (unfold [ Rec X. X ] (fold [ Bool ] true )) else (if ({a = true , b = false }.b) then ({a = true , b = true }.b) else (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (if (let u = false in u) then (pred 1) else (((\x: Unit .\y: Nat .x) 1 ) false)) , b = (((\x: Unit .\y: Rec X. X .x) (( \f: Unit .((f (let u = 1 in 0) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = 1 in true)) }.b))
(let u = (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in ({a = (fix (\x: Nat . 1 )) , b = ({a = true , b = (((\x: Rec X. X .\y: Bool .x) false ) false) }.b) , c = (let u = false in 1) }.c)) in (unfold [ Bool ] (fold [ Bool ] (let u = ({a = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = 1 }.b) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Nat . (if false then false else false) )) ))) )))
(( \f: Rec X. X .((f ({a = (pred ({a = (let u = false in u) , b = ({a = true , b = 1 }.b) }.b)) , b = (succ (let u = 1 in u)) }.b) ) ({a = (pred (fix (\x: Bool . 0 ))) , b = (case <r = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) }.b) > as Unit of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Rec X. X .\b: Unit .b))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Nat .y) false ) true) ) ({a = 0 , b = (fix (\x: Bool . true )) }.a)) , b = (case <r = (let u = (iszero 1) in u) > as Unit of < l = x > => x | < r = y > => y) , c =  (let u = (unfold [ Unit ] (fold [ Bool ] false )) in (if (let u = 0 in false) then 0 else 1)) }.b) ))
(iszero (fix (\x: Unit . ({a = 0 , b = true }.a) )))
(unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Nat .x) (( \f: Bool .((f (succ 0) ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Nat .\y: Rec X. X .x) (iszero 0) ) (let u = false in u))) ))
(let u = (succ (if (((\x: Nat .\y: Bool .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (let u = 0 in true)) then (((\x: Bool .\y: Rec X. X .y) true ) 1) else (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)))) in (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Bool ] (let u = ({a = 1 , b = false , c = 1 }.c) in 1) )) ) (case <r = (case <r = (let u = 1 in true) > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)))
(let u = (let u = (((\x: Bool .\y: Bool .y) (let u = true in u) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b))) in ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = true , b = 1 }.a) }.b)) in ({a = (fix (\x: Unit . (let u = 0 in 0) )) , b = ({a = (pred 1) , b = ({a = 0 , b = true , c =  0 }.b) , c = (fix (\x: Bool . ({a = 1 , b = false }.a) )) }.c) }.b))
(if (let u = (iszero (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false)) in u) then ({a = (iszero (fix (\x: Bool . (let u = 1 in u) ))) , b = (succ (succ (pred 0))) }.b) else (succ (fix (\x: Unit . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) )) ))))
(let u = (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) (let u = (if false then false else false) in u)) in (if (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (( \f: Bool .((f false ) ({a = false , b = false }.b) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .b)) then (case <r = (let u = ({a = 0 , b = true , c =  1 }.b) in true) > as Rec X. X of < l = x > => x | < r = y > => y) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (( \f: Rec X. X .((f false ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Nat .a)) , b = ({a = true , b = 0 }.a) }.b) ))))
({a = (let u = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) in u) in (( \f: Nat .((f (fix (\x: Bool . 1 )) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Unit .b))) , b = (let u = (case <l = (if true then 1 else 0) > as Unit of < l = x > => x | < r = y > => y) in (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (let u = ({a = 0 , b = true , c = 0 }.c) in (unfold [ Rec X. X ] (fold [ Unit ] true ))) else ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )))) }.b)
(let u = (succ (((\x: Bool .\y: Nat .y) (( \f: Bool .((f (let u = (((\x: Unit .\y: Bool .y) false ) 0) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true ))) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false))) in (((\x: Nat .\y: Unit .x) (if true then 0 else 1) ) (unfold [ Nat ] (fold [ Nat ] (fix (\x: Unit . false )) ))))
({a = (((\x: Rec X. X .\y: Unit .x) (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) )) ) (( \f: Nat .((f (if ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) then (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .a)) else (unfold [ Bool ] (fold [ Bool ] true ))) ) (if true then false else false) ) ) (\a: Nat .\b: Rec X. X .a))) , b = (case <r = (iszero (succ 0)) > as Unit of < l = x > => x | < r = y > => y) , c =  (let u = (case <r = (if (iszero 1) then false else false) > as Nat of < l = x > => x | < r = y > => y) in ({a = false , b = (fix (\x: Rec X. X . 0 )) }.b)) }.b)
(let u = (let u = (( \f: Bool .((f (( \f: Unit .((f 0 ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Unit .\y: Nat .x) (if false then 0 else 1) ) (fix (\x: Rec X. X . false ))) ) ) (\a: Unit .\b: Bool .b)) in u) in (( \f: Rec X. X .((f (let u = (fix (\x: Unit . 1 )) in u) ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Bool .a)))
({a = (let u = (let u = (succ ({a = true , b = 0 }.b)) in ({a = (pred 0) , b = ({a = false , b = true }.b) , c =  ({a = (let u = 1 in u) , b = true , c = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.c) }.b)) in ({a = (( \f: Unit .((f (succ 0) ) ({a = false , b = 1 }.b) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Nat ] true )) , c =  (fix (\x: Rec X. X . 0 )) }.b)) , b = ({a = (let u = (if false then true else false) in 0) , b = (fix (\x: Bool . ({a = 1 , b = false , c =  1 }.b) )) }.b) }.b)
(( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then false else true) in (let u = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Bool .a)) in u)) )) ) (case <r = (let u = ({a = false , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = (unfold [ Bool ] (fold [ Bool ] (fix (\x: Bool . true )) )) , b = (iszero (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b))) }.b) ))
(if (let u = (let u = 1 in (if true then false else false)) in u) then (case <r = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) (iszero (let u = 0 in 1)) ) ) (\a: Unit .\b: Bool .a)) )) > as Unit of < l = x > => x | < r = y > => y) else (unfold [ Nat ] (fold [ Bool ] ({a = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in true) , b = (let u = 0 in u) }.a) )))
(let u = (((\x: Rec X. X .\y: Unit .y) ({a = false , b = (pred 1) }.a) ) (fix (\x: Rec X. X . ({a = (((\x: Rec X. X .\y: Unit .y) true ) 1) , b = false }.b) ))) in (((\x: Unit .\y: Bool .x) (succ ({a = 1 , b = true }.a)) ) ({a = (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (fix (\x: Nat . 1 )) }.b)))
(( \f: Nat .((f ({a = ({a = (if (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) then (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) else 0) , b = (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.b) , b = (let u = (fix (\x: Nat . 0 )) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a))) }.b) ) (((\x: Bool .\y: Bool .y) (iszero (( \f: Unit .((f (((\x: Nat .\y: Bool .x) 1 ) true) ) (let u = 1 in 0) ) ) (\a: Nat .\b: Bool .b))) ) (( \f: Unit .((f (pred (let u = 0 in u)) ) (( \f: Rec X. X .((f (if true then 0 else 0) ) (let u = true in 1) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Bool .\b: Unit .a))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (if (((\x: Bool .\y: Bool .x) true ) true) then ({a = 0 , b = false }.b) else (fix (\x: Unit . true ))) )) , b = (let u = ({a = (let u = 1 in u) , b = (let u = true in false) , c =  (let u = false in 0) }.b) in (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = false in true) )) in ({a = (case <r = ({a = false , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (if false then ({a = 1 , b = 1 }.b) else (((\x: Rec X. X .\y: Bool .y) true ) 1)) }.a))) }.b)
({a = (let u = ({a = (pred (fix (\x: Unit . 0 ))) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) , b = (unfold [ Unit ] (fold [ Rec X. X ] (iszero 1) )) }.b) , c =  (case <l = ({a = 1 , b = false , c = 1 }.c) > as Nat of < l = x > => x | < r = y > => y) }.b) in ({a = (let u = (((\x: Nat .\y: Rec X. X .x) 1 ) (((\x: Nat .\y: Rec X. X .y) false ) true)) in (let u = 1 in 1)) , b = ({a = (((\x: Bool .\y: Bool .y) true ) 1) , b = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = ({a = 0 , b = false , c =  0 }.b) }.b) , c = ({a = true , b = (let u = 0 in u) }.b) }.c) }.b)) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .y) false ) true) ) (unfold [ Unit ] (fold [ Rec X. X ] true ))) ) (if (let u = false in true) then ({a = true , b = 0 }.a) else ({a = 1 , b = true , c =  1 }.b)) ) ) (\a: Nat .\b: Bool .a)) }.a)
(let u = (( \f: Rec X. X .((f (( \f: Unit .((f (succ 0) ) (let u = (fix (\x: Bool . true )) in ({a = 1 , b = false }.a)) ) ) (\a: Unit .\b: Nat .a)) ) (( \f: Rec X. X .((f ({a = (let u = true in u) , b = ({a = 1 , b = true }.a) }.b) ) (( \f: Nat .((f (pred 1) ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Bool .\b: Nat .b)) in (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Nat .((f (( \f: Nat .((f ({a = (fix (\x: Bool . true )) , b = (if true then 1 else 1) }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (((\x: Nat .\y: Rec X. X .y) true ) 0) )) ) ) (\a: Nat .\b: Bool .b)) ) (case <l = (succ (pred (let u = 1 in u))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))
(fix (\x: Nat . ({a = (let u = (let u = ({a = 1 , b = true , c =  0 }.b) in u) in ({a = 0 , b = 1 }.b)) , b = (let u = ({a = (let u = false in 1) , b = 0 }.b) in (( \f: Bool .((f false ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , c =  (succ (case <l = (succ 0) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) ))
(( \f: Nat .((f (( \f: Unit .((f (if true then (if true then false else true) else (let u = 1 in false)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) ) (\a: Bool .\b: Unit .b)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (let u = ({a = 1 , b = true , c =  0 }.b) in u) ) ({a = false , b = true }.b) ) ) (\a: Unit .\b: Nat .b)) )) ) ) (\a: Bool .\b: Unit .a))
(let u = (pred (if ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (pred 0) )) , b = (let u = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) in true) }.b) then (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = false , c = ({a = false , b = 1 }.b) }.c) ) (((\x: Nat .\y: Bool .x) false ) (iszero 0))) else ({a = (pred 0) , b = (((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) false) }.a))) in (case <l = (let u = (let u = 0 in true) in (unfold [ Bool ] (fold [ Unit ] (let u = 1 in 1) ))) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Unit .\y: Unit .x) (( \f: Unit .((f (( \f: Unit .((f (((\x: Nat .\y: Unit .x) false ) true) ) (case <r = (if false then false else true) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) ) (( \f: Nat .((f ({a = ({a = 0 , b = true }.b) , b = ({a = 1 , b = true }.a) }.a) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Nat .y) (iszero 0) ) (((\x: Bool .\y: Rec X. X .x) false ) true)) ) (((\x: Bool .\y: Unit .x) true ) false)) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Unit .\y: Unit .y) false ) false) )) in u))
({a = (( \f: Nat .((f (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (fix (\x: Nat . 1 )) else (fix (\x: Nat . 1 ))) ) (( \f: Unit .((f (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Bool .y) true ) true) ) 0) ) (((\x: Bool .\y: Nat .x) 0 ) false) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = 0 }.b) )) }.b)
(let u = ({a = (let u = (((\x: Bool .\y: Nat .y) true ) 0) in (let u = true in (let u = 1 in 0))) , b = ({a = (succ 1) , b = true , c =  1 }.b) }.a) in u)
({a = ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = true }.b) , b = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) false ) false) ) (let u = false in 0)) }.b) }.a) , b = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) )) }.b)
(let u = (unfold [ Unit ] (fold [ Rec X. X ] (let u = ({a = 1 , b = false }.b) in ({a = 0 , b = false }.b)) )) in (( \f: Nat .((f ({a = ({a = 0 , b = 1 }.b) , b = false }.b) ) (case <r = (if true then false else true) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)))
({a = (((\x: Unit .\y: Bool .y) (case <r = ({a = false , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Unit ] true ))) , b = (let u = (((\x: Bool .\y: Bool .y) ({a = true , b = 1 }.a) ) (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Nat .y) false ) 0) ) ({a = false , b = 1 }.a))) in (( \f: Bool .((f (let u = false in u) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b))) }.b)
(( \f: Rec X. X .((f (iszero ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = (let u = false in 0) }.b)) ) (( \f: Rec X. X .((f (let u = false in false) ) (let u = (fix (\x: Nat . true )) in false) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a))
(((\x: Rec X. X .\y: Bool .x) (if (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .a)) else (if (iszero 1) then (fix (\x: Unit . false )) else ({a = (((\x: Nat .\y: Bool .x) true ) false) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b))) ) (case <r = (if ({a = 0 , b = true , c =  0 }.b) then ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = true , b = 0 }.a) )) else (if true then true else true)) > as Rec X. X of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f (if (((\x: Bool .\y: Unit .x) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = 0 , b = true }.b)) then ({a = ({a = 1 , b = 0 }.b) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.b) else ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = (case <l = ({a = true , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) ) (( \f: Rec X. X .((f (( \f: Nat .((f (unfold [ Nat ] (fold [ Bool ] (succ 1) )) ) (if ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (iszero 1) )) then (let u = 0 in 1) else (let u = ({a = 0 , b = 0 }.b) in 1)) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Nat .\y: Bool .y) (let u = (((\x: Nat .\y: Rec X. X .y) false ) true) in u) ) ({a = (pred (((\x: Rec X. X .\y: Nat .x) 1 ) true)) , b = ({a = 0 , b = true }.b) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .a))
(pred ({a = (let u = (let u = false in u) in (((\x: Bool .\y: Unit .x) 0 ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)))) , b = (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) true ) (if true then 1 else 1)) )) }.b))
(((\x: Rec X. X .\y: Unit .x) (let u = (let u = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) , b = ({a = 0 , b = false , c = 1 }.c) }.a) in u) in ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , b = (if true then 1 else 1) }.a)) ) (( \f: Unit .((f ({a = (succ (unfold [ Unit ] (fold [ Nat ] 1 ))) , b = (( \f: Rec X. X .((f ({a = true , b = false }.b) ) ({a = (fix (\x: Bool . 0 )) , b = (unfold [ Bool ] (fold [ Unit ] false )) }.b) ) ) (\a: Unit .\b: Unit .a)) }.b) ) (case <r = (if false then (unfold [ Unit ] (fold [ Bool ] true )) else (((\x: Rec X. X .\y: Unit .x) false ) false)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero (pred ({a = false , b = 0 }.b))) ))
({a = (let u = (let u = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) in u) in u) , b = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f (pred 0) ) 0 ) ) (\a: Unit .\b: Nat .b)) )) , b = (iszero (succ ({a = 0 , b = true , c = 1 }.c))) , c =  (unfold [ Nat ] (fold [ Nat ] ({a = (succ (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a))) , b = (unfold [ Nat ] (fold [ Unit ] (succ 1) )) }.b) )) }.b) , c = ({a = ({a = (case <l = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) }.a) , b = (( \f: Nat .((f ({a = 0 , b = false , c =  0 }.b) ) ({a = (( \f: Bool .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) ) (let u = true in u) ) ) (\a: Unit .\b: Unit .b)) , b = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.a) ) ) (\a: Rec X. X .\b: Unit .a)) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) ) (fix (\x: Bool . 1 )) ) ) (\a: Bool .\b: Rec X. X .b)) )) }.c) }.c)
(( \f: Nat .((f (fix (\x: Nat . (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) )) )) ) ({a = (fix (\x: Nat . (if (let u = true in true) then (iszero 1) else ({a = true , b = 0 }.a)) )) , b = ({a = 0 , b = (let u = true in u) , c = 1 }.c) }.a) ) ) (\a: Unit .\b: Unit .b))
(unfold [ Bool ] (fold [ Rec X. X ] (if ({a = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.a) , b = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = false , c =  1 }.b) }.b) then (case <l = (case <l = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = ({a = 0 , b = (let u = 0 in false) }.b) , b = (let u = (((\x: Rec X. X .\y: Unit .y) false ) 0) in u) }.b)) ))
(if ({a = (succ 0) , b = ({a = 1 , b = true }.b) , c =  ({a = ({a = true , b = 1 }.b) , b = false , c = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) }.c) }.b) then ({a = (( \f: Unit .((f ({a = (let u = 1 in u) , b = (iszero 1) }.a) ) (let u = ({a = ({a = true , b = 1 }.b) , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b)) , c = 0 }.c) in (let u = true in 0)) ) ) (\a: Bool .\b: Unit .a)) , b = (iszero (let u = (succ 1) in (fix (\x: Bool . 1 )))) }.b) else (((\x: Rec X. X .\y: Unit .x) (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f (let u = true in false) ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Nat .b)) )) ) (((\x: Nat .\y: Bool .x) ({a = 0 , b = false , c =  1 }.b) ) ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 1 , b = false , c =  0 }.b) , c =  (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b))))
({a = (((\x: Nat .\y: Rec X. X .x) ({a = (iszero 0) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true )) )) }.b) ) (((\x: Rec X. X .\y: Nat .y) (fix (\x: Bool . true )) ) (if false then false else true))) , b = (let u = (fix (\x: Nat . 0 )) in ({a = 1 , b = false , c = ({a = 1 , b = 0 }.b) }.c)) }.a)
(((\x: Unit .\y: Unit .y) (let u = (( \f: Rec X. X .((f (( \f: Bool .((f (let u = true in true) ) (iszero 0) ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = 0 in true) ) ) (\a: Nat .\b: Bool .b)) in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) in (((\x: Nat .\y: Bool .y) false ) 1)) )))
(( \f: Unit .((f (((\x: Bool .\y: Nat .x) ({a = (succ 1) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.a) ) (if (fix (\x: Rec X. X . (iszero 0) )) then (unfold [ Unit ] (fold [ Bool ] true )) else (let u = (unfold [ Unit ] (fold [ Unit ] true )) in (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a))))) ) (let u = (let u = (let u = (((\x: Nat .\y: Nat .y) false ) 1) in u) in u) in (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f (fix (\x: Unit . 1 )) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Bool .a)) ))) ) ) (\a: Unit .\b: Unit .b))
(((\x: Rec X. X .\y: Bool .x) (((\x: Rec X. X .\y: Unit .y) (fix (\x: Rec X. X . ({a = (let u = 0 in u) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) }.b) )) ) (((\x: Bool .\y: Bool .x) (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) in (((\x: Unit .\y: Bool .x) true ) true)) ) (if true then false else true))) ) ({a = (((\x: Rec X. X .\y: Nat .x) true ) true) , b = ({a = true , b = (if false then 1 else 1) }.a) }.b))
(if ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (if true then false else true) in (if false then true else false)) )) )) then (iszero (let u = (if false then (((\x: Rec X. X .\y: Nat .x) 0 ) true) else (let u = 0 in u)) in u)) else ({a = ({a = (let u = 0 in 0) , b = true }.a) , b = (iszero ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) , c =  (pred ({a = 1 , b = false }.a)) }.b))
(( \f: Unit .((f ({a = (let u = (let u = true in (unfold [ Rec X. X ] (fold [ Bool ] false ))) in (let u = false in true)) , b = ({a = (if true then ({a = 1 , b = false , c =  1 }.b) else true) , b = ({a = 0 , b = (((\x: Nat .\y: Rec X. X .x) 1 ) true) }.b) }.b) }.b) ) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 1 in false) )) , b = (pred ({a = 1 , b = 1 }.b)) }.b) ) ) (\a: Nat .\b: Unit .b))
(let u = (case <r = (iszero ({a = ({a = 1 , b = false }.a) , b = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) , c = (let u = (((\x: Unit .\y: Unit .x) 0 ) false) in 1) }.c)) > as Bool of < l = x > => x | < r = y > => y) in u)
(((\x: Bool .\y: Nat .y) (let u = ({a = false , b = 1 }.a) in ({a = (pred 0) , b = ({a = false , b = 1 }.a) }.b)) ) (if ({a = (let u = true in false) , b = (((\x: Nat .\y: Unit .y) false ) 0) }.a) then (let u = ({a = 1 , b = false , c =  0 }.b) in u) else (((\x: Bool .\y: Nat .x) (let u = false in u) ) (let u = (iszero 0) in false))))
({a = (if (let u = ({a = 0 , b = true }.a) in ({a = (fix (\x: Unit . (unfold [ Unit ] (fold [ Rec X. X ] false )) )) , b = (iszero 1) }.b)) then (let u = (((\x: Nat .\y: Rec X. X .y) false ) (let u = 1 in 0)) in u) else (( \f: Bool .((f (succ (let u = false in 0)) ) (if ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) then 0 else 0) ) ) (\a: Nat .\b: Unit .a))) , b = (let u = ({a = (((\x: Bool .\y: Rec X. X .y) false ) true) , b = ({a = 0 , b = false , c =  1 }.b) }.b) in ({a = false , b = ({a = 1 , b = true }.b) }.b)) , c =  ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) false ) ) (\a: Rec X. X .\b: Bool .b)) in (let u = 0 in 0)) )) }.b)
(case <l = ({a = ({a = 0 , b = 0 }.b) , b = ({a = (fix (\x: Nat . ({a = 0 , b = false }.b) )) , b = (let u = 1 in 0) }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (let u = (if (((\x: Bool .\y: Bool .y) true ) false) then (let u = true in 1) else 0) in u) in ({a = (((\x: Unit .\y: Nat .y) (iszero 1) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b))) , b = (( \f: Nat .((f (let u = (if false then (succ 0) else 0) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ))) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) , c = (unfold [ Bool ] (fold [ Nat ] (if ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) then (if false then 1 else 1) else (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) )) }.c))
(( \f: Rec X. X .((f ({a = (let u = (pred (if false then 1 else 0)) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (((\x: Bool .\y: Unit .y) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) true) , c = (let u = ({a = 0 , b = (iszero 0) , c = (((\x: Unit .\y: Nat .x) 1 ) false) }.c) in u) }.c) ) (succ (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in u)) ) ) (\a: Unit .\b: Bool .a))
(((\x: Nat .\y: Rec X. X .x) (iszero (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) (succ 0) ) ) (\a: Unit .\b: Unit .b))) ) ({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Bool . true )) )) in u) , b = (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f (if false then 1 else 1) ) (let u = 0 in u) ) ) (\a: Bool .\b: Unit .b)) ) (iszero (((\x: Unit .\y: Unit .x) 1 ) true))) }.a))
({a = (((\x: Bool .\y: Rec X. X .x) (pred (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) ) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) , b = false , c =  0 }.b)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (let u = (succ 1) in (let u = 1 in true)) , b = (((\x: Nat .\y: Bool .y) true ) ({a = true , b = 1 }.a)) }.b) )) , c = ({a = ({a = ({a = 1 , b = true , c =  0 }.b) , b = ({a = false , b = true }.b) }.b) , b = (let u = ({a = true , b = false }.b) in (pred 0)) }.b) }.c)
(let u = (if (fix (\x: Nat . (if true then true else true) )) then (if ({a = 0 , b = false }.b) then ({a = 1 , b = true }.a) else ({a = 1 , b = true }.a)) else (( \f: Bool .((f ({a = true , b = 1 }.b) ) (let u = true in ({a = 0 , b = true }.a)) ) ) (\a: Nat .\b: Unit .b))) in (fix (\x: Unit . (let u = 0 in u) )))
(let u = (( \f: Nat .((f (pred 1) ) (unfold [ Nat ] (fold [ Unit ] 0 )) ) ) (\a: Bool .\b: Nat .a)) in (let u = (fix (\x: Bool . ({a = 0 , b = false , c =  1 }.b) )) in (let u = (((\x: Nat .\y: Nat .x) 0 ) false) in u)))
({a = (let u = (((\x: Unit .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) false) in (fix (\x: Unit . (iszero 0) ))) , b = ({a = (let u = (iszero 0) in (let u = 0 in u)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = 0 , b = false }.a) , b = false }.b) )) , c = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) )) }.c) }.b)
(( \f: Nat .((f (if (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) then (let u = (((\x: Rec X. X .\y: Unit .y) true ) true) in (((\x: Rec X. X .\y: Unit .x) 1 ) true)) else (( \f: Unit .((f (if false then 1 else 1) ) (((\x: Rec X. X .\y: Bool .y) false ) 0) ) ) (\a: Rec X. X .\b: Nat .a))) ) (unfold [ Nat ] (fold [ Nat ] (let u = (let u = ({a = false , b = ({a = false , b = 0 }.b) }.a) in ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 ))) in u) )) ) ) (\a: Nat .\b: Unit .b))
(succ (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (pred ({a = 0 , b = false }.a)) in u) )))
(pred (((\x: Nat .\y: Unit .y) (let u = (( \f: Rec X. X .((f (if false then true else true) ) false ) ) (\a: Nat .\b: Bool .a)) in ({a = true , b = true }.b)) ) ({a = (succ 1) , b = (succ 1) }.b)))
(( \f: Rec X. X .((f (case <r = (iszero ({a = 1 , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (fix (\x: Rec X. X . ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = 0 }.b) )) in ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = true in u) ))) ) ) (\a: Unit .\b: Nat .a))
(case <l = (let u = (fix (\x: Nat . (if (let u = false in ({a = false , b = 0 }.a)) then (let u = false in u) else (iszero 1)) )) in ({a = (if true then false else true) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) > as Bool of < l = x > => x | < r = y > => y)
({a = (iszero (((\x: Nat .\y: Unit .y) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = (let u = 1 in u) }.a) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) )))) , b = (case <r = (let u = (((\x: Rec X. X .\y: Nat .x) 1 ) false) in (unfold [ Bool ] (fold [ Bool ] false ))) > as Unit of < l = x > => x | < r = y > => y) }.b)
(let u = (let u = (((\x: Rec X. X .\y: Unit .x) (unfold [ Bool ] (fold [ Bool ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) )) ) (( \f: Unit .((f ({a = true , b = true }.b) ) (iszero 1) ) ) (\a: Unit .\b: Bool .a))) in (pred ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) )))) in (let u = (let u = (let u = 1 in 1) in (fix (\x: Bool . (fix (\x: Nat . false )) ))) in (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Nat .x) 1 ) true) ))))
(succ ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = ({a = (( \f: Nat .((f ({a = true , b = 0 }.a) ) (let u = true in false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if true then 1 else 1) }.b) in (pred ({a = 0 , b = false }.a))) )))
(let u = (succ (if (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) false ) ) (\a: Bool .\b: Unit .a)) then (if true then 1 else ({a = true , b = 1 }.b)) else (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = true }.a) )))) in (unfold [ Rec X. X ] (fold [ Nat ] (if (((\x: Nat .\y: Unit .y) true ) false) then (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) else (unfold [ Bool ] (fold [ Unit ] true ))) )))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .y) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = true , c =  0 }.b) ) ({a = ({a = false , b = 0 }.a) , b = 0 }.b)) )) , b = (((\x: Unit .\y: Nat .x) (((\x: Unit .\y: Bool .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = true in u) )) ) (let u = true in false)) ) ({a = false , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.b)) }.b)
({a = (if ({a = 0 , b = true }.b) then (fix (\x: Nat . 1 )) else (let u = ({a = (succ 0) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = (((\x: Bool .\y: Bool .y) true ) 1) }.c) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) 1 ) false) )))) , b = (iszero (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) in ({a = 0 , b = (fix (\x: Rec X. X . 0 )) }.b))) }.a)
(pred ({a = (((\x: Rec X. X .\y: Unit .x) (pred 1) ) (let u = ({a = false , b = 0 }.a) in u)) , b = (iszero ({a = ({a = true , b = true }.b) , b = ({a = true , b = 0 }.b) }.b)) }.a))
(unfold [ Rec X. X ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = 0 , b = ({a = 0 , b = true }.b) }.a) , b = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) }.b) )) ))
(let u = (let u = (( \f: Bool .((f ({a = ({a = 0 , b = false , c =  0 }.b) , b = (((\x: Bool .\y: Nat .y) true ) 1) }.b) ) (succ 1) ) ) (\a: Nat .\b: Nat .b)) in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = false in 1) ))) in u)
({a = (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Rec X. X .y) (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Unit .\b: Nat .a)) ) (succ 1)) ) (( \f: Unit .((f (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Bool .a))) , b = ({a = ({a = (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = true , c = 1 }.c) )) , b = (if true then (if false then false else false) else (let u = 0 in false)) , c =  (let u = ({a = 0 , b = true }.a) in 0) }.b) , b = ({a = (let u = ({a = 0 , b = false }.b) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 ))) , b = ({a = ({a = false , b = 0 }.a) , b = (unfold [ Unit ] (fold [ Unit ] 0 )) }.a) }.a) }.a) }.a)
(let u = (pred (if false then (let u = 1 in u) else ({a = 0 , b = false , c = 0 }.c))) in u)
(iszero (( \f: Rec X. X .((f (if ({a = ({a = 1 , b = true , c = 1 }.c) , b = false , c =  ({a = true , b = 1 }.b) }.b) then (((\x: Rec X. X .\y: Bool .x) (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) in (if false then 1 else 0)) ) (iszero 1)) else (pred (let u = 1 in u))) ) (((\x: Bool .\y: Nat .x) (case <l = (let u = false in 0) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) (let u = true in false) ) (let u = (let u = 0 in 0) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true ))))) ) ) (\a: Nat .\b: Rec X. X .a)))
({a = (( \f: Bool .((f (let u = ({a = (let u = 0 in 1) , b = (let u = true in 0) }.b) in u) ) (((\x: Nat .\y: Unit .y) false ) (fix (\x: Rec X. X . 1 ))) ) ) (\a: Bool .\b: Unit .b)) , b = (fix (\x: Rec X. X . (let u = ({a = (let u = false in false) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) in (fix (\x: Nat . (let u = 1 in true) ))) )) , c = (case <l = (let u = 1 in u) > as Rec X. X of < l = x > => x | < r = y > => y) }.c)
(unfold [ Unit ] (fold [ Bool ] (let u = ({a = ({a = false , b = 0 }.a) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) in u) ))
(let u = ({a = (fix (\x: Nat . false )) , b = ({a = 1 , b = false , c = ({a = false , b = 0 }.b) }.c) }.a) in (iszero (if (fix (\x: Nat . (let u = false in false) )) then (((\x: Unit .\y: Nat .x) 1 ) false) else ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )))))
({a = (( \f: Rec X. X .((f ({a = ({a = true , b = 1 }.b) , b = false , c = 0 }.c) ) (((\x: Rec X. X .\y: Nat .x) 1 ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = ({a = (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Bool .y) true ) true) ) ({a = 1 , b = true }.b)) , b = (let u = (let u = 1 in 0) in u) }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Unit .x) false ) false) )) , c =  ({a = 1 , b = false , c = ({a = 1 , b = 1 }.b) }.c) }.b) , c =  (if ({a = ({a = (if false then 0 else 1) , b = true , c = (pred 1) }.c) , b = (( \f: Unit .((f ({a = 1 , b = false , c =  1 }.b) ) (let u = 1 in (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Nat .b)) }.b) then (let u = (((\x: Unit .\y: Rec X. X .y) (case <r = (unfold [ Nat ] (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y) ) (succ 0)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) ))) else (let u = (((\x: Nat .\y: Nat .x) 1 ) true) in u)) }.b)
(((\x: Unit .\y: Unit .x) (unfold [ Unit ] (fold [ Nat ] ({a = (let u = false in (let u = 1 in false)) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) }.b) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = (fix (\x: Unit . true )) , b = (let u = 1 in 1) }.a) )))
({a = (let u = (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) 1 ) true) ) (if false then true else (let u = true in true))) in u) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = 1 , b = 0 }.b) in (( \f: Bool .((f true ) (iszero 0) ) ) (\a: Unit .\b: Bool .b))) )) }.b)
(let u = ({a = (((\x: Unit .\y: Unit .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 ))) , b = (fix (\x: Bool . (( \f: Bool .((f false ) (iszero 1) ) ) (\a: Nat .\b: Bool .a)) )) }.b) in (((\x: Rec X. X .\y: Unit .x) (let u = ({a = 0 , b = 1 }.b) in (((\x: Bool .\y: Rec X. X .y) false ) 0)) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = false }.b) ))))
(unfold [ Rec X. X ] (fold [ Nat ] (case <l = (let u = ({a = (( \f: Nat .((f (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) ) (unfold [ Unit ] (fold [ Nat ] true )) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = 0 , b = true , c =  1 }.b) }.b) in ({a = (pred 0) , b = true }.a)) > as Bool of < l = x > => x | < r = y > => y) ))
({a = (let u = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) (((\x: Unit .\y: Unit .x) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = true , b = false }.b)) ) ) (\a: Nat .\b: Rec X. X .a)) in (unfold [ Unit ] (fold [ Unit ] (( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ) (unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) 0 ) false) )) ) ) (\a: Unit .\b: Nat .b)) ))) , b = ({a = (let u = ({a = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = false }.b) in (let u = 0 in u)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) false ) true) )) ) ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = 0 }.a) ) ) (\a: Bool .\b: Rec X. X .b)) )) , c =  (pred (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true)) }.b) , c =  (let u = (let u = ({a = 0 , b = 0 }.b) in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 ))) in ({a = 0 , b = ({a = 1 , b = true , c = 1 }.c) }.b)) }.b)
(((\x: Nat .\y: Unit .y) (let u = (((\x: Unit .\y: Bool .x) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Unit .\y: Unit .x) true ) false)) in u) ) (( \f: Rec X. X .((f (let u = (let u = false in u) in (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Nat .y) false ) true) ) (iszero ({a = true , b = 1 }.b)))) ) (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = (let u = true in true) , c =  (let u = 1 in u) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) (let u = 0 in u) ) ({a = (((\x: Nat .\y: Bool .x) 1 ) false) , b = (if ({a = true , b = false }.b) then (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) else ({a = 0 , b = false }.b)) }.b)) ) ({a = (fix (\x: Bool . (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) )) , b = (if (( \f: Rec X. X .((f (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . true )) ) ) (\a: Nat .\b: Unit .b)) then (let u = (( \f: Nat .((f ({a = 1 , b = false }.b) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Nat .a)) in (fix (\x: Bool . ({a = 0 , b = true }.a) ))) else (case <l = ({a = 1 , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y)) }.b) ) ) (\a: Nat .\b: Bool .b))
(unfold [ Unit ] (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] (let u = (case <l = (unfold [ Nat ] (fold [ Bool ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) in u) )) ))
({a = (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) false ) ({a = false , b = 0 }.a)) ) (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) true ) true) ) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Unit .a)) in u) }.b)
(let u = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Bool .\y: Rec X. X .x) false ) true) )) then (((\x: Nat .\y: Unit .y) (if false then false else false) ) (((\x: Unit .\y: Unit .x) false ) false)) else (case <r = (( \f: Rec X. X .((f (let u = true in u) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y)) in u)
(fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .y) false ) ({a = false , b = true }.b)) )) ))
({a = ({a = (case <l = (( \f: Unit .((f (succ 1) ) 0 ) ) (\a: Bool .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) , b = (if (let u = true in u) then ({a = (iszero ({a = 0 , b = true , c = 1 }.c)) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) else (let u = ({a = 1 , b = false , c =  1 }.b) in u)) }.a) , b = (unfold [ Bool ] (fold [ Unit ] (let u = (iszero 0) in u) )) }.b)
(iszero (((\x: Bool .\y: Nat .x) (let u = (((\x: Bool .\y: Nat .x) 0 ) false) in (((\x: Unit .\y: Unit .y) true ) 1)) ) (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Bool ] true )) ))))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f (pred (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) ) ({a = (unfold [ Unit ] (fold [ Bool ] true )) , b = (let u = 1 in (if false then 1 else 1)) }.b) ) ) (\a: Unit .\b: Nat .b)) )) ))
(let u = ({a = (let u = ({a = ({a = ({a = false , b = false }.b) , b = (let u = 0 in 1) }.b) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.a) in u) , b = (let u = ({a = false , b = 0 }.a) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) , c = (fix (\x: Rec X. X . ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) )) }.c) in u)
({a = (((\x: Nat .\y: Rec X. X .x) (succ ({a = true , b = 0 }.b)) ) ({a = (((\x: Unit .\y: Nat .y) (let u = 1 in false) ) (((\x: Nat .\y: Nat .y) true ) true)) , b = (if true then true else true) }.b)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f ({a = (pred 1) , b = false , c = (let u = 0 in 1) }.c) ) (succ 0) ) ) (\a: Rec X. X .\b: Unit .a)) )) }.b)
(case <l = (let u = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) (( \f: Nat .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (if false then 1 else 1) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Unit .b)) in (unfold [ Bool ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ))
(case <l = (fix (\x: Nat . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) )) )) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (pred (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in u)) ) (let u = ({a = ({a = 0 , b = (let u = 1 in true) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c) , b = (fix (\x: Bool . false )) }.a) in (pred (((\x: Unit .\y: Nat .x) 1 ) false))) ) ) (\a: Bool .\b: Nat .a))
(((\x: Rec X. X .\y: Bool .x) (let u = (succ (fix (\x: Bool . (if false then 1 else 1) ))) in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (iszero (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) )))
(( \f: Bool .((f (((\x: Unit .\y: Nat .x) (( \f: Bool .((f (fix (\x: Unit . (fix (\x: Nat . 0 )) )) ) (pred 0) ) ) (\a: Nat .\b: Nat .b)) ) (let u = (let u = false in false) in u)) ) ({a = ({a = (succ 1) , b = (let u = true in u) , c = (let u = 0 in u) }.c) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (fix (\x: Nat . ({a = 1 , b = true , c = 1 }.c) )) }.c) }.b) ) ) (\a: Unit .\b: Bool .a))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (fix (\x: Nat . (let u = 1 in (if false then 1 else 1)) )) in (case <l = (((\x: Rec X. X .\y: Rec X. X .y) true ) (let u = true in 0)) > as Rec X. X of < l = x > => x | < r = y > => y)) ))
(case <l = (((\x: Rec X. X .\y: Nat .y) ({a = (let u = (let u = 0 in 0) in (unfold [ Unit ] (fold [ Rec X. X ] false ))) , b = (fix (\x: Rec X. X . 0 )) }.a) ) (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) in u)) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (if (case <r = (case <r = ({a = 0 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) then (case <l = (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) (let u = false in false) ) (if false then true else false)) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) else ({a = (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) in 0) , b = ({a = (if true then 1 else 0) , b = ({a = true , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.a) , c =  (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) , c = (( \f: Nat .((f (pred 0) ) (unfold [ Unit ] (fold [ Unit ] 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) }.c)) , b = ({a = (iszero (let u = 0 in 0)) , b = (if (fix (\x: Rec X. X . false )) then ({a = 0 , b = false }.a) else (let u = true in (pred 0))) }.a) , c = ({a = (succ ({a = (((\x: Rec X. X .\y: Nat .y) false ) 0) , b = ({a = 0 , b = true }.b) , c = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) }.c)) , b = (( \f: Rec X. X .((f (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)) ) (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in true) ) ) (\a: Unit .\b: Nat .a)) }.a) }.c)
(iszero (( \f: Unit .((f (let u = 0 in u) ) ({a = 1 , b = 0 }.b) ) ) (\a: Nat .\b: Nat .a)))
(((\x: Nat .\y: Bool .y) ({a = (unfold [ Rec X. X ] (fold [ Unit ] (let u = 1 in 1) )) , b = ({a = (iszero 1) , b = true }.b) , c =  (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) else (if (((\x: Bool .\y: Nat .x) true ) false) then 0 else (let u = 0 in u))) }.b) ) ({a = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = false }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Unit .x) 0 ) true) )) }.a))
(( \f: Nat .((f (( \f: Bool .((f ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = true in 1) }.b) ) ({a = (let u = (pred 0) in u) , b = (if (if false then true else true) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) else (let u = 1 in 0)) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = ({a = (((\x: Rec X. X .\y: Unit .y) true ) 0) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , c = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.c) , b = (iszero 0) , c = (fix (\x: Rec X. X . 1 )) }.c) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (let u = (let u = (let u = (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) ) ) (\a: Bool .\b: Nat .b)) in (let u = 0 in u)) in ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .b)) }.b)) in (((\x: Rec X. X .\y: Nat .y) ({a = true , b = true }.b) ) (((\x: Bool .\y: Nat .x) true ) true))) in u)
({a = (succ ({a = (( \f: Unit .((f ({a = 0 , b = true }.b) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (((\x: Nat .\y: Nat .y) (let u = 0 in true) ) ({a = 0 , b = false , c = 1 }.c)) }.b)) , b = (( \f: Bool .((f (fix (\x: Unit . (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) ) (fix (\x: Bool . (if (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else true) )) ) ) (\a: Bool .\b: Bool .a)) , c = (pred ({a = (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = false }.a) ) false) , b = ({a = false , b = 1 }.b) }.b)) }.c)
(let u = (case <r = (let u = (((\x: Nat .\y: Rec X. X .x) true ) true) in u) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] (fix (\x: Rec X. X . ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (iszero 0) }.a) )) )) ) (let u = (fix (\x: Unit . (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) )) in (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Nat ] 0 )) ))) ) ) (\a: Unit .\b: Nat .b))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (let u = (let u = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .a)) , b = 0 }.b) in (( \f: Bool .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) 0 ) ) (\a: Nat .\b: Unit .a))) in u) in ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = (pred 1) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Unit . true )) )) , c = (let u = false in 1) }.c) ))) ))
(let u = (succ (case <l = ({a = ({a = 0 , b = true }.a) , b = (pred 1) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) in u)
(case <l = (fix (\x: Unit . ({a = (fix (\x: Unit . ({a = 1 , b = true , c = 0 }.c) )) , b = (fix (\x: Bool . (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .b)) )) }.a) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = (( \f: Bool .((f (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) else (succ 1)) ) ({a = (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y) , b = (if true then true else true) }.a) ) ) (\a: Unit .\b: Bool .b)) in ({a = (( \f: Rec X. X .((f (pred 1) ) (((\x: Unit .\y: Rec X. X .y) false ) 1) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (let u = ({a = 0 , b = 1 }.b) in (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a))) }.b))
({a = ({a = (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) )) , b = ({a = (fix (\x: Bool . 0 )) , b = (succ 0) }.b) }.b) , b = ({a = (pred (((\x: Bool .\y: Unit .y) true ) 0)) , b = (case <r = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) , c =  ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = false , b = ({a = 0 , b = true , c = 1 }.c) }.b) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = (let u = false in (unfold [ Nat ] (fold [ Nat ] 0 ))) }.c) )) }.b) , c = (unfold [ Nat ] (fold [ Bool ] (unfold [ Bool ] (fold [ Unit ] ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) , b = true }.a) )) )) }.c)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (if ({a = ({a = 1 , b = false }.a) , b = ({a = 0 , b = false }.b) }.b) then (( \f: Unit .((f (let u = true in false) ) true ) ) (\a: Bool .\b: Bool .b)) else (let u = (let u = true in u) in u)) in ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) then (((\x: Unit .\y: Rec X. X .y) false ) true) else (unfold [ Bool ] (fold [ Unit ] false ))) }.b)) ))
(succ (fix (\x: Rec X. X . (( \f: Rec X. X .((f (fix (\x: Rec X. X . (succ 1) )) ) ({a = (if true then 1 else 0) , b = (iszero 0) , c = ({a = true , b = 1 }.b) }.c) ) ) (\a: Nat .\b: Unit .a)) )))
((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (iszero ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) ))) ))) ))
({a = ({a = (unfold [ Unit ] (fold [ Nat ] ({a = true , b = 1 }.a) )) , b = (let u = true in 0) }.a) , b = (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Rec X. X .x) false ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (let u = (let u = true in false) in ({a = true , b = 0 }.b))) }.b)
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (let u = (let u = 1 in 1) in ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = ({a = 1 , b = false , c = 1 }.c) }.b)) , b = (unfold [ Bool ] (fold [ Unit ] ({a = 1 , b = true }.b) )) }.a) ))
({a = (((\x: Unit .\y: Bool .y) (if (let u = (let u = 1 in 1) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) then (let u = (unfold [ Nat ] (fold [ Unit ] true )) in u) else (( \f: Unit .((f (( \f: Rec X. X .((f false ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .a)) ) (( \f: Bool .((f (fix (\x: Nat . true )) ) (if true then false else true) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Nat .a))) ) (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (pred 0) )) in (( \f: Bool .((f ({a = 1 , b = 0 }.b) ) ({a = ({a = false , b = 1 }.b) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) }.a) ) ) (\a: Bool .\b: Nat .a)))) , b = (iszero (((\x: Unit .\y: Nat .y) (if false then (let u = true in u) else (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) , c = (case <l = (if false then ({a = 1 , b = false , c = 0 }.c) else (((\x: Bool .\y: Bool .y) false ) 0)) > as Unit of < l = x > => x | < r = y > => y) }.c)
(let u = (let u = (pred ({a = 0 , b = false , c = 0 }.c)) in u) in u)
(((\x: Bool .\y: Nat .y) ({a = ({a = ({a = 1 , b = false }.b) , b = (let u = 1 in u) }.a) , b = (((\x: Unit .\y: Nat .y) (let u = (let u = false in u) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true ))) }.b) ) ({a = (((\x: Unit .\y: Nat .y) (iszero 1) ) (pred 1)) , b = (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in false) )) )) , c = (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = (let u = 1 in true) , c = (let u = 0 in u) }.c) )) }.c))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Bool . (fix (\x: Nat . ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = (let u = 1 in u) }.b) )) )) ))
(((\x: Bool .\y: Rec X. X .x) (if (unfold [ Unit ] (fold [ Bool ] true )) then ({a = false , b = (pred 0) }.b) else (let u = 0 in (if true then 1 else 1))) ) (unfold [ Unit ] (fold [ Bool ] (case <r = (let u = 0 in true) > as Bool of < l = x > => x | < r = y > => y) )))
({a = (((\x: Nat .\y: Unit .y) (if false then ({a = 1 , b = true , c =  1 }.b) else true) ) (let u = (if true then 0 else 0) in u)) , b = ({a = (fix (\x: Nat . true )) , b = (iszero 0) }.b) }.b)
(( \f: Nat .((f (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) (let u = 1 in u) ) ({a = false , b = true }.b)) ) (succ ({a = (succ 0) , b = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (((\x: Bool .\y: Rec X. X .y) true ) true) }.b) , c = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.c)) ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = (( \f: Nat .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .a)) in (if (iszero 1) then ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) else 1)) ) ) (\a: Unit .\b: Nat .b))
({a = (( \f: Nat .((f ({a = 0 , b = true , c =  1 }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = (let u = ({a = false , b = 0 }.b) in (if true then 0 else 1)) , b = (((\x: Nat .\y: Rec X. X .y) (case <r = (((\x: Nat .\y: Bool .x) false ) false) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (pred 0) , b = false , c =  1 }.b)) , c =  (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) }.b)) }.b)
({a = ({a = (unfold [ Unit ] (fold [ Nat ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) , b = (fix (\x: Bool . (unfold [ Bool ] (fold [ Bool ] (unfold [ Bool ] (fold [ Nat ] 1 )) )) )) }.a) , b = ({a = (((\x: Nat .\y: Bool .x) (fix (\x: Rec X. X . true )) ) (((\x: Unit .\y: Unit .x) (let u = ({a = true , b = 0 }.a) in u) ) (if false then false else true))) , b = (((\x: Nat .\y: Rec X. X .x) (let u = (((\x: Nat .\y: Bool .x) true ) true) in (( \f: Bool .((f (let u = true in 1) ) (let u = 1 in 0) ) ) (\a: Rec X. X .\b: Unit .a))) ) ({a = (fix (\x: Bool . (let u = 1 in true) )) , b = (fix (\x: Unit . true )) }.b)) }.a) }.b)
(let u = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Nat .((f (let u = true in u) ) (((\x: Unit .\y: Bool .x) false ) false) ) ) (\a: Bool .\b: Unit .b)) )) , b = (((\x: Nat .\y: Bool .x) (let u = ({a = true , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.a) in (let u = true in 1)) ) ({a = (succ (let u = false in 0)) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in u) , c =  (succ 1) }.b)) }.a) in u)
(((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f true ) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Bool .\y: Bool .x) (iszero 1) ) ({a = (iszero 0) , b = 0 }.a))) ) (case <l = ({a = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) in u) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .a)) , c = (let u = 0 in 1) }.c) > as Nat of < l = x > => x | < r = y > => y))
(if ({a = (if ({a = false , b = 0 }.a) then (fix (\x: Nat . 0 )) else (fix (\x: Nat . 1 ))) , b = (let u = (( \f: Nat .((f 0 ) (succ 0) ) ) (\a: Unit .\b: Nat .b)) in (unfold [ Unit ] (fold [ Bool ] false ))) , c =  ({a = (let u = false in 0) , b = ({a = 1 , b = true , c =  0 }.b) , c = (pred 0) }.c) }.b) then (fix (\x: Unit . (( \f: Rec X. X .((f (let u = 0 in 1) ) (let u = (let u = 0 in u) in ({a = false , b = 1 }.b)) ) ) (\a: Bool .\b: Rec X. X .b)) )) else (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = (case <r = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = false , c =  1 }.b) }.b) )) then ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] 0 )) )) else ({a = (((\x: Bool .\y: Rec X. X .y) false ) ({a = 1 , b = false }.a)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = true , c =  1 }.b) )) , c = (succ (unfold [ Bool ] (fold [ Bool ] 1 ))) }.c)))
(let u = (iszero (unfold [ Nat ] (fold [ Nat ] (if false then 1 else 0) ))) in (((\x: Unit .\y: Unit .x) (let u = (if ({a = true , b = 0 }.a) then (case <r = false > as Unit of < l = x > => x | < r = y > => y) else (((\x: Unit .\y: Unit .x) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) true)) in (iszero (fix (\x: Nat . (let u = 0 in 1) )))) ) (( \f: Nat .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Nat .a))))
({a = (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = 1 , b = (((\x: Bool .\y: Rec X. X .y) true ) false) }.a) ) ) (\a: Rec X. X .\b: Nat .b))) )) , b = (let u = ({a = (let u = 1 in u) , b = ({a = 0 , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) }.b) , c =  (( \f: Rec X. X .((f (fix (\x: Bool . ({a = true , b = 1 }.b) )) ) ({a = ({a = false , b = 0 }.b) , b = (let u = 0 in u) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) in (( \f: Unit .((f (fix (\x: Rec X. X . 0 )) ) ({a = 1 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.b)
(let u = (( \f: Nat .((f ({a = (if false then (let u = 0 in u) else 0) , b = ({a = ({a = false , b = 1 }.b) , b = (if true then true else false) , c =  (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) in 0) }.b) , c =  ({a = true , b = 1 }.b) }.b) ) (let u = (let u = 1 in 0) in (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .a))) ) ) (\a: Unit .\b: Nat .a)) in (case <l = (( \f: Nat .((f (fix (\x: Unit . 1 )) ) ({a = 0 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c = 1 }.c) ) ) (\a: Rec X. X .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Bool .y) (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Bool ] false )) )) ) (case <r = ({a = ({a = (let u = false in 1) , b = ({a = false , b = false }.b) }.a) , b = ({a = (iszero 1) , b = 0 }.a) }.b) > as Nat of < l = x > => x | < r = y > => y))
(unfold [ Nat ] (fold [ Unit ] (case <r = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) , b = (if false then false else true) }.b) > as Unit of < l = x > => x | < r = y > => y) ))
(iszero (succ ({a = 0 , b = (let u = 1 in u) }.b)))
(( \f: Nat .((f (iszero ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in 0) ))) ) ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a))) , b = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , c =  (((\x: Nat .\y: Nat .y) true ) (fix (\x: Rec X. X . 1 ))) }.b) }.b) ) ) (\a: Unit .\b: Rec X. X .a))
(((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .y) (let u = (if (fix (\x: Unit . true )) then (if ({a = false , b = true }.b) then (iszero 1) else false) else ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true ))) in u) ) (if ({a = 1 , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) }.b) then (((\x: Unit .\y: Rec X. X .x) 1 ) ({a = 0 , b = false , c =  1 }.b)) else (succ (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))))) ) ({a = (((\x: Rec X. X .\y: Nat .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (let u = true in u) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )))) , b = (unfold [ Unit ] (fold [ Rec X. X ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) }.a))
({a = (((\x: Nat .\y: Nat .x) (( \f: Unit .((f (( \f: Unit .((f false ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a)) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) (iszero (fix (\x: Bool . ({a = 1 , b = (((\x: Bool .\y: Unit .x) 1 ) false) }.b) )))) , b = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = (let u = 0 in false) , b = ({a = 0 , b = true }.a) }.b) )) , b = (((\x: Unit .\y: Nat .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false }.a) }.a)) , c = (case <l = ({a = 1 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y) }.c) }.a)
(((\x: Bool .\y: Unit .x) ({a = ({a = false , b = (((\x: Unit .\y: Bool .y) true ) 1) }.b) , b = (let u = ({a = true , b = 0 }.a) in (let u = (let u = 1 in false) in u)) }.b) ) ({a = (((\x: Unit .\y: Unit .y) ({a = 1 , b = true , c =  1 }.b) ) 0) , b = ({a = ({a = 1 , b = false }.b) , b = false }.b) , c =  (succ (((\x: Unit .\y: Unit .y) ({a = true , b = 0 }.a) ) (let u = true in 0))) }.b))
(let u = ({a = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Rec X. X ] 1 )) )) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Bool . 1 )) ))) , b = ({a = (let u = 0 in true) , b = (let u = (((\x: Rec X. X .\y: Unit .y) true ) true) in true) }.b) , c =  (((\x: Unit .\y: Rec X. X .x) ({a = 1 , b = (let u = false in u) , c = 0 }.c) ) (let u = 1 in (let u = false in u))) }.b) in (let u = (fix (\x: Bool . ({a = 0 , b = true , c = 0 }.c) )) in ({a = (let u = true in 1) , b = (let u = (let u = false in true) in ({a = 1 , b = true }.b)) , c =  (fix (\x: Rec X. X . 1 )) }.b)))
({a = ({a = (((\x: Nat .\y: Nat .x) (pred ({a = 0 , b = true , c = 1 }.c)) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b))) , b = (((\x: Bool .\y: Nat .x) (unfold [ Nat ] (fold [ Bool ] 1 )) ) (((\x: Bool .\y: Rec X. X .x) false ) ({a = 0 , b = true , c =  1 }.b))) }.b) , b = ({a = ({a = (((\x: Unit .\y: Rec X. X .y) (if true then false else true) ) ({a = 0 , b = true }.a)) , b = (let u = (if true then true else false) in u) }.a) , b = ({a = (pred (let u = 1 in 0)) , b = ({a = ({a = true , b = 0 }.b) , b = (unfold [ Unit ] (fold [ Bool ] ({a = true , b = 0 }.a) )) }.b) }.b) , c =  (unfold [ Nat ] (fold [ Bool ] (case <l = ({a = false , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) )) }.b) , c =  (((\x: Bool .\y: Nat .x) (pred (let u = 1 in u)) ) (if ({a = true , b = true }.b) then ({a = true , b = 0 }.a) else (fix (\x: Nat . false )))) }.b)
(let u = ({a = (((\x: Rec X. X .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Bool ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (let u = true in true)) , b = (unfold [ Unit ] (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Bool .x) 1 ) false) )) )) }.a) in (let u = (iszero (fix (\x: Bool . 1 ))) in (if true then 0 else ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )))))
(let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f (((\x: Nat .\y: Nat .x) true ) true) ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Rec X. X .a)) ) (( \f: Rec X. X .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) 0 ) ) (\a: Unit .\b: Nat .b))) , b = ({a = (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .y) true ) 1) )) , b = (( \f: Bool .((f false ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Unit .\b: Nat .a)) }.b) , c =  (fix (\x: Bool . (if (((\x: Unit .\y: Unit .y) (let u = 1 in true) ) false) then (((\x: Rec X. X .\y: Bool .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) 1) else (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) )) }.b) in u)
(pred (((\x: Rec X. X .\y: Unit .x) (case <l = ({a = 0 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) ({a = (let u = false in false) , b = 0 }.a) ) ({a = 0 , b = false , c =  0 }.b))))
({a = (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (let u = ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = 0 }.a) in (( \f: Unit .((f (((\x: Nat .\y: Unit .y) true ) 0) ) 1 ) ) (\a: Unit .\b: Rec X. X .a))) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) }.b)
({a = (iszero (case <l = ({a = 0 , b = false }.a) > as Bool of < l = x > => x | < r = y > => y)) , b = (((\x: Rec X. X .\y: Unit .x) (pred (let u = (succ 1) in u)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = ({a = (fix (\x: Rec X. X . true )) , b = false }.b) in u) ))) }.b)
(let u = (case <l = (let u = (unfold [ Nat ] (fold [ Unit ] 0 )) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a))) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = (let u = ({a = 1 , b = (succ 1) }.b) in u) , b = ({a = (if true then false else (unfold [ Nat ] (fold [ Bool ] true ))) , b = ({a = (fix (\x: Unit . false )) , b = ({a = 1 , b = false , c = 1 }.c) }.a) }.b) , c =  (( \f: Nat .((f (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) (let u = 0 in u) ) ) (\a: Bool .\b: Rec X. X .b)) ) (if true then 0 else 1) ) ) (\a: Nat .\b: Bool .a)) ) (if false then 0 else 1) ) ) (\a: Rec X. X .\b: Nat .b)) }.b))
(((\x: Nat .\y: Unit .y) ({a = (((\x: Rec X. X .\y: Bool .y) (if true then false else false) ) (if false then true else false)) , b = (succ (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) }.a) ) (let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = false , b = true }.b) )) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = (if true then 0 else 1) , b = ({a = 1 , b = 0 }.b) }.b) ))))
(let u = (((\x: Unit .\y: Unit .x) (pred 1) ) (fix (\x: Unit . ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) ))) in (let u = (succ (pred 1)) in u))
(let u = (((\x: Bool .\y: Bool .x) (case <r = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . true )) }.a) , b = (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] true )) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) }.b)) in u)
(succ ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if (fix (\x: Rec X. X . true )) then (if false then 1 else 0) else (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y))) )))
(( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = (if (let u = true in u) then ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) else (((\x: Bool .\y: Bool .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = true , b = true }.b))) , b = (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a))) }.b) )) ) (( \f: Nat .((f (let u = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a)) in u) ) (( \f: Rec X. X .((f (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] true )) ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Unit .a)) ) ({a = false , b = (let u = false in false) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .b))
(if (unfold [ Bool ] (fold [ Unit ] (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) in (((\x: Bool .\y: Nat .y) (let u = true in true) ) true)) )) then (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f ({a = (fix (\x: Bool . 1 )) , b = (((\x: Bool .\y: Rec X. X .x) false ) true) }.b) ) (if true then false else true) ) ) (\a: Unit .\b: Nat .b)) ) (iszero (((\x: Bool .\y: Bool .x) 1 ) false))) else ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (case <l = ({a = 1 , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) in (iszero (let u = false in (fix (\x: Unit . 1 ))))) ))
(let u = (( \f: Unit .((f (unfold [ Bool ] (fold [ Nat ] (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .b)) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (iszero 0) )) ) ) (\a: Nat .\b: Rec X. X .a)) in u)
(case <l = ({a = (let u = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in u) in (((\x: Nat .\y: Rec X. X .x) (succ 1) ) ({a = true , b = true }.b))) , b = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (let u = 1 in u)) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = (fix (\x: Nat . (( \f: Rec X. X .((f ({a = ({a = 1 , b = false , c = 0 }.c) , b = ({a = 1 , b = false }.b) , c = 0 }.c) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) , b = ({a = (if (((\x: Rec X. X .\y: Rec X. X .x) (let u = 1 in false) ) ({a = false , b = false }.b)) then (fix (\x: Unit . false )) else (if false then (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) else ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )))) , b = (succ (succ 1)) }.a) , c = (if (iszero ({a = ({a = false , b = false }.b) , b = (let u = false in 1) }.b)) then ({a = ({a = (let u = true in true) , b = 0 }.a) , b = (( \f: Nat .((f 1 ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Nat .b)) }.b) else (let u = (case <l = (if true then 0 else 0) > as Nat of < l = x > => x | < r = y > => y) in u)) }.c)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (fix (\x: Bool . 0 )) in u) ))
({a = (fix (\x: Rec X. X . (let u = ({a = 0 , b = (((\x: Unit .\y: Nat .x) true ) true) }.b) in (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) in u)) )) , b = (let u = (unfold [ Rec X. X ] (fold [ Bool ] (if false then false else false) )) in (pred 1)) }.a)
(unfold [ Unit ] (fold [ Rec X. X ] (let u = (((\x: Nat .\y: Bool .x) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = ({a = 0 , b = 1 }.b) }.a) ) ({a = (pred 0) , b = (iszero 0) }.b)) in (case <r = (fix (\x: Nat . (let u = false in u) )) > as Nat of < l = x > => x | < r = y > => y)) ))
(let u = ({a = ({a = (let u = (let u = false in u) in u) , b = (let u = 0 in 0) }.b) , b = (let u = (succ 0) in 0) }.b) in (let u = (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Nat . true )) ) 0) in u))
(( \f: Bool .((f (if (if ({a = (fix (\x: Unit . 0 )) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .b)) }.b) then (let u = (fix (\x: Unit . false )) in u) else (fix (\x: Rec X. X . ({a = 0 , b = true }.b) ))) then (let u = (( \f: Rec X. X .((f false ) (iszero 0) ) ) (\a: Bool .\b: Unit .b)) in (((\x: Nat .\y: Nat .y) (((\x: Rec X. X .\y: Unit .x) (iszero 0) ) false) ) (let u = true in true))) else (iszero (let u = 1 in 0))) ) (if (let u = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Unit .x) true ) true) ) (fix (\x: Unit . false ))) in u) then ({a = (let u = ({a = 1 , b = false }.a) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) , b = (( \f: Bool .((f false ) ({a = false , b = false }.b) ) ) (\a: Nat .\b: Nat .a)) }.b) else (( \f: Unit .((f (let u = false in u) ) (((\x: Unit .\y: Unit .x) true ) false) ) ) (\a: Bool .\b: Nat .b))) ) ) (\a: Nat .\b: Nat .b))
(( \f: Unit .((f (let u = (let u = (iszero 1) in (unfold [ Unit ] (fold [ Rec X. X ] true ))) in u) ) ({a = (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) false ) 0) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) ) (\a: Unit .\b: Nat .b)) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a)) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
(fix (\x: Unit . (let u = (pred (((\x: Unit .\y: Bool .y) true ) 0)) in (let u = (let u = 1 in u) in ({a = true , b = 0 }.a))) ))
(let u = (case <l = (( \f: Unit .((f (( \f: Nat .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ) (let u = (((\x: Unit .\y: Bool .x) 0 ) true) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) in u)
(((\x: Nat .\y: Nat .x) (case <l = (((\x: Nat .\y: Bool .y) ({a = true , b = 0 }.a) ) (((\x: Nat .\y: Nat .y) true ) 1)) > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = true , b = (let u = true in u) }.b) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = ({a = ({a = 0 , b = true }.a) , b = (let u = true in u) , c =  0 }.b) , c =  (succ (fix (\x: Bool . 0 ))) }.b) ))
(unfold [ Bool ] (fold [ Unit ] (if (let u = ({a = true , b = (((\x: Rec X. X .\y: Bool .y) false ) true) }.b) in (iszero 1)) then (iszero ({a = (pred 1) , b = ({a = true , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) }.b) }.a)) else ({a = ({a = ({a = 1 , b = false , c =  1 }.b) , b = ({a = 1 , b = true }.a) }.a) , b = ({a = ({a = 0 , b = false , c =  (let u = true in 1) }.b) , b = (let u = true in (pred 0)) }.b) }.a)) ))
(let u = (((\x: Nat .\y: Nat .x) (( \f: Bool .((f (((\x: Bool .\y: Nat .y) false ) 1) ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) ) (case <r = (fix (\x: Bool . true )) > as Rec X. X of < l = x > => x | < r = y > => y)) in u)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Rec X. X .((f ({a = ({a = 1 , b = false , c = 0 }.c) , b = (if false then false else true) }.b) ) (( \f: Unit .((f (let u = false in u) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .a)) ))
(unfold [ Rec X. X ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) ({a = (succ 1) , b = (unfold [ Bool ] (fold [ Bool ] true )) }.b) ) ({a = (succ 0) , b = true }.a)) ))
({a = ({a = (let u = (fix (\x: Nat . (fix (\x: Unit . 1 )) )) in u) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = true , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) )) , c = (((\x: Rec X. X .\y: Nat .y) (let u = true in true) ) (((\x: Rec X. X .\y: Unit .x) 0 ) (let u = 0 in true))) }.c) , b = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Rec X. X . (fix (\x: Rec X. X . false )) )) )) in u) , c =  ({a = (let u = (let u = 1 in false) in (let u = 1 in 1)) , b = ({a = ({a = 0 , b = (((\x: Bool .\y: Nat .y) true ) false) , c =  1 }.b) , b = ({a = true , b = 0 }.a) }.b) }.a) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] (if (fix (\x: Bool . (((\x: Bool .\y: Rec X. X .y) true ) true) )) then ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) else (case <l = (unfold [ Nat ] (fold [ Unit ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y)) ))
(( \f: Bool .((f ({a = (((\x: Rec X. X .\y: Unit .x) (pred 1) ) false) , b = (let u = (fix (\x: Nat . 1 )) in true) , c =  (fix (\x: Rec X. X . 0 )) }.b) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) , b = ({a = ({a = false , b = (if true then false else true) }.b) , b = (let u = 0 in 0) }.b) }.a) ) ) (\a: Rec X. X .\b: Nat .a))
(if ({a = (fix (\x: Unit . (let u = 0 in u) )) , b = (((\x: Rec X. X .\y: Unit .y) ({a = 1 , b = true }.b) ) (fix (\x: Rec X. X . false ))) , c =  (let u = ({a = 0 , b = false }.a) in ({a = (iszero 1) , b = (fix (\x: Bool . 0 )) }.b)) }.b) then (if (fix (\x: Rec X. X . (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) )) then (if ({a = true , b = 0 }.a) then (fix (\x: Rec X. X . 1 )) else (let u = true in ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )))) else (case <l = (succ (if true then 1 else 1)) > as Unit of < l = x > => x | < r = y > => y)) else (((\x: Rec X. X .\y: Bool .x) (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ) (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .x) (if false then true else true) ) ({a = 0 , b = false , c =  0 }.b)) ))))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (unfold [ Unit ] (fold [ Unit ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) )) , b = (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f false ) (if true then false else false) ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = true , b = true }.b)) }.a) ))
({a = (( \f: Unit .((f (let u = (((\x: Nat .\y: Bool .y) false ) 0) in u) ) (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Nat .x) 0 ) ({a = 1 , b = false , c =  0 }.b)) ) (let u = (if false then true else false) in u)) ) ) (\a: Nat .\b: Nat .a)) , b = (fix (\x: Nat . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true )) )) }.a)
(if (( \f: Nat .((f (( \f: Unit .((f (let u = true in u) ) (((\x: Rec X. X .\y: Nat .y) true ) true) ) ) (\a: Nat .\b: Nat .b)) ) (let u = false in u) ) ) (\a: Bool .\b: Unit .b)) then (succ (fix (\x: Rec X. X . 0 ))) else (let u = (if (let u = true in ({a = false , b = false }.b)) then (unfold [ Nat ] (fold [ Unit ] 1 )) else (if true then 1 else 1)) in (unfold [ Unit ] (fold [ Nat ] ({a = (fix (\x: Nat . 0 )) , b = true }.a) ))))
(let u = (succ (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = false , c = 1 }.c) ))) in (let u = (fix (\x: Bool . (let u = 0 in u) )) in (let u = ({a = true , b = 0 }.a) in u)))
(let u = (let u = (let u = (iszero 0) in (if true then false else false)) in (fix (\x: Nat . true ))) in (fix (\x: Bool . (let u = (((\x: Unit .\y: Unit .x) 0 ) false) in (let u = 0 in false)) )))
(case <l = ({a = (let u = (let u = 1 in u) in u) , b = (case <r = ({a = true , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = (if false then 1 else 1) in ({a = false , b = 1 }.b)) )) , b = (( \f: Bool .((f (((\x: Nat .\y: Bool .y) true ) false) ) (let u = ({a = 1 , b = false }.b) in u) ) ) (\a: Nat .\b: Rec X. X .b)) }.a)
(let u = ({a = (( \f: Nat .((f ({a = 1 , b = ({a = true , b = 0 }.a) , c =  1 }.b) ) (if true then false else true) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = true , c =  1 }.b) }.b) in u)
(( \f: Bool .((f (((\x: Unit .\y: Unit .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] 0 )) )) ) (((\x: Unit .\y: Unit .y) (iszero 0) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y))) ) (let u = (( \f: Bool .((f (fix (\x: Nat . 0 )) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Bool .a)) in (let u = (((\x: Rec X. X .\y: Nat .y) true ) 1) in 0)) ) ) (\a: Unit .\b: Rec X. X .a))
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 1 in 1) )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero ({a = 1 , b = false , c = 1 }.c)) )) }.a)
({a = (let u = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . false )) }.a) in (let u = (let u = (let u = true in true) in (let u = false in 0)) in ({a = (succ 0) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false )) }.b))) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (succ 0) )) , b = ({a = true , b = true }.b) , c =  (((\x: Nat .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] true )) ) 0) }.b) }.b)
(( \f: Unit .((f ({a = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Bool .x) (unfold [ Unit ] (fold [ Nat ] false )) ) false) ) (iszero ({a = 0 , b = false }.a))) , b = (((\x: Bool .\y: Nat .y) ({a = ({a = true , b = 1 }.b) , b = (fix (\x: Nat . true )) }.b) ) (unfold [ Bool ] (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] 0 )) ))) }.a) ) (iszero (if ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = true }.b) then ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) )) else (let u = ({a = true , b = true }.b) in 1))) ) ) (\a: Bool .\b: Rec X. X .a))
(( \f: Nat .((f (succ (if ({a = 1 , b = true }.b) then ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) else (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)))) ) ({a = (let u = (((\x: Rec X. X .\y: Nat .y) false ) 0) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) , b = (let u = ({a = 0 , b = false , c = 1 }.c) in (let u = 1 in u)) }.b) ) ) (\a: Rec X. X .\b: Bool .a))
({a = (fix (\x: Nat . ({a = ({a = 1 , b = false , c = 0 }.c) , b = (fix (\x: Rec X. X . true )) }.a) )) , b = (if (( \f: Bool .((f (let u = 1 in false) ) (let u = (succ 0) in false) ) ) (\a: Nat .\b: Unit .b)) then ({a = (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = true , c = 0 }.c) ) false) , b = (( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] false )) ) (let u = 1 in true) ) ) (\a: Nat .\b: Unit .b)) }.b) else (((\x: Bool .\y: Rec X. X .y) ({a = 0 , b = true , c =  0 }.b) ) (if true then true else false))) }.b)
(((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) )) ) (( \f: Bool .((f ({a = 0 , b = ({a = 0 , b = 1 }.b) }.b) ) (let u = 1 in 1) ) ) (\a: Nat .\b: Rec X. X .a))) ) (let u = (let u = (((\x: Rec X. X .\y: Bool .y) true ) true) in u) in ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = false , c =  1 }.b) ))))
(let u = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .y) (let u = false in false) ) ({a = 1 , b = false , c = 1 }.c)) )) , b = ({a = (case <l = ({a = 1 , b = true , c = 1 }.c) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (succ 0) in false) , c = (succ (let u = 1 in (unfold [ Nat ] (fold [ Bool ] 0 )))) }.c) }.b) in (if ({a = ({a = 1 , b = true }.a) , b = ({a = false , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b) then (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (if (let u = true in true) then true else (iszero 0)) )) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (iszero 1) }.b) ) ) (\a: Nat .\b: Unit .b)) else ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) }.b) ))))
(( \f: Bool .((f (if (( \f: Rec X. X .((f (let u = (let u = false in u) in u) ) (((\x: Bool .\y: Bool .y) true ) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a))) ) ) (\a: Rec X. X .\b: Bool .b)) then ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = false }.a) , b = (let u = 1 in u) }.b) else (( \f: Nat .((f (let u = (((\x: Nat .\y: Nat .y) false ) 1) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 ))) ) (((\x: Bool .\y: Bool .y) (if false then true else true) ) 0) ) ) (\a: Nat .\b: Rec X. X .b))) ) ({a = (case <l = ({a = (( \f: Nat .((f 1 ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) }.a) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Nat . ({a = 0 , b = true , c =  1 }.b) )) )) , b = (let u = true in u) }.b) }.a) ) ) (\a: Nat .\b: Unit .b))
(case <r = ({a = (( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Rec X. X .y) false ) 0) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) ) (let u = false in u) ) ) (\a: Unit .\b: Nat .b)) , b = (( \f: Bool .((f (if false then 0 else (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b))) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) )) ) ) (\a: Unit .\b: Bool .a)) }.a) > as Unit of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Nat ] (case <l = (if ({a = false , b = true }.b) then (pred 0) else (((\x: Nat .\y: Rec X. X .y) false ) 1)) > as Nat of < l = x > => x | < r = y > => y) ))
(((\x: Bool .\y: Nat .y) (iszero (let u = (( \f: Nat .((f 0 ) (pred 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u)) ) (((\x: Unit .\y: Unit .x) (fix (\x: Nat . ({a = false , b = false }.b) )) ) ({a = (fix (\x: Bool . true )) , b = (if false then 0 else 1) }.a)))
({a = ({a = (let u = (let u = 1 in 1) in ({a = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .b)) , b = (((\x: Unit .\y: Unit .x) false ) true) }.b)) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.a) , b = (((\x: Bool .\y: Rec X. X .y) ({a = true , b = true }.b) ) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .b)) }.b)) }.b)
(( \f: Nat .((f (let u = (let u = ({a = false , b = 1 }.a) in (unfold [ Bool ] (fold [ Bool ] true ))) in ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = false , b = 0 }.b) }.b)) ) ({a = (let u = (iszero 1) in ({a = (let u = 1 in 0) , b = ({a = 0 , b = false , c =  1 }.b) }.b)) , b = ({a = ({a = false , b = 0 }.b) , b = (iszero 0) }.a) }.b) ) ) (\a: Rec X. X .\b: Nat .b))
(pred (fix (\x: Nat . ({a = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) (let u = 0 in u) ) ) (\a: Unit .\b: Unit .a)) , b = (fix (\x: Nat . 0 )) }.b) )))
({a = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (let u = 0 in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) )) , b = (fix (\x: Nat . 0 )) }.a) , b = (( \f: Nat .((f (unfold [ Bool ] (fold [ Unit ] (let u = 1 in u) )) ) (pred 1) ) ) (\a: Unit .\b: Bool .a)) }.b)
(let u = (( \f: Rec X. X .((f (let u = (fix (\x: Rec X. X . 1 )) in false) ) ({a = ({a = false , b = 0 }.b) , b = false , c =  ({a = 0 , b = false , c = 0 }.c) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) in (((\x: Nat .\y: Unit .y) ({a = (iszero 1) , b = (if false then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) else ({a = true , b = true }.b)) }.b) ) (((\x: Unit .\y: Nat .x) (((\x: Unit .\y: Unit .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) false) ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)))))
(fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (pred 1) )) ) (pred 0) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) true) , b = (let u = (let u = 0 in false) in ({a = false , b = 1 }.b)) }.a)) ))
(case <r = ({a = (((\x: Rec X. X .\y: Bool .y) (let u = (iszero 1) in u) ) (let u = 1 in u)) , b = (let u = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .b)) in (if false then true else (iszero 1))) , c =  (fix (\x: Bool . (pred 1) )) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(if (case <r = (let u = (if true then true else false) in (((\x: Bool .\y: Nat .x) true ) true)) > as Unit of < l = x > => x | < r = y > => y) then ({a = (case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = false in 0) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (let u = 1 in (((\x: Unit .\y: Bool .x) false ) false)) , b = (((\x: Bool .\y: Bool .y) ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = false , c =  ({a = 1 , b = 1 }.b) }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) }.b) }.a) else (((\x: Rec X. X .\y: Unit .x) ({a = 0 , b = (if false then 0 else 0) }.b) ) (let u = (((\x: Rec X. X .\y: Unit .x) (let u = 1 in true) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) in u)))
(pred (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Nat .((f (if true then 1 else 0) ) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = false }.a) ) ) (\a: Nat .\b: Bool .a)) )))
(let u = (fix (\x: Bool . (((\x: Bool .\y: Nat .x) false ) true) )) in ({a = (fix (\x: Bool . (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) )) )) , b = (iszero ({a = 1 , b = 1 }.b)) }.a))
({a = (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Nat ] true )) ) (let u = (let u = false in false) in false)) ) (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in ({a = false , b = false }.b))) , b = (((\x: Unit .\y: Rec X. X .x) ({a = (((\x: Bool .\y: Bool .x) 1 ) true) , b = (let u = (fix (\x: Bool . 1 )) in u) }.b) ) (unfold [ Bool ] (fold [ Bool ] (let u = 1 in false) ))) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = ({a = ({a = true , b = 1 }.a) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) in (let u = true in u)) , b = (let u = (( \f: Nat .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .a)) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) }.b) ))
(succ (( \f: Unit .((f (pred (fix (\x: Nat . 0 ))) ) (( \f: Nat .((f (let u = true in 1) ) (fix (\x: Nat . 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .a)))
({a = (let u = ({a = (let u = ({a = false , b = true }.b) in (succ 0)) , b = ({a = false , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.b) }.a) in ({a = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) 0) , b = (fix (\x: Unit . true )) , c = (let u = 0 in u) }.c)) , b = ({a = (if ({a = true , b = 1 }.a) then ({a = (let u = 0 in false) , b = 0 }.b) else (let u = (succ 1) in ({a = true , b = 0 }.b))) , b = ({a = (let u = (let u = true in u) in u) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) )) }.b) }.b) }.b)
(((\x: Rec X. X .\y: Nat .y) ({a = (if false then (case <r = false > as Unit of < l = x > => x | < r = y > => y) else true) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true )) in ({a = false , b = 1 }.a)) }.b) ) (((\x: Unit .\y: Nat .y) (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) > as Unit of < l = x > => x | < r = y > => y) ) (case <r = (if (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) then false else false) > as Rec X. X of < l = x > => x | < r = y > => y)))
(unfold [ Nat ] (fold [ Unit ] (iszero (pred ({a = ({a = 1 , b = false , c =  1 }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) }.b))) ))
(iszero (unfold [ Nat ] (fold [ Nat ] (let u = (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 1) > as Rec X. X of < l = x > => x | < r = y > => y) in u) )))
(let u = (case <r = ({a = (( \f: Unit .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (if (let u = 0 in false) then (unfold [ Rec X. X ] (fold [ Nat ] false )) else false) ) ) (\a: Nat .\b: Unit .a)) , b = (iszero ({a = ({a = true , b = 0 }.b) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) , c = 0 }.c)) }.b) > as Unit of < l = x > => x | < r = y > => y) in (let u = (succ ({a = ({a = 1 , b = false }.a) , b = (case <l = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) }.b)) in (unfold [ Rec X. X ] (fold [ Unit ] (case <r = (let u = 0 in false) > as Nat of < l = x > => x | < r = y > => y) ))))
(let u = (( \f: Unit .((f (iszero (let u = ({a = 1 , b = true , c = 1 }.c) in u)) ) (let u = (iszero ({a = 0 , b = false }.a)) in u) ) ) (\a: Unit .\b: Bool .b)) in u)
(fix (\x: Rec X. X . ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a)) , b = (if true then 1 else (let u = 0 in 1)) }.a) ))
({a = ({a = (if (let u = (((\x: Unit .\y: Unit .y) false ) false) in (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b))) then (let u = 0 in true) else (fix (\x: Bool . true ))) , b = (succ (fix (\x: Unit . 0 ))) }.b) , b = (let u = (((\x: Bool .\y: Rec X. X .x) (((\x: Bool .\y: Unit .x) true ) (let u = 1 in false)) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .b))) in ({a = (let u = 1 in 0) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in true) )) , c =  ({a = true , b = 0 }.b) }.b)) }.b)
(if (((\x: Bool .\y: Unit .y) ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 0 in false) , c =  (let u = 1 in 0) }.b) ) (let u = (succ 0) in (( \f: Unit .((f false ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Unit .\b: Bool .b)))) then (unfold [ Unit ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (if false then true else true) )) )) else (if (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) true ) false) )) then (case <r = ({a = 0 , b = true , c =  1 }.b) > as Nat of < l = x > => x | < r = y > => y) else (unfold [ Rec X. X ] (fold [ Unit ] (if false then false else false) ))))
(( \f: Bool .((f (iszero (((\x: Nat .\y: Bool .y) true ) 1)) ) (( \f: Bool .((f (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in (let u = (((\x: Unit .\y: Unit .x) false ) false) in true)) ) (iszero (case <l = (((\x: Nat .\y: Rec X. X .y) true ) 1) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = ({a = (( \f: Nat .((f ({a = (fix (\x: Unit . 1 )) , b = (unfold [ Bool ] (fold [ Unit ] true )) , c = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.c) ) (let u = 1 in (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = true in (let u = true in false)) )) ) (iszero ({a = 0 , b = 1 }.b)) ) ) (\a: Nat .\b: Unit .b)) }.a) , b = (let u = (( \f: Nat .((f (pred 1) ) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = (iszero 1) }.a) ) ) (\a: Nat .\b: Nat .b)) in ({a = ({a = (((\x: Rec X. X .\y: Unit .x) 1 ) true) , b = ({a = false , b = 0 }.b) }.b) , b = (case <r = (fix (\x: Unit . false )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) , c =  (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Unit .x) ({a = 0 , b = false , c =  1 }.b) ) true) ) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .a))) ) ({a = (succ (fix (\x: Nat . 0 ))) , b = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] 1 )) )) , b = (( \f: Rec X. X .((f (let u = true in u) ) ({a = 0 , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .b)) , c = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) ) (unfold [ Unit ] (fold [ Nat ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.c) }.b)) }.b)
(((\x: Bool .\y: Unit .x) ({a = (let u = (((\x: Nat .\y: Nat .y) false ) 1) in (unfold [ Nat ] (fold [ Rec X. X ] false ))) , b = (let u = (( \f: Unit .((f (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Nat .b)) in u) }.b) ) (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = true , b = 1 }.b) )) in ({a = (let u = true in 1) , b = ({a = false , b = 1 }.a) }.b)))
(if (unfold [ Bool ] (fold [ Unit ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) )) then (( \f: Bool .((f (( \f: Nat .((f (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) true ) false) ) false ) ) (\a: Bool .\b: Unit .b)) ) (iszero (let u = 1 in u)) ) ) (\a: Nat .\b: Bool .a)) ) (let u = ({a = ({a = 0 , b = false }.b) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) in (fix (\x: Rec X. X . (((\x: Unit .\y: Nat .y) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) (((\x: Nat .\y: Bool .y) false ) false)) ))) ) ) (\a: Nat .\b: Rec X. X .a)) else (( \f: Nat .((f (( \f: Bool .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = (let u = 0 in false) in false) ) ) (\a: Unit .\b: Unit .a)) ) (let u = (((\x: Bool .\y: Bool .y) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) in u) ) ) (\a: Unit .\b: Bool .b)))
(let u = (let u = (( \f: Rec X. X .((f (let u = 1 in false) ) ({a = true , b = 0 }.a) ) ) (\a: Rec X. X .\b: Unit .b)) in u) in u)
(( \f: Nat .((f (let u = (iszero (let u = (let u = true in u) in ({a = 0 , b = 0 }.b))) in u) ) (((\x: Rec X. X .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = false , c =  1 }.b) )) ) ({a = (( \f: Nat .((f ({a = 1 , b = true }.a) ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = ({a = false , b = 0 }.a) }.b)) ) ) (\a: Unit .\b: Unit .b))
(( \f: Bool .((f (((\x: Bool .\y: Nat .y) (let u = (if false then 1 else 1) in (let u = false in u)) ) (let u = (fix (\x: Nat . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) )) in (pred (let u = 1 in u)))) ) (pred (let u = ({a = 0 , b = 1 }.b) in u)) ) ) (\a: Rec X. X .\b: Bool .b))
(( \f: Unit .((f (fix (\x: Rec X. X . ({a = ({a = true , b = 1 }.a) , b = (( \f: Bool .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Bool ] true )) ) ) (\a: Unit .\b: Bool .b)) }.b) )) ) ({a = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Nat . (iszero 1) )) ) (((\x: Unit .\y: Unit .y) (iszero 1) ) (if false then false else true))) , b = (( \f: Rec X. X .((f false ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Nat .\b: Nat .a)) }.b) ) ) (\a: Unit .\b: Nat .b))
(let u = (let u = ({a = (let u = ({a = 1 , b = true }.a) in u) , b = (let u = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .a)) in (let u = 0 in false)) , c = (((\x: Unit .\y: Rec X. X .x) 0 ) ({a = true , b = false }.b)) }.c) in (( \f: Bool .((f (let u = 0 in u) ) (((\x: Nat .\y: Bool .y) true ) 0) ) ) (\a: Rec X. X .\b: Bool .b))) in ({a = (iszero (succ 1)) , b = ({a = 0 , b = ({a = 0 , b = true , c =  0 }.b) , c = (pred 0) }.c) }.a))
(((\x: Unit .\y: Rec X. X .x) (let u = (((\x: Nat .\y: Bool .x) (( \f: Bool .((f true ) (if false then true else false) ) ) (\a: Bool .\b: Nat .b)) ) (( \f: Nat .((f ({a = 1 , b = true , c =  1 }.b) ) ({a = true , b = true }.b) ) ) (\a: Rec X. X .\b: Nat .a))) in u) ) (if ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = true in u) )) then ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .b)) }.b) else (case <r = false > as Unit of < l = x > => x | < r = y > => y)))
(((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) (( \f: Unit .((f ({a = 0 , b = false , c =  1 }.b) ) false ) ) (\a: Unit .\b: Unit .b)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false ))) )) ) (case <r = (let u = (fix (\x: Bool . (iszero ({a = 0 , b = false }.a)) )) in u) > as Nat of < l = x > => x | < r = y > => y))
(if ({a = (let u = (((\x: Unit .\y: Bool .y) false ) false) in (case <l = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (let u = (let u = (let u = 0 in false) in u) in u) , c =  ({a = (fix (\x: Rec X. X . 1 )) , b = ({a = 1 , b = false , c =  1 }.b) }.a) }.b) then ({a = ({a = (let u = (iszero 1) in (let u = (iszero 0) in 1)) , b = ({a = (if true then 0 else 0) , b = true , c =  (let u = true in 1) }.b) }.a) , b = (( \f: Nat .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (iszero 0) )) ) ) (\a: Nat .\b: Bool .b)) }.a) else ({a = (((\x: Nat .\y: Nat .x) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = ({a = 0 , b = true , c =  1 }.b) , c = (let u = 0 in u) }.c) ) (let u = 0 in false)) , b = (((\x: Nat .\y: Nat .y) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) ) (if false then false else false)) }.a))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Rec X. X . ({a = ({a = ({a = false , b = true }.b) , b = 0 }.a) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) }.b) )) ))
(succ (fix (\x: Rec X. X . (pred (if (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) then 0 else 0)) )))
(((\x: Bool .\y: Unit .x) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = (succ 1) in u) )) in u) ) (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = ({a = true , b = false }.b) in true) )) > as Bool of < l = x > => x | < r = y > => y))
({a = (fix (\x: Bool . (pred (((\x: Rec X. X .\y: Unit .y) true ) 1)) )) , b = (let u = (let u = ({a = 0 , b = false , c =  0 }.b) in (fix (\x: Unit . false ))) in (iszero (let u = 1 in u))) , c =  ({a = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Rec X. X . (succ 1) )) )) , b = (iszero (( \f: Bool .((f (pred (fix (\x: Bool . 0 ))) ) (if false then ({a = 0 , b = true }.a) else (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Bool .b))) , c = (( \f: Unit .((f (succ (let u = 1 in u)) ) ({a = 0 , b = (let u = false in u) }.a) ) ) (\a: Nat .\b: Bool .b)) }.c) }.b)
(((\x: Unit .\y: Unit .y) (let u = ({a = 0 , b = (((\x: Unit .\y: Bool .y) false ) true) , c =  0 }.b) in (fix (\x: Nat . ({a = 1 , b = false }.b) ))) ) (( \f: Bool .((f (let u = (succ 0) in ({a = false , b = false }.b)) ) (let u = (let u = 1 in 0) in false) ) ) (\a: Bool .\b: Rec X. X .b)))
(let u = ({a = (unfold [ Bool ] (fold [ Bool ] (succ (let u = 0 in u)) )) , b = (( \f: Rec X. X .((f ({a = true , b = false }.b) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .b)) , c = ({a = ({a = true , b = ({a = 0 , b = true , c =  1 }.b) }.b) , b = (let u = 0 in u) }.b) }.c) in (( \f: Nat .((f ({a = (case <r = (if false then false else false) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Bool .y) true ) (unfold [ Nat ] (fold [ Nat ] true ))) }.b) ) ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = 0 in u) )) }.b) ) ) (\a: Nat .\b: Bool .a)))
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) ({a = ({a = (let u = 0 in 0) , b = (succ (pred 1)) }.b) , b = (((\x: Unit .\y: Bool .x) (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) ) (fix (\x: Rec X. X . false ))) }.b) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) in ({a = 0 , b = true , c =  0 }.b))) ) (case <l = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = (((\x: Unit .\y: Rec X. X .x) true ) true) }.a) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a))
(fix (\x: Nat . ({a = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Unit .x) (let u = true in true) ) ({a = 0 , b = true }.b)) }.b) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = (let u = false in u) }.a) }.b) ))
({a = ({a = (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Unit .y) false ) 1) )) , b = (((\x: Bool .\y: Nat .y) ({a = 1 , b = (iszero 1) }.b) ) ({a = 0 , b = false }.b)) , c =  ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.b) , b = (let u = (((\x: Nat .\y: Unit .y) false ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a))) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) }.b)
(let u = (((\x: Nat .\y: Nat .y) (( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .x) true ) false) )) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = (unfold [ Unit ] (fold [ Rec X. X ] false )) , b = ({a = 1 , b = false }.a) }.b)) in (fix (\x: Unit . ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = false , c = ({a = 0 , b = false , c = 0 }.c) }.c) )))
({a = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) ({a = (let u = 0 in 0) , b = (let u = true in u) }.b) ) (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in 1)) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] (pred 1) )) }.b)
(pred ({a = (let u = 1 in (let u = 1 in u)) , b = (( \f: Unit .((f (( \f: Bool .((f false ) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) ) (\a: Nat .\b: Bool .a)) ) (if ({a = true , b = 0 }.a) then ({a = false , b = 0 }.a) else (let u = false in u)) ) ) (\a: Bool .\b: Bool .b)) }.a))
({a = (pred (let u = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in (succ 0)) in u)) , b = (if ({a = ({a = (fix (\x: Bool . 0 )) , b = (let u = true in true) }.a) , b = (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Unit ] false )) )) , c =  ({a = (let u = false in 1) , b = ({a = 0 , b = false , c = 0 }.c) }.b) }.b) then ({a = (succ 0) , b = (fix (\x: Nat . true )) }.b) else (let u = ({a = 1 , b = true }.b) in u)) }.a)
(( \f: Nat .((f (let u = (succ (fix (\x: Unit . 0 ))) in u) ) (((\x: Unit .\y: Rec X. X .x) (let u = ({a = (iszero (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) , b = ({a = false , b = (if false then 1 else 1) }.b) }.b) in u) ) (let u = (iszero 1) in u)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (let u = ({a = 1 , b = true , c =  0 }.b) in u) , b = ({a = (fix (\x: Nat . 1 )) , b = (iszero 0) }.b) }.b) ))
(let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in ({a = 0 , b = 1 }.b)) )) in ({a = (((\x: Nat .\y: Unit .y) (fix (\x: Rec X. X . (let u = 1 in false) )) ) (( \f: Rec X. X .((f (let u = 1 in u) ) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = ({a = 0 , b = false }.b) , c = 0 }.c) ) ) (\a: Bool .\b: Unit .b))) , b = ({a = ({a = (let u = (if false then 0 else 0) in (let u = true in 0)) , b = (( \f: Nat .((f (fix (\x: Bool . true )) ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) , b = (succ ({a = 0 , b = false , c = 0 }.c)) }.b) }.b))
(if (case <r = (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (if false then 1 else ({a = 0 , b = true }.a)) , b = ({a = 1 , b = false }.b) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) then ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) in u) )) )) else (succ (((\x: Nat .\y: Rec X. X .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ({a = (let u = 0 in u) , b = (iszero 0) , c = 0 }.c))))
({a = (pred (let u = ({a = false , b = 1 }.a) in (let u = 0 in u))) , b = (case <r = ({a = (iszero (fix (\x: Bool . 1 ))) , b = (iszero 0) }.b) > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = (((\x: Rec X. X .\y: Bool .y) (iszero (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) ) (fix (\x: Unit . (case <r = true > as Nat of < l = x > => x | < r = y > => y) ))) in (( \f: Rec X. X .((f ({a = (let u = true in 1) , b = false }.a) ) (let u = false in (fix (\x: Unit . 1 ))) ) ) (\a: Bool .\b: Unit .a))) }.b)
(if (let u = ({a = (let u = (((\x: Nat .\y: Nat .x) 1 ) true) in ({a = 0 , b = 1 }.b)) , b = (let u = ({a = false , b = false }.b) in 0) }.b) in ({a = (fix (\x: Bool . ({a = (let u = true in false) , b = true }.b) )) , b = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = (fix (\x: Bool . true )) }.b) }.b)) then (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) )) )) else (unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = (let u = false in false) }.a) , b = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.a) )))
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (let u = 1 in u) in u) )) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) ({a = 1 , b = (let u = false in true) , c =  1 }.b) ) ({a = (succ 1) , b = (let u = 1 in false) , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b)) ))
(((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f ({a = (((\x: Unit .\y: Nat .x) (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .a)) )) ) (unfold [ Nat ] (fold [ Bool ] false ))) , b = (let u = (iszero 1) in (((\x: Nat .\y: Unit .x) false ) false)) }.b) ) (if ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f true ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Unit .a)) )) then ({a = (succ 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.b) else (let u = ({a = 1 , b = false , c = 0 }.c) in (fix (\x: Unit . (if true then true else true) )))) ) ) (\a: Unit .\b: Nat .b)) ) (unfold [ Unit ] (fold [ Bool ] (let u = (unfold [ Bool ] (fold [ Nat ] false )) in (let u = true in 0)) )))
(iszero (case <l = (((\x: Unit .\y: Rec X. X .y) ({a = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = 0 }.a) ) (( \f: Bool .((f (pred 0) ) 1 ) ) (\a: Unit .\b: Bool .b))) > as Bool of < l = x > => x | < r = y > => y))
(let u = (let u = ({a = (if true then false else false) , b = (let u = true in u) }.b) in u) in u)
(unfold [ Bool ] (fold [ Bool ] ({a = (( \f: Rec X. X .((f (pred 1) ) ({a = 1 , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (fix (\x: Rec X. X . (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.b) ))
((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (pred (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) )) ))
({a = ({a = (( \f: Nat .((f ({a = 0 , b = false }.a) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = true }.a) )) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (fix (\x: Bool . ({a = true , b = 1 }.b) )) , b = ({a = (let u = 1 in true) , b = (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) then true else (let u = true in true)) }.b) }.b) }.a) , b = (fix (\x: Nat . (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .b)) )) }.b)
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) )) ))
(( \f: Nat .((f (let u = (if (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) then (let u = (((\x: Bool .\y: Unit .x) 0 ) true) in u) else (pred (((\x: Rec X. X .\y: Nat .x) 1 ) false))) in ({a = (if ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )) then (let u = 1 in u) else (let u = 1 in 1)) , b = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.b)) ) (( \f: Unit .((f ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = (iszero (fix (\x: Rec X. X . 0 ))) , c = ({a = 1 , b = ({a = 0 , b = false }.a) }.b) }.c) , b = (unfold [ Bool ] (fold [ Unit ] true )) , c = (succ (let u = true in 1)) }.c) ) ({a = (if false then false else true) , b = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false }.a) }.b) }.b) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Unit .a))
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = (fix (\x: Bool . (((\x: Bool .\y: Nat .y) (let u = 0 in false) ) false) )) in (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) )) ))) ))
(fix (\x: Rec X. X . (( \f: Nat .((f (if (fix (\x: Bool . (((\x: Unit .\y: Bool .x) true ) true) )) then ({a = 0 , b = true }.b) else ({a = false , b = true }.b)) ) (unfold [ Bool ] (fold [ Nat ] false )) ) ) (\a: Bool .\b: Unit .a)) ))
(unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f (let u = (let u = 0 in 1) in u) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (succ 1) )) ) ) (\a: Nat .\b: Nat .a)) ))
(pred (( \f: Bool .((f ({a = ({a = 0 , b = false , c =  0 }.b) , b = (pred 0) }.b) ) (case <l = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = (let u = 1 in 0) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)))
({a = ({a = (((\x: Unit .\y: Nat .x) (let u = true in u) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = (if ({a = ({a = 1 , b = false , c =  1 }.b) , b = (let u = 1 in u) }.a) then (let u = 1 in u) else (let u = 1 in 1)) , b = ({a = true , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) }.b) , c =  ({a = 0 , b = ({a = 1 , b = 0 }.b) }.b) }.b) }.b) , b = (((\x: Rec X. X .\y: Nat .x) (iszero (let u = (((\x: Bool .\y: Nat .x) 1 ) false) in u)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = false in u) ))) }.b)
({a = (succ (((\x: Nat .\y: Rec X. X .x) 0 ) true)) , b = (let u = (( \f: Nat .((f true ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Nat .a)) in (( \f: Unit .((f (fix (\x: Unit . 1 )) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Bool .\b: Rec X. X .b))) }.b)
(unfold [ Rec X. X ] (fold [ Nat ] ({a = (( \f: Bool .((f (let u = false in 1) ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = ({a = (succ 0) , b = ({a = ({a = 1 , b = true , c = 0 }.c) , b = true }.b) }.a) }.b) ))
(( \f: Bool .((f (let u = (( \f: Unit .((f ({a = 1 , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .a)) , c =  (((\x: Nat .\y: Unit .x) 0 ) true) }.b) ) (let u = ({a = true , b = 0 }.a) in u) ) ) (\a: Nat .\b: Unit .b)) in (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) false ) (((\x: Unit .\y: Nat .x) true ) true)) ))) ) (case <r = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = (let u = 0 in false) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a))
(let u = (succ (let u = ({a = (if true then 1 else 1) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) in (let u = true in (if false then 0 else 0)))) in (((\x: Nat .\y: Rec X. X .y) ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .b)) }.b) ) (if false then 0 else 0)))
(((\x: Unit .\y: Rec X. X .x) (let u = (if (let u = true in false) then ({a = 1 , b = true , c = (succ 1) }.c) else (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) in 0)) in u) ) ({a = (let u = false in 0) , b = ({a = ({a = 0 , b = false }.b) , b = (fix (\x: Nat . true )) }.b) , c =  (let u = (let u = false in u) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 ))) }.b))
(((\x: Bool .\y: Unit .y) (let u = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Rec X. X . 0 )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) ))) ) (succ ({a = 0 , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .b)) }.a)))
(if (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Unit . (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) )) then (( \f: Bool .((f (( \f: Rec X. X .((f ({a = false , b = (let u = false in false) }.b) ) ({a = 1 , b = ({a = 1 , b = false , c =  1 }.b) }.b) ) ) (\a: Unit .\b: Nat .a)) ) (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = false , c =  0 }.b) )) ) ) (\a: Nat .\b: Bool .b)) else (case <r = (( \f: Bool .((f (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f ({a = ({a = (let u = true in u) , b = (succ (succ 0)) }.a) , b = (( \f: Nat .((f (( \f: Bool .((f true ) (let u = false in true) ) ) (\a: Nat .\b: Nat .a)) ) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Nat .\b: Bool .a)) }.b) ) (let u = ({a = (pred 0) , b = (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Nat .y) (let u = false in false) ) (let u = 1 in u)) ) ({a = false , b = 0 }.a)) }.b) in ({a = (if (let u = 0 in true) then (unfold [ Nat ] (fold [ Bool ] 0 )) else (if (let u = 1 in false) then 1 else 0)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) )) , c =  ({a = (let u = true in false) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.b) }.b)) ) ) (\a: Bool .\b: Nat .a))
(let u = (pred ({a = ({a = true , b = true }.b) , b = 0 }.b)) in ({a = (if false then ({a = true , b = 1 }.b) else 0) , b = (((\x: Rec X. X .\y: Rec X. X .x) (pred 0) ) false) }.b))
({a = (fix (\x: Nat . (let u = (unfold [ Rec X. X ] (fold [ Unit ] (iszero 0) )) in ({a = 1 , b = true , c = 0 }.c)) )) , b = ({a = ({a = (((\x: Nat .\y: Rec X. X .x) (if true then 0 else 1) ) ({a = false , b = 0 }.a)) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , c =  (succ ({a = 1 , b = true }.a)) }.b) , b = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) )) in (unfold [ Nat ] (fold [ Unit ] 1 ))) }.a) , c = (if ({a = (let u = false in u) , b = (if (iszero 1) then (if false then (pred 0) else 1) else ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = true , c = 1 }.c) ))) }.a) then (((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Rec X. X .x) false ) (iszero 1)) ) (succ 0)) else ({a = (( \f: Unit .((f 1 ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Unit .y) false ) true) }.a)) }.c)
(case <r = ({a = (fix (\x: Rec X. X . (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) false ) 0) ) (fix (\x: Unit . 1 )) ) ) (\a: Rec X. X .\b: Bool .a)) )) , b = (if (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .a)) )) then ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) else (((\x: Bool .\y: Rec X. X .y) false ) true)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Bool .((f ({a = (pred ({a = 1 , b = 0 }.b)) , b = ({a = ({a = (((\x: Unit .\y: Nat .y) true ) (if true then 0 else 0)) , b = (fix (\x: Nat . true )) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b) , b = (fix (\x: Rec X. X . ({a = true , b = 1 }.a) )) }.b) , c = (((\x: Rec X. X .\y: Unit .y) (let u = (let u = 1 in u) in (unfold [ Unit ] (fold [ Nat ] true ))) ) (succ (succ 0))) }.c) ) (let u = (( \f: Nat .((f ({a = 0 , b = (fix (\x: Rec X. X . false )) , c =  1 }.b) ) (((\x: Nat .\y: Nat .x) false ) false) ) ) (\a: Nat .\b: Unit .a)) in (( \f: Unit .((f (let u = 1 in 1) ) (let u = 0 in u) ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Rec X. X .b))
(iszero (pred (( \f: Rec X. X .((f (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .y) false ) 1) ) (if false then 1 else 1) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) }.b) ) ) (\a: Unit .\b: Rec X. X .b))))
(fix (\x: Nat . (let u = (( \f: Nat .((f ({a = 1 , b = false }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) in (((\x: Nat .\y: Rec X. X .y) (if false then true else false) ) ({a = true , b = 0 }.a))) ))
(succ (let u = (let u = 0 in 1) in u))
(let u = ({a = (( \f: Unit .((f ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = (let u = 1 in 1) }.b) ) ({a = ({a = 1 , b = (((\x: Unit .\y: Unit .y) false ) true) }.a) , b = ({a = true , b = false }.b) }.a) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (if (if false then false else true) then ({a = true , b = 1 }.a) else (((\x: Unit .\y: Bool .x) (let u = 0 in false) ) (let u = false in u))) }.a) in u)
(let u = (let u = (succ (let u = ({a = false , b = 1 }.b) in 1)) in ({a = (( \f: Nat .((f ({a = 0 , b = true , c = 1 }.c) ) (let u = true in (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) ) ) (\a: Bool .\b: Bool .b)) , b = (fix (\x: Rec X. X . false )) }.a)) in u)
(( \f: Nat .((f (( \f: Rec X. X .((f (let u = true in false) ) (((\x: Rec X. X .\y: Rec X. X .x) ({a = (((\x: Bool .\y: Nat .y) true ) true) , b = (iszero 0) }.b) ) (((\x: Unit .\y: Rec X. X .y) true ) true)) ) ) (\a: Nat .\b: Bool .b)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .y) (iszero 1) ) (iszero 1)) )) ) ) (\a: Bool .\b: Nat .a))
(((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .y) ({a = ({a = false , b = 0 }.a) , b = ({a = (( \f: Nat .((f (((\x: Nat .\y: Unit .x) 1 ) false) ) (let u = false in 0) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = 0 , b = true , c = 1 }.c) }.b) }.a) ) (( \f: Unit .((f (fix (\x: Unit . 0 )) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Bool .\b: Bool .b))) ) (let u = (( \f: Bool .((f (if false then (let u = 1 in true) else ({a = 0 , b = true , c =  0 }.b)) ) ({a = (((\x: Unit .\y: Bool .x) false ) true) , b = (fix (\x: Rec X. X . false )) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) in u))
({a = (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .y) true ) false) )) , b = ({a = ({a = 0 , b = 0 }.b) , b = (let u = (unfold [ Bool ] (fold [ Nat ] false )) in ({a = 0 , b = 0 }.b)) }.b) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] (pred ({a = ({a = true , b = false }.b) , b = (succ (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) }.b)) ))
(if (let u = (case <r = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) in u) then (unfold [ Nat ] (fold [ Unit ] (let u = (( \f: Nat .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) true ) ) (\a: Bool .\b: Nat .b)) in u) )) else ({a = ({a = (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) ) true) , b = (iszero (let u = 1 in u)) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.b) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false )) ) ({a = 0 , b = false , c = 0 }.c)) )) }.a))
({a = (unfold [ Unit ] (fold [ Bool ] (let u = false in 0) )) , b = (( \f: Bool .((f ({a = (((\x: Nat .\y: Nat .y) false ) false) , b = ({a = (pred 1) , b = 0 }.b) }.a) ) ({a = (let u = 1 in 0) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) , c =  (pred ({a = (let u = false in 1) , b = (iszero 0) , c = (succ 1) }.c)) }.b)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .x) (case <r = ({a = 0 , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .b)) , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = 1 }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (fix (\x: Unit . true )) , c =  (case <l = (((\x: Rec X. X .\y: Nat .x) 1 ) false) > as Unit of < l = x > => x | < r = y > => y) }.b)) ))
(succ ({a = (((\x: Unit .\y: Nat .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (( \f: Nat .((f 1 ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Bool .a))) , b = ({a = ({a = false , b = 1 }.b) , b = ({a = true , b = 1 }.a) }.b) , c = (let u = (if (((\x: Rec X. X .\y: Rec X. X .y) false ) false) then (pred 1) else ({a = (if false then 0 else 0) , b = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) , c = (unfold [ Bool ] (fold [ Unit ] 1 )) }.c)) in (pred (((\x: Unit .\y: Nat .x) (succ 0) ) true))) }.c))
(let u = (if ({a = 0 , b = true }.b) then (fix (\x: Nat . ({a = 1 , b = true , c = (let u = false in 1) }.c) )) else (fix (\x: Rec X. X . (if (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) then 0 else 0) ))) in (let u = (( \f: Bool .((f ({a = false , b = 0 }.a) ) false ) ) (\a: Unit .\b: Rec X. X .a)) in (((\x: Rec X. X .\y: Nat .y) (unfold [ Unit ] (fold [ Bool ] true )) ) (((\x: Nat .\y: Nat .y) true ) true))))
(let u = (let u = (let u = (let u = (succ 0) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) in (( \f: Unit .((f (((\x: Bool .\y: Nat .y) false ) true) ) true ) ) (\a: Unit .\b: Nat .b))) in u) in ({a = (unfold [ Bool ] (fold [ Unit ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) )) , b = (((\x: Bool .\y: Unit .y) false ) true) , c = ({a = 1 , b = ({a = true , b = 1 }.b) }.b) }.c))
({a = (let u = ({a = ({a = 1 , b = true , c =  1 }.b) , b = (((\x: Nat .\y: Rec X. X .y) false ) 0) }.a) in u) , b = (fix (\x: Nat . (let u = (succ 1) in (((\x: Nat .\y: Bool .y) ({a = true , b = false }.b) ) (succ 0))) )) }.a)
(case <r = (if (let u = ({a = ({a = true , b = 0 }.a) , b = (unfold [ Unit ] (fold [ Nat ] false )) }.b) in u) then ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = (unfold [ Unit ] (fold [ Unit ] true )) }.b) else (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Rec X. X .((f (if false then true else true) ) (((\x: Rec X. X .\y: Rec X. X .x) (let u = false in u) ) false) ) ) (\a: Unit .\b: Bool .b)) ))) > as Bool of < l = x > => x | < r = y > => y)
({a = (iszero ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = (let u = true in 1) }.b)) , b = (succ ({a = ({a = 0 , b = 0 }.b) , b = ({a = 0 , b = true }.b) , c = ({a = (unfold [ Unit ] (fold [ Bool ] true )) , b = 1 }.b) }.c)) }.a)
(let u = (( \f: Unit .((f (let u = (case <l = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) > as Bool of < l = x > => x | < r = y > => y) in u) ) (let u = ({a = (if true then 1 else ({a = false , b = 0 }.b)) , b = (( \f: Bool .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) in u) ) ) (\a: Rec X. X .\b: Unit .b)) in u)
({a = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) in u)) ) (if (let u = false in u) then (pred 1) else (succ 1)) ) ) (\a: Nat .\b: Nat .a)) , b = (fix (\x: Bool . (let u = (let u = (let u = false in 1) in u) in (iszero 1)) )) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (if ({a = ({a = false , b = false }.b) , b = (let u = 0 in u) }.a) then (((\x: Nat .\y: Bool .x) true ) true) else (( \f: Bool .((f ({a = 0 , b = false }.b) ) ({a = true , b = false }.b) ) ) (\a: Unit .\b: Unit .a))) ))
(succ ({a = (((\x: Nat .\y: Nat .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (iszero 1)) , b = (((\x: Bool .\y: Rec X. X .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = true , b = 1 }.a)) , c = (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) false ) 0) ) (if true then 0 else 0) ) ) (\a: Rec X. X .\b: Bool .a)) }.c))
(let u = (let u = (((\x: Rec X. X .\y: Bool .y) ({a = false , b = true }.b) ) (let u = 0 in 0)) in (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Unit .y) false ) true) ) ({a = true , b = 1 }.a))) in (((\x: Bool .\y: Unit .x) (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in u) ) (unfold [ Nat ] (fold [ Unit ] (if false then true else true) ))))
(let u = (if (iszero ({a = 1 , b = true , c = 0 }.c)) then ({a = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .a)) , b = (let u = 0 in 1) }.b) else (( \f: Unit .((f (((\x: Nat .\y: Unit .x) (if true then 0 else 1) ) false) ) (succ 1) ) ) (\a: Unit .\b: Unit .b))) in u)
(( \f: Nat .((f ({a = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero 0) )) in u) , b = (( \f: Rec X. X .((f (pred (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) ) (case <l = (let u = 0 in 0) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) }.a) ) (fix (\x: Bool . ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) )) )) ) ) (\a: Bool .\b: Nat .a))
(( \f: Unit .((f (let u = (let u = (((\x: Bool .\y: Rec X. X .x) true ) true) in u) in (((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Rec X. X .y) (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Nat .\y: Bool .y) false ) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .a)))) ) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] true )) )) in ({a = 0 , b = false , c = 1 }.c)))) ) ({a = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Rec X. X . true )) ) (((\x: Nat .\y: Nat .x) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) ({a = 1 , b = true }.b))) , b = (((\x: Nat .\y: Rec X. X .y) (let u = 1 in false) ) ({a = (((\x: Bool .\y: Unit .x) (pred 0) ) false) , b = (if ({a = false , b = 1 }.a) then false else false) , c = (if false then (unfold [ Unit ] (fold [ Nat ] 1 )) else ({a = 0 , b = true }.a)) }.c)) }.b) ) ) (\a: Nat .\b: Bool .b))
(case <l = (succ (( \f: Rec X. X .((f (( \f: Nat .((f (fix (\x: Unit . 1 )) ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .a))) > as Unit of < l = x > => x | < r = y > => y)
(unfold [ Bool ] (fold [ Nat ] ({a = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = 0 }.b) , b = (if (let u = false in u) then false else true) , c =  (case <l = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) > as Unit of < l = x > => x | < r = y > => y) }.b) ))
({a = ({a = (unfold [ Nat ] (fold [ Bool ] ({a = false , b = 1 }.b) )) , b = ({a = false , b = (((\x: Nat .\y: Rec X. X .x) 1 ) false) }.b) }.b) , b = (case <r = ({a = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Bool .\y: Nat .y) false ) false) }.b) > as Unit of < l = x > => x | < r = y > => y) , c = ({a = (fix (\x: Bool . ({a = 1 , b = false , c = 0 }.c) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = false , c =  0 }.b) , b = 1 }.a) )) , c = ({a = ({a = 1 , b = 1 }.b) , b = (fix (\x: Unit . false )) }.a) }.c) }.c)
(pred (if (fix (\x: Bool . (((\x: Bool .\y: Bool .x) (let u = true in u) ) (if true then false else true)) )) then (let u = (succ 0) in u) else (( \f: Rec X. X .((f ({a = ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , b = 1 }.a) , b = (unfold [ Bool ] (fold [ Rec X. X ] (if false then 0 else 0) )) }.b) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) ) ) (\a: Unit .\b: Unit .b))))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = true , b = (let u = 0 in true) }.b) , b = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = false , c =  0 }.b)) }.b) ))
(iszero (pred (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Bool .y) false ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) ) (fix (\x: Nat . ({a = true , b = 0 }.b) )))))
(succ (((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Nat .y) (let u = false in u) ) (let u = true in 0)) ) ({a = (let u = false in 0) , b = (( \f: Nat .((f (let u = true in u) ) false ) ) (\a: Unit .\b: Unit .a)) }.b)))
(let u = ({a = (((\x: Bool .\y: Unit .x) (((\x: Nat .\y: Bool .x) 0 ) (fix (\x: Bool . true ))) ) (unfold [ Bool ] (fold [ Nat ] false ))) , b = (iszero ({a = (fix (\x: Rec X. X . 1 )) , b = ({a = false , b = 1 }.a) }.a)) , c = (let u = (let u = 1 in true) in (succ (succ 0))) }.c) in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) (let u = false in 1) ) false) )))
(let u = (iszero (if (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) then (succ (pred 0)) else ({a = 1 , b = false , c = 1 }.c))) in (fix (\x: Bool . (fix (\x: Nat . 1 )) )))
(((\x: Unit .\y: Unit .x) (if (let u = ({a = false , b = 0 }.a) in u) then (let u = 0 in 0) else (let u = (( \f: Nat .((f 1 ) (let u = true in 0) ) ) (\a: Bool .\b: Nat .b)) in (pred 0))) ) (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f false ) (let u = false in true) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = false , b = false }.b)) ) ({a = (fix (\x: Rec X. X . false )) , b = (if (if true then true else false) then (unfold [ Nat ] (fold [ Unit ] 1 )) else 0) }.a) ) ) (\a: Bool .\b: Rec X. X .a)))
({a = ({a = (if (let u = true in true) then (( \f: Unit .((f ({a = 1 , b = false , c =  0 }.b) ) true ) ) (\a: Unit .\b: Bool .b)) else (fix (\x: Bool . ({a = 1 , b = true }.b) ))) , b = (succ (let u = 1 in u)) }.b) , b = (if (iszero (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) in 0)) then (let u = true in (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .b))) else (let u = false in (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)))) }.b)
(let u = (succ (let u = ({a = 1 , b = false , c = 1 }.c) in u)) in (let u = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (fix (\x: Rec X. X . 0 )) else ({a = 0 , b = true }.a)) in u))
({a = (let u = (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) (iszero 0) ) ) (\a: Bool .\b: Bool .b)) in (let u = (((\x: Unit .\y: Unit .x) true ) true) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] false )))) , b = (pred (let u = true in (unfold [ Unit ] (fold [ Bool ] 0 )))) }.b)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (case <l = (succ (let u = false in 1)) > as Rec X. X of < l = x > => x | < r = y > => y) in u) ))
(let u = (let u = (iszero ({a = 1 , b = false }.a)) in ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (if true then 0 else (let u = 0 in u)) }.b)) in (let u = ({a = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in (if (((\x: Rec X. X .\y: Bool .x) false ) true) then (unfold [ Unit ] (fold [ Rec X. X ] false )) else true)) , b = (unfold [ Nat ] (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) }.b) in u))
({a = (if (let u = ({a = 1 , b = false , c =  1 }.b) in ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = false }.b)) then (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) false ) ) (\a: Nat .\b: Rec X. X .b)) else (unfold [ Bool ] (fold [ Bool ] (let u = false in false) ))) , b = (succ (unfold [ Rec X. X ] (fold [ Bool ] (succ 0) ))) }.a)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .y) (fix (\x: Unit . (let u = true in true) )) ) (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) true ) false) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Rec X. X .a))) ))
({a = (let u = (if (let u = true in u) then false else true) in (pred (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)))) , b = (((\x: Rec X. X .\y: Nat .y) ({a = (fix (\x: Bool . true )) , b = (let u = false in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) true)) }.b)
(((\x: Bool .\y: Unit .x) (if (((\x: Bool .\y: Nat .x) (let u = true in true) ) (((\x: Unit .\y: Bool .x) true ) false)) then ({a = (if false then 0 else 1) , b = true , c =  0 }.b) else (iszero (succ 1))) ) (fix (\x: Unit . (unfold [ Nat ] (fold [ Bool ] false )) )))
(let u = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero ({a = 0 , b = false }.a)) )) in (let u = ({a = (iszero (pred 1)) , b = ({a = true , b = 0 }.a) }.b) in (let u = ({a = 0 , b = true , c = 0 }.c) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false ))))) in u)
(( \f: Bool .((f (if (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) in (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) (iszero 1))) then (( \f: Bool .((f (let u = (succ 1) in (let u = 0 in true)) ) (let u = (if true then true else true) in ({a = 0 , b = (let u = 0 in false) , c =  (let u = 1 in u) }.b)) ) ) (\a: Rec X. X .\b: Unit .a)) else (( \f: Nat .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Bool .a))) ) (if ({a = ({a = false , b = 0 }.b) , b = true }.b) then (let u = false in u) else ({a = 0 , b = false , c =  (pred 1) }.b)) ) ) (\a: Unit .\b: Rec X. X .b))
(succ (fix (\x: Unit . ({a = (fix (\x: Nat . 1 )) , b = (iszero 1) , c = (((\x: Bool .\y: Rec X. X .y) false ) 1) }.c) )))
(let u = ({a = (succ ({a = false , b = 1 }.b)) , b = (let u = ({a = (iszero 0) , b = (fix (\x: Unit . 0 )) }.a) in u) }.b) in (if (let u = (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) (let u = 1 in u) ) ) (\a: Bool .\b: Nat .b)) ) (((\x: Nat .\y: Rec X. X .x) 0 ) (((\x: Bool .\y: Bool .x) true ) true)) ) ) (\a: Bool .\b: Nat .b)) in ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) true ) true) , c =  0 }.b)) then (pred (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in u)) else ({a = (let u = 1 in 1) , b = (pred 1) }.b)))
(((\x: Nat .\y: Unit .x) ({a = (let u = ({a = 0 , b = false , c =  0 }.b) in (let u = 0 in u)) , b = ({a = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = false , c =  1 }.b) , b = (fix (\x: Unit . true )) }.b) }.b) ) (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) false ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) ) (let u = ({a = 1 , b = 1 }.b) in (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) ) ) (\a: Nat .\b: Unit .a)))
(( \f: Nat .((f (if (fix (\x: Nat . ({a = 1 , b = true }.b) )) then (((\x: Nat .\y: Nat .y) ({a = 1 , b = true }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) else ({a = 0 , b = true }.a)) ) ({a = (let u = (( \f: Rec X. X .((f 1 ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Nat .\b: Nat .b)) in u) , b = (let u = ({a = 1 , b = false }.a) in (( \f: Nat .((f (let u = 0 in 0) ) ({a = false , b = 1 }.b) ) ) (\a: Nat .\b: Rec X. X .a))) }.b) ) ) (\a: Unit .\b: Rec X. X .b))
(((\x: Nat .\y: Nat .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Unit .((f ({a = 0 , b = (let u = false in true) }.b) ) (((\x: Nat .\y: Nat .y) ({a = true , b = 0 }.a) ) (unfold [ Bool ] (fold [ Unit ] true ))) ) ) (\a: Rec X. X .\b: Unit .a)) )) )) ) (unfold [ Unit ] (fold [ Rec X. X ] (if ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f true ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .b)) )) then (let u = (((\x: Rec X. X .\y: Nat .x) true ) (unfold [ Nat ] (fold [ Nat ] false ))) in u) else (((\x: Bool .\y: Nat .x) ({a = 1 , b = false , c =  1 }.b) ) false)) )))
(let u = (let u = ({a = (fix (\x: Unit . 1 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .a)) }.a) in (pred (succ (((\x: Nat .\y: Bool .x) 0 ) false)))) in (((\x: Nat .\y: Unit .x) (let u = (let u = 0 in true) in (( \f: Unit .((f (let u = true in u) ) true ) ) (\a: Nat .\b: Rec X. X .b))) ) (case <r = (( \f: Nat .((f (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) false ) ) (\a: Bool .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y)))
({a = ({a = (if ({a = true , b = true }.b) then false else true) , b = (case <l = (((\x: Unit .\y: Rec X. X .y) false ) 1) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = ({a = ({a = ({a = 1 , b = ({a = 1 , b = false }.b) }.a) , b = (pred 1) }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) )) )) }.b) }.b)
({a = ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Nat .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) true) }.b) , b = (((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .a)) ) ({a = 0 , b = false }.b)) ) ({a = (fix (\x: Unit . 0 )) , b = (let u = 1 in true) , c =  ({a = 1 , b = 1 }.b) }.b)) }.b)
({a = (( \f: Bool .((f (let u = (let u = (fix (\x: Bool . false )) in 1) in u) ) ({a = (let u = 1 in false) , b = (if true then 1 else 0) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = ({a = (( \f: Bool .((f (((\x: Unit .\y: Unit .x) 1 ) true) ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = 0 in false) , c = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.c) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Nat . true )) )) , c =  (( \f: Nat .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) (fix (\x: Unit . ({a = 1 , b = true , c = 1 }.c) )) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) }.b)
(fix (\x: Bool . (( \f: Rec X. X .((f ({a = (fix (\x: Unit . 0 )) , b = (((\x: Nat .\y: Nat .x) true ) true) , c = ({a = true , b = 1 }.b) }.c) ) (case <l = ({a = 1 , b = true }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ))
(let u = (let u = ({a = (succ (let u = 0 in u)) , b = ({a = 0 , b = (((\x: Nat .\y: Unit .x) true ) false) }.b) , c =  ({a = ({a = 0 , b = false , c =  0 }.b) , b = (((\x: Nat .\y: Nat .y) false ) 1) }.b) }.b) in (succ (unfold [ Nat ] (fold [ Rec X. X ] 1 )))) in (let u = (( \f: Rec X. X .((f ({a = 1 , b = ({a = true , b = 1 }.a) , c =  (succ 1) }.b) ) (((\x: Rec X. X .\y: Unit .y) true ) false) ) ) (\a: Unit .\b: Unit .a)) in u))
(((\x: Unit .\y: Unit .x) (if ({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Nat .x) 1 ) false)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) }.b) then (((\x: Nat .\y: Nat .x) (succ 0) ) (fix (\x: Nat . false ))) else ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = true }.a)) ) ({a = (( \f: Unit .((f ({a = (succ 1) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , c =  ({a = 0 , b = false }.a) }.b) ) (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) , b = (case <l = (fix (\x: Bool . 1 )) > as Unit of < l = x > => x | < r = y > => y) }.a))
({a = ({a = (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) (((\x: Bool .\y: Bool .y) true ) true)) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in ({a = (if false then 0 else 1) , b = ({a = 1 , b = true , c =  0 }.b) }.a)) }.a) , b = (fix (\x: Rec X. X . (if (iszero 1) then (let u = 0 in false) else (fix (\x: Nat . true ))) )) }.b)
({a = ({a = (((\x: Unit .\y: Bool .y) false ) (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) , b = ({a = ({a = 1 , b = 0 }.b) , b = ({a = true , b = 1 }.a) , c =  1 }.b) , c =  (fix (\x: Rec X. X . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) }.b) , b = ({a = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) )) , b = (((\x: Unit .\y: Unit .x) 1 ) false) }.b) , b = (let u = (let u = true in 1) in (let u = false in u)) }.b) }.b)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (let u = false in u) in (case <l = ({a = false , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y)) ))
(let u = ({a = (unfold [ Unit ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) )) , b = (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Rec X. X .x) 0 ) false) )) }.b) in (if (let u = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) in (let u = 1 in (unfold [ Bool ] (fold [ Bool ] true )))) then (case <l = (let u = false in 0) > as Rec X. X of < l = x > => x | < r = y > => y) else (case <l = (fix (\x: Unit . 0 )) > as Nat of < l = x > => x | < r = y > => y)))
({a = (if (((\x: Unit .\y: Bool .x) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) false) then (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) (((\x: Rec X. X .\y: Unit .y) false ) false) ) ) (\a: Bool .\b: Nat .a)) else (let u = (fix (\x: Nat . true )) in (let u = 1 in true))) , b = (pred ({a = (( \f: Bool .((f (case <l = (if false then 0 else 0) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .y) true ) ({a = false , b = 0 }.b)) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) , b = ({a = 1 , b = (((\x: Nat .\y: Rec X. X .y) false ) true) }.a) }.a) }.a)) }.a)
(((\x: Rec X. X .\y: Bool .y) (fix (\x: Rec X. X . (case <r = (((\x: Unit .\y: Nat .y) true ) (unfold [ Nat ] (fold [ Nat ] false ))) > as Unit of < l = x > => x | < r = y > => y) )) ) (fix (\x: Rec X. X . (let u = ({a = (iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 ))) , b = (if true then 1 else 0) }.a) in ({a = (if false then 1 else 1) , b = true }.a)) )))
(let u = (let u = (iszero (let u = 1 in u)) in (( \f: Unit .((f (unfold [ Nat ] (fold [ Nat ] true )) ) ({a = 0 , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , c =  0 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))) in u)
({a = (((\x: Unit .\y: Bool .x) ({a = (unfold [ Unit ] (fold [ Bool ] (if false then 1 else 0) )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) }.b) ) (fix (\x: Unit . (if (( \f: Unit .((f (let u = true in true) ) (let u = true in false) ) ) (\a: Unit .\b: Bool .b)) then (if false then true else false) else (fix (\x: Unit . (((\x: Unit .\y: Nat .y) true ) true) ))) ))) , b = (((\x: Nat .\y: Unit .x) (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) ) (((\x: Nat .\y: Bool .x) ({a = 0 , b = false }.b) ) (let u = true in false))) }.a)
({a = (if (fix (\x: Unit . (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) )) then (pred (if false then 0 else 0)) else (( \f: Nat .((f (((\x: Nat .\y: Nat .y) true ) 0) ) (if (let u = true in true) then 0 else ({a = 1 , b = 1 }.b)) ) ) (\a: Nat .\b: Nat .a))) , b = (if (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) in u) then (succ (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) (iszero 0))) else ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (if false then true else true) )) , b = (case <l = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) }.b)) }.b)
(let u = (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Rec X. X .y) ({a = (let u = false in u) , b = ({a = false , b = 1 }.a) }.b) ) (((\x: Rec X. X .\y: Unit .x) true ) false)) ) (case <r = (if false then (((\x: Bool .\y: Nat .x) false ) true) else (((\x: Unit .\y: Nat .x) false ) false)) > as Bool of < l = x > => x | < r = y > => y)) in u)
(((\x: Bool .\y: Nat .x) (pred (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false }.a) ))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.b) ) (( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] true )) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Bool .a))) )))
(let u = (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .x) (((\x: Bool .\y: Nat .y) true ) 0) ) (if (fix (\x: Nat . true )) then ({a = false , b = 1 }.a) else false)) ) ({a = (fix (\x: Rec X. X . (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = ({a = true , b = (((\x: Unit .\y: Unit .x) 0 ) false) }.a) }.a) ) ) (\a: Nat .\b: Unit .a)) in (if (let u = true in true) then (((\x: Unit .\y: Rec X. X .x) 1 ) (iszero 0)) else (let u = (pred 1) in u)))
(let u = (fix (\x: Nat . (let u = (let u = true in false) in u) )) in (pred ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = (iszero 1) }.a)))
(if (( \f: Unit .((f ({a = ({a = 0 , b = false }.b) , b = ({a = true , b = 1 }.b) }.a) ) ({a = (let u = false in false) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.a) ) ) (\a: Nat .\b: Bool .b)) then (case <r = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y) else (case <r = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b) > as Nat of < l = x > => x | < r = y > => y))
(fix (\x: Rec X. X . ({a = (succ ({a = 0 , b = true , c = 0 }.c)) , b = (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (if (let u = 1 in (fix (\x: Unit . true ))) then (((\x: Unit .\y: Unit .x) true ) true) else (let u = 0 in true)) ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (if (((\x: Unit .\y: Bool .y) (fix (\x: Nat . false )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) then (let u = false in 1) else (let u = ({a = 0 , b = false }.a) in u)) }.b) ))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (if (let u = 0 in true) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) else (unfold [ Bool ] (fold [ Unit ] 1 ))) )) in ({a = (let u = 1 in u) , b = (unfold [ Nat ] (fold [ Unit ] 0 )) }.b)) ))
({a = (( \f: Unit .((f (((\x: Bool .\y: Nat .y) (iszero 0) ) (((\x: Unit .\y: Rec X. X .y) true ) false)) ) ({a = (let u = false in false) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (fix (\x: Unit . (let u = (if (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) then (((\x: Unit .\y: Nat .y) true ) 0) else 1) in (fix (\x: Rec X. X . (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ))) )) }.a)
(((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (case <r = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) )) ) ({a = (let u = false in u) , b = (( \f: Nat .((f true ) (((\x: Nat .\y: Rec X. X .x) true ) false) ) ) (\a: Nat .\b: Nat .a)) }.b))
(((\x: Bool .\y: Nat .x) (iszero ({a = (( \f: Nat .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .b)) , b = (if true then (let u = false in 1) else 1) }.b)) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Unit .\b: Bool .a)) }.b))
(if (if (let u = ({a = (let u = 1 in u) , b = (fix (\x: Unit . (if false then false else false) )) }.a) in (( \f: Rec X. X .((f (if (let u = 1 in false) then true else false) ) (if false then true else true) ) ) (\a: Rec X. X .\b: Unit .a))) then (((\x: Nat .\y: Unit .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 0 , b = true , c =  0 }.b) )) ) ({a = (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (if false then 1 else 1) else 0) , b = (let u = true in true) , c =  ({a = 0 , b = 0 }.b) }.b)) else (case <r = ({a = 1 , b = true , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y)) then (( \f: Rec X. X .((f (if false then 0 else (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a))) ) ({a = (fix (\x: Unit . 0 )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) }.a) ) ) (\a: Rec X. X .\b: Nat .b)) else (((\x: Unit .\y: Unit .y) (( \f: Unit .((f false ) (((\x: Unit .\y: Bool .x) true ) false) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = 0 , b = false }.a)))
({a = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) (let u = 0 in 1) ) (if true then true else true)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = 1 , b = false }.a) in u) )) ) ) (\a: Bool .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Nat .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = 0 }.b) , b = (let u = false in u) , c =  (if (((\x: Nat .\y: Unit .y) true ) true) then 0 else ({a = 1 , b = 0 }.b)) }.b) )) ) ({a = (succ 1) , b = ({a = true , b = false }.b) }.b)) , c =  (let u = (succ ({a = true , b = 1 }.b)) in u) }.b)
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .x) (let u = ({a = (let u = 0 in 1) , b = (fix (\x: Unit . 0 )) }.b) in u) ) (((\x: Unit .\y: Rec X. X .y) (let u = ({a = 1 , b = false , c =  1 }.b) in u) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) false ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) in u))) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .x) (fix (\x: Bool . true )) ) ({a = true , b = 0 }.a)) )) ))
({a = ({a = (((\x: Unit .\y: Bool .y) (( \f: Unit .((f ({a = false , b = true }.b) ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = 1 in (succ 0))) , b = ({a = (((\x: Rec X. X .\y: Bool .y) (let u = ({a = 0 , b = false }.b) in u) ) (let u = 0 in true)) , b = (let u = (let u = true in u) in (let u = 1 in 1)) }.a) , c =  (( \f: Rec X. X .((f (let u = false in 1) ) ({a = 0 , b = 1 }.b) ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (pred (pred (if true then ({a = 1 , b = true , c = 1 }.c) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 ))))) }.a)
(succ ({a = (let u = (iszero (fix (\x: Bool . 0 ))) in u) , b = (let u = (( \f: Rec X. X .((f (iszero 1) ) false ) ) (\a: Bool .\b: Unit .b)) in (let u = 1 in 0)) }.b))
(let u = (case <r = (let u = (fix (\x: Unit . (((\x: Unit .\y: Unit .y) false ) true) )) in u) > as Nat of < l = x > => x | < r = y > => y) in (case <r = (unfold [ Bool ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] false )) )) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Rec X. X .y) (if ({a = ({a = 0 , b = false }.a) , b = false }.b) then (if false then (fix (\x: Nat . true )) else (let u = true in u)) else (fix (\x: Nat . ({a = 1 , b = true , c =  1 }.b) ))) ) (let u = (fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = 1 }.a) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = false , c = 1 }.c) }.a)) )) in ({a = (pred 1) , b = ({a = true , b = false }.b) }.a)))
(let u = (( \f: Nat .((f ({a = (( \f: Rec X. X .((f ({a = 0 , b = ({a = 1 , b = true }.a) }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) ) (\a: Bool .\b: Unit .b)) , b = (fix (\x: Rec X. X . (pred 0) )) }.b) ) (((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Bool .\y: Nat .y) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) ) 1)) ) ) (\a: Rec X. X .\b: Bool .b)) in ({a = (((\x: Nat .\y: Bool .x) ({a = 1 , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) in u)) , b = (pred 0) }.b))
(((\x: Bool .\y: Nat .x) (if (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (if true then false else false) }.b) )) then (( \f: Rec X. X .((f (let u = false in true) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) else (let u = (let u = false in u) in (case <r = ({a = 1 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y))) ) ({a = (let u = (let u = 1 in (let u = false in 0)) in u) , b = (let u = (case <r = (let u = true in true) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Bool .((f ({a = false , b = false }.b) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a))) }.b))
(iszero (if (( \f: Rec X. X .((f ({a = false , b = ({a = true , b = false }.b) }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) ) ) (\a: Unit .\b: Unit .a)) then (((\x: Nat .\y: Unit .y) ({a = (let u = true in u) , b = (let u = 0 in false) }.b) ) ({a = 1 , b = ({a = 0 , b = true }.b) }.a)) else (((\x: Nat .\y: Rec X. X .x) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (if false then (iszero 1) else (((\x: Rec X. X .\y: Unit .y) false ) false)) , c = (( \f: Nat .((f ({a = 1 , b = true , c = 0 }.c) ) (let u = false in 1) ) ) (\a: Rec X. X .\b: Nat .b)) }.c) ) (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .b)) in (iszero 1)))))
({a = ({a = ({a = 0 , b = false }.a) , b = ({a = (succ 1) , b = true }.b) }.a) , b = (let u = (let u = false in u) in u) , c = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Unit . (let u = false in 1) )) ) (((\x: Unit .\y: Unit .y) true ) true)) }.c)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Bool .((f false ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Nat .\b: Unit .a)) )) ))
(let u = (case <l = (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = 1 , b = true }.a) in u) ) (if (let u = false in u) then true else false)) > as Bool of < l = x > => x | < r = y > => y) in (let u = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = 0 , b = false , c =  1 }.b) ) (((\x: Bool .\y: Unit .x) false ) false) ) ) (\a: Unit .\b: Nat .a)) )) in u))
(( \f: Rec X. X .((f (let u = (case <l = (if (fix (\x: Bool . true )) then ({a = 0 , b = false , c = 0 }.c) else 0) > as Nat of < l = x > => x | < r = y > => y) in (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = 0 in true) )) ))) ) (if ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (let u = false in (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a))) )) then (( \f: Nat .((f (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) ({a = true , b = 0 }.a) ) ) (\a: Bool .\b: Bool .a)) else (((\x: Bool .\y: Rec X. X .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = ({a = 0 , b = false , c =  1 }.b) }.b))) ) ) (\a: Unit .\b: Nat .b))
(( \f: Unit .((f (succ ({a = (((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .x) 0 ) false) ) (if true then false else true)) , b = (let u = ({a = 0 , b = false }.b) in u) }.a)) ) (( \f: Rec X. X .((f ({a = (let u = false in false) , b = ({a = 0 , b = true }.a) }.b) ) (( \f: Bool .((f ({a = (if false then 1 else 0) , b = (pred 0) }.b) ) (fix (\x: Nat . (((\x: Bool .\y: Unit .x) 1 ) false) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .b))
(( \f: Rec X. X .((f (case <r = (if ({a = 1 , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) , c =  ({a = 0 , b = 0 }.b) }.b) then (iszero (let u = 1 in 0)) else ({a = (let u = false in 1) , b = (let u = ({a = false , b = true }.b) in u) , c =  (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Rec X. X . 0 )) )) }.b)) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) in (iszero 0)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) ) ) (\a: Bool .\b: Bool .a))
(let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (let u = ({a = true , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) }.b) in ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = (fix (\x: Unit . true )) }.a)) , b = (if false then false else false) , c = (fix (\x: Unit . (fix (\x: Rec X. X . ({a = 0 , b = true }.a) )) )) }.c) )) in u)
(unfold [ Bool ] (fold [ Rec X. X ] (let u = (((\x: Bool .\y: Unit .y) (fix (\x: Rec X. X . false )) ) ({a = false , b = 1 }.a)) in u) ))
(iszero (let u = (let u = (( \f: Rec X. X .((f true ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Rec X. X .\b: Unit .b)) in u) in (pred 0)))
(let u = (let u = (pred (unfold [ Nat ] (fold [ Nat ] 0 ))) in u) in ({a = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) , b = ({a = (let u = false in 1) , b = 0 }.b) }.a) , b = (let u = (((\x: Unit .\y: Rec X. X .x) true ) false) in u) }.b))
({a = (if ({a = (let u = ({a = 0 , b = false }.a) in u) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .b)) , c =  (((\x: Bool .\y: Bool .y) (iszero 0) ) (((\x: Bool .\y: Bool .x) 1 ) true)) }.b) then (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) (let u = 0 in true) ) true) ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Bool .a)) else (( \f: Nat .((f (case <r = (fix (\x: Nat . true )) > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Rec X. X .b))) , b = (let u = (succ (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) 0 ) true) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) ) (\a: Unit .\b: Rec X. X .a))) in (succ (pred 0))) }.b)
({a = (if ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) then (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (case <l = ({a = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) else (pred (let u = (let u = 0 in 1) in 0))) , b = ({a = (let u = (case <l = (if true then 0 else 0) > as Unit of < l = x > => x | < r = y > => y) in u) , b = (((\x: Nat .\y: Nat .x) (let u = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)) in false) ) ({a = 0 , b = false , c =  0 }.b)) }.a) }.b)
(let u = (( \f: Unit .((f (unfold [ Bool ] (fold [ Nat ] ({a = false , b = true }.b) )) ) (if (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) true ) false) ) false ) ) (\a: Rec X. X .\b: Bool .b)) then (((\x: Rec X. X .\y: Nat .y) false ) true) else (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) ) (\a: Rec X. X .\b: Nat .b)) in (((\x: Nat .\y: Nat .x) (iszero (let u = 1 in u)) ) (let u = (((\x: Bool .\y: Nat .y) true ) false) in (((\x: Unit .\y: Rec X. X .x) true ) false))))
({a = (((\x: Bool .\y: Rec X. X .x) (let u = ({a = true , b = 1 }.a) in ({a = false , b = true }.b)) ) (let u = (((\x: Nat .\y: Bool .x) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = true , b = true }.b)) in u)) , b = (((\x: Rec X. X .\y: Bool .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = false in (unfold [ Rec X. X ] (fold [ Nat ] 0 ))) )) ) ({a = (fix (\x: Nat . true )) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.a)) }.a)
({a = ({a = (unfold [ Nat ] (fold [ Bool ] (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in (let u = 0 in 0)) )) , b = (( \f: Rec X. X .((f false ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .b)) }.a) , b = (( \f: Bool .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (let u = (let u = 1 in u) in (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in false)) ) ) (\a: Nat .\b: Unit .b)) }.b)
(let u = (( \f: Nat .((f (fix (\x: Unit . (let u = 0 in (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) )) ) (let u = (((\x: Bool .\y: Bool .y) ({a = 1 , b = false , c =  0 }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b))) ) ) (\a: Unit .\b: Rec X. X .b)) in (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , b = false }.b) )) ) (fix (\x: Rec X. X . (((\x: Bool .\y: Unit .y) true ) true) )) ) ) (\a: Rec X. X .\b: Bool .a)))
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (pred ({a = ({a = false , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (unfold [ Nat ] (fold [ Unit ] (let u = 1 in 0) )) }.b)) ))
(( \f: Unit .((f (( \f: Nat .((f (if (if (((\x: Nat .\y: Bool .y) false ) false) then false else (let u = 1 in false)) then ({a = (((\x: Bool .\y: Bool .y) false ) false) , b = 1 }.a) else (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) false ) ) (\a: Nat .\b: Nat .b))) ) (let u = 1 in (unfold [ Bool ] (fold [ Unit ] true ))) ) ) (\a: Nat .\b: Bool .b)) ) ({a = (if (let u = true in u) then (let u = (let u = false in u) in u) else (iszero (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)))) , b = (if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) then false else (let u = 1 in false)) }.b) ) ) (\a: Nat .\b: Unit .b))
(((\x: Bool .\y: Rec X. X .y) ({a = (if (iszero 1) then (succ 1) else ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) , b = (if (((\x: Nat .\y: Unit .x) false ) false) then (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) else ({a = false , b = false }.b)) , c =  ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) }.b) ) (pred (let u = ({a = 0 , b = true }.a) in 1)))
(((\x: Rec X. X .\y: Nat .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .x) (case <l = (fix (\x: Rec X. X . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . false ))) )) ) (unfold [ Unit ] (fold [ Unit ] (case <r = (let u = true in false) > as Nat of < l = x > => x | < r = y > => y) )))
(let u = (let u = (let u = (let u = false in 0) in ({a = true , b = 1 }.b)) in (if (iszero 1) then (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .a)) else (let u = true in false))) in (fix (\x: Nat . ({a = (fix (\x: Rec X. X . false )) , b = (let u = false in u) }.b) )))
(pred (succ (let u = (((\x: Rec X. X .\y: Bool .x) 0 ) false) in (pred 0))))
(pred (((\x: Nat .\y: Bool .y) (let u = 1 in true) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))))
(iszero (pred (let u = (let u = false in true) in (let u = 0 in 1))))
(let u = (succ (let u = (pred 0) in (let u = false in 0))) in (case <r = (let u = ({a = (let u = 0 in 1) , b = (fix (\x: Rec X. X . true )) , c = (((\x: Unit .\y: Bool .x) 0 ) true) }.c) in (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) true ) ({a = false , b = 0 }.a)) ) (unfold [ Nat ] (fold [ Nat ] false )) ) ) (\a: Nat .\b: Nat .b))) > as Bool of < l = x > => x | < r = y > => y))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Unit ] (iszero 0) )) ) (iszero (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) ) (succ 0) ) ) (\a: Bool .\b: Bool .b)))) )) , b = ({a = ({a = (case <r = ({a = ({a = 0 , b = false , c =  0 }.b) , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) in (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) }.b) , b = ({a = (if ({a = 0 , b = false }.b) then (let u = 0 in true) else (let u = 0 in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) , b = ({a = (let u = 0 in false) , b = ({a = 1 , b = ({a = 0 , b = false , c = 1 }.c) }.b) }.a) }.b) , c = ({a = (succ (let u = 1 in 0)) , b = (((\x: Bool .\y: Bool .y) false ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) , c = (unfold [ Bool ] (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] 0 )) )) }.c) }.c) }.a)
(let u = (let u = (iszero ({a = 0 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c = 0 }.c)) in ({a = (let u = true in true) , b = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = true , b = 0 }.a) }.a) }.b)) in ({a = (( \f: Unit .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (if (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .b)) then (succ 0) else (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) }.b))
(iszero ({a = (pred ({a = (if false then 0 else 0) , b = (let u = 1 in 0) }.b)) , b = (fix (\x: Nat . (unfold [ Bool ] (fold [ Nat ] false )) )) , c = (fix (\x: Unit . ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) )) )) }.c))
(((\x: Bool .\y: Rec X. X .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (let u = true in u) in u) )) ) ({a = (let u = (((\x: Bool .\y: Unit .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) ) true) in ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 ))) , b = ({a = 1 , b = true , c =  (((\x: Rec X. X .\y: Bool .x) 1 ) false) }.b) , c =  (fix (\x: Rec X. X . 0 )) }.b))
({a = (fix (\x: Unit . (let u = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) in u) )) , b = (case <r = (unfold [ Nat ] (fold [ Nat ] (if false then ({a = 0 , b = false }.b) else false) )) > as Unit of < l = x > => x | < r = y > => y) , c = (if (((\x: Bool .\y: Unit .y) true ) (let u = 1 in true)) then (let u = ({a = 1 , b = false , c = 0 }.c) in (let u = 0 in u)) else (let u = ({a = 0 , b = true , c =  0 }.b) in ({a = true , b = 0 }.b))) }.c)
(fix (\x: Bool . (let u = (let u = (((\x: Unit .\y: Bool .x) 0 ) false) in u) in u) ))
({a = (( \f: Bool .((f (unfold [ Bool ] (fold [ Unit ] 0 )) ) (succ ({a = 0 , b = false , c = 1 }.c)) ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = (((\x: Bool .\y: Bool .x) false ) true) , b = (if ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) false) , b = false }.b) then (if false then 0 else 1) else (((\x: Bool .\y: Rec X. X .y) true ) 1)) }.a) , c = (((\x: Unit .\y: Unit .x) ({a = (unfold [ Unit ] (fold [ Rec X. X ] (succ 1) )) , b = (((\x: Nat .\y: Unit .x) ({a = 1 , b = true , c =  1 }.b) ) true) , c = ({a = 1 , b = true , c = 0 }.c) }.c) ) (let u = (((\x: Bool .\y: Unit .x) false ) (((\x: Bool .\y: Unit .x) true ) true)) in u)) }.c)
(succ (((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Bool .x) ({a = (((\x: Bool .\y: Unit .x) 1 ) false) , b = (let u = (((\x: Rec X. X .\y: Bool .x) true ) false) in u) , c = (if false then 1 else 0) }.c) ) (let u = (fix (\x: Rec X. X . ({a = 1 , b = true , c =  1 }.b) )) in u)) ) ({a = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Nat ] false )) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Unit .b)) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) }.a)))
({a = (fix (\x: Bool . (( \f: Unit .((f (((\x: Nat .\y: Bool .x) (if false then 0 else 1) ) false) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) )) , b = ({a = (case <l = (( \f: Rec X. X .((f ({a = false , b = 0 }.b) ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) (let u = true in true) ) ) (\a: Unit .\b: Nat .a)) , c = ({a = (pred (succ 1)) , b = (((\x: Rec X. X .\y: Unit .x) 1 ) true) }.b) }.c) }.b)
({a = (succ ({a = 0 , b = ({a = true , b = false }.b) , c = 0 }.c)) , b = (let u = (let u = (((\x: Bool .\y: Rec X. X .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .x) false ) true) ))) in (iszero (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)))) in u) }.a)
(iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .x) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = (succ 1) }.b) ) ({a = 0 , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.b)) )))
(( \f: Nat .((f (( \f: Rec X. X .((f (succ (case <l = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y)) ) (( \f: Unit .((f (let u = false in 1) ) (fix (\x: Bool . 1 )) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .b)) ) (let u = (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) in u) ) ) (\a: Unit .\b: Bool .a))
(let u = (case <r = ({a = (let u = true in (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (((\x: Rec X. X .\y: Nat .y) true ) true) }.b) > as Nat of < l = x > => x | < r = y > => y) in (if (fix (\x: Nat . ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) )) then ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)) }.b) else ({a = 0 , b = true }.b)))
(((\x: Unit .\y: Rec X. X .y) (fix (\x: Nat . ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.a) )) ) (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .x) 1 ) (let u = false in u)) )))
(let u = (((\x: Nat .\y: Nat .y) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = true , b = 0 }.a)) ) (((\x: Bool .\y: Rec X. X .x) (if (unfold [ Bool ] (fold [ Bool ] false )) then true else ({a = false , b = 0 }.a)) ) ({a = 0 , b = true }.b))) in ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (if true then false else (if true then false else false)) )))
(let u = (( \f: Unit .((f (pred (succ 0)) ) (((\x: Rec X. X .\y: Rec X. X .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) 1) ) ) (\a: Nat .\b: Unit .b)) in (iszero (unfold [ Nat ] (fold [ Bool ] (let u = 0 in (((\x: Rec X. X .\y: Rec X. X .y) true ) 1)) ))))
(pred (( \f: Nat .((f (((\x: Bool .\y: Bool .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) ) (((\x: Unit .\y: Bool .y) false ) 1)) ) (((\x: Nat .\y: Rec X. X .x) 0 ) (let u = 0 in true)) ) ) (\a: Rec X. X .\b: Bool .a)))
({a = (case <r = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = (let u = true in (fix (\x: Rec X. X . true ))) , c =  ({a = 1 , b = 1 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (let u = (let u = ({a = 0 , b = false }.b) in ({a = 1 , b = 0 }.b)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) false ) false) ))) , b = ({a = ({a = 0 , b = false }.a) , b = ({a = true , b = false }.b) }.a) }.b) }.a)
(let u = (((\x: Bool .\y: Nat .y) (( \f: Nat .((f (( \f: Nat .((f ({a = true , b = false }.b) ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) (fix (\x: Rec X. X . true )) ) ) (\a: Bool .\b: Unit .a)) ) (( \f: Rec X. X .((f (let u = (let u = false in u) in true) ) (if (let u = true in false) then (fix (\x: Rec X. X . true )) else (let u = false in u)) ) ) (\a: Rec X. X .\b: Nat .a))) in (let u = ({a = ({a = (pred (succ 0)) , b = (fix (\x: Nat . true )) }.a) , b = (let u = (let u = 1 in u) in false) }.b) in (if (case <r = (unfold [ Nat ] (fold [ Nat ] true )) > as Nat of < l = x > => x | < r = y > => y) then (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 0 in false) )) > as Nat of < l = x > => x | < r = y > => y) else (let u = ({a = 1 , b = false , c =  0 }.b) in u))))
({a = (pred (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) )) ))) , b = (let u = (if true then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) else (((\x: Bool .\y: Bool .x) 1 ) true)) in (unfold [ Nat ] (fold [ Bool ] (if false then true else false) ))) }.b)
({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Nat .x) ({a = false , b = true }.b) ) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) , b = false , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b)) )) , b = (if ({a = ({a = 0 , b = true , c = 0 }.c) , b = ({a = 0 , b = true , c =  1 }.b) }.b) then (unfold [ Unit ] (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) true ) true) )) else ({a = (fix (\x: Unit . true )) , b = (((\x: Bool .\y: Nat .x) 0 ) true) }.a)) }.b)
({a = (iszero (let u = 1 in u)) , b = (((\x: Nat .\y: Nat .y) (let u = (fix (\x: Bool . false )) in (( \f: Bool .((f false ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Rec X. X .b))) ) (succ ({a = 1 , b = true , c = 0 }.c))) }.a)
({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Bool .y) (iszero 0) ) ({a = 0 , b = 1 }.b)) )) , b = (((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .x) (let u = false in u) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) in ({a = false , b = 0 }.a))) ) (( \f: Unit .((f true ) (let u = true in u) ) ) (\a: Nat .\b: Rec X. X .a))) }.b)
({a = (let u = (if (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) then (let u = ({a = true , b = false }.b) in (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )) in ({a = 0 , b = 1 }.b))) else (((\x: Bool .\y: Bool .y) false ) ({a = 0 , b = false }.a))) in u) , b = (let u = (((\x: Nat .\y: Bool .y) (let u = (let u = false in u) in (((\x: Unit .\y: Nat .x) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) true)) ) (iszero (let u = 0 in u))) in u) }.a)
({a = (( \f: Unit .((f (fix (\x: Rec X. X . (fix (\x: Rec X. X . true )) )) ) ({a = ({a = false , b = 0 }.a) , b = (let u = true in true) }.b) ) ) (\a: Bool .\b: Bool .b)) , b = (unfold [ Unit ] (fold [ Rec X. X ] (let u = ({a = (let u = 1 in u) , b = false }.b) in ({a = false , b = 1 }.a)) )) }.b)
({a = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (succ 0) )) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = (((\x: Unit .\y: Unit .x) (let u = 1 in 0) ) ({a = false , b = true }.b)) , b = (fix (\x: Unit . (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .b)) )) }.a) }.b)
({a = ({a = (pred (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = (if (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = true , c =  0 }.b) ) false) then (let u = true in (let u = false in u)) else ({a = ({a = false , b = 0 }.a) , b = (let u = ({a = true , b = 0 }.b) in u) }.a)) }.a) , b = (( \f: Unit .((f ({a = (((\x: Bool .\y: Rec X. X .y) false ) true) , b = (if ({a = true , b = 1 }.a) then 0 else 1) }.a) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = ({a = 0 , b = true }.b) , b = 1 }.a)) ) ) (\a: Nat .\b: Bool .a)) }.b)
(((\x: Bool .\y: Nat .x) ({a = ({a = (pred (succ (let u = 0 in 0))) , b = (((\x: Bool .\y: Bool .x) (( \f: Unit .((f false ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Bool .b)) ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .a))) }.b) , b = (let u = (iszero ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false , c = 1 }.c)) in ({a = 1 , b = (unfold [ Bool ] (fold [ Bool ] false )) }.a)) }.a) ) (iszero (( \f: Nat .((f 0 ) (succ 0) ) ) (\a: Unit .\b: Bool .b))))
({a = (if (let u = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) , b = ({a = true , b = 1 }.b) }.b) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) then (fix (\x: Unit . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) )) else (case <l = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) false ) (let u = 1 in 1)) ) (fix (\x: Bool . 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .y) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)) ) (let u = true in true)) ) (fix (\x: Rec X. X . true )) ) ) (\a: Bool .\b: Unit .a)) , b = (let u = (if (fix (\x: Bool . true )) then (let u = true in (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a))) else ({a = 1 , b = (pred 1) }.b)) in ({a = ({a = 0 , b = false }.a) , b = (((\x: Unit .\y: Bool .x) false ) true) }.a)) }.a) }.a)
({a = ({a = (fix (\x: Bool . (let u = 1 in u) )) , b = ({a = (let u = 0 in u) , b = false , c = 0 }.c) }.b) , b = ({a = ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = 0 in u) }.a) , b = (if (if false then true else true) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = false in u)) }.b) }.b)
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] 0 )) )) in (case <r = (( \f: Rec X. X .((f false ) (let u = false in u) ) ) (\a: Rec X. X .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y)) ))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (let u = (fix (\x: Rec X. X . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) in u) , b = ({a = (case <r = (unfold [ Bool ] (fold [ Nat ] true )) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (let u = true in u) in (let u = 1 in 0)) }.a) }.b) ))
(let u = (let u = ({a = ({a = 0 , b = 1 }.b) , b = (let u = false in true) }.a) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) in (( \f: Nat .((f (fix (\x: Bool . (let u = 0 in 0) )) ) (((\x: Unit .\y: Rec X. X .x) (fix (\x: Nat . 1 )) ) (((\x: Bool .\y: Rec X. X .x) ({a = false , b = true }.b) ) true)) ) ) (\a: Nat .\b: Bool .a)))
(let u = ({a = (let u = false in ({a = true , b = true }.b)) , b = (let u = (( \f: Nat .((f (let u = true in true) ) true ) ) (\a: Nat .\b: Unit .a)) in (if false then false else false)) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) , c =  (unfold [ Unit ] (fold [ Nat ] 0 )) }.b) )))
(let u = (unfold [ Unit ] (fold [ Nat ] (let u = 0 in (((\x: Bool .\y: Unit .y) true ) 0)) )) in (case <r = (((\x: Nat .\y: Bool .y) (( \f: Nat .((f true ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Unit .b)) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) false ) false) ))) > as Bool of < l = x > => x | < r = y > => y))
(case <r = (let u = (fix (\x: Unit . (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) )) in u) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (let u = (case <r = (((\x: Rec X. X .\y: Nat .y) true ) true) > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Unit . (iszero (succ ({a = false , b = 0 }.b))) ))) ) (let u = (let u = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) in (((\x: Bool .\y: Bool .y) true ) 0)) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] false )) ) (if true then false else false) ) ) (\a: Nat .\b: Bool .a)) ))) ) ) (\a: Bool .\b: Bool .b))
(( \f: Nat .((f (case <l = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (((\x: Unit .\y: Nat .y) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) 1) , b = (case <r = (( \f: Rec X. X .((f false ) ({a = 0 , b = true }.b) ) ) (\a: Bool .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) , c = ({a = (unfold [ Unit ] (fold [ Bool ] 1 )) , b = (pred 0) }.b) }.c) ) ) (\a: Bool .\b: Nat .a))
(case <r = (let u = (pred (((\x: Unit .\y: Rec X. X .y) true ) 0)) in (iszero ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .a)) , b = 0 }.b))) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (((\x: Nat .\y: Rec X. X .y) ({a = (let u = 1 in false) , b = 1 }.a) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) in (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) (let u = true in 0) ) ) (\a: Bool .\b: Nat .b))) in ({a = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) in u) , b = ({a = (fix (\x: Unit . false )) , b = (pred 0) }.b) }.a))
(((\x: Bool .\y: Bool .x) (( \f: Unit .((f ({a = (iszero 1) , b = (let u = 1 in true) }.b) ) ({a = (unfold [ Nat ] (fold [ Rec X. X ] false )) , b = ({a = 0 , b = false , c =  0 }.b) }.b) ) ) (\a: Bool .\b: Bool .a)) ) (let u = ({a = (let u = true in u) , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.a) in (unfold [ Bool ] (fold [ Rec X. X ] false ))))
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (( \f: Unit .((f (iszero (((\x: Unit .\y: Unit .y) true ) (let u = 1 in 1))) ) ({a = false , b = (pred 1) }.a) ) ) (\a: Rec X. X .\b: Unit .b)) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = (case <l = ({a = true , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) in (let u = (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in u)) ))
(fix (\x: Bool . ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (if ({a = false , b = 0 }.a) then 0 else (let u = 0 in u)) )) ))
(let u = ({a = (let u = (let u = (let u = (let u = true in true) in u) in u) in u) , b = (((\x: Bool .\y: Bool .x) (let u = 1 in u) ) (( \f: Nat .((f (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) in u) ) (if true then true else false) ) ) (\a: Unit .\b: Nat .b))) }.b) in (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (((\x: Bool .\y: Bool .x) false ) true) , c = ({a = (fix (\x: Unit . true )) , b = ({a = 0 , b = 1 }.b) }.b) }.c) ) ({a = (let u = (pred 1) in u) , b = (fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .y) false ) false) )) }.a) ) ) (\a: Unit .\b: Nat .b)))
(( \f: Rec X. X .((f ({a = (succ (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b))) , b = ({a = ({a = (pred 0) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  1 }.b) , b = (fix (\x: Bool . (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) }.b) , c =  (case <l = (let u = (if false then 1 else 1) in u) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (let u = (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) 0 ) (((\x: Rec X. X .\y: Bool .y) false ) true)) ) (succ 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (let u = (( \f: Bool .((f (((\x: Nat .\y: Unit .x) 0 ) false) ) 1 ) ) (\a: Nat .\b: Unit .a)) in (fix (\x: Nat . false )))) ) ) (\a: Rec X. X .\b: Unit .a))
((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .x) (( \f: Bool .((f (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .a)) ) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) in (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (if true then true else (if false then false else false)) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) ))
(( \f: Nat .((f (if ({a = ({a = 0 , b = true }.a) , b = false , c =  (((\x: Nat .\y: Unit .x) 1 ) true) }.b) then (pred 1) else (( \f: Bool .((f (let u = 0 in ({a = 0 , b = true }.a)) ) (unfold [ Nat ] (fold [ Nat ] 1 )) ) ) (\a: Nat .\b: Unit .b))) ) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Bool ] (iszero 0) )) }.a) ) ) (\a: Nat .\b: Nat .b))
({a = (succ ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) , b = ({a = (( \f: Rec X. X .((f ({a = false , b = 0 }.b) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = (let u = 0 in true) in u) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Bool . 0 )) )) }.b) , c =  (unfold [ Nat ] (fold [ Unit ] (pred (pred (let u = 0 in 1))) )) }.b)
(unfold [ Bool ] (fold [ Unit ] (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) )) > as Nat of < l = x > => x | < r = y > => y) ))
(iszero ({a = (fix (\x: Rec X. X . ({a = ({a = false , b = 1 }.b) , b = (((\x: Bool .\y: Nat .y) false ) true) , c = ({a = false , b = 1 }.b) }.c) )) , b = ({a = (unfold [ Bool ] (fold [ Bool ] 1 )) , b = ({a = ({a = (if false then false else false) , b = ({a = 0 , b = false }.a) }.b) , b = (if true then true else false) }.b) }.a) }.b))
(let u = (if (case <r = ({a = (fix (\x: Nat . (let u = true in 0) )) , b = ({a = true , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) }.b) }.b) > as Nat of < l = x > => x | < r = y > => y) then (pred (( \f: Nat .((f 1 ) (let u = 1 in 0) ) ) (\a: Nat .\b: Bool .b))) else ({a = ({a = (pred 1) , b = ({a = 1 , b = true }.b) , c = 1 }.c) , b = (((\x: Unit .\y: Rec X. X .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) ) ({a = 1 , b = true }.b)) }.a)) in (( \f: Unit .((f (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f false ) (let u = 0 in true) ) ) (\a: Nat .\b: Nat .a)) ) ({a = 0 , b = false }.b)) ) (fix (\x: Unit . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) )) ) ) (\a: Unit .\b: Rec X. X .a)))
(case <l = ({a = (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 ))) , b = (let u = 0 in (let u = true in 0)) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = (((\x: Nat .\y: Bool .x) (((\x: Unit .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (succ 1) ))) ) (if ({a = false , b = (fix (\x: Unit . true )) }.b) then (if (let u = true in (unfold [ Rec X. X ] (fold [ Bool ] true ))) then (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .a)) else (let u = false in true)) else (iszero ({a = 0 , b = true }.a)))) , b = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (case <r = (unfold [ Bool ] (fold [ Bool ] true )) > as Bool of < l = x > => x | < r = y > => y) )) in u) }.b)
(case <r = ({a = ({a = (((\x: Unit .\y: Unit .y) false ) false) , b = (((\x: Bool .\y: Unit .y) false ) true) }.b) , b = ({a = (if true then 1 else 0) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (fix (\x: Unit . (((\x: Bool .\y: Nat .x) ({a = 1 , b = false }.a) ) true) )) , b = (let u = ({a = 0 , b = 0 }.b) in true) }.b) , b = ({a = ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = (pred 1) }.b) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = false }.a) }.b) }.a)
(let u = (let u = (unfold [ Nat ] (fold [ Unit ] (pred 1) )) in (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) false ) false) ) ({a = 1 , b = 0 }.b))) in u)
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = 0 , b = false }.b) )) in u)
(let u = (let u = (succ 0) in (( \f: Rec X. X .((f (let u = true in 0) ) ({a = 0 , b = true }.a) ) ) (\a: Rec X. X .\b: Bool .a))) in u)
(((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Bool .y) (case <r = ({a = 1 , b = true , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Unit .y) (unfold [ Unit ] (fold [ Bool ] (fix (\x: Nat . false )) )) ) ({a = 0 , b = (iszero 0) }.b))) ) ({a = (( \f: Unit .((f (( \f: Nat .((f (let u = (if false then 0 else 0) in u) ) ({a = 1 , b = true , c = (succ 0) }.c) ) ) (\a: Rec X. X .\b: Nat .b)) ) (unfold [ Nat ] (fold [ Bool ] 0 )) ) ) (\a: Unit .\b: Bool .b)) , b = (let u = (if false then 1 else 1) in (if (let u = false in false) then (iszero 1) else ({a = true , b = 1 }.a))) , c =  (((\x: Rec X. X .\y: Bool .y) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) }.b) ) (((\x: Bool .\y: Bool .x) (let u = true in 0) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )))) }.b))
({a = (((\x: Rec X. X .\y: Nat .y) (((\x: Rec X. X .\y: Bool .y) (unfold [ Bool ] (fold [ Bool ] (let u = true in true) )) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Bool .y) false ) true) ) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .a))) ))) ) (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Nat .y) (fix (\x: Unit . false )) ) (((\x: Bool .\y: Rec X. X .x) true ) true)) ) (((\x: Unit .\y: Unit .x) (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) ) true ) ) (\a: Nat .\b: Unit .a)) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)))) , b = (let u = (unfold [ Bool ] (fold [ Nat ] 1 )) in (((\x: Nat .\y: Unit .y) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) (let u = 0 in u))) }.b)
(let u = (case <r = ({a = false , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.a) > as Bool of < l = x > => x | < r = y > => y) in u)
(unfold [ Bool ] (fold [ Bool ] (iszero ({a = (fix (\x: Rec X. X . false )) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) ))
(iszero (case <l = ({a = ({a = 1 , b = (let u = false in false) }.b) , b = ({a = (fix (\x: Bool . true )) , b = (succ 1) }.b) }.b) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Unit .((f (unfold [ Unit ] (fold [ Rec X. X ] ({a = (let u = true in u) , b = 0 }.b) )) ) (case <l = ({a = (if true then true else true) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a))
({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false , c =  1 }.b) ) ({a = true , b = ({a = true , b = 1 }.b) }.b)) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ))) , b = ({a = ({a = (((\x: Bool .\y: Nat .y) true ) false) , b = 0 }.a) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , c =  (fix (\x: Unit . ({a = (((\x: Rec X. X .\y: Nat .x) 1 ) false) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = false }.a) )) }.b) )) }.b)
(let u = ({a = (case <r = (((\x: Bool .\y: Nat .x) (let u = false in u) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (pred (if true then 0 else 0)) in u) }.b) in (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Nat .y) (iszero 0) ) true) ) (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in (fix (\x: Unit . true )))))
(let u = (if (unfold [ Unit ] (fold [ Nat ] ({a = false , b = 0 }.a) )) then (iszero 0) else (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )))) in (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = false , b = true }.b) ) (((\x: Nat .\y: Unit .x) (if ({a = true , b = true }.b) then true else (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a))) ) ({a = (((\x: Nat .\y: Nat .x) true ) false) , b = (((\x: Unit .\y: Unit .x) false ) true) }.b))) ) ) (\a: Nat .\b: Unit .b)))
(( \f: Rec X. X .((f (let u = (succ (let u = false in 0)) in (case <r = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y)) ) (((\x: Bool .\y: Bool .x) (if true then false else (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a))) ) (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .b)) in (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) false ) true) ) true ) ) (\a: Unit .\b: Nat .a)))) ) ) (\a: Unit .\b: Unit .a))
(( \f: Nat .((f (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Nat .\y: Rec X. X .x) true ) false) )) )) ) (let u = ({a = (( \f: Rec X. X .((f (( \f: Unit .((f 0 ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) ) ) (\a: Bool .\b: Bool .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = 0 }.b) )) }.b) in (iszero (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) ) ) (\a: Bool .\b: Nat .a))
(let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (case <l = ({a = 0 , b = true }.a) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (unfold [ Nat ] (fold [ Bool ] (let u = true in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) )) }.a) )) in (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = false in u) )) in (((\x: Unit .\y: Nat .x) 0 ) false)))
(( \f: Unit .((f (pred (case <l = (((\x: Rec X. X .\y: Unit .y) false ) 0) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = (succ (pred (succ 0))) in u) ) ) (\a: Bool .\b: Nat .b))
(succ ({a = (((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) ({a = (fix (\x: Unit . true )) , b = 1 }.a)) , b = (((\x: Bool .\y: Unit .x) true ) (unfold [ Nat ] (fold [ Rec X. X ] false ))) }.a))
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (let u = ({a = false , b = true }.b) in ({a = true , b = false }.b)) , b = (if true then 0 else (succ 0)) }.a) ) ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] false )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Unit . true )) )) }.b))
(unfold [ Bool ] (fold [ Unit ] ({a = ({a = (let u = true in u) , b = (pred 1) }.b) , b = (((\x: Unit .\y: Rec X. X .y) (iszero 1) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true ))) , c =  (let u = 0 in u) }.b) ))
(if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .a)) in u) )) then ({a = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u) , b = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) false ) true) ) true ) ) (\a: Bool .\b: Bool .a)) }.a) else (if (( \f: Bool .((f (if false then true else false) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) ) (\a: Bool .\b: Unit .b)) then (succ ({a = 1 , b = 1 }.b)) else ({a = (case <l = (if false then 1 else 1) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) , c = (((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Bool .x) true ) true) ) 1) }.c)))
(((\x: Rec X. X .\y: Rec X. X .y) (case <r = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (((\x: Nat .\y: Nat .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) true) , b = (( \f: Rec X. X .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .y) false ) true) ) ) (\a: Nat .\b: Nat .b)) }.a))
(let u = (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Bool .y) true ) false) ) (let u = 0 in false)) in (fix (\x: Rec X. X . (((\x: Bool .\y: Unit .x) false ) ({a = false , b = 0 }.a)) )))
(((\x: Nat .\y: Nat .x) (pred (((\x: Nat .\y: Bool .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true }.b))) ) (case <r = (unfold [ Unit ] (fold [ Unit ] (((\x: Bool .\y: Unit .x) true ) false) )) > as Unit of < l = x > => x | < r = y > => y))
({a = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) in u) , b = (if ({a = ({a = 0 , b = true }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) }.b) then (((\x: Unit .\y: Unit .y) true ) false) else (if (fix (\x: Unit . true )) then (let u = (let u = 1 in false) in u) else ({a = false , b = false }.b))) , c = ({a = (case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) }.a) }.c)
(case <l = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) 0 ) true) ) (if false then 0 else 0) ) ) (\a: Rec X. X .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y)
(iszero ({a = (if (let u = true in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) then (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) else (( \f: Nat .((f 0 ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Nat .b))) , b = (let u = (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) in (((\x: Nat .\y: Nat .y) false ) (fix (\x: Unit . false )))) in ({a = (let u = true in u) , b = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b)) , c = (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .y) true ) (((\x: Nat .\y: Bool .x) 1 ) true)) )) }.c))
(case <l = (( \f: Rec X. X .((f (fix (\x: Bool . (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = 0 , b = 0 }.b) , b = ({a = 1 , b = false }.a) }.b) )) ) ) (\a: Nat .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y)
(case <l = (let u = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , c =  ({a = false , b = 0 }.b) }.b) in (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) ))) > as Nat of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f (((\x: Nat .\y: Nat .y) (if true then false else false) ) 0) ) (pred (let u = 1 in u)) ) ) (\a: Rec X. X .\b: Nat .a)) ))
({a = (((\x: Bool .\y: Bool .y) (unfold [ Nat ] (fold [ Bool ] (let u = 0 in false) )) ) (((\x: Unit .\y: Nat .y) ({a = 0 , b = true }.b) ) false)) , b = (succ ({a = 1 , b = 1 }.b)) }.a)
({a = (pred (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (fix (\x: Unit . 1 )) else (( \f: Nat .((f (fix (\x: Bool . 0 )) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)))) , b = (iszero (case <l = (let u = ({a = 0 , b = 1 }.b) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = true }.a) ))) > as Bool of < l = x > => x | < r = y > => y)) }.b)
({a = (let u = (( \f: Unit .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Bool .x) 1 ) false) ) ) (\a: Unit .\b: Unit .b)) in ({a = (let u = true in 0) , b = (if false then true else true) }.a)) , b = (let u = (let u = (iszero 0) in u) in u) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f ({a = 0 , b = false , c =  0 }.b) ) (let u = 1 in true) ) ) (\a: Unit .\b: Nat .b)) in (iszero (((\x: Unit .\y: Unit .y) true ) 1))) ))
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = (case <r = (( \f: Nat .((f (let u = true in true) ) (let u = 0 in false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) , b = (pred (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) in ({a = 0 , b = 1 }.b))) }.a) ))
({a = ({a = (iszero (((\x: Nat .\y: Unit .y) false ) 1)) , b = (fix (\x: Unit . ({a = 0 , b = true }.a) )) }.b) , b = (case <r = (( \f: Rec X. X .((f (let u = true in u) ) (((\x: Unit .\y: Bool .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Nat .\y: Bool .x) true ) false)) ) ) (\a: Nat .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) , c =  (unfold [ Nat ] (fold [ Nat ] (let u = ({a = (((\x: Unit .\y: Nat .y) true ) 1) , b = false }.a) in (let u = 0 in u)) )) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (let u = (( \f: Rec X. X .((f ({a = false , b = true }.b) ) (let u = false in false) ) ) (\a: Rec X. X .\b: Unit .b)) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = false }.a) ))) in (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (unfold [ Unit ] (fold [ Nat ] 1 )) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .a)) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.b) ))) ))
({a = ({a = ({a = (fix (\x: Rec X. X . (let u = true in true) )) , b = (let u = (let u = 1 in u) in 0) }.a) , b = (((\x: Rec X. X .\y: Rec X. X .x) (succ (fix (\x: Rec X. X . 1 ))) ) ({a = 0 , b = false }.b)) }.b) , b = (((\x: Unit .\y: Unit .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) )) ) ({a = (let u = ({a = (let u = false in true) , b = 0 }.b) in u) , b = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , c =  ({a = true , b = (fix (\x: Rec X. X . 0 )) }.b) }.b) , c =  (pred 0) }.b)) , c = (let u = ({a = (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) in u) , b = (((\x: Bool .\y: Bool .x) true ) true) , c = (case <l = (((\x: Bool .\y: Rec X. X .y) false ) 1) > as Nat of < l = x > => x | < r = y > => y) }.c) in u) }.c)
(let u = (if (let u = (let u = true in u) in true) then (if false then 1 else (pred 0)) else (case <l = (if true then 1 else 0) > as Rec X. X of < l = x > => x | < r = y > => y)) in (((\x: Nat .\y: Nat .y) (unfold [ Nat ] (fold [ Nat ] (let u = true in u) )) ) ({a = (let u = 1 in false) , b = (((\x: Nat .\y: Unit .x) 0 ) (fix (\x: Rec X. X . false ))) }.a)))
(fix (\x: Unit . ({a = (((\x: Nat .\y: Unit .x) (let u = 1 in u) ) (if false then false else false)) , b = (let u = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = false , b = ({a = 1 , b = false , c = 1 }.c) }.b)) }.b) ))
({a = ({a = (case <l = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Rec X. X .((f (let u = 1 in u) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Nat .b)) in (let u = (let u = 1 in true) in (((\x: Rec X. X .\y: Unit .x) true ) true))) }.a) , b = (( \f: Nat .((f ({a = ({a = (fix (\x: Nat . 1 )) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) , c = 1 }.c) , b = (( \f: Unit .((f true ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) }.b) ) (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .b)) in u) ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (case <l = (fix (\x: Rec X. X . (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (let u = true in 0) in (fix (\x: Unit . 1 ))) )) , b = (fix (\x: Unit . (((\x: Rec X. X .\y: Bool .y) (iszero 0) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) )) }.b) in u)
(((\x: Nat .\y: Bool .x) (( \f: Bool .((f ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = 0 }.b) ) (let u = 0 in u) ) ) (\a: Bool .\b: Rec X. X .b)) ) (( \f: Nat .((f (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 0 in 0) )) in (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = true , c =  1 }.b) ))) ) ({a = ({a = true , b = 0 }.b) , b = (let u = false in (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .b))) , c =  (let u = true in (let u = 1 in 1)) }.b) ) ) (\a: Unit .\b: Rec X. X .a)))
(((\x: Unit .\y: Bool .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (iszero ({a = true , b = 0 }.b)) )) ) (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) in u))
({a = (case <r = (( \f: Rec X. X .((f ({a = 1 , b = false , c =  1 }.b) ) (unfold [ Unit ] (fold [ Bool ] (fix (\x: Unit . true )) )) ) ) (\a: Rec X. X .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (let u = (unfold [ Unit ] (fold [ Rec X. X ] true )) in u) , b = (((\x: Rec X. X .\y: Unit .x) 1 ) true) }.b) }.a)
(unfold [ Unit ] (fold [ Rec X. X ] (let u = (if (fix (\x: Rec X. X . (let u = false in u) )) then ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = (let u = 1 in u) }.b) else (pred (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Bool .y) false ) 0) )))) in ({a = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = true }.b) , b = ({a = 0 , b = 1 }.b) }.a)) ))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = ({a = 1 , b = false , c =  0 }.b) , b = (let u = true in 0) }.a) in u) )) ))
(((\x: Unit .\y: Bool .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Nat .((f ({a = false , b = 0 }.a) ) (if true then true else true) ) ) (\a: Rec X. X .\b: Nat .a)) )) ) (case <l = ({a = (unfold [ Bool ] (fold [ Rec X. X ] true )) , b = (succ 0) }.b) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Nat .((f (iszero (succ (if (let u = true in true) then 1 else (let u = 1 in u)))) ) (( \f: Bool .((f (( \f: Nat .((f ({a = (let u = false in u) , b = true }.b) ) ({a = (((\x: Bool .\y: Nat .x) true ) true) , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = ({a = 0 , b = (pred 0) }.b) in (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) false ) true) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )))) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then true else (((\x: Rec X. X .\y: Unit .x) true ) true)) )) in (((\x: Rec X. X .\y: Rec X. X .x) ({a = (succ 0) , b = (let u = 0 in false) , c = 0 }.c) ) (unfold [ Unit ] (fold [ Rec X. X ] true )))) )))
(case <r = (fix (\x: Bool . (( \f: Nat .((f ({a = 1 , b = true , c =  1 }.b) ) ({a = true , b = 0 }.a) ) ) (\a: Unit .\b: Unit .b)) )) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (let u = (let u = (let u = 0 in false) in (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b))) in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) (( \f: Unit .((f (let u = false in 1) ) (fix (\x: Unit . ({a = 0 , b = 1 }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .a))
(((\x: Rec X. X .\y: Bool .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) (unfold [ Nat ] (fold [ Bool ] false )) ) ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = 0 , b = true , c =  0 }.b) }.b)) )) ) (((\x: Rec X. X .\y: Rec X. X .x) (pred (pred 1)) ) (fix (\x: Nat . ({a = 1 , b = false , c =  0 }.b) ))))
({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Bool .b)) ) (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = ({a = (let u = true in u) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) in (if (if false then true else false) then (fix (\x: Nat . 0 )) else ({a = 1 , b = true , c = 1 }.c))) }.a)
(let u = (let u = ({a = (succ 1) , b = (fix (\x: Nat . ({a = 0 , b = true }.b) )) , c = ({a = 0 , b = 1 }.b) }.c) in u) in (fix (\x: Bool . (( \f: Unit .((f true ) (let u = true in u) ) ) (\a: Rec X. X .\b: Unit .b)) )))
({a = ({a = (let u = (succ (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) in (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) in u)) , b = (iszero ({a = 1 , b = 1 }.b)) }.a) , b = (pred ({a = 1 , b = 0 }.b)) }.b)
(let u = (iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in 1) )) ))) in (succ (fix (\x: Nat . (if (if false then true else true) then (fix (\x: Rec X. X . 1 )) else (((\x: Rec X. X .\y: Unit .y) true ) 1)) ))))
({a = (unfold [ Unit ] (fold [ Bool ] (succ 0) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Unit .x) (iszero (let u = 1 in u)) ) (let u = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .a)) in false)) )) , c = (unfold [ Unit ] (fold [ Rec X. X ] (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) )) }.c)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .x) (succ (let u = 1 in 1)) ) (let u = (( \f: Nat .((f (let u = 0 in u) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) in ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = (((\x: Bool .\y: Rec X. X .y) ({a = false , b = false }.b) ) true) }.b))) ))
(( \f: Unit .((f (iszero (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a))) ) ({a = ({a = false , b = (let u = true in true) }.b) , b = (let u = (let u = 1 in u) in (unfold [ Unit ] (fold [ Rec X. X ] 0 ))) }.a) ) ) (\a: Bool .\b: Nat .a))
(( \f: Unit .((f (( \f: Rec X. X .((f (let u = (((\x: Unit .\y: Rec X. X .x) true ) true) in u) ) ({a = ({a = false , b = (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.b) , b = ({a = 0 , b = false , c =  1 }.b) , c =  (unfold [ Rec X. X ] (fold [ Unit ] 1 )) }.b) ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Unit .\y: Nat .x) (fix (\x: Nat . (unfold [ Unit ] (fold [ Bool ] false )) )) ) (let u = (unfold [ Bool ] (fold [ Bool ] (let u = (((\x: Nat .\y: Nat .y) true ) false) in 1) )) in (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Nat .((f (((\x: Nat .\y: Nat .y) false ) false) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Unit .b))))) ) ) (\a: Nat .\b: Bool .b))
(let u = (if (((\x: Bool .\y: Bool .x) (iszero 0) ) (((\x: Rec X. X .\y: Nat .y) true ) false)) then ({a = ({a = 0 , b = (iszero 1) , c =  (let u = 1 in u) }.b) , b = (if ({a = false , b = 1 }.a) then true else (let u = false in true)) }.b) else (((\x: Bool .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Rec X. X ] true )) ) (((\x: Nat .\y: Rec X. X .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) ) ({a = 1 , b = true , c =  1 }.b)))) in u)
({a = (succ (let u = (if true then (let u = false in 1) else 0) in (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )))) , b = (( \f: Rec X. X .((f (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) )) ) (let u = 1 in false) ) ) (\a: Bool .\b: Unit .a)) ) (let u = ({a = true , b = 1 }.a) in ({a = true , b = (((\x: Unit .\y: Bool .x) 0 ) false) }.a)) ) ) (\a: Nat .\b: Rec X. X .b)) }.b)
(( \f: Unit .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = 0 in true) , b = (((\x: Nat .\y: Nat .y) false ) false) }.b) )) ) (let u = (unfold [ Bool ] (fold [ Nat ] ({a = true , b = true }.b) )) in u) ) ) (\a: Nat .\b: Bool .a))
(fix (\x: Rec X. X . (case <l = (((\x: Rec X. X .\y: Bool .y) (let u = 0 in false) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a))) > as Bool of < l = x > => x | < r = y > => y) ))
(if ({a = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = 1 }.b) )) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = (unfold [ Rec X. X ] (fold [ Unit ] (pred 0) )) in (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) in u)) , c =  (let u = (let u = true in 0) in (let u = 0 in 1)) }.b) then ({a = (let u = ({a = 1 , b = true , c =  0 }.b) in (((\x: Nat .\y: Rec X. X .y) (let u = false in u) ) (((\x: Nat .\y: Nat .x) 0 ) false))) , b = (if (let u = 0 in false) then ({a = true , b = (succ 1) }.a) else ({a = false , b = 0 }.a)) }.b) else ({a = (unfold [ Bool ] (fold [ Rec X. X ] (succ 0) )) , b = (( \f: Bool .((f (let u = (( \f: Unit .((f ({a = 1 , b = true , c = 1 }.c) ) (succ 0) ) ) (\a: Nat .\b: Rec X. X .b)) in (unfold [ Nat ] (fold [ Rec X. X ] true ))) ) (if (let u = (((\x: Nat .\y: Bool .x) true ) true) in (fix (\x: Rec X. X . false ))) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Unit .a)) , c =  (( \f: Rec X. X .((f ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = false }.a) ) (pred (fix (\x: Unit . 0 ))) ) ) (\a: Bool .\b: Rec X. X .b)) }.b))
(pred (let u = ({a = (succ 1) , b = (unfold [ Bool ] (fold [ Nat ] true )) }.b) in ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (pred 0) ))))
(((\x: Unit .\y: Nat .y) (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) false) )) then (case <r = (let u = (iszero 1) in (let u = true in u)) > as Unit of < l = x > => x | < r = y > => y) else (( \f: Nat .((f ({a = 0 , b = false }.b) ) ({a = (let u = 1 in u) , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b))) ) (((\x: Nat .\y: Bool .x) (fix (\x: Unit . (iszero (let u = false in 0)) )) ) (iszero ({a = ({a = 1 , b = false , c = 0 }.c) , b = true }.a))))
(let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Unit ] true )) ) (fix (\x: Bool . 1 ))) )) in (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) in u))
(pred (let u = (case <l = (case <l = ({a = 0 , b = false , c = 0 }.c) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) in u))
({a = (case <r = (let u = (let u = true in true) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = ({a = (let u = (((\x: Bool .\y: Unit .x) false ) true) in u) , b = (let u = 1 in 0) }.a) in (pred (case <l = 1 > as Unit of < l = x > => x | < r = y > => y))) }.a)
(if (fix (\x: Nat . ({a = (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in false) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .b))) , b = ({a = true , b = (((\x: Rec X. X .\y: Nat .x) 1 ) true) }.b) }.a) )) then (fix (\x: Nat . ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (((\x: Bool .\y: Nat .y) false ) true) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b) )) else (( \f: Unit .((f (let u = (( \f: Unit .((f (((\x: Bool .\y: Bool .y) true ) false) ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Nat .a)) in u) ) (((\x: Unit .\y: Bool .x) (fix (\x: Nat . (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) ) ({a = (let u = 1 in u) , b = (fix (\x: Rec X. X . false )) , c =  (((\x: Nat .\y: Nat .y) true ) (let u = 0 in 1)) }.b)) ) ) (\a: Bool .\b: Unit .b)))
(let u = (( \f: Unit .((f (( \f: Nat .((f (let u = 0 in 1) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) ) (\a: Nat .\b: Unit .a)) ) (((\x: Bool .\y: Bool .x) 0 ) true) ) ) (\a: Rec X. X .\b: Bool .b)) in (((\x: Nat .\y: Unit .y) ({a = (if true then false else true) , b = (let u = false in 1) }.a) ) (( \f: Unit .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ) (let u = ({a = false , b = 0 }.a) in (fix (\x: Bool . 1 ))) ) ) (\a: Rec X. X .\b: Bool .b))))
({a = ({a = (((\x: Unit .\y: Bool .y) (fix (\x: Nat . (fix (\x: Bool . false )) )) ) ({a = false , b = 0 }.a)) , b = (unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f false ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Bool .a)) )) }.b) , b = (((\x: Unit .\y: Bool .y) (iszero (case <l = ({a = 1 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = (let u = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) in ({a = 0 , b = false }.b)) in (let u = 1 in true)) in (if (let u = 1 in false) then ({a = false , b = 0 }.b) else (( \f: Unit .((f 0 ) (((\x: Rec X. X .\y: Unit .y) true ) 0) ) ) (\a: Bool .\b: Unit .a))))) }.b)
({a = (fix (\x: Bool . ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Bool .y) true ) true) )) )) , b = ({a = (if (((\x: Bool .\y: Nat .y) true ) (((\x: Bool .\y: Bool .x) false ) false)) then (( \f: Rec X. X .((f (let u = 1 in u) ) (if true then 0 else 1) ) ) (\a: Unit .\b: Rec X. X .b)) else (let u = 0 in u)) , b = (fix (\x: Rec X. X . (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) }.b) }.a)
(case <l = (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = true , b = 0 }.a) )) ) (let u = (if (((\x: Unit .\y: Nat .x) true ) false) then (let u = (fix (\x: Bool . 0 )) in 1) else ({a = true , b = 0 }.b)) in (((\x: Nat .\y: Bool .y) (let u = false in u) ) 0))) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Rec X. X .y) (let u = (( \f: Rec X. X .((f (fix (\x: Unit . (if false then false else true) )) ) (iszero (fix (\x: Unit . 1 ))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Bool .\y: Rec X. X .x) true ) false) , c =  ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in 1) )) }.b)) ) ({a = (succ 0) , b = (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Nat .x) ({a = 1 , b = 0 }.b) ) false) )) }.b))
(case <l = (pred (let u = (let u = ({a = true , b = false }.b) in (((\x: Rec X. X .\y: Unit .x) 0 ) true)) in u)) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <l = ({a = (let u = ({a = ({a = true , b = 1 }.b) , b = ({a = 1 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) , b = ({a = (let u = (unfold [ Rec X. X ] (fold [ Nat ] false )) in u) , b = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] false )) in (unfold [ Unit ] (fold [ Unit ] ({a = false , b = false }.b) ))) }.b) , c = (pred ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Bool . 0 )) ))) }.c) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Unit .x) true ) false) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false ))) )) ) (case <r = (fix (\x: Nat . ({a = 1 , b = true , c =  1 }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))
(( \f: Nat .((f (iszero (((\x: Rec X. X .\y: Bool .y) true ) (unfold [ Nat ] (fold [ Unit ] 0 )))) ) (unfold [ Unit ] (fold [ Nat ] (if ({a = (let u = 0 in u) , b = (let u = false in ({a = 0 , b = true , c =  1 }.b)) }.b) then (iszero 1) else ({a = (case <l = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.b)) )) ) ) (\a: Nat .\b: Rec X. X .b))
({a = (( \f: Bool .((f (let u = (let u = true in 0) in 1) ) ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = false }.a) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = (let u = (if true then false else true) in u) , b = ({a = (let u = false in u) , b = 0 }.b) }.a) , c =  (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Unit .y) false ) true) ) (((\x: Bool .\y: Bool .y) false ) 1)) ) (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Nat .a)) }.b)
((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) true ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b))) )) , b = (((\x: Bool .\y: Bool .x) (let u = 0 in (let u = false in false)) ) ({a = (fix (\x: Bool . 0 )) , b = (((\x: Nat .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) true) , c =  (let u = 1 in u) }.b)) , c = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = 0 }.b) )) ) (( \f: Nat .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Unit .\b: Nat .a)) }.c) ))
(((\x: Unit .\y: Unit .y) ({a = (( \f: Bool .((f (((\x: Nat .\y: Bool .y) (let u = true in (let u = true in u)) ) (succ 1)) ) ({a = (if false then (pred 1) else 1) , b = ({a = 0 , b = false , c =  0 }.b) }.a) ) ) (\a: Unit .\b: Bool .b)) , b = (( \f: Nat .((f (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) in (unfold [ Rec X. X ] (fold [ Unit ] false ))) ) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) ) (\a: Unit .\b: Bool .b)) }.b) ) (unfold [ Bool ] (fold [ Rec X. X ] (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) in (let u = true in false)) )))
({a = (if (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .x) false ) true) ) (( \f: Rec X. X .((f ({a = false , b = 1 }.a) ) (((\x: Nat .\y: Unit .x) true ) true) ) ) (\a: Bool .\b: Unit .a))) then (if ({a = 1 , b = false }.b) then ({a = true , b = 1 }.b) else (let u = 0 in 0)) else (( \f: Nat .((f ({a = (let u = true in u) , b = 1 }.b) ) (let u = (((\x: Nat .\y: Bool .y) true ) 0) in u) ) ) (\a: Bool .\b: Rec X. X .b))) , b = (let u = ({a = ({a = 1 , b = false , c = 1 }.c) , b = false }.b) in (( \f: Bool .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) (let u = 0 in false) ) ) (\a: Nat .\b: Rec X. X .b))) }.b)
(let u = (let u = ({a = ({a = 1 , b = 1 }.b) , b = ({a = 1 , b = true }.b) , c = ({a = 0 , b = 1 }.b) }.c) in ({a = (succ ({a = true , b = 0 }.b)) , b = (if true then 0 else 1) }.b)) in (pred (let u = ({a = (if ({a = false , b = 0 }.a) then false else (((\x: Rec X. X .\y: Bool .y) false ) false)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = true }.b) )) }.b) in (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 ))))))
(( \f: Bool .((f (( \f: Nat .((f ({a = false , b = 0 }.b) ) (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = (((\x: Nat .\y: Bool .x) ({a = 1 , b = 1 }.b) ) (iszero 0)) in u) ) ) (\a: Nat .\b: Bool .a))
(succ (( \f: Rec X. X .((f ({a = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in 0) , b = (if (((\x: Bool .\y: Bool .y) false ) true) then false else true) }.a) ) (let u = ({a = (let u = 1 in (pred 0)) , b = (fix (\x: Unit . 1 )) }.b) in (let u = (unfold [ Nat ] (fold [ Nat ] false )) in (( \f: Nat .((f 0 ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Unit .\b: Rec X. X .a)))) ) ) (\a: Bool .\b: Rec X. X .a)))
(iszero ({a = (let u = (if (fix (\x: Rec X. X . true )) then 1 else ({a = 1 , b = true , c = 1 }.c)) in u) , b = (fix (\x: Bool . (let u = ({a = 0 , b = false }.a) in (((\x: Nat .\y: Unit .y) true ) true)) )) }.a))
({a = (( \f: Rec X. X .((f (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (let u = false in (let u = true in true)) )) ) (fix (\x: Unit . (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b)) )) ) ) (\a: Unit .\b: Unit .a)) ) (case <r = ({a = 1 , b = false , c =  (((\x: Rec X. X .\y: Bool .y) true ) 1) }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = (case <r = (let u = false in (iszero 1)) > as Unit of < l = x > => x | < r = y > => y) , b = (pred 1) }.b) }.a)
(( \f: Bool .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in (let u = false in u)) )) ) (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Nat . false )) )) ) ) (\a: Unit .\b: Nat .b))
(pred (unfold [ Rec X. X ] (fold [ Bool ] ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (fix (\x: Bool . 0 )) }.b) )))
(( \f: Unit .((f ({a = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (((\x: Nat .\y: Nat .x) false ) true) , b = (fix (\x: Unit . 0 )) }.b) )) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )) in ({a = (((\x: Nat .\y: Bool .x) 0 ) false) , b = (((\x: Bool .\y: Unit .x) false ) false) , c = 1 }.c)) }.b) ) (( \f: Unit .((f (let u = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = (let u = false in u) }.b) in (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Bool .\y: Unit .y) true ) 1) ))) ) ({a = (( \f: Unit .((f (if false then true else false) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .a))
(( \f: Nat .((f (if (if true then ({a = 1 , b = true }.b) else false) then ({a = (fix (\x: Unit . ({a = 1 , b = true }.b) )) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.a) else ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = false }.b)) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Unit . false )) )) ) ({a = 1 , b = false }.b)) ) (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then (iszero (let u = (let u = 0 in 0) in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y))) else (((\x: Nat .\y: Nat .y) ({a = true , b = 1 }.a) ) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . false )) , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.b))) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Rec X. X .a))
(pred (( \f: Bool .((f ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (let u = 1 in u) }.b) ) (( \f: Nat .((f (( \f: Nat .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ) 0 ) ) (\a: Nat .\b: Nat .b)) ) (pred 1) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a)))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = true , b = 0 }.b) )) )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = 0 in u) )) ) ) (\a: Rec X. X .\b: Nat .b)) ))
(let u = (if (fix (\x: Unit . ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) )) then (let u = (((\x: Rec X. X .\y: Unit .y) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) (unfold [ Unit ] (fold [ Unit ] false ))) in (unfold [ Bool ] (fold [ Bool ] 0 ))) else (let u = (let u = (pred 0) in 1) in ({a = 0 , b = true , c = 0 }.c))) in (pred ({a = (fix (\x: Nat . (if true then ({a = 1 , b = false }.a) else 1) )) , b = (( \f: Nat .((f 1 ) (let u = false in 1) ) ) (\a: Unit .\b: Rec X. X .a)) }.b)))
(( \f: Unit .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .y) false ) 0) ) (case <l = ({a = 1 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) )) ) (case <l = (((\x: Nat .\y: Rec X. X .y) false ) ({a = 0 , b = true , c = 1 }.c)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a))
(pred ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (unfold [ Unit ] (fold [ Unit ] false )) }.a) , b = ({a = ({a = false , b = 0 }.a) , b = (let u = false in 0) }.a) }.a))
(unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Nat . true )) )) ))
({a = ({a = (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (succ ({a = (let u = 0 in u) , b = 0 }.b)) }.b) , b = (let u = (let u = ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (((\x: Rec X. X .\y: Nat .y) false ) 0) }.b) in u) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = 1 in true) ))) }.b)
(((\x: Unit .\y: Nat .x) ({a = (fix (\x: Nat . (( \f: Bool .((f ({a = 1 , b = true , c =  0 }.b) ) true ) ) (\a: Unit .\b: Bool .b)) )) , b = (( \f: Bool .((f (let u = (succ 0) in u) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .x) 0 ) false) )) ) ) (\a: Nat .\b: Unit .b)) }.a) ) ({a = ({a = (fix (\x: Nat . 1 )) , b = (unfold [ Nat ] (fold [ Nat ] true )) , c =  (let u = false in 1) }.b) , b = (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) (succ 1) ) ) (\a: Nat .\b: Unit .b)) ) ({a = 0 , b = true , c = ({a = 1 , b = true , c = 0 }.c) }.c) ) ) (\a: Bool .\b: Unit .b)) }.a))
(if ({a = ({a = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (iszero 1) , c = ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = 1 }.b) }.c) , b = (pred 0) }.b) , b = (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Bool .x) true ) true) ) ({a = ({a = 1 , b = true }.a) , b = (let u = true in false) }.b)) }.b) then (fix (\x: Nat . (if ({a = true , b = true }.b) then (((\x: Unit .\y: Bool .y) false ) 1) else (pred ({a = true , b = 1 }.b))) )) else (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = true in 0) ))))
({a = (( \f: Bool .((f ({a = ({a = 0 , b = 1 }.b) , b = (let u = true in 0) }.b) ) (unfold [ Bool ] (fold [ Nat ] 0 )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (iszero ({a = ({a = true , b = 1 }.b) , b = ({a = (let u = false in u) , b = 1 }.a) , c = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.c)) , c = (succ ({a = (succ 1) , b = (unfold [ Nat ] (fold [ Nat ] false )) , c = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.c)) }.c)
(case <r = ({a = (let u = (( \f: Bool .((f false ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Nat .b)) in u) , b = (let u = true in u) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ({a = (if false then 1 else 1) , b = 1 }.b) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , c = (let u = 1 in u) }.c) )) , b = (pred (( \f: Nat .((f 1 ) (((\x: Bool .\y: Rec X. X .y) true ) 1) ) ) (\a: Unit .\b: Bool .b))) }.b)
(let u = (fix (\x: Bool . (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)) ) (( \f: Rec X. X .((f (let u = true in u) ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Unit .a))) )) in (((\x: Nat .\y: Unit .y) (let u = (let u = 0 in u) in (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a))) ) ({a = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , b = 1 }.b) , b = (let u = 0 in u) }.b)))
(((\x: Nat .\y: Nat .y) (case <r = (let u = (let u = 0 in false) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . (( \f: Nat .((f (let u = true in 1) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .a)) )))
(((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .y) (iszero (fix (\x: Bool . 1 ))) ) (( \f: Bool .((f (if (((\x: Rec X. X .\y: Unit .x) true ) true) then true else (let u = true in true)) ) (let u = false in u) ) ) (\a: Unit .\b: Rec X. X .b))) ) ({a = (let u = (let u = true in u) in u) , b = ({a = true , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) }.b))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Nat .((f (succ (( \f: Nat .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a))) ) (if (fix (\x: Unit . (unfold [ Bool ] (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] false )) )) )) then (let u = false in (succ 0)) else (unfold [ Bool ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .x) 0 ) (iszero 0)) ))) ) ) (\a: Nat .\b: Rec X. X .b)) ))
(( \f: Unit .((f (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .x) (let u = ({a = false , b = 0 }.a) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) ) (if false then (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) else false)) ) ({a = (iszero 0) , b = true }.b) ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Nat .((f ({a = (( \f: Bool .((f ({a = 1 , b = false , c =  1 }.b) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Bool .\b: Bool .b)) , b = (let u = false in 0) }.a) ) ({a = (if (iszero 0) then ({a = 1 , b = true , c =  1 }.b) else (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .b))) , b = (let u = true in u) }.b) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Bool .\b: Unit .a))
(if (fix (\x: Bool . ({a = ({a = 0 , b = ({a = 1 , b = false , c =  0 }.b) , c =  0 }.b) , b = (fix (\x: Unit . (let u = true in 0) )) }.a) )) then (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = 0 , b = false }.a) , b = (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )) , c = (((\x: Unit .\y: Bool .x) 1 ) true) }.c) )) ) (fix (\x: Unit . ({a = false , b = 1 }.b) )) ) ) (\a: Bool .\b: Bool .a)) else ({a = (let u = 0 in u) , b = (((\x: Rec X. X .\y: Unit .y) (let u = true in u) ) ({a = true , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.a)) , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = false in 0) )) }.c))
(pred (if (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = true }.b) )) then (pred (((\x: Bool .\y: Rec X. X .x) (succ 1) ) false)) else (((\x: Bool .\y: Nat .x) ({a = false , b = 0 }.b) ) ({a = (((\x: Bool .\y: Bool .y) false ) 1) , b = (((\x: Unit .\y: Nat .x) true ) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b))) }.b))))
(let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Bool . true )) )) )) in (((\x: Bool .\y: Bool .y) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (let u = 1 in u) )) }.a) ) (pred 1)))
(unfold [ Nat ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) ({a = false , b = ({a = false , b = 0 }.a) }.b) ) ({a = (( \f: Unit .((f (if false then 0 else 1) ) (succ 1) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = false in u) }.b)) ))
({a = ({a = (( \f: Rec X. X .((f (let u = 0 in false) ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .b)) )) }.b) , b = (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Rec X. X .x) (if false then false else false) ) (iszero 1)) ) (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .b)) in (fix (\x: Nat . (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) )))) }.b)
(if (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Bool .x) false ) false) ) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true)) , b = ({a = true , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b) }.b) in ({a = (case <l = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = 1 in ({a = false , b = false }.b)) , c =  (let u = (((\x: Unit .\y: Nat .x) 1 ) true) in u) }.b)) then (unfold [ Nat ] (fold [ Nat ] (((\x: Unit .\y: Unit .x) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) (let u = false in u)) )) else ({a = ({a = (let u = false in 0) , b = ({a = 0 , b = false }.b) , c = (( \f: Unit .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b)) }.c) , b = (if ({a = (case <l = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) false ) ) (\a: Unit .\b: Nat .b)) }.b) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = false , b = true }.b) )) else (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) false ) true) )))) , c = ({a = (((\x: Unit .\y: Nat .y) true ) ({a = false , b = true }.b)) , b = (( \f: Rec X. X .((f 1 ) (if false then 0 else 0) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) }.c))
(fix (\x: Rec X. X . ({a = (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = true }.a) ) ({a = 1 , b = true , c =  1 }.b)) , b = (((\x: Bool .\y: Unit .y) true ) false) }.a) ))
({a = (((\x: Unit .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Unit ] (succ 1) )) ) ({a = 1 , b = ({a = 1 , b = false , c =  0 }.b) , c =  (((\x: Bool .\y: Rec X. X .y) true ) 1) }.b)) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) )) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Nat .\y: Unit .y) false ) false) )) }.b) }.a)
({a = (let u = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) in (((\x: Rec X. X .\y: Bool .y) false ) false)) in u) , b = (case <l = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) ))) > as Unit of < l = x > => x | < r = y > => y) }.b)
(let u = (fix (\x: Nat . (case <r = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) )) in (pred (unfold [ Unit ] (fold [ Unit ] 1 ))))
(pred (( \f: Rec X. X .((f ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = (let u = 0 in true) }.a) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) (let u = 0 in false) ) (fix (\x: Bool . 0 ))) ) ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (if (fix (\x: Bool . true )) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) else 1) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .b)))
(((\x: Rec X. X .\y: Nat .x) ({a = (if (let u = (pred 0) in (let u = 0 in false)) then (let u = (if true then 0 else (fix (\x: Rec X. X . 0 ))) in ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .a)) , b = 0 }.b)) else ({a = (let u = 0 in (let u = 1 in 1)) , b = (( \f: Bool .((f (((\x: Nat .\y: Nat .y) false ) 1) ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b)) , b = (((\x: Nat .\y: Rec X. X .x) (if ({a = (let u = 1 in 0) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , c =  (let u = false in 0) }.b) then (((\x: Nat .\y: Nat .x) (let u = true in false) ) (((\x: Unit .\y: Nat .y) true ) false)) else ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = true , c =  (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b)) ) (case <r = (((\x: Unit .\y: Bool .y) true ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y)) }.a) ) (((\x: Rec X. X .\y: Unit .x) ({a = (iszero 0) , b = (let u = (succ 1) in u) }.a) ) (case <r = (((\x: Nat .\y: Rec X. X .y) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) ) (fix (\x: Bool . (if true then false else false) ))) > as Rec X. X of < l = x > => x | < r = y > => y)))
({a = (let u = ({a = (iszero 0) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) in (iszero (let u = true in (if false then 0 else 1)))) , b = (( \f: Bool .((f (let u = (fix (\x: Bool . 1 )) in u) ) (((\x: Unit .\y: Bool .x) (let u = false in 1) ) (((\x: Unit .\y: Nat .x) (fix (\x: Nat . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)))) ) ) (\a: Bool .\b: Rec X. X .b)) }.b)
(case <l = ({a = (succ ({a = 0 , b = 0 }.b)) , b = (let u = (((\x: Nat .\y: Nat .y) true ) true) in ({a = true , b = ({a = false , b = 0 }.b) }.a)) }.a) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (let u = (let u = ({a = 0 , b = 0 }.b) in u) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) ))
(let u = ({a = ({a = (fix (\x: Unit . true )) , b = (pred 0) }.a) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = 0 }.b) }.a) in u)
({a = (( \f: Bool .((f (( \f: Nat .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) false ) ) (\a: Bool .\b: Unit .b)) ) ({a = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , b = 0 }.a) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Unit .((f (case <l = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = true , c = 1 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = ({a = 1 , b = false }.b) , c = (unfold [ Unit ] (fold [ Bool ] 0 )) }.c) ) ) (\a: Bool .\b: Bool .b)) }.b)
({a = (let u = (let u = (unfold [ Bool ] (fold [ Rec X. X ] true )) in ({a = (succ 0) , b = ({a = 1 , b = false }.b) , c = (pred 0) }.c)) in ({a = ({a = (if true then true else false) , b = (let u = 0 in u) }.b) , b = (fix (\x: Rec X. X . (((\x: Bool .\y: Nat .x) true ) true) )) , c = (let u = 1 in u) }.c)) , b = (( \f: Unit .((f ({a = ({a = true , b = true }.b) , b = 1 }.a) ) (((\x: Unit .\y: Nat .x) ({a = 1 , b = false }.b) ) (((\x: Nat .\y: Unit .y) true ) false)) ) ) (\a: Rec X. X .\b: Bool .b)) , c = ({a = (if (let u = (iszero 0) in u) then ({a = 0 , b = true }.b) else ({a = (let u = 1 in 0) , b = (fix (\x: Unit . true )) }.b)) , b = (case <l = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.b) }.c)
({a = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (case <r = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) )) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f (let u = false in 0) ) 0 ) ) (\a: Bool .\b: Unit .b)) ))) , b = ({a = ({a = ({a = false , b = 0 }.a) , b = ({a = 0 , b = false }.a) }.a) , b = (case <l = (succ ({a = 0 , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y) }.a) , c =  (let u = (unfold [ Bool ] (fold [ Rec X. X ] (let u = true in ({a = false , b = true }.b)) )) in ({a = ({a = 0 , b = false }.a) , b = ({a = 0 , b = (let u = false in 1) }.b) }.b)) }.b)
(let u = (((\x: Unit .\y: Rec X. X .x) (let u = (let u = (pred 1) in u) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) (unfold [ Unit ] (fold [ Unit ] ({a = true , b = true }.b) ))) in (fix (\x: Bool . (if (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a)) then ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b)) )) else (case <r = (((\x: Unit .\y: Rec X. X .x) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y)) )))
(succ (((\x: Nat .\y: Rec X. X .x) (pred (succ 1)) ) (let u = ({a = (succ 0) , b = true , c =  0 }.b) in u)))
(((\x: Rec X. X .\y: Bool .y) (if (iszero ({a = 1 , b = true , c = 1 }.c)) then (( \f: Unit .((f (iszero 1) ) (fix (\x: Bool . false )) ) ) (\a: Nat .\b: Nat .b)) else ({a = ({a = 0 , b = 0 }.b) , b = ({a = false , b = 1 }.a) }.b)) ) (( \f: Nat .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (succ 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(let u = (succ (if ({a = 1 , b = false , c =  (pred 0) }.b) then (let u = (fix (\x: Rec X. X . 1 )) in ({a = 0 , b = 1 }.b)) else (((\x: Unit .\y: Nat .y) false ) 1))) in (if (if false then false else (let u = 1 in false)) then (case <r = (fix (\x: Rec X. X . true )) > as Bool of < l = x > => x | < r = y > => y) else (case <r = (((\x: Rec X. X .\y: Unit .x) false ) (((\x: Nat .\y: Rec X. X .y) false ) true)) > as Unit of < l = x > => x | < r = y > => y)))
(fix (\x: Bool . ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) (fix (\x: Rec X. X . false ))) in (unfold [ Unit ] (fold [ Bool ] 0 ))) , b = ({a = false , b = 0 }.a) }.a) ))
(((\x: Unit .\y: Rec X. X .y) ({a = (((\x: Bool .\y: Bool .x) ({a = 0 , b = false }.b) ) (fix (\x: Nat . (let u = true in true) ))) , b = (let u = ({a = ({a = 0 , b = 0 }.b) , b = (let u = 1 in 1) }.b) in u) }.a) ) (fix (\x: Rec X. X . ({a = 0 , b = false , c = 1 }.c) )))
(case <l = (let u = (if (((\x: Rec X. X .\y: Rec X. X .x) false ) false) then (if (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) then 1 else ({a = 0 , b = false }.a)) else (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b))) in u) > as Bool of < l = x > => x | < r = y > => y)
(case <r = (unfold [ Unit ] (fold [ Bool ] ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b)) , c =  ({a = 0 , b = (((\x: Nat .\y: Rec X. X .x) false ) false) , c = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.c) }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Rec X. X .y) (let u = (( \f: Nat .((f ({a = 1 , b = false }.b) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .b)) in u) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (succ (let u = ({a = 0 , b = 1 }.b) in u)) )))
({a = (fix (\x: Unit . (succ (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a))) )) , b = (fix (\x: Unit . (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) true ) false) ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Unit .b)) )) }.a)
({a = ({a = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) in (if false then 0 else 0)) , b = (( \f: Bool .((f ({a = 1 , b = false , c =  1 }.b) ) (( \f: Nat .((f (((\x: Unit .\y: Nat .y) true ) true) ) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a)) , c = ({a = ({a = 1 , b = true }.a) , b = (fix (\x: Rec X. X . (if true then false else false) )) , c = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) }.c) }.c) , b = (let u = (case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) > as Unit of < l = x > => x | < r = y > => y) in u) , c =  (let u = ({a = (let u = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) in u) , b = (succ 0) }.b) in u) }.b)
(( \f: Rec X. X .((f (let u = ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = (iszero 0) }.b) in (((\x: Bool .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) (unfold [ Unit ] (fold [ Nat ] true )) ) (unfold [ Bool ] (fold [ Unit ] true ))) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (case <l = ({a = 0 , b = false , c = 1 }.c) > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Rec X. X .\b: Bool .b))
({a = (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) (((\x: Bool .\y: Unit .x) false ) true)) ) (( \f: Nat .((f 1 ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Rec X. X .b))) )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (( \f: Rec X. X .((f (let u = false in (((\x: Unit .\y: Rec X. X .x) false ) false)) ) (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) (let u = true in true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Bool .b)) )) }.b)
(let u = (let u = (unfold [ Bool ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) )) in u) in (let u = (let u = (((\x: Unit .\y: Nat .x) (let u = false in true) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) in (case <l = ({a = 1 , b = false }.a) > as Bool of < l = x > => x | < r = y > => y)) in (if (let u = true in true) then (let u = 0 in false) else (((\x: Bool .\y: Unit .x) false ) (let u = true in u)))))
({a = ({a = (let u = (let u = true in u) in ({a = 1 , b = 0 }.b)) , b = (fix (\x: Rec X. X . (iszero 1) )) , c =  ({a = (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b))) , b = (((\x: Unit .\y: Rec X. X .x) (((\x: Unit .\y: Unit .y) true ) true) ) true) }.a) }.b) , b = (succ (((\x: Nat .\y: Unit .x) 1 ) true)) }.b)
(( \f: Nat .((f ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 1 in true) )) , b = ({a = 0 , b = (succ 0) }.b) }.b) ) ({a = (succ ({a = 1 , b = true , c = 0 }.c)) , b = (( \f: Bool .((f (let u = false in false) ) (let u = false in false) ) ) (\a: Nat .\b: Rec X. X .b)) , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = true in 1) )) }.c) ) ) (\a: Bool .\b: Nat .a))
({a = ({a = (((\x: Bool .\y: Unit .x) (let u = (if true then 1 else 0) in u) ) (((\x: Unit .\y: Bool .y) false ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )))) , b = (((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Rec X. X .y) false ) true) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) }.b) , b = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) , b = (unfold [ Bool ] (fold [ Unit ] (if (((\x: Bool .\y: Rec X. X .y) false ) false) then false else (iszero 0)) )) }.b) }.b)
(if (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .x) true ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true ))) in ({a = ({a = false , b = (((\x: Bool .\y: Unit .y) true ) 1) }.a) , b = (((\x: Nat .\y: Unit .x) ({a = 1 , b = false }.a) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) true)) }.a)) in u) then (((\x: Nat .\y: Unit .x) (iszero (pred 0)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ))) else (( \f: Unit .((f (case <r = (unfold [ Bool ] (fold [ Bool ] true )) > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . (let u = 1 in true) )) ) ) (\a: Nat .\b: Bool .a)))
(unfold [ Bool ] (fold [ Bool ] (fix (\x: Rec X. X . (( \f: Unit .((f (((\x: Unit .\y: Unit .y) true ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) ) (( \f: Bool .((f (((\x: Unit .\y: Unit .x) 1 ) (((\x: Nat .\y: Bool .x) true ) true)) ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Nat .a)) )) ))
(iszero ({a = ({a = (let u = true in false) , b = ({a = false , b = 0 }.b) }.b) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = false , b = true }.b) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .b)) }.b) )) }.a))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (succ ({a = (let u = false in 0) , b = ({a = 1 , b = (let u = true in u) }.b) , c = ({a = ({a = 0 , b = false , c = 0 }.c) , b = false , c = (fix (\x: Rec X. X . 0 )) }.c) }.c)) ))
(let u = (let u = (case <l = ({a = false , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y) in (let u = 0 in u)) in u)
(let u = (let u = (succ (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ))) in u) in u)
(succ (fix (\x: Bool . (let u = (iszero 1) in (let u = false in 1)) )))
(let u = ({a = ({a = false , b = 1 }.a) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (if true then 0 else 0) )) }.b) in u)
(let u = (pred (case <l = (((\x: Bool .\y: Rec X. X .x) (let u = 0 in 0) ) (((\x: Rec X. X .\y: Bool .x) true ) true)) > as Rec X. X of < l = x > => x | < r = y > => y)) in (pred (let u = (case <l = (let u = false in 0) > as Nat of < l = x > => x | < r = y > => y) in (fix (\x: Nat . 0 )))))
(succ (((\x: Rec X. X .\y: Bool .x) (fix (\x: Nat . ({a = 1 , b = 1 }.b) )) ) (((\x: Nat .\y: Rec X. X .y) true ) (iszero 1))))
(((\x: Nat .\y: Rec X. X .y) (fix (\x: Rec X. X . (let u = (fix (\x: Rec X. X . (fix (\x: Nat . 0 )) )) in (iszero ({a = 0 , b = true }.a))) )) ) (pred (let u = ({a = 1 , b = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .b)) }.a) in u)))
(let u = (((\x: Rec X. X .\y: Nat .y) (fix (\x: Nat . false )) ) (((\x: Nat .\y: Bool .y) true ) ({a = 0 , b = true , c =  0 }.b))) in (( \f: Nat .((f ({a = (((\x: Bool .\y: Nat .y) true ) false) , b = (((\x: Rec X. X .\y: Unit .y) true ) false) }.b) ) (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) true ) false) ) (let u = false in false) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Unit .b)))
(case <l = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (( \f: Nat .((f ({a = 1 , b = true , c = 1 }.c) ) 1 ) ) (\a: Bool .\b: Unit .a)) )) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Nat . (case <r = (( \f: Unit .((f (if false then false else false) ) (iszero (fix (\x: Unit . 0 ))) ) ) (\a: Unit .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) ))
(unfold [ Nat ] (fold [ Bool ] ({a = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) in (((\x: Unit .\y: Nat .x) 0 ) (((\x: Bool .\y: Rec X. X .y) false ) true))) , b = (case <r = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .y) true ) true) ) ({a = 0 , b = true }.b) ) ) (\a: Bool .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) , c = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false , c = 0 }.c) }.b) }.c) ))
(((\x: Unit .\y: Rec X. X .y) (iszero (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in 0)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Unit .((f ({a = false , b = true }.b) ) (let u = false in u) ) ) (\a: Unit .\b: Rec X. X .b)) )))
(let u = (succ ({a = (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) true ) true) ) true ) ) (\a: Bool .\b: Nat .b)) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.b)) in (let u = (let u = ({a = 1 , b = false }.a) in u) in ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Rec X. X . true )) ))))
(pred (((\x: Unit .\y: Nat .x) (fix (\x: Nat . (((\x: Unit .\y: Bool .x) (if true then 1 else 0) ) ({a = false , b = false }.b)) )) ) (fix (\x: Rec X. X . (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ))))
(case <l = (pred (((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Bool ] 1 )) ) ({a = 0 , b = true }.b))) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Nat . ({a = (fix (\x: Nat . (fix (\x: Rec X. X . ({a = 0 , b = false , c = 0 }.c) )) )) , b = (iszero (((\x: Rec X. X .\y: Unit .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) 1)) , c =  ({a = (succ (((\x: Rec X. X .\y: Bool .y) false ) 0)) , b = (let u = 1 in (if false then 0 else 1)) }.b) }.b) ))
(( \f: Unit .((f (let u = (let u = (let u = (((\x: Nat .\y: Rec X. X .y) true ) 0) in (let u = true in u)) in (((\x: Rec X. X .\y: Nat .y) (let u = true in false) ) 0)) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (if true then 1 else 0) )) ) ) (\a: Rec X. X .\b: Bool .a))
(let u = (let u = (fix (\x: Rec X. X . (let u = true in true) )) in (( \f: Bool .((f (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) (if (unfold [ Bool ] (fold [ Nat ] true )) then (let u = (((\x: Nat .\y: Rec X. X .x) 1 ) false) in false) else (((\x: Nat .\y: Nat .x) false ) true)) ) ) (\a: Unit .\b: Nat .b))) in (case <l = (succ ({a = 0 , b = ({a = 0 , b = false , c =  0 }.b) , c = 1 }.c)) > as Unit of < l = x > => x | < r = y > => y))
(unfold [ Unit ] (fold [ Unit ] (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) )) then (unfold [ Unit ] (fold [ Bool ] 0 )) else (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .x) 0 ) true) ))) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] (let u = (if (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) then 1 else 0) in (iszero 0)) )) ))
({a = (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Rec X. X .y) (let u = false in true) ) (let u = 0 in false)) ) ({a = ({a = 1 , b = true }.b) , b = 0 }.b)) ) (iszero (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = true , c = 0 }.c) )))) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = (let u = true in u) in ({a = 1 , b = false }.b)) )) }.b)
({a = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) true ) true) )) > as Unit of < l = x > => x | < r = y > => y) )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Nat .((f ({a = false , b = 0 }.b) ) (pred (fix (\x: Rec X. X . 1 ))) ) ) (\a: Unit .\b: Unit .a)) )) }.b)
(case <r = (( \f: Unit .((f (if (((\x: Unit .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ({a = 1 , b = false }.b)) then (if (let u = true in true) then ({a = 0 , b = false , c =  0 }.b) else true) else (( \f: Bool .((f (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] false )) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Nat .a)) ) (unfold [ Rec X. X ] (fold [ Nat ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Bool .b))) ) (let u = (let u = true in u) in u) ) ) (\a: Bool .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f (unfold [ Nat ] (fold [ Nat ] (( \f: Nat .((f (fix (\x: Unit . (let u = 1 in true) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Bool .b)) )) ) (let u = (((\x: Unit .\y: Bool .x) 0 ) false) in (((\x: Nat .\y: Unit .y) false ) false)) ) ) (\a: Bool .\b: Bool .b)) ))
(succ (fix (\x: Rec X. X . (((\x: Bool .\y: Bool .x) (((\x: Bool .\y: Bool .y) false ) 1) ) ({a = 0 , b = false }.b)) )))
(( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = true , b = 1 }.b) , b = (unfold [ Unit ] (fold [ Unit ] 0 )) }.b) )) ) (unfold [ Unit ] (fold [ Nat ] (let u = (if false then 1 else 0) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 ))) )) ) ) (\a: Unit .\b: Nat .a))
({a = (unfold [ Nat ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] ({a = true , b = (if false then 1 else 0) }.b) )) )) , b = ({a = ({a = (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Nat .((f (pred 1) ) (pred 1) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Rec X. X .((f false ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) ) (\a: Nat .\b: Unit .b)) }.a) , b = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = true , c =  ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) }.b)) , c =  (((\x: Bool .\y: Rec X. X .x) (fix (\x: Rec X. X . (succ 1) )) ) (((\x: Nat .\y: Bool .y) false ) (unfold [ Unit ] (fold [ Nat ] true )))) }.b) }.b)
(let u = (let u = ({a = (unfold [ Bool ] (fold [ Bool ] 1 )) , b = (unfold [ Bool ] (fold [ Bool ] false )) , c = (succ 0) }.c) in (if ({a = 0 , b = false , c =  0 }.b) then true else true)) in u)
({a = (let u = (( \f: Unit .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) ) (let u = false in (pred 1)) ) ) (\a: Unit .\b: Unit .a)) in (fix (\x: Nat . (succ ({a = false , b = 1 }.b)) ))) , b = (unfold [ Unit ] (fold [ Bool ] (case <r = (let u = (pred 1) in (unfold [ Bool ] (fold [ Bool ] true ))) > as Bool of < l = x > => x | < r = y > => y) )) , c = (fix (\x: Bool . (if ({a = true , b = ({a = 1 , b = 1 }.b) }.a) then (unfold [ Nat ] (fold [ Nat ] 1 )) else ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 ))) )) }.c)
({a = (unfold [ Unit ] (fold [ Bool ] (if true then false else (let u = true in u)) )) , b = (( \f: Unit .((f (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) )) ) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = ({a = true , b = 1 }.a) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in ({a = 0 , b = true }.b)) ) ) (\a: Unit .\b: Nat .a)) }.b)
(((\x: Nat .\y: Unit .y) ({a = (let u = ({a = 0 , b = true }.b) in u) , b = (pred (let u = 0 in u)) }.a) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (((\x: Nat .\y: Rec X. X .x) true ) true) in (pred 0)) )))
(unfold [ Nat ] (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .x) true ) ({a = 0 , b = false }.b)) )) ))
({a = (unfold [ Nat ] (fold [ Nat ] (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) , b = (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false ))) )) }.b)
(fix (\x: Rec X. X . (( \f: Bool .((f ({a = (fix (\x: Nat . true )) , b = (succ 1) }.a) ) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) , c =  ({a = 1 , b = false , c = 1 }.c) }.b) ) ) (\a: Nat .\b: Bool .b)) ))
(let u = (( \f: Bool .((f (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) ({a = true , b = true }.b) ) (if (iszero 1) then (((\x: Nat .\y: Nat .y) false ) true) else (if true then true else false))) ) ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = false }.b) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Unit .\y: Bool .x) ({a = 1 , b = true }.b) ) (let u = true in u)) ) ) (\a: Nat .\b: Bool .a)) in ({a = (succ (succ ({a = 0 , b = false , c = 0 }.c))) , b = (case <r = ({a = 0 , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) , c = ({a = (let u = 0 in u) , b = ({a = 0 , b = 0 }.b) }.b) }.c))
(iszero ({a = (if (( \f: Rec X. X .((f (if (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .b)) then false else true) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Bool .a)) then ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = (( \f: Nat .((f ({a = 0 , b = false , c =  1 }.b) ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) else (let u = 1 in false)) , b = (let u = (((\x: Rec X. X .\y: Nat .y) true ) 0) in u) }.b))
(((\x: Bool .\y: Rec X. X .x) (( \f: Nat .((f (let u = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (pred (if false then 1 else 1)) }.b) in (((\x: Rec X. X .\y: Nat .y) (fix (\x: Bool . true )) ) (unfold [ Rec X. X ] (fold [ Nat ] true )))) ) (( \f: Unit .((f (iszero ({a = true , b = 0 }.b)) ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Bool .\b: Unit .b)) ) (if (case <r = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y) then (iszero (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) else (fix (\x: Bool . (( \f: Bool .((f (((\x: Unit .\y: Bool .y) true ) true) ) (((\x: Rec X. X .\y: Unit .x) true ) false) ) ) (\a: Rec X. X .\b: Unit .a)) ))))
(( \f: Unit .((f (let u = (((\x: Rec X. X .\y: Unit .x) true ) true) in (((\x: Nat .\y: Unit .y) ({a = false , b = false }.b) ) (((\x: Rec X. X .\y: Nat .x) false ) false))) ) (fix (\x: Bool . (fix (\x: Rec X. X . (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .b)) )) )) ) ) (\a: Rec X. X .\b: Unit .b))
(pred (fix (\x: Bool . ({a = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero 0) , c =  (let u = false in 0) }.b) , b = ({a = true , b = ({a = false , b = 1 }.b) }.b) }.b) )))
(iszero (fix (\x: Nat . (let u = 0 in u) )))
(if (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) )) ) (((\x: Rec X. X .\y: Unit .y) (unfold [ Unit ] (fold [ Nat ] true )) ) (((\x: Unit .\y: Nat .y) true ) (case <r = true > as Bool of < l = x > => x | < r = y > => y))) ) ) (\a: Unit .\b: Rec X. X .b)) then (let u = (if (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] false )) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Unit .b)) then ({a = (let u = ({a = true , b = true }.b) in 1) , b = (fix (\x: Bool . true )) }.a) else ({a = ({a = 0 , b = false }.b) , b = 0 }.b)) in u) else (let u = ({a = 0 , b = ({a = 0 , b = true }.b) }.a) in u))
(case <r = (( \f: Nat .((f (((\x: Bool .\y: Bool .y) (let u = false in true) ) (unfold [ Nat ] (fold [ Rec X. X ] true ))) ) (iszero ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  ({a = 0 , b = 1 }.b) }.b) , c = ({a = 0 , b = false , c = 0 }.c) }.c)) ) ) (\a: Bool .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y)
(case <l = ({a = ({a = (let u = true in true) , b = (let u = 0 in u) }.b) , b = (((\x: Nat .\y: Nat .y) (unfold [ Unit ] (fold [ Nat ] true )) ) ({a = false , b = false }.b)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Unit .y) ({a = (let u = 0 in 0) , b = (((\x: Rec X. X .\y: Bool .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false , c =  0 }.b)) , c =  (case <l = (fix (\x: Unit . (pred 0) )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) 1 ) true) ) (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)))
({a = (let u = ({a = (if false then 0 else (let u = false in 0)) , b = (let u = (succ 1) in false) , c =  ({a = ({a = true , b = 1 }.b) , b = (( \f: Rec X. X .((f ({a = false , b = false }.b) ) true ) ) (\a: Bool .\b: Unit .a)) }.a) }.b) in ({a = ({a = true , b = 0 }.b) , b = (if (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) then (let u = 1 in true) else true) }.a)) , b = (((\x: Rec X. X .\y: Unit .x) ({a = (unfold [ Bool ] (fold [ Unit ] true )) , b = (let u = 0 in u) }.a) ) (((\x: Rec X. X .\y: Unit .y) (let u = 0 in (unfold [ Bool ] (fold [ Bool ] false ))) ) (( \f: Nat .((f ({a = 0 , b = false , c =  0 }.b) ) true ) ) (\a: Unit .\b: Nat .b)))) }.b)
(if ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = (let u = true in 0) , b = true }.b) )) then (( \f: Unit .((f (( \f: Nat .((f (if (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) then (iszero 1) else (unfold [ Rec X. X ] (fold [ Bool ] true ))) ) (let u = (( \f: Unit .((f ({a = 0 , b = true }.b) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ({a = 0 , b = false }.b)) ) ) (\a: Unit .\b: Nat .b)) ) (((\x: Bool .\y: Rec X. X .x) (let u = false in u) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (if false then false else true) ))) ) ) (\a: Bool .\b: Bool .a)) else (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) ({a = false , b = 0 }.a) ) (( \f: Unit .((f (case <r = (iszero 0) > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = false , c =  1 }.b) )) ) ) (\a: Unit .\b: Nat .a))) ) ({a = (fix (\x: Nat . ({a = 1 , b = 1 }.b) )) , b = (let u = true in u) }.b) ) ) (\a: Nat .\b: Unit .b)))
({a = ({a = ({a = ({a = true , b = ({a = 0 , b = true }.b) }.b) , b = (fix (\x: Nat . ({a = false , b = 0 }.b) )) }.b) , b = (fix (\x: Rec X. X . (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) in true) )) , c = (( \f: Bool .((f (unfold [ Unit ] (fold [ Unit ] 0 )) ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Bool .a)) }.c) , b = (iszero (if (((\x: Rec X. X .\y: Unit .y) true ) true) then (let u = true in 0) else 0)) , c =  (case <l = ({a = (fix (\x: Bool . 1 )) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = true in u) )) > as Nat of < l = x > => x | < r = y > => y)
(let u = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) , b = (case <r = (unfold [ Bool ] (fold [ Rec X. X ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in (let u = ({a = ({a = true , b = 0 }.a) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.a) in u))
((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) , b = 1 }.a) , b = (case <l = (let u = 0 in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 ))) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in u) ))
(( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .x) (let u = 1 in (let u = true in false)) ) ({a = (if true then false else false) , b = (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) in (pred 1)) }.a)) )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ({a = 0 , b = 0 }.b) , b = ({a = 1 , b = true , c =  0 }.b) }.b) )) ) ) (\a: Bool .\b: Nat .a))
(let u = (if ({a = (pred 1) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) (let u = false in u)) }.b) then (( \f: Unit .((f (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = (((\x: Nat .\y: Bool .y) true ) true) , b = (succ 0) }.a) ) ) (\a: Bool .\b: Unit .b)) else (fix (\x: Unit . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ))) in (fix (\x: Bool . (((\x: Nat .\y: Rec X. X .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (case <l = (((\x: Rec X. X .\y: Unit .y) false ) 1) > as Bool of < l = x > => x | < r = y > => y)) )))
(fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Unit ] true )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ))) ))
(fix (\x: Nat . (case <l = (((\x: Bool .\y: Bool .x) (let u = 0 in 1) ) ({a = false , b = false }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(( \f: Rec X. X .((f ({a = (if (let u = 1 in false) then (let u = 0 in 1) else (fix (\x: Unit . 1 ))) , b = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (iszero 0) )) in (((\x: Bool .\y: Unit .y) (let u = true in false) ) (let u = false in 0))) }.b) ) ({a = ({a = (if (( \f: Nat .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) (let u = true in u) ) ) (\a: Nat .\b: Unit .b)) then ({a = false , b = 1 }.a) else (fix (\x: Nat . true ))) , b = (fix (\x: Bool . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) }.b) , b = (let u = ({a = 1 , b = true }.a) in u) }.b) ) ) (\a: Bool .\b: Bool .b))
(iszero (((\x: Nat .\y: Bool .x) (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in u) ) (fix (\x: Rec X. X . ({a = 1 , b = true , c =  0 }.b) ))))
(unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f (let u = ({a = (fix (\x: Bool . false )) , b = 0 }.b) in (let u = 1 in true)) ) (fix (\x: Bool . (let u = (let u = false in true) in u) )) ) ) (\a: Nat .\b: Rec X. X .b)) ))
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Nat . ({a = ({a = false , b = 0 }.b) , b = ({a = 1 , b = true }.b) , c = 0 }.c) )) ))
(succ ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (case <l = ({a = 0 , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) )))
(( \f: Bool .((f (fix (\x: Rec X. X . (((\x: Unit .\y: Nat .x) (let u = false in u) ) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a))) )) ) (((\x: Bool .\y: Nat .x) (if (((\x: Rec X. X .\y: Rec X. X .x) true ) false) then ({a = true , b = ({a = 1 , b = false , c =  1 }.b) }.b) else (let u = true in u)) ) ({a = (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) false ) 1) )) , b = (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = false }.b) )) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
({a = (((\x: Unit .\y: Nat .x) ({a = ({a = (succ (let u = 0 in 1)) , b = (if true then false else true) }.a) , b = (let u = (if false then false else true) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) ) ({a = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 1 in true) , c =  ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = true }.b) )) }.b)) , b = (fix (\x: Unit . (( \f: Nat .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (iszero 0) ) ) (\a: Nat .\b: Bool .a)) )) , c =  ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = ({a = (let u = 1 in u) , b = (succ ({a = true , b = 0 }.b)) }.b) > as Bool of < l = x > => x | < r = y > => y) )) }.b)
({a = (let u = (((\x: Bool .\y: Nat .x) (iszero (let u = false in 0)) ) ({a = 0 , b = true }.b)) in (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = 1 , b = false }.a) , b = ({a = 1 , b = false }.b) , c = 1 }.c) )) ) (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Nat .x) (succ 0) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b))) ) (let u = false in (((\x: Rec X. X .\y: Unit .y) false ) false))) ) ) (\a: Unit .\b: Rec X. X .a))) , b = (((\x: Nat .\y: Unit .x) (case <r = (let u = 0 in ({a = 0 , b = true , c =  0 }.b)) > as Nat of < l = x > => x | < r = y > => y) ) (case <r = ({a = 1 , b = true , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) , c =  (( \f: Rec X. X .((f (pred (let u = (unfold [ Bool ] (fold [ Unit ] 0 )) in 1)) ) (let u = 0 in u) ) ) (\a: Unit .\b: Bool .a)) }.b)
(if ({a = (((\x: Unit .\y: Bool .x) (fix (\x: Bool . 0 )) ) (((\x: Nat .\y: Unit .y) false ) true)) , b = (((\x: Nat .\y: Bool .x) (let u = (if true then false else false) in (unfold [ Rec X. X ] (fold [ Bool ] true ))) ) (let u = 0 in true)) , c =  (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true , c = 0 }.c)) )) }.b) then (let u = ({a = (if ({a = false , b = 1 }.a) then (let u = 0 in true) else (fix (\x: Rec X. X . false ))) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) }.b) in (fix (\x: Nat . (let u = (fix (\x: Bool . (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) )) in u) ))) else (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (succ 1) , b = (if (let u = (succ 0) in (fix (\x: Bool . false ))) then (case <r = (iszero 0) > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = false , b = 1 }.a)) , c = (succ 0) }.c) )))
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) )) )) , b = (iszero (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )))) , c =  (pred (if (case <r = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) then (fix (\x: Rec X. X . 1 )) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) }.b)
({a = (succ ({a = (let u = ({a = ({a = 0 , b = false , c = 1 }.c) , b = false , c =  1 }.b) in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (fix (\x: Nat . (((\x: Nat .\y: Unit .y) true ) true) )) }.a)) , b = (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Unit .y) (((\x: Unit .\y: Bool .y) false ) false) ) (((\x: Unit .\y: Nat .x) true ) true)) ) ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) true) , b = (iszero (((\x: Bool .\y: Nat .y) false ) 1)) }.b)) , c =  ({a = (fix (\x: Rec X. X . ({a = 1 , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) )) , b = (case <l = (( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] 1 )) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b)
(((\x: Rec X. X .\y: Nat .y) (fix (\x: Nat . (let u = ({a = (fix (\x: Rec X. X . false )) , b = true }.b) in (let u = false in true)) )) ) (pred (case <l = (let u = (pred 1) in u) > as Rec X. X of < l = x > => x | < r = y > => y)))
(pred (((\x: Unit .\y: Nat .x) (fix (\x: Nat . 0 )) ) ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = 0 }.a)))
(((\x: Bool .\y: Nat .y) ({a = (if ({a = true , b = false }.b) then (((\x: Bool .\y: Rec X. X .y) true ) true) else (((\x: Unit .\y: Rec X. X .y) false ) false)) , b = (( \f: Bool .((f (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) in (pred 1)) ) (pred (fix (\x: Rec X. X . 0 ))) ) ) (\a: Rec X. X .\b: Unit .b)) }.a) ) (unfold [ Bool ] (fold [ Bool ] (let u = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .b)) in true) )))
({a = (((\x: Nat .\y: Nat .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) ) (unfold [ Nat ] (fold [ Nat ] (if true then false else false) ))) , b = ({a = (( \f: Unit .((f (let u = 1 in true) ) false ) ) (\a: Bool .\b: Bool .a)) , b = (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f true ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = (fix (\x: Rec X. X . 0 )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) }.b) }.b) ))
(let u = (fix (\x: Nat . ({a = ({a = 1 , b = false , c =  1 }.b) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) )) in (if (((\x: Nat .\y: Bool .x) false ) true) then (((\x: Bool .\y: Unit .y) ({a = false , b = 1 }.a) ) (((\x: Rec X. X .\y: Unit .x) 1 ) false)) else ({a = 1 , b = false , c = 0 }.c)))
(( \f: Rec X. X .((f ({a = ({a = ({a = 1 , b = false , c = 1 }.c) , b = ({a = (((\x: Bool .\y: Nat .x) true ) ({a = 0 , b = false }.b)) , b = (((\x: Rec X. X .\y: Bool .y) false ) 1) }.a) }.b) , b = (((\x: Nat .\y: Bool .x) (case <l = ({a = true , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . true ))) }.a) ) (let u = (((\x: Bool .\y: Unit .x) (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = true , c =  0 }.b) )) ) (((\x: Nat .\y: Nat .x) false ) true)) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (iszero 0) ))) ) ) (\a: Rec X. X .\b: Nat .b))
(if (let u = (fix (\x: Bool . (succ 0) )) in ({a = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) , b = (let u = false in u) }.b)) then (case <r = (((\x: Bool .\y: Nat .x) true ) false) > as Unit of < l = x > => x | < r = y > => y) else (case <r = (let u = (if false then true else false) in u) > as Bool of < l = x > => x | < r = y > => y))
({a = (( \f: Unit .((f (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .b)) ) (( \f: Unit .((f ({a = false , b = false }.b) ) (if false then ({a = 0 , b = true }.b) else (if true then true else true)) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (let u = ({a = ({a = true , b = 0 }.b) , b = (if false then false else false) , c = (if false then 1 else 1) }.c) in u) }.b)
(fix (\x: Rec X. X . ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = 1 , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .a)) }.b)) )) ))
(iszero (pred ({a = ({a = (iszero 0) , b = (((\x: Rec X. X .\y: Nat .x) 1 ) false) }.b) , b = (if (fix (\x: Rec X. X . false )) then 0 else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))) }.b)))
({a = ({a = (( \f: Nat .((f ({a = true , b = 0 }.a) ) (let u = true in u) ) ) (\a: Bool .\b: Nat .a)) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] true )) in (((\x: Nat .\y: Nat .x) 1 ) false)) }.a) , b = (( \f: Unit .((f (((\x: Unit .\y: Bool .x) false ) ({a = true , b = 0 }.a)) ) (let u = (let u = false in false) in u) ) ) (\a: Unit .\b: Nat .a)) }.b)
(iszero (let u = (iszero (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) in (( \f: Bool .((f ({a = (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.a) ) ({a = ({a = 1 , b = true , c =  0 }.b) , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .a))))
(fix (\x: Unit . ({a = (succ (let u = ({a = true , b = false }.b) in 1)) , b = (let u = (unfold [ Bool ] (fold [ Bool ] true )) in (((\x: Unit .\y: Rec X. X .x) false ) false)) }.a) ))
(fix (\x: Nat . (let u = (let u = (((\x: Rec X. X .\y: Nat .y) false ) true) in (let u = false in u)) in (((\x: Bool .\y: Unit .x) 0 ) true)) ))
({a = (( \f: Nat .((f (case <l = (if ({a = 1 , b = true , c =  0 }.b) then 0 else ({a = 1 , b = false , c = 1 }.c)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (if false then (if true then 0 else 1) else (let u = 1 in u)) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .b)) , b = (if (let u = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) false ) false) ) ({a = true , b = 1 }.b)) in (((\x: Nat .\y: Unit .x) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .a)) ) (let u = true in u))) then (if (((\x: Nat .\y: Nat .y) false ) (fix (\x: Nat . true ))) then (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] true )) ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) else ({a = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = true }.b)) else ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f ({a = 0 , b = false }.b) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Unit .b)) ))) }.b)
({a = ({a = ({a = (case <l = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) > as Unit of < l = x > => x | < r = y > => y) , b = (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y) , c =  (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.b) )) in u) }.b) , b = (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in (let u = 0 in u)) }.a) , b = (((\x: Nat .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Nat ] true )) ) (((\x: Bool .\y: Rec X. X .x) ({a = false , b = 0 }.b) ) false)) }.a)
({a = (succ (fix (\x: Nat . (pred 0) ))) , b = ({a = (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .b)) , b = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u) , c =  ({a = (fix (\x: Bool . 1 )) , b = ({a = 0 , b = true , c = 0 }.c) }.b) }.b) }.a) }.b)
(succ ({a = (fix (\x: Nat . (case <l = (if false then 1 else 1) > as Unit of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f (succ 0) ) ({a = ({a = true , b = 1 }.b) , b = false , c = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.c) ) ) (\a: Bool .\b: Nat .b)) }.b))
(( \f: Bool .((f ({a = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] false )) ) (fix (\x: Rec X. X . false )) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = (if true then 0 else 0) , b = false , c = (fix (\x: Bool . 1 )) }.c) }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = (let u = (iszero 0) in ({a = 0 , b = false , c = 1 }.c)) , b = (( \f: Rec X. X .((f false ) (unfold [ Bool ] (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c = (let u = true in 0) }.c) )) ) ) (\a: Nat .\b: Nat .a))
(fix (\x: Bool . (( \f: Rec X. X .((f (let u = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (succ 0) )) in ({a = 0 , b = true }.b)) in (( \f: Nat .((f true ) ({a = true , b = 1 }.a) ) ) (\a: Unit .\b: Nat .a))) ) (iszero ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 ))) ) ) (\a: Nat .\b: Bool .b)) ))
({a = (unfold [ Bool ] (fold [ Bool ] ({a = (let u = false in false) , b = (succ ({a = 1 , b = true , c = 0 }.c)) }.b) )) , b = (let u = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) , b = ({a = false , b = 0 }.a) }.b) in ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = ({a = false , b = 0 }.a) , c =  (((\x: Unit .\y: Unit .y) false ) (let u = false in 0)) }.b)) }.b)
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (iszero (if true then 0 else 1)) )) , b = (((\x: Bool .\y: Rec X. X .y) (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) true ) true) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .a)) ) (case <l = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y)) }.a)
(( \f: Bool .((f ({a = (pred (let u = (( \f: Unit .((f (let u = 0 in u) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )))) , b = ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = (let u = false in 0) }.a) , c =  (unfold [ Bool ] (fold [ Unit ] (let u = (case <r = ({a = 0 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) )) }.b) ) ({a = ({a = (iszero 0) , b = (pred 1) }.b) , b = (unfold [ Nat ] (fold [ Unit ] (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) in (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b))) )) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (( \f: Unit .((f (( \f: Unit .((f (((\x: Nat .\y: Nat .y) true ) true) ) (if false then true else false) ) ) (\a: Bool .\b: Bool .a)) ) ({a = 0 , b = (unfold [ Unit ] (fold [ Bool ] false )) }.b) ) ) (\a: Bool .\b: Nat .a)) , b = (fix (\x: Rec X. X . ({a = 0 , b = ({a = 0 , b = true , c =  1 }.b) }.a) )) }.a)
(((\x: Nat .\y: Unit .x) (if (let u = (if true then (unfold [ Rec X. X ] (fold [ Nat ] true )) else true) in (((\x: Nat .\y: Unit .x) ({a = false , b = true }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )))) then (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in u) )) else (case <r = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) in false) > as Unit of < l = x > => x | < r = y > => y)) ) (case <r = (unfold [ Nat ] (fold [ Unit ] (let u = ({a = false , b = 1 }.b) in (let u = (if false then 0 else 0) in ({a = true , b = false }.b))) )) > as Bool of < l = x > => x | < r = y > => y))
(fix (\x: Unit . (let u = ({a = (let u = true in (unfold [ Nat ] (fold [ Bool ] false ))) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = 1 }.a) )) }.b) in (( \f: Rec X. X .((f (( \f: Unit .((f 0 ) (let u = false in 1) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = ({a = 1 , b = true , c =  0 }.b) , b = 0 }.b) ) ) (\a: Unit .\b: Nat .a))) ))
(iszero ({a = (let u = 0 in u) , b = (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.a))
({a = ({a = (( \f: Bool .((f (if (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .b)) then (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) else true) ) (((\x: Bool .\y: Nat .x) false ) true) ) ) (\a: Nat .\b: Nat .a)) , b = (let u = (fix (\x: Rec X. X . 0 )) in (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b))) }.b) , b = (((\x: Rec X. X .\y: Bool .y) (unfold [ Nat ] (fold [ Nat ] (let u = 0 in true) )) ) ({a = (let u = true in u) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) }.b)) }.a)
(let u = (( \f: Rec X. X .((f (let u = ({a = (succ 1) , b = false }.b) in u) ) (if (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) then (unfold [ Nat ] (fold [ Unit ] false )) else (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in u) ))) ) ) (\a: Unit .\b: Nat .b)) in (( \f: Rec X. X .((f ({a = (iszero 1) , b = (iszero (let u = false in 0)) }.b) ) (iszero (succ (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)))) ) ) (\a: Nat .\b: Bool .b)))
(unfold [ Nat ] (fold [ Rec X. X ] (pred ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Bool .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) ) 1) ))) ))
(pred (let u = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Nat .x) (if true then true else true) ) ({a = 0 , b = true }.b)) }.b) in ({a = (unfold [ Nat ] (fold [ Rec X. X ] (let u = (let u = true in 1) in (unfold [ Nat ] (fold [ Nat ] 1 ))) )) , b = (if (unfold [ Nat ] (fold [ Unit ] false )) then (let u = false in true) else (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) (((\x: Rec X. X .\y: Nat .y) true ) false) ) ) (\a: Bool .\b: Unit .a))) , c = ({a = (((\x: Nat .\y: Rec X. X .y) false ) 0) , b = (((\x: Nat .\y: Rec X. X .x) false ) (iszero 0)) }.a) }.c)))
({a = (( \f: Rec X. X .((f (fix (\x: Bool . ({a = 1 , b = false }.b) )) ) (( \f: Rec X. X .((f ({a = 0 , b = true , c =  1 }.b) ) (let u = 0 in (((\x: Rec X. X .\y: Unit .y) false ) true)) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Nat .((f ({a = (( \f: Unit .((f (if false then 1 else 1) ) (let u = 0 in 1) ) ) (\a: Unit .\b: Unit .a)) , b = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) in true) , c = (( \f: Unit .((f (fix (\x: Unit . ({a = 0 , b = 0 }.b) )) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) }.c) ) (let u = (case <l = (let u = (let u = 1 in u) in 1) > as Unit of < l = x > => x | < r = y > => y) in u) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(( \f: Bool .((f ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) (let u = true in 1)) , b = ({a = (fix (\x: Rec X. X . true )) , b = ({a = false , b = (let u = false in 1) }.b) }.b) }.b) ) (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b))
(if (let u = ({a = (let u = 1 in u) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .a)) , c = (let u = (((\x: Bool .\y: Unit .x) (succ 1) ) ({a = 1 , b = true , c =  0 }.b)) in u) }.c) in ({a = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) , b = ({a = 1 , b = false , c =  0 }.b) }.b)) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) false ) true) )) )) )) else (let u = (unfold [ Unit ] (fold [ Bool ] (pred (((\x: Nat .\y: Unit .x) 1 ) true)) )) in ({a = (((\x: Nat .\y: Nat .x) 1 ) false) , b = (unfold [ Bool ] (fold [ Unit ] true )) }.b)))
({a = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Bool .((f ({a = 1 , b = false , c =  0 }.b) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Nat .\b: Unit .a)) )) in (((\x: Bool .\y: Rec X. X .y) (iszero (let u = 1 in 0)) ) (if false then true else true))) , b = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f (let u = (fix (\x: Bool . 1 )) in u) ) (((\x: Bool .\y: Nat .y) (let u = true in (((\x: Bool .\y: Bool .y) true ) false)) ) (((\x: Nat .\y: Nat .y) true ) (pred 1))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) }.b)
(unfold [ Nat ] (fold [ Nat ] (let u = (if (iszero 1) then 0 else 0) in u) ))
({a = (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) true ) false) )) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = false , b = 0 }.b) }.b) )) , b = (((\x: Rec X. X .\y: Unit .x) (unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Unit .y) false ) false) )) ) (((\x: Rec X. X .\y: Nat .x) false ) true)) , c =  (succ (pred (let u = 1 in u))) }.b) }.b)
(((\x: Bool .\y: Rec X. X .y) (let u = (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Bool .y) true ) true) ) (let u = false in (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)))) in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f ({a = false , b = 0 }.a) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Rec X. X .a)) )))
({a = ({a = (((\x: Bool .\y: Nat .y) (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in false) ) (( \f: Bool .((f (let u = true in 1) ) 1 ) ) (\a: Nat .\b: Bool .b))) , b = (unfold [ Nat ] (fold [ Unit ] ({a = ({a = 0 , b = (((\x: Bool .\y: Unit .y) false ) true) , c = 1 }.c) , b = (((\x: Unit .\y: Unit .x) true ) false) }.b) )) }.b) , b = (((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Nat .x) (fix (\x: Unit . (pred 0) )) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) false)) ) (fix (\x: Rec X. X . (let u = true in u) ))) }.b)
(pred (((\x: Rec X. X .\y: Nat .x) (if (if true then false else (let u = true in false)) then ({a = ({a = true , b = false }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.b) else (fix (\x: Nat . 0 ))) ) (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Nat ] true )) ) ({a = true , b = 1 }.a))))
(((\x: Unit .\y: Rec X. X .y) ({a = (let u = (let u = 1 in false) in ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false ))) , b = ({a = (let u = true in 0) , b = (pred 1) }.b) }.a) ) (let u = (succ (let u = (if false then 1 else 0) in u)) in u))
(( \f: Rec X. X .((f (( \f: Unit .((f (( \f: Unit .((f (case <l = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Rec X. X .x) false ) true) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f ({a = 0 , b = false }.a) ) (unfold [ Bool ] (fold [ Bool ] 1 )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Nat .b)) ) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (if true then 0 else 0) )) , b = (((\x: Nat .\y: Nat .y) (let u = false in u) ) (if true then true else true)) , c = (if (if (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .a)) then ({a = 1 , b = true }.b) else true) then (let u = 1 in 1) else (let u = 1 in (succ 1))) }.c) ) ) (\a: Nat .\b: Nat .a))
({a = (let u = (((\x: Rec X. X .\y: Nat .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) (let u = 0 in (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)))) in (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) false ) true) ) (iszero 0) ) ) (\a: Unit .\b: Unit .b))) , b = (let u = (fix (\x: Unit . (unfold [ Unit ] (fold [ Bool ] 1 )) )) in (if (let u = 0 in false) then (let u = false in false) else (((\x: Unit .\y: Nat .y) true ) false))) }.b)
(let u = (iszero (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y)) in u)
({a = ({a = (((\x: Nat .\y: Bool .x) (( \f: Nat .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) (fix (\x: Unit . true ))) , b = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = 0 , b = 0 }.b) , b = (let u = false in u) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) )) , b = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 1 , b = false , c = 1 }.c) )) in ({a = 1 , b = false , c =  0 }.b)) , c =  (((\x: Unit .\y: Bool .x) 1 ) true) }.b) , c = (let u = (unfold [ Rec X. X ] (fold [ Nat ] true )) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 ))) }.c) , b = ({a = (((\x: Bool .\y: Rec X. X .x) (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) true) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .a)) , c =  (succ 0) }.b) , c =  (let u = (( \f: Nat .((f (let u = 1 in 0) ) (fix (\x: Unit . ({a = true , b = 1 }.b) )) ) ) (\a: Rec X. X .\b: Nat .a)) in u) }.b)
(let u = (iszero (succ 1)) in u)
({a = (let u = (if (iszero 1) then ({a = true , b = 0 }.a) else (case <r = false > as Bool of < l = x > => x | < r = y > => y)) in ({a = (fix (\x: Nat . true )) , b = 0 }.b)) , b = ({a = (if true then (pred 0) else (let u = 1 in 1)) , b = (let u = ({a = true , b = 1 }.a) in u) , c =  ({a = 1 , b = 1 }.b) }.b) , c = ({a = (( \f: Bool .((f (let u = 1 in 1) ) (if true then 1 else 0) ) ) (\a: Bool .\b: Nat .b)) , b = (unfold [ Nat ] (fold [ Bool ] ({a = (((\x: Rec X. X .\y: Bool .x) false ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) , b = (let u = false in 1) }.b) )) }.b) }.c)
(let u = (let u = (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) in u) in u)
(succ (pred (let u = (fix (\x: Nat . (if false then false else false) )) in ({a = 0 , b = 1 }.b))))
(case <l = ({a = (( \f: Rec X. X .((f (succ 0) ) (case <l = (let u = 0 in u) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Bool . false )) )) }.a) > as Nat of < l = x > => x | < r = y > => y)
({a = (((\x: Bool .\y: Bool .y) (let u = (case <l = ({a = 0 , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y) in (if true then ({a = false , b = 0 }.a) else (iszero 1))) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ))) , b = (if (fix (\x: Rec X. X . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) then (((\x: Rec X. X .\y: Nat .y) (unfold [ Nat ] (fold [ Nat ] (unfold [ Nat ] (fold [ Bool ] true )) )) ) (((\x: Unit .\y: Rec X. X .x) 1 ) true)) else (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) ) (((\x: Bool .\y: Rec X. X .x) 1 ) true) ) ) (\a: Bool .\b: Nat .a))) }.a)
({a = (fix (\x: Unit . ({a = (succ ({a = 0 , b = true }.a)) , b = (fix (\x: Rec X. X . ({a = 0 , b = false , c =  0 }.b) )) }.a) )) , b = (if (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) true ) true) )) then (((\x: Rec X. X .\y: Bool .y) ({a = false , b = 0 }.a) ) (if true then false else true)) else (((\x: Nat .\y: Nat .x) (iszero 1) ) (((\x: Nat .\y: Nat .x) true ) (unfold [ Unit ] (fold [ Bool ] false ))))) , c =  ({a = (let u = (let u = (let u = true in true) in (let u = false in u)) in (((\x: Unit .\y: Bool .x) 0 ) true)) , b = (if ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) then ({a = (if true then true else false) , b = ({a = 0 , b = 1 }.b) }.a) else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) }.a) }.b)
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = 0 , b = false }.b) )) )) , b = (let u = ({a = 0 , b = true , c = (pred 0) }.c) in (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) ) (((\x: Unit .\y: Nat .x) 0 ) false) ) ) (\a: Unit .\b: Unit .b))) }.b)
(if ({a = (let u = (((\x: Bool .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Unit ] 1 )) ) (( \f: Rec X. X .((f (iszero 1) ) false ) ) (\a: Bool .\b: Nat .a))) in ({a = false , b = ({a = 1 , b = true , c =  0 }.b) }.b)) , b = (fix (\x: Bool . (( \f: Nat .((f (let u = true in 1) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .b)) )) }.a) then (if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) then (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) in false) else (let u = ({a = 1 , b = 1 }.b) in (((\x: Unit .\y: Rec X. X .x) true ) false))) else (let u = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (let u = false in true) , c = (((\x: Bool .\y: Unit .x) (succ 0) ) (((\x: Unit .\y: Rec X. X .y) false ) true)) }.c) in (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) ) (if ({a = 0 , b = true , c =  1 }.b) then true else (((\x: Unit .\y: Nat .x) true ) false)) ) ) (\a: Rec X. X .\b: Nat .a))))
({a = ({a = ({a = (( \f: Bool .((f false ) ({a = true , b = 1 }.a) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = (fix (\x: Nat . 0 )) in 1) }.a) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) }.b) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .x) ({a = 0 , b = (((\x: Bool .\y: Nat .y) false ) 0) }.b) ) (fix (\x: Nat . (let u = 0 in true) ))) )) }.a)
(case <r = (let u = (( \f: Bool .((f (let u = 0 in u) ) (let u = false in 0) ) ) (\a: Nat .\b: Unit .b)) in ({a = (((\x: Unit .\y: Unit .y) false ) (if false then false else true)) , b = ({a = 1 , b = (((\x: Rec X. X .\y: Nat .x) true ) false) , c = (if true then 1 else 1) }.c) }.a)) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Nat .x) false ) ({a = 1 , b = false , c =  0 }.b))) ) (unfold [ Rec X. X ] (fold [ Bool ] (case <r = (if (((\x: Bool .\y: Bool .y) false ) true) then false else true) > as Rec X. X of < l = x > => x | < r = y > => y) ))) ) (( \f: Rec X. X .((f (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) )) ) ({a = (((\x: Nat .\y: Rec X. X .x) (((\x: Unit .\y: Unit .y) true ) 1) ) false) , b = ({a = 0 , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) , c =  (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) ) (\a: Bool .\b: Nat .a)))
(((\x: Nat .\y: Unit .x) (fix (\x: Nat . (iszero (fix (\x: Bool . ({a = ({a = 0 , b = true , c = 1 }.c) , b = (fix (\x: Rec X. X . true )) }.a) ))) )) ) (((\x: Unit .\y: Unit .y) ({a = ({a = true , b = true }.b) , b = ({a = (fix (\x: Unit . 1 )) , b = false , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.c) }.a) ) (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) , b = (let u = 1 in 1) }.a) in ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in u) }.b))))
({a = (( \f: Unit .((f ({a = (((\x: Unit .\y: Unit .y) false ) 1) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , c = 1 }.c) ) ({a = (unfold [ Unit ] (fold [ Unit ] (let u = 1 in u) )) , b = (if true then (let u = true in false) else (((\x: Rec X. X .\y: Bool .y) false ) true)) , c = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.c) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (if (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .a)) )) then (let u = (unfold [ Unit ] (fold [ Unit ] false )) in u) else (let u = true in false)) , c =  (let u = ({a = (fix (\x: Rec X. X . ({a = 1 , b = false }.a) )) , b = (((\x: Bool .\y: Bool .x) false ) true) , c = ({a = 0 , b = (fix (\x: Bool . 0 )) }.b) }.c) in (let u = ({a = 1 , b = ({a = 0 , b = false }.b) }.a) in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )))) }.b)
({a = (let u = ({a = (( \f: Rec X. X .((f ({a = 1 , b = false }.a) ) 1 ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Nat .\y: Nat .x) (if false then 1 else 0) ) (fix (\x: Unit . true ))) }.b) in ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = false , c =  ({a = 1 , b = true , c = 0 }.c) }.b)) , b = ({a = (pred ({a = 0 , b = true }.a)) , b = (let u = (let u = false in u) in (if false then false else true)) }.b) }.b)
(if (iszero ({a = true , b = (let u = 0 in u) }.b)) then ({a = (unfold [ Nat ] (fold [ Unit ] (let u = 0 in u) )) , b = (if (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .a)) then true else (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .a))) }.b) else (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y))
(let u = (( \f: Unit .((f ({a = (let u = ({a = 1 , b = true , c = 1 }.c) in u) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) in ({a = 1 , b = 1 }.b)) }.b) ) ({a = ({a = 0 , b = false }.a) , b = true , c = (((\x: Unit .\y: Nat .y) true ) 1) }.c) ) ) (\a: Unit .\b: Nat .b)) in u)
(((\x: Unit .\y: Rec X. X .x) ({a = ({a = (case <r = ({a = true , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if (if false then true else true) then (unfold [ Unit ] (fold [ Bool ] 0 )) else (((\x: Rec X. X .\y: Unit .y) true ) 0)) }.b) , b = (((\x: Nat .\y: Nat .x) (iszero (((\x: Unit .\y: Rec X. X .y) true ) 0)) ) ({a = true , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.a)) , c = (let u = (pred 1) in (succ (((\x: Rec X. X .\y: Bool .x) 0 ) false))) }.c) ) (( \f: Nat .((f (let u = (pred 1) in ({a = (iszero 1) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) }.a)) ) (unfold [ Nat ] (fold [ Bool ] (let u = (fix (\x: Unit . ({a = 0 , b = true }.b) )) in u) )) ) ) (\a: Nat .\b: Nat .a)))
({a = (succ (pred (unfold [ Unit ] (fold [ Nat ] 0 )))) , b = (if (if (unfold [ Unit ] (fold [ Rec X. X ] ({a = 1 , b = true }.b) )) then (case <r = ({a = true , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Rec X. X .x) (fix (\x: Unit . (((\x: Rec X. X .\y: Unit .y) true ) true) )) ) (fix (\x: Bool . (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) )))) then (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = true , b = 1 }.a) ))) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 0) > as Nat of < l = x > => x | < r = y > => y) )) }.b)
(let u = (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) (let u = (((\x: Unit .\y: Nat .y) false ) 0) in false) ) (let u = false in false)) ) (let u = (succ 0) in (let u = ({a = 0 , b = false , c =  0 }.b) in false)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (if (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else (( \f: Unit .((f (iszero 1) ) (( \f: Nat .((f (let u = false in u) ) false ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Nat .\b: Rec X. X .a))))
(((\x: Rec X. X .\y: Unit .x) (unfold [ Nat ] (fold [ Rec X. X ] (let u = (succ ({a = 0 , b = false }.a)) in u) )) ) (iszero (unfold [ Rec X. X ] (fold [ Unit ] ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = false , c = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) }.c) ))))
(if (( \f: Rec X. X .((f (iszero ({a = 1 , b = (unfold [ Unit ] (fold [ Unit ] 0 )) }.b)) ) ({a = (((\x: Nat .\y: Rec X. X .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) ) (let u = (fix (\x: Nat . true )) in u)) , b = (((\x: Nat .\y: Unit .x) ({a = true , b = 1 }.a) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b))) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) then ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (pred 0) }.b) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) }.b) else ({a = (( \f: Nat .((f (( \f: Nat .((f (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) true ) ) (\a: Nat .\b: Unit .a)) ) ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 0 in 0) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (succ 0) }.a))
({a = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Bool .((f 0 ) ({a = 0 , b = false }.a) ) ) (\a: Bool .\b: Rec X. X .b)) )) in (let u = (fix (\x: Rec X. X . ({a = 1 , b = true , c = 0 }.c) )) in (let u = true in u))) , b = (((\x: Unit .\y: Rec X. X .y) (let u = (case <r = (((\x: Nat .\y: Nat .y) true ) true) > as Rec X. X of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Rec X. X ] false ))) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false ))) }.b)
(( \f: Unit .((f ({a = ({a = 1 , b = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) }.a) , b = (unfold [ Bool ] (fold [ Bool ] false )) , c =  (((\x: Unit .\y: Bool .x) 0 ) ({a = false , b = 1 }.a)) }.b) ) (((\x: Unit .\y: Bool .x) ({a = (let u = 1 in u) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) , c =  ({a = true , b = 1 }.b) }.b) ) (if ({a = false , b = false }.b) then (let u = (unfold [ Unit ] (fold [ Nat ] false )) in u) else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(((\x: Rec X. X .\y: Bool .y) ({a = (case <l = (pred (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (case <l = ({a = 0 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (case <r = (( \f: Unit .((f true ) ({a = 1 , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y)) , c =  (case <l = (pred 1) > as Unit of < l = x > => x | < r = y > => y) }.b) ) (((\x: Nat .\y: Bool .y) (unfold [ Bool ] (fold [ Nat ] (fix (\x: Rec X. X . false )) )) ) (unfold [ Bool ] (fold [ Unit ] (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ))))
(let u = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = 1 }.b) )) ) (fix (\x: Nat . ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if true then 1 else 0) }.b) )) ) ) (\a: Unit .\b: Rec X. X .a)) in (unfold [ Rec X. X ] (fold [ Bool ] (case <r = ({a = 1 , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) )))
(((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Unit .x) (let u = true in u) ) ({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = true }.a) , b = ({a = 1 , b = true , c =  1 }.b) }.b)) ) (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Bool ] (if (unfold [ Unit ] (fold [ Rec X. X ] true )) then 0 else 1) )) ) (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = false }.b) )) ))))
(succ (unfold [ Unit ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) )) )))
({a = ({a = (let u = (fix (\x: Unit . 0 )) in u) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) false ) (((\x: Unit .\y: Bool .x) false ) true)) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) , b = (((\x: Nat .\y: Nat .y) ({a = (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in u) , b = ({a = ({a = 1 , b = false , c = 1 }.c) , b = (((\x: Nat .\y: Rec X. X .x) false ) true) , c = ({a = (let u = 0 in u) , b = (iszero 1) }.a) }.c) }.a) ) (if ({a = (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) false ) 1) )) , b = ({a = (unfold [ Unit ] (fold [ Nat ] false )) , b = 0 }.a) , c =  (let u = true in 1) }.b) then ({a = (if false then 0 else 1) , b = (let u = false in true) , c = (let u = 1 in u) }.c) else ({a = 0 , b = false , c = ({a = false , b = 0 }.b) }.c))) }.b)
(unfold [ Rec X. X ] (fold [ Bool ] (let u = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Bool .x) true ) (let u = 0 in false)) ) (((\x: Unit .\y: Rec X. X .x) 1 ) false)) in (iszero 1)) ))
(let u = (if (( \f: Rec X. X .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (if ({a = true , b = 0 }.a) then false else (let u = true in u)) ) ) (\a: Nat .\b: Nat .a)) then (fix (\x: Nat . ({a = true , b = 0 }.a) )) else (let u = (let u = false in false) in u)) in u)
(let u = (case <r = (let u = ({a = ({a = 1 , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.a) , b = (iszero 0) , c = (let u = false in 0) }.c) in (let u = (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) in u)) > as Unit of < l = x > => x | < r = y > => y) in (if ({a = (let u = (let u = true in 0) in true) , b = ({a = (succ 0) , b = true , c =  1 }.b) }.b) then (let u = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) in u) else ({a = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = (((\x: Bool .\y: Nat .x) false ) (if true then false else true)) }.a)))
(succ (if (let u = ({a = false , b = true }.b) in u) then (((\x: Nat .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Nat ] (if true then true else false) )) ) (let u = (((\x: Nat .\y: Nat .y) false ) false) in (((\x: Unit .\y: Nat .x) (let u = 1 in u) ) true))) else ({a = (((\x: Rec X. X .\y: Nat .x) 1 ) true) , b = (((\x: Nat .\y: Rec X. X .x) 0 ) false) }.b)))
((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (case <l = ({a = ({a = false , b = false }.b) , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) ))
(unfold [ Bool ] (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) (unfold [ Nat ] (fold [ Bool ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .x) 1 ) true) )) )) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .x) false ) false) ) (iszero 0) ) ) (\a: Rec X. X .\b: Bool .a))) ))
({a = ({a = ({a = true , b = ({a = true , b = true }.b) }.b) , b = (if (iszero 1) then 1 else (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.b) , b = (case <r = ({a = (unfold [ Unit ] (fold [ Unit ] 1 )) , b = (let u = 0 in (((\x: Unit .\y: Unit .y) true ) false)) }.b) > as Unit of < l = x > => x | < r = y > => y) }.b)
(let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = ({a = 1 , b = false , c = 1 }.c) in (pred (let u = 1 in u))) )) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) )))
(( \f: Bool .((f (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Rec X. X ] (let u = (pred (unfold [ Nat ] (fold [ Bool ] 0 ))) in (let u = 0 in 1)) )) )) ) (fix (\x: Unit . (let u = 0 in (let u = false in 0)) )) ) ) (\a: Rec X. X .\b: Bool .b))
(fix (\x: Nat . (( \f: Bool .((f ({a = (( \f: Unit .((f (let u = true in u) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) , b = (succ 0) }.a) ) (case <r = (fix (\x: Bool . true )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) ))
(if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] ({a = false , b = false }.b) )) )) then (iszero (if (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b)) then ({a = 0 , b = 0 }.b) else (case <l = (pred 0) > as Rec X. X of < l = x > => x | < r = y > => y))) else (let u = ({a = false , b = true }.b) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) ))))
(succ ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = 0 in 0) )) , b = (((\x: Nat .\y: Nat .x) (if true then (fix (\x: Rec X. X . true )) else (((\x: Unit .\y: Unit .y) false ) false)) ) (let u = 1 in false)) , c = (succ ({a = false , b = (((\x: Nat .\y: Bool .x) 1 ) false) }.b)) }.c))
(let u = (if (iszero ({a = true , b = 1 }.b)) then ({a = ({a = true , b = 0 }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) , c = (succ 0) }.c) else (if (( \f: Unit .((f true ) (if false then false else true) ) ) (\a: Nat .\b: Rec X. X .b)) then ({a = 0 , b = 0 }.b) else (let u = (if false then true else false) in 0))) in u)
(((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) (let u = (( \f: Rec X. X .((f 0 ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b)) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) (let u = (((\x: Nat .\y: Bool .y) false ) false) in (if true then true else false))) ) (((\x: Nat .\y: Bool .y) ({a = (if (((\x: Unit .\y: Nat .y) false ) false) then (case <r = true > as Unit of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Nat .x) true ) false)) , b = ({a = (succ 1) , b = (((\x: Bool .\y: Rec X. X .x) true ) false) , c =  ({a = true , b = 0 }.b) }.b) }.b) ) (((\x: Rec X. X .\y: Rec X. X .y) (if (iszero 1) then (unfold [ Nat ] (fold [ Unit ] false )) else (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )))) ) (fix (\x: Bool . false )))))
((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Bool . ({a = (fix (\x: Rec X. X . 0 )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) , c =  (let u = 1 in 1) }.b) )) ))
(((\x: Bool .\y: Bool .y) ({a = ({a = (fix (\x: Rec X. X . ({a = 1 , b = false }.b) )) , b = (((\x: Bool .\y: Rec X. X .x) (pred 0) ) (unfold [ Bool ] (fold [ Unit ] false ))) }.a) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (iszero ({a = false , b = 0 }.b)) else (((\x: Nat .\y: Unit .x) false ) (((\x: Bool .\y: Unit .x) true ) true))) )) }.b) ) (let u = (((\x: Unit .\y: Unit .x) (let u = (((\x: Nat .\y: Rec X. X .x) 0 ) false) in u) ) (fix (\x: Bool . (let u = 0 in false) ))) in u))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (if (((\x: Unit .\y: Bool .y) false ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) then ({a = false , b = false }.b) else (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b))) )) , b = ({a = (((\x: Bool .\y: Unit .x) (fix (\x: Bool . 1 )) ) ({a = 0 , b = false , c =  0 }.b)) , b = (case <l = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) > as Bool of < l = x > => x | < r = y > => y) }.b) }.b)
(let u = (case <l = (((\x: Nat .\y: Rec X. X .y) (let u = true in u) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) in u)
(let u = (( \f: Bool .((f ({a = (((\x: Unit .\y: Rec X. X .y) true ) true) , b = (if ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = false }.b) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (((\x: Unit .\y: Bool .y) true ) (let u = 0 in true))) }.b) ) ({a = (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Bool .a)) )) , b = (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.a) ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = (if (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .a)) then (((\x: Bool .\y: Bool .y) true ) 0) else (unfold [ Bool ] (fold [ Bool ] 1 ))) , b = (if ({a = false , b = 0 }.a) then ({a = (let u = 1 in true) , b = 1 }.a) else (iszero (let u = false in 1))) , c =  (((\x: Nat .\y: Rec X. X .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (if true then false else true)) }.b))
(case <r = (case <r = (((\x: Bool .\y: Unit .y) (( \f: Nat .((f ({a = false , b = 1 }.a) ) (if false then true else false) ) ) (\a: Bool .\b: Rec X. X .a)) ) (let u = true in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)))) > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f ({a = (iszero 0) , b = (let u = (((\x: Unit .\y: Bool .x) 1 ) (let u = false in u)) in (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in u) ) 1)) }.b) ) (( \f: Nat .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Nat . 0 )) )) ) ({a = (succ 0) , b = (if true then 0 else 0) }.b) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Unit .\b: Nat .b))
(( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) (case <r = (unfold [ Unit ] (fold [ Nat ] (if true then false else true) )) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Rec X. X ] (fold [ Bool ] (succ 1) )) , b = (unfold [ Unit ] (fold [ Bool ] false )) }.b)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f 1 ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Nat .b)) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) )) ) ) (\a: Nat .\b: Bool .a))
({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (if ({a = 1 , b = false , c =  0 }.b) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) else (unfold [ Bool ] (fold [ Nat ] 1 ))) )) , b = (( \f: Nat .((f ({a = (if (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .b)) then ({a = 0 , b = true , c = 1 }.c) else ({a = 1 , b = true }.a)) , b = (let u = false in u) , c =  ({a = 0 , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)) , c = ({a = 0 , b = true }.a) }.c) }.b) ) ({a = (((\x: Nat .\y: Rec X. X .x) true ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true ))) , b = (let u = ({a = 1 , b = (if true then true else true) }.b) in u) }.b) ) ) (\a: Bool .\b: Bool .a)) , c = (( \f: Bool .((f ({a = ({a = 0 , b = false }.a) , b = (((\x: Nat .\y: Unit .x) true ) true) }.a) ) ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Rec X. X .\y: Nat .x) 1 ) true) }.b) ) ) (\a: Unit .\b: Nat .b)) }.c)
({a = ({a = ({a = (let u = 1 in 0) , b = ({a = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b)) , b = 1 }.a) }.b) , b = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) )) }.b) , b = ({a = (((\x: Bool .\y: Nat .y) true ) 1) , b = ({a = (fix (\x: Bool . true )) , b = (if false then true else true) }.b) }.b) , c =  (( \f: Rec X. X .((f (if ({a = 1 , b = false , c =  1 }.b) then (fix (\x: Nat . (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) else ({a = true , b = 0 }.b)) ) (( \f: Rec X. X .((f 0 ) (let u = 0 in 0) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .a)) }.b)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (succ 1) in u) ))
(( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (( \f: Unit .((f (fix (\x: Unit . (unfold [ Unit ] (fold [ Rec X. X ] (let u = true in 0) )) )) ) (((\x: Unit .\y: Rec X. X .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 0 in false)) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) (let u = (((\x: Unit .\y: Nat .x) (succ 1) ) ({a = true , b = false }.b)) in (if (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = true }.b) )) then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else ({a = 1 , b = true , c = 1 }.c))) ) ) (\a: Unit .\b: Rec X. X .b))
(( \f: Bool .((f ({a = (iszero (fix (\x: Rec X. X . 1 ))) , b = (((\x: Bool .\y: Rec X. X .y) (let u = true in u) ) (let u = 1 in 0)) }.a) ) (((\x: Unit .\y: Unit .x) (if ({a = 0 , b = true , c =  0 }.b) then false else false) ) ({a = 1 , b = ({a = false , b = false }.b) , c =  (((\x: Rec X. X .\y: Unit .x) 1 ) false) }.b)) ) ) (\a: Bool .\b: Unit .b))
(((\x: Bool .\y: Rec X. X .y) ({a = (fix (\x: Rec X. X . ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] false )) )) , b = (let u = true in (if false then true else false)) }.b) ) (case <r = (( \f: Nat .((f (( \f: Unit .((f (fix (\x: Nat . false )) ) (let u = 1 in false) ) ) (\a: Bool .\b: Unit .b)) ) ({a = ({a = true , b = 1 }.a) , b = (let u = false in 1) }.a) ) ) (\a: Unit .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y))
(let u = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (pred 1) )) in (( \f: Nat .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Nat .\b: Nat .b))) in ({a = (case <l = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Rec X. X .\y: Rec X. X .y) false ) true)) , c = (let u = (iszero 0) in (succ 1)) }.c))
(succ (unfold [ Unit ] (fold [ Bool ] ({a = ({a = true , b = (((\x: Unit .\y: Nat .x) 0 ) true) }.b) , b = ({a = 0 , b = false }.a) }.b) )))
({a = (case <l = (((\x: Unit .\y: Bool .x) (pred 1) ) (let u = true in u)) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (iszero (let u = ({a = 1 , b = false , c = 0 }.c) in 1)) , b = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Nat . 0 )) ) (let u = false in false)) }.a) , c = (unfold [ Bool ] (fold [ Bool ] (case <l = (( \f: Bool .((f (let u = false in (if false then 0 else 1)) ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) )) }.c)
({a = (unfold [ Nat ] (fold [ Unit ] (let u = (fix (\x: Bool . true )) in u) )) , b = ({a = (succ (((\x: Unit .\y: Unit .y) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) 0)) , b = ({a = (((\x: Bool .\y: Bool .x) false ) false) , b = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) }.b) , c =  (case <l = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = 0 , b = true , c = (((\x: Bool .\y: Bool .y) false ) 1) }.c)) > as Unit of < l = x > => x | < r = y > => y) }.b) }.b)
({a = (case <l = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) in u) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (let u = false in 1) }.b) )) , c = (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Bool . (unfold [ Unit ] (fold [ Nat ] 1 )) )) )) }.c)
((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (succ (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Nat .\b: Unit .a))) ))
(let u = (( \f: Unit .((f (let u = (if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) then (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) else (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a))) in ({a = 1 , b = (fix (\x: Rec X. X . false )) }.b)) ) (((\x: Nat .\y: Rec X. X .x) (let u = 1 in false) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) ) ) (\a: Nat .\b: Rec X. X .b)) in (pred (case <l = (pred 1) > as Rec X. X of < l = x > => x | < r = y > => y)))
(fix (\x: Bool . (pred (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Rec X. X . false )) )) in (fix (\x: Bool . 1 )))) ))
(fix (\x: Nat . (((\x: Bool .\y: Nat .y) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = true }.b) ) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) , b = false }.b)) ))
(( \f: Unit .((f (( \f: Bool .((f ({a = (( \f: Unit .((f true ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Unit .a)) , b = (case <l = ({a = 1 , b = true , c = 0 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (fix (\x: Rec X. X . (let u = false in 1) )) ) ) (\a: Rec X. X .\b: Unit .b)) ) (if (unfold [ Bool ] (fold [ Bool ] (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 1 in true) ))) )) then ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] 1 )) )) else (succ (if (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) then ({a = (((\x: Unit .\y: Rec X. X .y) false ) 0) , b = 1 }.b) else ({a = 1 , b = 1 }.b)))) ) ) (\a: Nat .\b: Unit .a))
(iszero (succ (( \f: Rec X. X .((f (if true then ({a = 1 , b = true , c = 0 }.c) else (fix (\x: Rec X. X . 1 ))) ) (((\x: Rec X. X .\y: Unit .x) 0 ) true) ) ) (\a: Rec X. X .\b: Nat .a))))
(((\x: Nat .\y: Nat .y) (( \f: Nat .((f (( \f: Unit .((f (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in true) ) (fix (\x: Bool . true )) ) ) (\a: Nat .\b: Nat .b)) ) (( \f: Rec X. X .((f (iszero 1) ) (let u = true in false) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (case <r = (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) )) }.b))
(((\x: Rec X. X .\y: Unit .x) (( \f: Rec X. X .((f ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 1 , b = true , c = 1 }.c) }.b) ) (let u = true in (succ 1)) ) ) (\a: Nat .\b: Bool .b)) ) (let u = (unfold [ Nat ] (fold [ Unit ] (let u = true in true) )) in u))
({a = (if (let u = ({a = true , b = 1 }.b) in (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b))) then (( \f: Nat .((f (let u = (unfold [ Rec X. X ] (fold [ Nat ] true )) in (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b))) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = 1 }.b) )) ) ) (\a: Nat .\b: Unit .b)) else (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = (((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Unit .y) true ) false) ) (let u = false in 1)) , b = (case <r = ({a = false , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) )) }.b)
(fix (\x: Rec X. X . ({a = (unfold [ Unit ] (fold [ Bool ] ({a = ({a = false , b = 0 }.b) , b = 0 }.b) )) , b = (let u = (( \f: Unit .((f (((\x: Bool .\y: Bool .y) false ) 1) ) 0 ) ) (\a: Bool .\b: Bool .a)) in u) }.b) ))
(( \f: Bool .((f (succ (( \f: Nat .((f ({a = 0 , b = 0 }.b) ) (((\x: Bool .\y: Nat .x) 1 ) true) ) ) (\a: Unit .\b: Rec X. X .a))) ) (let u = (let u = ({a = false , b = 0 }.b) in (succ 1)) in u) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(fix (\x: Unit . (((\x: Bool .\y: Nat .x) (let u = (((\x: Nat .\y: Rec X. X .x) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Nat .b)) ) true) in (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) ) (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) (((\x: Rec X. X .\y: Nat .x) false ) true) ) ) (\a: Bool .\b: Bool .a))) ))
(((\x: Bool .\y: Bool .x) (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) (succ 0) ) ) (\a: Bool .\b: Bool .a)) ) (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] ({a = (succ 0) , b = ({a = true , b = (iszero 0) }.b) , c =  (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) }.b) )) )))
(fix (\x: Rec X. X . (fix (\x: Bool . (fix (\x: Unit . ({a = false , b = false }.b) )) )) ))
(let u = (let u = (let u = (let u = 1 in u) in u) in u) in ({a = (( \f: Bool .((f (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Nat .a)) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in (fix (\x: Unit . true ))) }.b))
(((\x: Nat .\y: Unit .y) (( \f: Nat .((f (unfold [ Unit ] (fold [ Rec X. X ] (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) )) ) (if (let u = 0 in false) then ({a = (unfold [ Bool ] (fold [ Unit ] false )) , b = true }.b) else (( \f: Nat .((f (((\x: Bool .\y: Nat .x) true ) false) ) false ) ) (\a: Rec X. X .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Unit .b)) ) (fix (\x: Unit . ({a = (( \f: Bool .((f ({a = false , b = 1 }.b) ) (((\x: Bool .\y: Rec X. X .y) false ) 1) ) ) (\a: Bool .\b: Unit .b)) , b = (iszero 0) , c =  (fix (\x: Nat . ({a = false , b = 1 }.b) )) }.b) )))
(((\x: Unit .\y: Nat .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (if (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = 0 , b = true , c =  0 }.b)) )) ) (let u = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )) in u) in (iszero (( \f: Rec X. X .((f (if true then 1 else 0) ) ({a = 1 , b = false , c = 1 }.c) ) ) (\a: Nat .\b: Bool .a)))))
(( \f: Nat .((f (((\x: Unit .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) in (let u = 0 in false))) ) ({a = ({a = (if ({a = true , b = false }.b) then 0 else 0) , b = ({a = false , b = 0 }.a) , c =  (pred 1) }.b) , b = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = ({a = 0 , b = true , c = 0 }.c) , b = false , c = (((\x: Bool .\y: Unit .y) true ) 0) }.c) }.b) }.a) ) ) (\a: Unit .\b: Bool .b))
(let u = ({a = (( \f: Bool .((f (fix (\x: Bool . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) )) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (((\x: Unit .\y: Unit .y) false ) 1) , b = ({a = 0 , b = ({a = true , b = false }.b) }.b) , c = (((\x: Nat .\y: Unit .y) (iszero 1) ) (let u = false in 1)) }.c) }.b) in (( \f: Bool .((f (( \f: Bool .((f ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = true }.b) ) (fix (\x: Nat . (((\x: Bool .\y: Nat .x) true ) false) )) ) ) (\a: Unit .\b: Unit .a)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) ) ) (\a: Bool .\b: Nat .b)))
(fix (\x: Rec X. X . (succ (let u = (fix (\x: Nat . 1 )) in u)) ))
(( \f: Nat .((f (( \f: Bool .((f (let u = ({a = 1 , b = true , c =  0 }.b) in (unfold [ Nat ] (fold [ Unit ] false ))) ) (case <r = (( \f: Unit .((f (let u = 0 in true) ) (fix (\x: Bool . false )) ) ) (\a: Nat .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Nat . (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .a)) )) )) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = (((\x: Rec X. X .\y: Unit .y) (let u = (( \f: Bool .((f ({a = (((\x: Nat .\y: Unit .x) false ) true) , b = false }.b) ) (if true then false else false) ) ) (\a: Unit .\b: Unit .b)) in u) ) (let u = ({a = 0 , b = 1 }.b) in (iszero 0))) in ({a = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) , b = ({a = (let u = true in false) , b = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) }.b) }.b) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in true) ) 0) }.b))
(fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] (iszero 0) )) ))
({a = (if ({a = (succ 0) , b = ({a = false , b = (iszero 0) }.b) , c =  ({a = 1 , b = 0 }.b) }.b) then ({a = ({a = 1 , b = true }.a) , b = (let u = true in true) }.b) else ({a = (( \f: Bool .((f (( \f: Unit .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) ) ({a = false , b = false }.b) ) ) (\a: Unit .\b: Unit .b)) ) (fix (\x: Bool . true )) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) , b = (((\x: Unit .\y: Nat .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) ) (let u = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .a)) in (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)))) }.b)
(let u = (unfold [ Unit ] (fold [ Unit ] ({a = (if (fix (\x: Rec X. X . true )) then (fix (\x: Unit . 1 )) else (pred 0)) , b = (if true then 0 else 0) }.b) )) in (unfold [ Bool ] (fold [ Unit ] ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) }.a) )))
(((\x: Bool .\y: Nat .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) ({a = ({a = false , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.a) , b = (if false then ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) else 1) }.a) ) (((\x: Nat .\y: Unit .y) ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = (let u = 0 in u) }.a) ) ({a = false , b = 1 }.a))) )) ) (unfold [ Unit ] (fold [ Rec X. X ] (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) in (let u = false in false)) )))
(((\x: Unit .\y: Unit .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero (pred 1)) )) ) ({a = (case <l = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = 1 , b = false , c =  1 }.b) ) ({a = true , b = true }.b) ) ) (\a: Rec X. X .\b: Unit .b)) }.a))
({a = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Unit .x) 0 ) false) )) , b = (( \f: Rec X. X .((f (let u = false in false) ) (let u = true in u) ) ) (\a: Nat .\b: Rec X. X .b)) , c = ({a = (case <r = (let u = (fix (\x: Rec X. X . 1 )) in ({a = false , b = 1 }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) , b = (iszero (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) , c = (pred (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) true ) 0) ))) }.c) }.b) }.c)
({a = (case <l = ({a = (let u = true in 0) , b = (let u = false in true) , c = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.c) > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . (if ({a = 1 , b = true }.b) then ({a = 1 , b = true }.a) else (succ 0)) )) }.b)
(( \f: Rec X. X .((f (pred (case <l = (((\x: Unit .\y: Nat .x) (let u = true in 1) ) ({a = 1 , b = false }.b)) > as Bool of < l = x > => x | < r = y > => y)) ) (( \f: Nat .((f ({a = (((\x: Bool .\y: Nat .y) false ) 0) , b = (( \f: Rec X. X .((f (let u = 1 in u) ) (( \f: Bool .((f (pred 0) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .a)) }.b) ) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Nat .y) true ) 1) )) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .a))
(let u = (let u = (let u = (( \f: Bool .((f (if true then false else true) ) (((\x: Nat .\y: Nat .y) false ) true) ) ) (\a: Unit .\b: Unit .b)) in (fix (\x: Bool . true ))) in (let u = (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (((\x: Nat .\y: Unit .x) true ) true) else ({a = 0 , b = true , c =  1 }.b)) in u)) in u)
(fix (\x: Unit . (case <l = (pred ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (((\x: Bool .\y: Rec X. X .x) false ) false) , c = ({a = 1 , b = true , c = 1 }.c) }.c)) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(fix (\x: Unit . (let u = (fix (\x: Rec X. X . ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (if false then 0 else 1) }.b) )) in u) ))
({a = ({a = (case <r = (let u = true in true) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (let u = 0 in 0) )) }.a) , b = (( \f: Nat .((f (fix (\x: Unit . (((\x: Bool .\y: Rec X. X .x) true ) false) )) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .a)) }.b)
(case <r = (fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .y) true ) (if true then true else true)) )) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Nat .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (if (let u = (iszero 1) in true) then ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) else (case <r = (((\x: Nat .\y: Nat .y) false ) true) > as Bool of < l = x > => x | < r = y > => y)) )) ) (let u = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) in u))
(fix (\x: Rec X. X . (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Nat .y) (( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .b)) ) (unfold [ Unit ] (fold [ Rec X. X ] (if true then false else false) ))) ) (case <r = (fix (\x: Rec X. X . false )) > as Bool of < l = x > => x | < r = y > => y)) ))
(let u = ({a = (case <r = (if true then false else true) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (let u = 1 in u) , b = (if false then true else false) }.a) }.b) in (let u = (if (fix (\x: Rec X. X . true )) then ({a = 1 , b = false }.a) else (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b))) in ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = ({a = true , b = 0 }.a) }.a)))
(unfold [ Bool ] (fold [ Rec X. X ] (if (iszero (let u = 0 in 1)) then (iszero 1) else (((\x: Nat .\y: Bool .y) ({a = false , b = 1 }.a) ) (((\x: Bool .\y: Unit .y) true ) true))) ))
(if (( \f: Rec X. X .((f ({a = (case <r = (let u = (iszero 0) in u) > as Unit of < l = x > => x | < r = y > => y) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) ) ({a = ({a = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) , b = (iszero 1) }.b) , b = (((\x: Nat .\y: Rec X. X .x) true ) true) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) then ({a = ({a = (let u = 0 in u) , b = (if false then false else true) }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Unit . 0 )) )) }.b) else ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c = (if true then 1 else 1) }.c) )) )))
({a = (succ ({a = (let u = 1 in u) , b = (let u = 0 in false) , c = (pred 0) }.c)) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) )) ) (( \f: Rec X. X .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (if false then false else true) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
(case <r = (fix (\x: Rec X. X . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y)
({a = ({a = (unfold [ Unit ] (fold [ Bool ] (pred 0) )) , b = (pred (succ 1)) }.b) , b = (( \f: Rec X. X .((f (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = true }.b) )) in u) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = true , b = true }.b) )) ) ) (\a: Nat .\b: Bool .a)) }.a)
({a = ({a = (((\x: Rec X. X .\y: Unit .y) ({a = false , b = 1 }.a) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a))) , b = (let u = ({a = false , b = true }.b) in u) }.b) , b = (((\x: Bool .\y: Bool .y) (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) (iszero 1) ) (fix (\x: Nat . false ))) )) ) (let u = (let u = 0 in u) in (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f (((\x: Nat .\y: Unit .y) false ) false) ) (iszero 0) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = true , b = 0 }.a)))) }.b)
(((\x: Bool .\y: Unit .x) (let u = (let u = (if ({a = 1 , b = false , c =  0 }.b) then (((\x: Rec X. X .\y: Bool .y) false ) true) else (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .a))) in u) in (( \f: Bool .((f (let u = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b)) in 1) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Nat .\b: Bool .a))) ) (case <r = ({a = (let u = true in true) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = true }.b) ) true) }.b) > as Nat of < l = x > => x | < r = y > => y))
(fix (\x: Nat . (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = 0 , b = true , c =  1 }.b) )) in u) ))
(let u = ({a = (let u = (let u = true in true) in (( \f: Nat .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) , b = (if (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .a)) then ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) else ({a = false , b = 0 }.a)) }.b) in u)
({a = (((\x: Unit .\y: Bool .y) (let u = (let u = (succ 1) in (let u = true in u)) in u) ) (let u = (if (unfold [ Bool ] (fold [ Bool ] false )) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) else (let u = 1 in true)) in (let u = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) 1 ) false) )) in u))) , b = (iszero (unfold [ Unit ] (fold [ Nat ] 1 ))) , c =  (pred ({a = ({a = (((\x: Rec X. X .\y: Unit .x) false ) false) , b = (((\x: Nat .\y: Rec X. X .y) true ) 1) }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = false in true) )) }.a)) }.b)
(( \f: Bool .((f ({a = (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) ({a = (fix (\x: Bool . 0 )) , b = (fix (\x: Rec X. X . 0 )) }.b) ) ) (\a: Nat .\b: Bool .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (if (let u = false in u) then (let u = false in false) else true) )) , c = (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .a)) then ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) )) else (case <l = ({a = true , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y)) }.c) ) (pred (unfold [ Unit ] (fold [ Nat ] ({a = (((\x: Unit .\y: Nat .x) true ) true) , b = 1 }.b) ))) ) ) (\a: Nat .\b: Unit .a))
(succ (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Nat ] 0 )) )))
({a = (let u = (( \f: Unit .((f (unfold [ Unit ] (fold [ Unit ] true )) ) ({a = true , b = 1 }.a) ) ) (\a: Unit .\b: Rec X. X .b)) in (((\x: Bool .\y: Unit .x) (let u = 1 in u) ) (let u = false in u))) , b = (((\x: Bool .\y: Unit .y) (((\x: Unit .\y: Unit .x) (((\x: Unit .\y: Unit .y) false ) false) ) true) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = false , c =  1 }.b) ))) , c = (if ({a = (let u = (let u = false in false) in (((\x: Rec X. X .\y: Bool .x) 0 ) true)) , b = (( \f: Unit .((f (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Bool .b)) , c =  ({a = false , b = 0 }.b) }.b) then ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (case <l = (let u = 0 in u) > as Unit of < l = x > => x | < r = y > => y) )) else ({a = (fix (\x: Nat . 0 )) , b = ({a = true , b = 0 }.a) }.a)) }.c)
(let u = (succ (((\x: Bool .\y: Bool .x) ({a = 1 , b = false , c = 0 }.c) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) )))) in (((\x: Rec X. X .\y: Nat .y) (case <r = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true , c =  ({a = false , b = 0 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.b)))
(unfold [ Unit ] (fold [ Unit ] (succ (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) false ) 1) ))) ))
(( \f: Unit .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.a) )) ) (fix (\x: Bool . (( \f: Bool .((f ({a = false , b = false }.b) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ) (\a: Bool .\b: Nat .a))
(if ({a = (let u = (let u = (fix (\x: Nat . 0 )) in 0) in (((\x: Nat .\y: Unit .y) ({a = 1 , b = true }.b) ) (((\x: Unit .\y: Unit .x) true ) true))) , b = (iszero ({a = false , b = 1 }.b)) }.b) then (if (if (if ({a = false , b = 0 }.a) then true else (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .b))) then (( \f: Bool .((f (let u = 0 in true) ) ({a = true , b = 1 }.a) ) ) (\a: Nat .\b: Unit .a)) else (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b))) then (( \f: Unit .((f (let u = false in true) ) (((\x: Nat .\y: Nat .y) true ) ({a = 0 , b = false , c =  0 }.b)) ) ) (\a: Unit .\b: Unit .a)) else (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .x) true ) false) ))) else (iszero (let u = (fix (\x: Nat . true )) in (( \f: Bool .((f 0 ) (let u = false in 0) ) ) (\a: Bool .\b: Bool .b)))))
({a = (if (fix (\x: Rec X. X . (if (let u = true in u) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) else (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .a))) )) then (( \f: Rec X. X .((f (case <l = (if true then 0 else 0) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f 1 ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Unit .\b: Rec X. X .a)) else (((\x: Nat .\y: Rec X. X .x) (if (if true then ({a = 0 , b = true }.b) else false) then (if false then 1 else 0) else (((\x: Unit .\y: Unit .y) true ) 1)) ) (unfold [ Rec X. X ] (fold [ Bool ] true )))) , b = (succ (( \f: Rec X. X .((f ({a = false , b = 0 }.b) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b))) }.b)
(succ (((\x: Rec X. X .\y: Bool .x) (let u = (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) false ) 0) ) 1 ) ) (\a: Unit .\b: Unit .a)) in (let u = (if true then 0 else 1) in u)) ) (let u = (case <r = (if false then true else false) > as Unit of < l = x > => x | < r = y > => y) in u)))
(( \f: Rec X. X .((f (let u = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (if true then true else false) , c = ({a = 1 , b = false }.a) }.c) in u) ) ({a = (pred (pred 0)) , b = (let u = (let u = ({a = 0 , b = false , c =  0 }.b) in true) in u) }.a) ) ) (\a: Unit .\b: Nat .a))
(let u = (( \f: Bool .((f (let u = (fix (\x: Rec X. X . 1 )) in (((\x: Bool .\y: Unit .y) ({a = true , b = 1 }.a) ) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)))) ) (let u = (unfold [ Bool ] (fold [ Rec X. X ] true )) in u) ) ) (\a: Nat .\b: Nat .a)) in u)
(((\x: Nat .\y: Rec X. X .y) ({a = (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) in u) , b = (iszero (fix (\x: Unit . 0 ))) }.b) ) ({a = (((\x: Bool .\y: Nat .y) (let u = false in u) ) (( \f: Rec X. X .((f ({a = true , b = 1 }.a) ) true ) ) (\a: Bool .\b: Unit .b))) , b = ({a = (iszero 0) , b = 0 }.b) }.a))
(if (((\x: Rec X. X .\y: Bool .y) (let u = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) in (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) true ) false) ) false ) ) (\a: Nat .\b: Rec X. X .a))) ) (iszero 1)) then (((\x: Unit .\y: Unit .y) (let u = (fix (\x: Rec X. X . (succ 0) )) in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (fix (\x: Bool . (fix (\x: Unit . true )) ))) else (( \f: Bool .((f (let u = (let u = true in u) in ({a = 0 , b = true , c =  (if false then 0 else 0) }.b)) ) (((\x: Nat .\y: Rec X. X .y) (( \f: Bool .((f (( \f: Unit .((f ({a = false , b = 1 }.a) ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) (( \f: Bool .((f true ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .y) false ) true) ))) ) ) (\a: Nat .\b: Rec X. X .a)))
({a = ({a = (let u = (( \f: Unit .((f (pred 1) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Nat .b)) in ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (iszero 0) }.b)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) }.b) , b = (let u = (iszero ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = 1 }.b)) in (let u = (let u = false in false) in (((\x: Rec X. X .\y: Unit .x) true ) true))) , c = (if (unfold [ Unit ] (fold [ Bool ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) )) then (if (((\x: Rec X. X .\y: Rec X. X .y) true ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) then (let u = true in 0) else (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a))) else (if (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .b)) then (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) else (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)))) }.c)
(if ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (fix (\x: Nat . false )) }.b) , b = (succ ({a = (let u = 0 in u) , b = true , c = 1 }.c)) }.a) then ({a = ({a = false , b = 0 }.a) , b = (pred ({a = 1 , b = 0 }.b)) }.a) else (case <r = ({a = ({a = 0 , b = false }.a) , b = ({a = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = false , b = 1 }.b) }.a) }.b) > as Bool of < l = x > => x | < r = y > => y))
(pred (if (iszero ({a = 0 , b = true , c = 0 }.c)) then (fix (\x: Nat . (succ 0) )) else (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) ) (if (unfold [ Nat ] (fold [ Bool ] true )) then ({a = false , b = 0 }.b) else 1) ) ) (\a: Bool .\b: Bool .a))))
(pred (((\x: Unit .\y: Nat .x) (( \f: Rec X. X .((f (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) ) (\a: Unit .\b: Rec X. X .b)) ) (pred (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Unit .\b: Bool .b)) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Nat .y) true ) true) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ))))
(unfold [ Nat ] (fold [ Rec X. X ] ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero (fix (\x: Nat . 0 ))) , c =  (let u = (pred 0) in u) }.b) ))
({a = (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in u) , b = (let u = (( \f: Nat .((f ({a = false , b = 0 }.b) ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Nat .b)) in (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) (let u = false in u) ) ) (\a: Bool .\b: Unit .b))) }.a)
(( \f: Unit .((f (((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Unit .x) true ) true) ) (iszero (fix (\x: Bool . 1 )))) ) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = ({a = ({a = true , b = false }.b) , b = ({a = false , b = 1 }.b) }.a) }.b) ) ) (\a: Nat .\b: Nat .b))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = (iszero ({a = false , b = 0 }.b)) , b = (let u = 0 in u) }.a) , b = (case <l = (let u = true in 1) > as Bool of < l = x > => x | < r = y > => y) }.b) ))
(((\x: Bool .\y: Nat .y) (let u = (let u = (((\x: Rec X. X .\y: Bool .x) (let u = 0 in true) ) (((\x: Rec X. X .\y: Bool .x) true ) true)) in (succ (let u = 0 in 1))) in (let u = (let u = true in 0) in (fix (\x: Bool . (let u = false in u) )))) ) (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Rec X. X . true )) )) )))
(unfold [ Bool ] (fold [ Rec X. X ] (let u = (let u = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b)) in u) in u) ))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Bool ] (pred (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a))) )) ))
(((\x: Bool .\y: Rec X. X .x) ({a = (((\x: Unit .\y: Nat .x) ({a = 1 , b = false }.a) ) (let u = true in u)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 1 in 0) )) }.b) ) (fix (\x: Nat . (( \f: Nat .((f (if false then (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .b)) else (unfold [ Unit ] (fold [ Unit ] true ))) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) )))
({a = (( \f: Nat .((f ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = true }.b) ) (( \f: Nat .((f (let u = true in u) ) (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) in (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .a))) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (((\x: Rec X. X .\y: Nat .x) (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) in u) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true ))) }.b)
(case <l = (fix (\x: Rec X. X . (fix (\x: Nat . ({a = 0 , b = (((\x: Bool .\y: Unit .y) false ) 0) }.b) )) )) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) }.b) )) , b = (unfold [ Bool ] (fold [ Nat ] (iszero ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 ))) )) , c = ({a = ({a = (let u = false in 1) , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.a) , b = (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .b)) ) (let u = ({a = false , b = 0 }.a) in (fix (\x: Nat . ({a = 1 , b = 1 }.b) )))) }.b) }.c)
(((\x: Nat .\y: Unit .x) (let u = (((\x: Bool .\y: Nat .y) (let u = false in true) ) (((\x: Bool .\y: Bool .y) true ) false)) in u) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 0 , b = false }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true ))) in u))
(((\x: Rec X. X .\y: Rec X. X .y) (if (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) then (iszero (let u = (((\x: Nat .\y: Bool .x) true ) false) in (let u = false in (fix (\x: Nat . 1 ))))) else (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = 0 }.b) )) in (let u = false in true))) ) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (if true then 0 else 1) in u) )) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] (if false then false else false) )) , b = (case <r = (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) (((\x: Nat .\y: Nat .y) false ) false) ) ) (\a: Unit .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) }.b) , c = (( \f: Unit .((f (( \f: Unit .((f (if true then 0 else 0) ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = true , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) }.c))
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .y) (iszero 1) ) ({a = 0 , b = (let u = false in u) }.a)) ))
(((\x: Unit .\y: Nat .y) (iszero (case <l = (unfold [ Bool ] (fold [ Nat ] 1 )) > as Bool of < l = x > => x | < r = y > => y)) ) (fix (\x: Bool . (succ ({a = 0 , b = true }.a)) )))
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Unit ] (case <r = (let u = false in u) > as Nat of < l = x > => x | < r = y > => y) )) )) ))
(iszero (((\x: Unit .\y: Bool .y) (( \f: Nat .((f ({a = (let u = 0 in u) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) ) (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .x) false ) true) )) ) ) (\a: Bool .\b: Bool .b)) ) (( \f: Rec X. X .((f (fix (\x: Rec X. X . ({a = 0 , b = true , c = 0 }.c) )) ) ({a = 1 , b = 0 }.b) ) ) (\a: Nat .\b: Unit .b))))
({a = (let u = ({a = 0 , b = ({a = true , b = false }.b) }.a) in (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) in u)) , b = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) )) in u) }.a)
(succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred (let u = 0 in 1)) )))
(unfold [ Unit ] (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) )) ))
(( \f: Bool .((f ({a = ({a = (let u = 0 in u) , b = (( \f: Bool .((f ({a = false , b = 0 }.a) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) , c = (if false then 0 else 0) }.c) , b = (if (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) then (((\x: Unit .\y: Rec X. X .y) ({a = true , b = true }.b) ) 0) else ({a = 1 , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a)) }.a)) }.b) ) ({a = (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Nat .b)) , b = (case <r = (if false then true else true) > as Unit of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Rec X. X .\b: Unit .b))
(pred (pred (succ ({a = true , b = 0 }.b))))
(let u = ({a = (let u = (let u = false in u) in 1) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) }.a) in u)
(((\x: Unit .\y: Unit .y) (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = (((\x: Nat .\y: Nat .x) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) true) > as Bool of < l = x > => x | < r = y > => y) )) ) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = true }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) )) ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Nat .((f (if (((\x: Unit .\y: Bool .y) false ) false) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) (fix (\x: Unit . (if true then true else true) )) ) ) (\a: Bool .\b: Bool .b)))
({a = (((\x: Rec X. X .\y: Nat .x) (case <l = ({a = true , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .x) ({a = false , b = (succ 1) }.a) ) (fix (\x: Rec X. X . false ))) ) ({a = (unfold [ Bool ] (fold [ Nat ] true )) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.a) ) ) (\a: Bool .\b: Nat .a))) , b = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = false , b = 0 }.b) )) , b = (case <r = ({a = false , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , c =  ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = 0 }.b) )) , b = (if (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) then ({a = 1 , b = false }.b) else (fix (\x: Unit . true ))) }.a) }.b)
({a = (fix (\x: Unit . (( \f: Bool .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) )) , b = (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = false , c =  1 }.b) ) ({a = 1 , b = true }.b)) )) , c =  (((\x: Unit .\y: Unit .y) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a) ) (pred ({a = false , b = 1 }.b))) }.b)
({a = (case <l = (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = false , c = 0 }.c) ) (if false then false else ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )))) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Nat . (if true then 1 else 0) )) )) )) }.b)
(let u = (fix (\x: Bool . ({a = (( \f: Nat .((f (fix (\x: Rec X. X . 1 )) ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) }.b) )) in (let u = ({a = (let u = false in u) , b = 1 }.a) in ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Bool ] true )) }.b)))
({a = (let u = ({a = (let u = 1 in u) , b = 0 }.b) in u) , b = (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) ) ({a = false , b = 1 }.a)) ) ({a = 1 , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .a)) , c =  (succ (((\x: Bool .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) 1)) }.b)
(let u = (unfold [ Nat ] (fold [ Unit ] (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) in ({a = false , b = 1 }.b)) )) in u)
(fix (\x: Unit . (( \f: Rec X. X .((f ({a = (fix (\x: Nat . (iszero 1) )) , b = (let u = false in 1) }.a) ) (fix (\x: Rec X. X . (iszero (let u = 1 in u)) )) ) ) (\a: Nat .\b: Unit .a)) ))
(pred (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] (pred ({a = 0 , b = 0 }.b)) )) ) (case <l = ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = ({a = 1 , b = 1 }.b) in u) }.b) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)))
({a = (let u = (((\x: Nat .\y: Nat .y) ({a = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = true }.b) ) ({a = 1 , b = true , c =  1 }.b)) in (fix (\x: Rec X. X . false ))) , b = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (let u = false in u) in u) )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) }.b) }.b)
(case <r = (iszero ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (let u = (let u = false in u) in (succ 1)) }.b)) > as Bool of < l = x > => x | < r = y > => y)
(let u = (case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = false , c = 1 }.c) )) > as Rec X. X of < l = x > => x | < r = y > => y) in (case <r = (((\x: Nat .\y: Rec X. X .x) (((\x: Rec X. X .\y: Nat .x) true ) true) ) (let u = 0 in false)) > as Rec X. X of < l = x > => x | < r = y > => y))
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (succ (let u = 1 in 0)) , b = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Bool ] false )) ) (if false then true else true) ) ) (\a: Bool .\b: Rec X. X .b)) }.a) ))
({a = ({a = (pred ({a = 0 , b = true }.a)) , b = (fix (\x: Rec X. X . (( \f: Bool .((f true ) (((\x: Bool .\y: Nat .y) true ) true) ) ) (\a: Nat .\b: Nat .b)) )) , c = (((\x: Rec X. X .\y: Bool .y) false ) (if true then 0 else 1)) }.c) , b = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = false }.a) )) in (((\x: Nat .\y: Bool .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Rec X. X ] false )))) }.b)
(let u = ({a = (iszero (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .y) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .a)) ) false) )) }.b) in (fix (\x: Nat . (let u = (let u = ({a = 1 , b = false }.a) in (((\x: Nat .\y: Rec X. X .y) true ) (((\x: Unit .\y: Nat .y) true ) 1))) in ({a = (let u = 1 in 0) , b = true }.a)) )))
(iszero (case <l = (pred ({a = 1 , b = (fix (\x: Rec X. X . false )) }.a)) > as Nat of < l = x > => x | < r = y > => y))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = (let u = (unfold [ Nat ] (fold [ Nat ] (iszero 0) )) in (let u = true in true)) > as Bool of < l = x > => x | < r = y > => y) ))
(unfold [ Bool ] (fold [ Unit ] (succ ({a = (let u = 1 in u) , b = (let u = 0 in false) , c = ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) false) , b = ({a = 0 , b = false , c =  0 }.b) , c = (let u = false in 1) }.c) }.c)) ))
({a = (if (unfold [ Nat ] (fold [ Unit ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) )) then (((\x: Unit .\y: Bool .x) true ) false) else (((\x: Nat .\y: Bool .x) (fix (\x: Unit . false )) ) ({a = true , b = 1 }.a))) , b = (((\x: Rec X. X .\y: Nat .y) (if (let u = (let u = 0 in (((\x: Bool .\y: Rec X. X .y) false ) 1)) in (iszero 1)) then (let u = true in u) else ({a = ({a = false , b = 1 }.b) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) , c =  ({a = 1 , b = 0 }.b) }.b)) ) (( \f: Rec X. X .((f (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Bool .a))) }.b)
(( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (pred ({a = 0 , b = false , c = 0 }.c)) )) ) ({a = (fix (\x: Rec X. X . false )) , b = ({a = 0 , b = ({a = 1 , b = false }.b) }.a) }.b) ) ) (\a: Nat .\b: Nat .b))
(((\x: Nat .\y: Unit .y) (unfold [ Unit ] (fold [ Unit ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = false , b = true }.b) )) )) ) (succ (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .a)) ) ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) true ) false) }.a))))
(case <r = ({a = (let u = (if true then 0 else 1) in u) , b = (case <r = (let u = 0 in false) > as Nat of < l = x > => x | < r = y > => y) , c =  (fix (\x: Unit . 0 )) }.b) > as Nat of < l = x > => x | < r = y > => y)
(let u = (let u = (( \f: Unit .((f (fix (\x: Unit . 1 )) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .b)) in u) in (if ({a = (let u = 1 in (((\x: Nat .\y: Rec X. X .x) 0 ) false)) , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.b) then (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in true) else ({a = ({a = true , b = 0 }.a) , b = (unfold [ Bool ] (fold [ Bool ] (let u = 0 in true) )) }.b)))
({a = (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] (succ 1) )) ) (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] 1 )) ) (let u = (if false then 0 else 0) in (succ 0)) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = ({a = ({a = ({a = 0 , b = 0 }.b) , b = true }.b) , b = (((\x: Nat .\y: Rec X. X .y) (let u = true in false) ) (pred 1)) }.a) , b = (pred ({a = false , b = 0 }.b)) }.b) }.b)
(((\x: Nat .\y: Unit .x) (( \f: Nat .((f (case <r = (let u = false in false) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Rec X. X .x) true ) false) )) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .b)) ) (((\x: Rec X. X .\y: Nat .y) (let u = (pred (let u = 1 in 1)) in (let u = true in true)) ) (let u = ({a = 1 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in ({a = (let u = false in u) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.a))))
(succ (if ({a = (iszero (fix (\x: Nat . 1 ))) , b = (succ 1) }.a) then (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.b) )) else (fix (\x: Nat . (if (let u = 1 in false) then (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) else (pred 0)) ))))
(((\x: Bool .\y: Nat .y) ({a = (((\x: Nat .\y: Unit .x) true ) false) , b = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) ) false ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) (((\x: Bool .\y: Rec X. X .x) ({a = ({a = true , b = (if false then false else true) }.b) , b = (((\x: Rec X. X .\y: Unit .x) (if false then 1 else 1) ) true) }.b) ) (((\x: Unit .\y: Unit .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) ) ({a = 0 , b = false , c =  0 }.b))))
({a = ({a = (let u = (let u = true in u) in 1) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .x) true ) false) )) , c = (let u = ({a = 1 , b = 0 }.b) in u) }.c) , b = (((\x: Unit .\y: Bool .y) (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) (let u = true in u) ) false) ) ({a = 1 , b = (unfold [ Bool ] (fold [ Nat ] true )) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) (if false then false else (let u = true in u))) , c =  (unfold [ Nat ] (fold [ Rec X. X ] ({a = (unfold [ Nat ] (fold [ Nat ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) , b = ({a = (fix (\x: Unit . 0 )) , b = 0 }.b) }.b) )) }.b)
(fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) (let u = false in ({a = true , b = 1 }.a)) ) ({a = 0 , b = true , c =  (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) }.b)) ))
(((\x: Bool .\y: Nat .y) ({a = (fix (\x: Nat . (succ 1) )) , b = (let u = (let u = false in u) in u) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = ({a = (unfold [ Nat ] (fold [ Bool ] true )) , b = ({a = 1 , b = false , c =  0 }.b) }.b) in ({a = 0 , b = 0 }.b)) )))
(let u = ({a = (let u = (fix (\x: Rec X. X . true )) in u) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.a) in (( \f: Unit .((f (succ (let u = 0 in u)) ) (( \f: Nat .((f (pred 1) ) (((\x: Nat .\y: Nat .y) (if true then false else false) ) 1) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .b)))
(case <l = (let u = ({a = false , b = ({a = 0 , b = true , c = 0 }.c) }.a) in (if (((\x: Unit .\y: Bool .x) false ) false) then 0 else 0)) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Unit . (pred (pred (((\x: Unit .\y: Nat .x) 0 ) false))) ))
(((\x: Rec X. X .\y: Unit .y) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (((\x: Rec X. X .\y: Unit .y) false ) false) , b = (let u = true in 0) }.b) )) , b = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = true in u) )) ) (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in u) ) ) (\a: Rec X. X .\b: Unit .a)) , c =  ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in 0) }.b) }.b) ) ({a = (let u = (if (fix (\x: Nat . true )) then (let u = false in 1) else (unfold [ Nat ] (fold [ Nat ] 1 ))) in (if ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) then (case <l = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) else (unfold [ Nat ] (fold [ Unit ] 0 )))) , b = (((\x: Bool .\y: Unit .x) (fix (\x: Rec X. X . 0 )) ) (((\x: Bool .\y: Rec X. X .x) false ) (let u = 0 in true))) }.b))
(let u = (let u = (let u = (let u = 0 in false) in ({a = 0 , b = false }.a)) in (( \f: Unit .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) (pred ({a = (succ 1) , b = ({a = true , b = 1 }.a) , c = (let u = 0 in 0) }.c)) ) ) (\a: Unit .\b: Nat .b))) in u)
({a = (fix (\x: Bool . (let u = (((\x: Bool .\y: Nat .y) false ) (let u = true in u)) in ({a = 0 , b = false , c =  1 }.b)) )) , b = (let u = (succ (fix (\x: Rec X. X . 1 ))) in (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) in (let u = false in false))) }.b)
(if (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (if false then 1 else 1) ))) then (((\x: Bool .\y: Unit .y) (((\x: Unit .\y: Bool .x) ({a = 1 , b = (let u = false in false) , c =  (unfold [ Rec X. X ] (fold [ Bool ] 0 )) }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) (unfold [ Bool ] (fold [ Nat ] (fix (\x: Bool . true )) ))) else (iszero (succ (fix (\x: Bool . (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = 1 in u)) )))))
(unfold [ Rec X. X ] (fold [ Bool ] (( \f: Nat .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = true in true) )) ) ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if false then 1 else 0) )) , b = ({a = false , b = 1 }.a) }.b) , b = (( \f: Rec X. X .((f 0 ) (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) ) (\a: Bool .\b: Nat .b)) }.a) ) ) (\a: Bool .\b: Nat .b)) ))
({a = (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = (((\x: Rec X. X .\y: Nat .y) false ) true) , c = (pred 1) }.c) )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) ({a = ({a = false , b = 1 }.b) , b = (let u = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b)) in u) , c =  (((\x: Nat .\y: Rec X. X .y) (fix (\x: Rec X. X . true )) ) (if true then 0 else 1)) }.b) ) (( \f: Unit .((f (iszero 1) ) (if true then true else (let u = true in u)) ) ) (\a: Nat .\b: Rec X. X .a))) )) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .x) (let u = (if false then true else true) in (if true then 0 else 0)) ) (if (((\x: Rec X. X .\y: Unit .y) true ) true) then (if false then (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) else true) else (((\x: Unit .\y: Nat .y) true ) false))) )) }.b)
(((\x: Unit .\y: Rec X. X .y) (((\x: Unit .\y: Unit .y) (let u = true in true) ) ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = false in false) }.b)) ) (unfold [ Bool ] (fold [ Nat ] ({a = false , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) }.a) )))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .y) (let u = true in false) ) (let u = false in u)) )) ))
(( \f: Rec X. X .((f ({a = (fix (\x: Nat . (((\x: Unit .\y: Nat .x) 0 ) false) )) , b = (( \f: Nat .((f (if ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) then (let u = (pred 0) in ({a = false , b = 1 }.a)) else (if true then true else false)) ) (((\x: Unit .\y: Rec X. X .y) (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then false else (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.a) ))) ) ) (\a: Rec X. X .\b: Unit .b)) }.a) ) ({a = ({a = ({a = (((\x: Nat .\y: Unit .x) ({a = 0 , b = true , c = 0 }.c) ) false) , b = ({a = (let u = true in false) , b = false }.b) }.a) , b = ({a = (let u = (((\x: Nat .\y: Rec X. X .y) false ) 0) in u) , b = ({a = 1 , b = false , c = 0 }.c) }.b) }.b) , b = (((\x: Bool .\y: Bool .x) ({a = true , b = true }.b) ) (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then false else (let u = true in true))) }.a) ) ) (\a: Unit .\b: Nat .b))
(unfold [ Nat ] (fold [ Bool ] ({a = ({a = ({a = 0 , b = 1 }.b) , b = ({a = false , b = (let u = 1 in u) }.b) }.b) , b = ({a = (((\x: Unit .\y: Rec X. X .x) false ) true) , b = (((\x: Unit .\y: Unit .x) (if true then false else true) ) false) }.b) , c =  ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (let u = 1 in false) }.a) }.b) ))
({a = (let u = (( \f: Bool .((f (( \f: Bool .((f true ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .b)) ) (iszero 0) ) ) (\a: Rec X. X .\b: Nat .a)) in (succ (let u = (if true then false else true) in ({a = 0 , b = true , c = 1 }.c)))) , b = (let u = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (fix (\x: Unit . true )) ) (if true then true else true) ) ) (\a: Rec X. X .\b: Nat .a)) )) in (if (let u = false in true) then (case <r = true > as Unit of < l = x > => x | < r = y > => y) else (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)))) }.b)
(unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = (pred ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .x) 1 ) false) ))) , b = (((\x: Unit .\y: Nat .x) true ) false) , c = (( \f: Rec X. X .((f ({a = false , b = 1 }.b) ) 1 ) ) (\a: Bool .\b: Unit .b)) }.c) )) ))
(if ({a = (fix (\x: Nat . (let u = 1 in 1) )) , b = (if ({a = true , b = 0 }.a) then (let u = 0 in false) else (if true then true else false)) , c =  (((\x: Nat .\y: Bool .y) ({a = false , b = 0 }.a) ) ({a = true , b = 1 }.b)) }.b) then ({a = (((\x: Bool .\y: Rec X. X .y) (let u = false in false) ) (fix (\x: Nat . 0 ))) , b = (let u = ({a = true , b = true }.b) in u) }.b) else ({a = (((\x: Unit .\y: Bool .y) (let u = true in (let u = true in true)) ) ({a = (let u = true in 1) , b = (((\x: Nat .\y: Bool .y) true ) 0) }.b)) , b = ({a = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) in 0) , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)) }.b) , c =  (let u = ({a = 1 , b = true }.b) in (let u = (fix (\x: Unit . true )) in (let u = 0 in u))) }.b))
(unfold [ Unit ] (fold [ Unit ] (fix (\x: Unit . (( \f: Bool .((f ({a = 0 , b = false , c =  1 }.b) ) (((\x: Bool .\y: Bool .y) true ) true) ) ) (\a: Nat .\b: Rec X. X .a)) )) ))
(let u = (( \f: Bool .((f (( \f: Rec X. X .((f (let u = false in u) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = true , b = 1 }.a) )) ) ) (\a: Nat .\b: Bool .b)) in ({a = (( \f: Bool .((f (((\x: Nat .\y: Nat .y) false ) 1) ) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ) (\a: Nat .\b: Bool .a)) , b = (( \f: Unit .((f (iszero ({a = ({a = 1 , b = false }.a) , b = false }.a)) ) (let u = (iszero (((\x: Nat .\y: Bool .x) 1 ) false)) in u) ) ) (\a: Unit .\b: Nat .b)) }.b))
({a = (fix (\x: Rec X. X . (let u = (if true then ({a = 1 , b = false , c =  0 }.b) else true) in u) )) , b = ({a = (iszero 0) , b = (let u = (fix (\x: Rec X. X . 1 )) in (succ 0)) }.a) }.b)
(((\x: Bool .\y: Unit .y) ({a = (((\x: Bool .\y: Bool .y) true ) 0) , b = (if true then true else (((\x: Unit .\y: Unit .y) false ) false)) }.b) ) (pred (( \f: Bool .((f (let u = 1 in u) ) ({a = false , b = 0 }.b) ) ) (\a: Bool .\b: Unit .b))))
({a = (if (unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = 1 , b = true }.b) , b = (((\x: Rec X. X .\y: Unit .y) true ) (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) }.a) )) then (if ({a = (((\x: Unit .\y: Rec X. X .x) true ) true) , b = (pred 1) }.a) then (succ ({a = (pred 1) , b = true , c = (if true then 0 else 0) }.c)) else (case <l = (fix (\x: Nat . 0 )) > as Rec X. X of < l = x > => x | < r = y > => y)) else (( \f: Unit .((f (let u = 1 in u) ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Nat .a))) , b = (fix (\x: Bool . (if true then (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) else (unfold [ Bool ] (fold [ Nat ] false ))) )) }.b)
(iszero (pred (( \f: Unit .((f 0 ) (((\x: Nat .\y: Unit .y) true ) 1) ) ) (\a: Rec X. X .\b: Nat .a))))
(let u = ({a = ({a = (let u = true in u) , b = ({a = ({a = false , b = 0 }.b) , b = false , c =  0 }.b) }.b) , b = ({a = ({a = (((\x: Bool .\y: Unit .x) false ) false) , b = (iszero 1) }.b) , b = ({a = false , b = 1 }.b) }.b) }.b) in (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (iszero 0) ) ) (\a: Bool .\b: Nat .a)) )))
(((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Nat . (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ({a = (if ({a = false , b = false }.b) then (succ 1) else (( \f: Bool .((f 1 ) (let u = 0 in u) ) ) (\a: Bool .\b: Rec X. X .b))) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = 0 }.a) )) }.b))
(( \f: Rec X. X .((f ({a = ({a = (((\x: Nat .\y: Unit .y) false ) 0) , b = ({a = false , b = true }.b) , c = (pred 1) }.c) , b = (let u = (if true then 0 else 0) in (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b))) }.b) ) (let u = (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .x) (if false then 1 else 1) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) )) in u) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = (((\x: Unit .\y: Unit .y) ({a = (fix (\x: Rec X. X . false )) , b = (fix (\x: Unit . (let u = false in 1) )) }.a) ) (((\x: Bool .\y: Rec X. X .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) (if true then true else false))) in ({a = (( \f: Rec X. X .((f (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) ) false ) ) (\a: Rec X. X .\b: Bool .b)) , b = (unfold [ Bool ] (fold [ Unit ] (pred 0) )) }.a))
(( \f: Nat .((f ({a = (( \f: Unit .((f (if false then (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) else ({a = 1 , b = true }.a)) ) (let u = ({a = 1 , b = false , c =  1 }.b) in (fix (\x: Unit . 0 ))) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) ) ({a = ({a = true , b = 0 }.a) , b = ({a = 0 , b = 0 }.b) }.a)) }.a) ) (let u = (let u = (if true then ({a = 1 , b = false }.a) else 0) in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) in u) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = ({a = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = (iszero 1) }.b) , b = (if (unfold [ Nat ] (fold [ Nat ] true )) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) else (fix (\x: Unit . 0 ))) }.b) in (fix (\x: Unit . (((\x: Unit .\y: Bool .x) (if false then 1 else 1) ) (((\x: Nat .\y: Unit .y) true ) true)) )))
({a = (succ (( \f: Unit .((f (succ 0) ) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = true , c = (let u = 1 in u) }.c) ) ) (\a: Nat .\b: Rec X. X .a))) , b = (let u = (let u = (let u = 1 in 1) in (fix (\x: Rec X. X . true ))) in (let u = false in ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )))) }.b)
(pred (case <l = ({a = ({a = false , b = 0 }.a) , b = (((\x: Bool .\y: Bool .x) 1 ) false) }.b) > as Unit of < l = x > => x | < r = y > => y))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = (succ ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .y) true ) 0) ))) , b = ({a = (let u = true in u) , b = 1 }.a) , c = (unfold [ Bool ] (fold [ Nat ] ({a = false , b = 0 }.b) )) }.c) )) , b = (let u = ({a = ({a = true , b = 0 }.a) , b = ({a = 0 , b = 0 }.b) }.a) in u) }.b)
(pred (case <l = (pred (((\x: Nat .\y: Rec X. X .y) true ) 0)) > as Nat of < l = x > => x | < r = y > => y))
(succ (( \f: Unit .((f (pred 1) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Bool .a)))
(let u = (( \f: Nat .((f ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true , c = 1 }.c) }.a) ) (let u = (unfold [ Bool ] (fold [ Nat ] false )) in u) ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Bool .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (iszero 0) , b = false }.b) )) ) (( \f: Nat .((f (fix (\x: Nat . (fix (\x: Rec X. X . false )) )) ) (let u = (let u = 0 in u) in (if true then true else false)) ) ) (\a: Bool .\b: Rec X. X .a))))
(case <r = (let u = ({a = ({a = (((\x: Unit .\y: Nat .x) 1 ) true) , b = (let u = false in u) , c =  (let u = false in 0) }.b) , b = (fix (\x: Unit . ({a = 0 , b = 0 }.b) )) }.b) in (fix (\x: Bool . ({a = 1 , b = false }.b) ))) > as Nat of < l = x > => x | < r = y > => y)
(case <l = (((\x: Unit .\y: Nat .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ({a = (let u = false in ({a = false , b = false }.b)) , b = ({a = 1 , b = true , c = 0 }.c) }.a)) > as Unit of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ({a = (succ 0) , b = (case <l = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Unit .((f (fix (\x: Nat . 0 )) ) (let u = 1 in (fix (\x: Nat . 1 ))) ) ) (\a: Unit .\b: Nat .b)) }.b) ))
(let u = ({a = (( \f: Bool .((f ({a = true , b = 1 }.a) ) false ) ) (\a: Bool .\b: Unit .b)) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = false }.a) ))) }.b) in u)
(let u = ({a = (fix (\x: Unit . (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) )) , b = (((\x: Bool .\y: Unit .y) ({a = 1 , b = true , c =  1 }.b) ) (let u = 1 in false)) , c =  (let u = ({a = false , b = 0 }.b) in u) }.b) in u)
(((\x: Rec X. X .\y: Unit .x) (let u = ({a = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = 1 , b = true , c = 1 }.c) }.a) in u) ) (( \f: Bool .((f (let u = true in true) ) (fix (\x: Nat . ({a = 0 , b = false , c =  0 }.b) )) ) ) (\a: Rec X. X .\b: Unit .b)))
({a = (unfold [ Unit ] (fold [ Bool ] (fix (\x: Bool . (let u = 1 in ({a = 0 , b = true , c = 1 }.c)) )) )) , b = (((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Bool .y) false ) true) ) (((\x: Rec X. X .\y: Nat .y) true ) true)) ) (if ({a = 0 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) then (let u = false in false) else (if (let u = false in false) then ({a = ({a = 0 , b = false , c = 0 }.c) , b = true , c =  (if false then 0 else 0) }.b) else (if true then true else false)))) , c =  (if (( \f: Nat .((f true ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) then (((\x: Bool .\y: Unit .x) ({a = false , b = 1 }.b) ) true) else (succ ({a = 0 , b = false }.a))) }.b)
(let u = (unfold [ Rec X. X ] (fold [ Bool ] (let u = (if true then true else true) in ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = (succ 0) }.a)) )) in (case <l = ({a = ({a = true , b = 0 }.b) , b = true }.a) > as Bool of < l = x > => x | < r = y > => y))
({a = (let u = (( \f: Unit .((f (pred 0) ) (succ 0) ) ) (\a: Rec X. X .\b: Bool .b)) in (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Nat .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Unit .b)) ))) , b = ({a = (case <l = (((\x: Bool .\y: Unit .x) 1 ) (let u = 1 in false)) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Bool ] (iszero 0) )) , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) , c =  ({a = ({a = (fix (\x: Unit . 1 )) , b = (iszero 1) }.a) , b = ({a = (if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) then (((\x: Nat .\y: Rec X. X .x) false ) false) else true) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) }.a) }.a) }.b)
(let u = (let u = (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) ({a = 0 , b = true , c =  0 }.b)) in (( \f: Rec X. X .((f (let u = ({a = false , b = false }.b) in ({a = 1 , b = (let u = false in true) }.b)) ) (iszero (let u = false in 1)) ) ) (\a: Unit .\b: Unit .a))) in (((\x: Nat .\y: Nat .x) (fix (\x: Nat . ({a = 1 , b = 0 }.b) )) ) ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (unfold [ Nat ] (fold [ Bool ] false )) }.b)))
(fix (\x: Unit . (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) in u) ))
(( \f: Bool .((f (((\x: Rec X. X .\y: Nat .y) (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in ({a = true , b = 1 }.a)) ) ({a = 0 , b = 1 }.b)) ) (fix (\x: Rec X. X . ({a = ({a = 1 , b = (let u = false in u) , c = 0 }.c) , b = ({a = (fix (\x: Nat . 0 )) , b = true , c =  (let u = 0 in 0) }.b) }.a) )) ) ) (\a: Rec X. X .\b: Nat .a))
(unfold [ Nat ] (fold [ Nat ] (((\x: Unit .\y: Nat .x) (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in ({a = 0 , b = (if false then false else false) , c =  1 }.b)) ) (( \f: Unit .((f (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ))
({a = (pred ({a = ({a = 0 , b = 0 }.b) , b = true }.a)) , b = (( \f: Bool .((f (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (if (((\x: Bool .\y: Unit .y) true ) false) then false else true) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  (let u = (iszero (( \f: Bool .((f 0 ) (let u = 0 in 0) ) ) (\a: Rec X. X .\b: Bool .a))) in (if (let u = false in (fix (\x: Nat . false ))) then (pred ({a = true , b = 1 }.b)) else (fix (\x: Nat . (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) )))) }.b)
({a = (((\x: Nat .\y: Nat .x) (let u = (( \f: Bool .((f (((\x: Unit .\y: Unit .y) true ) (((\x: Bool .\y: Bool .x) false ) true)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ) (\a: Nat .\b: Unit .a)) in (fix (\x: Rec X. X . (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ))) ) ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (case <r = (( \f: Bool .((f (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) (iszero 1) ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) }.b)) , b = (case <r = (if (((\x: Bool .\y: Nat .y) true ) true) then false else (let u = false in u)) > as Bool of < l = x > => x | < r = y > => y) , c = (case <l = (fix (\x: Bool . (if false then 0 else 0) )) > as Bool of < l = x > => x | < r = y > => y) }.c)
({a = (fix (\x: Rec X. X . (succ ({a = (if true then false else false) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) , b = (pred 0) }.b) }.b)) )) , b = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) (iszero 0) ) ) (\a: Bool .\b: Unit .b)) }.a)
(case <r = (let u = (iszero 1) in u) > as Nat of < l = x > => x | < r = y > => y)
(let u = (( \f: Rec X. X .((f (let u = (if (let u = true in u) then (let u = 1 in 0) else 0) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) (unfold [ Nat ] (fold [ Nat ] ({a = false , b = false }.b) )) ) ) (\a: Nat .\b: Nat .b)) in (fix (\x: Rec X. X . (if (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .a)) then (let u = true in u) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = true , b = 0 }.a) ))) )))
(((\x: Bool .\y: Bool .x) ({a = (let u = (( \f: Rec X. X .((f true ) (((\x: Bool .\y: Nat .y) true ) false) ) ) (\a: Unit .\b: Bool .b)) in (iszero (((\x: Unit .\y: Rec X. X .x) 0 ) false))) , b = (( \f: Bool .((f ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (((\x: Bool .\y: Nat .y) false ) true) }.a) ) (( \f: Nat .((f (((\x: Unit .\y: Unit .y) false ) 0) ) 0 ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Bool .\b: Bool .b)) }.a) ) (iszero (let u = (case <l = (pred 1) > as Unit of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )))))
(unfold [ Nat ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (if ({a = true , b = true }.b) then true else (let u = 0 in true)) ) (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = false }.b) ) ({a = false , b = false }.b)) ) ) (\a: Unit .\b: Bool .a)) ))
(let u = (iszero (( \f: Unit .((f 0 ) (succ 1) ) ) (\a: Unit .\b: Nat .b))) in u)
(( \f: Bool .((f ({a = ({a = (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in true) }.b) , b = (case <l = (succ (if false then 0 else 1)) > as Unit of < l = x > => x | < r = y > => y) }.b) ) (case <l = (((\x: Unit .\y: Bool .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .b)) ) (succ 1)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Rec X. X . (iszero (fix (\x: Bool . (succ 0) ))) ))
(succ (case <l = (pred ({a = 1 , b = 0 }.b)) > as Unit of < l = x > => x | < r = y > => y))
(let u = (((\x: Nat .\y: Nat .x) (if (((\x: Nat .\y: Rec X. X .y) false ) true) then (iszero 1) else (fix (\x: Rec X. X . (((\x: Bool .\y: Bool .y) true ) true) ))) ) (((\x: Bool .\y: Nat .x) true ) true)) in u)
(succ (fix (\x: Bool . ({a = ({a = 0 , b = 1 }.b) , b = (let u = 1 in u) }.b) )))
(let u = (fix (\x: Bool . (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) in (fix (\x: Unit . (unfold [ Bool ] (fold [ Unit ] 1 )) ))) )) in ({a = (unfold [ Bool ] (fold [ Nat ] (((\x: Bool .\y: Unit .y) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) (let u = 0 in false)) )) , b = (( \f: Unit .((f (pred 0) ) (( \f: Unit .((f 0 ) (let u = false in 0) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .a)) }.b))
(unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f (pred (let u = 0 in 1)) ) ({a = 1 , b = (iszero 0) }.a) ) ) (\a: Nat .\b: Nat .a)) ))
(( \f: Unit .((f (iszero ({a = (if false then 0 else 0) , b = ({a = 0 , b = true , c =  0 }.b) , c = ({a = 1 , b = 0 }.b) }.c)) ) (iszero (let u = (if false then true else true) in (unfold [ Unit ] (fold [ Rec X. X ] 1 )))) ) ) (\a: Unit .\b: Rec X. X .a))
(case <l = ({a = ({a = (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f ({a = 0 , b = 1 }.b) ) (pred 1) ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = ({a = 0 , b = false , c =  1 }.b) }.a) , b = (let u = ({a = true , b = (((\x: Rec X. X .\y: Nat .x) 1 ) true) }.b) in ({a = 1 , b = 1 }.b)) }.b) > as Nat of < l = x > => x | < r = y > => y)
({a = (case <l = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 1 )) )) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ({a = (((\x: Bool .\y: Bool .x) false ) true) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.a) , b = (pred ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) }.a) }.a)
(fix (\x: Unit . (let u = (case <r = ({a = (let u = 1 in ({a = 0 , b = false , c =  0 }.b)) , b = (let u = 1 in false) }.b) > as Unit of < l = x > => x | < r = y > => y) in ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , b = ({a = 1 , b = false }.a) }.a)) ))
({a = (pred (( \f: Unit .((f (let u = (((\x: Nat .\y: Unit .x) false ) true) in 0) ) (if true then 1 else 1) ) ) (\a: Rec X. X .\b: Nat .b))) , b = (((\x: Bool .\y: Rec X. X .y) ({a = 0 , b = (fix (\x: Unit . false )) }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false ))) }.a)
(if (((\x: Unit .\y: Rec X. X .y) (let u = (iszero 1) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (case <r = ({a = (pred 1) , b = ({a = false , b = false }.b) , c =  (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.b) > as Bool of < l = x > => x | < r = y > => y) ))) then (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) ({a = false , b = 1 }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) )) )) )) else ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f (((\x: Nat .\y: Bool .y) true ) 1) ) (succ 1) ) ) (\a: Bool .\b: Rec X. X .a)) )))
(let u = (( \f: Nat .((f (iszero (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) 1 ) ) (\a: Bool .\b: Rec X. X .a))) ) (if ({a = false , b = true }.b) then ({a = false , b = (let u = false in u) }.b) else ({a = (((\x: Unit .\y: Rec X. X .x) true ) true) , b = (fix (\x: Unit . 0 )) }.a)) ) ) (\a: Bool .\b: Nat .b)) in ({a = ({a = (if true then 1 else 0) , b = ({a = (if false then 0 else 1) , b = false }.b) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.b) , b = ({a = true , b = 1 }.b) }.a))
(((\x: Rec X. X .\y: Nat .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (if true then true else (let u = false in u)) )))
(((\x: Rec X. X .\y: Bool .y) ({a = (let u = ({a = true , b = 0 }.a) in (if false then true else true)) , b = ({a = (if (let u = 0 in false) then (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) else ({a = true , b = 1 }.a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] 0 )) )) }.a) }.b) ) (((\x: Unit .\y: Bool .x) (let u = (((\x: Unit .\y: Nat .x) 1 ) true) in true) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 1 in false) ))))
(case <l = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (case <l = (let u = 0 in u) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f 1 ) (succ 0) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .a)) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = ({a = ({a = ({a = true , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.b) , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) }.b) , b = ({a = (unfold [ Rec X. X ] (fold [ Nat ] false )) , b = (iszero 0) }.b) }.b) in u)
({a = (unfold [ Rec X. X ] (fold [ Unit ] (let u = (succ 1) in u) )) , b = (pred ({a = ({a = 0 , b = false }.a) , b = (((\x: Nat .\y: Nat .x) 1 ) true) }.b)) }.b)
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = ({a = false , b = 0 }.b) , b = ({a = 1 , b = true , c = 1 }.c) }.b) , b = (if (( \f: Nat .((f ({a = (((\x: Bool .\y: Bool .x) 1 ) true) , b = (iszero 1) , c =  1 }.b) ) (iszero 0) ) ) (\a: Unit .\b: Rec X. X .b)) then (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) false ) ) (\a: Bool .\b: Nat .b)) else (if (let u = true in u) then (((\x: Nat .\y: Rec X. X .x) true ) false) else ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )))) }.b) ))
(( \f: Rec X. X .((f (succ (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) false ) (let u = false in u)) ) (((\x: Unit .\y: Rec X. X .x) (succ 1) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true ))))) ) (unfold [ Unit ] (fold [ Rec X. X ] (let u = (succ (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) in u) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(if (iszero (succ (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Bool .\y: Unit .x) 1 ) (iszero 0)) ) (let u = true in u)))) then ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = (let u = ({a = false , b = 0 }.b) in u) }.b) else (( \f: Unit .((f (let u = (((\x: Nat .\y: Bool .x) 1 ) false) in (let u = ({a = 0 , b = true }.a) in u)) ) (((\x: Nat .\y: Bool .y) ({a = 1 , b = false , c =  1 }.b) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Rec X. X .\b: Bool .a)))
(case <l = (((\x: Bool .\y: Unit .y) (case <r = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f (let u = 1 in true) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Bool .a)) ) (((\x: Bool .\y: Unit .x) false ) true)) > as Nat of < l = x > => x | < r = y > => y) ) (pred (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = (((\x: Unit .\y: Nat .y) ({a = (let u = false in u) , b = ({a = (succ 1) , b = 0 }.b) }.a) ) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) 1 ) false) ))) , b = (fix (\x: Unit . ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = true in false) )) )) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (pred ({a = 0 , b = true }.a)) )) }.c) in (( \f: Nat .((f (if (let u = 0 in false) then (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) else (if false then 1 else 0)) ) (unfold [ Nat ] (fold [ Unit ] (pred 1) )) ) ) (\a: Unit .\b: Nat .a)))
(case <r = (let u = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = (fix (\x: Bool . false )) , c = (((\x: Rec X. X .\y: Rec X. X .y) false ) (if true then 1 else 0)) }.c) in (case <r = (iszero ({a = 1 , b = 1 }.b)) > as Nat of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y)
(case <l = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (let u = (fix (\x: Rec X. X . ({a = (fix (\x: Rec X. X . 1 )) , b = (((\x: Bool .\y: Rec X. X .x) false ) false) }.a) )) in u) , b = (((\x: Unit .\y: Bool .y) (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .x) false ) false) ) (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Unit .x) true ) false) ) ({a = 1 , b = false , c =  1 }.b)) ) ) (\a: Nat .\b: Bool .a)) ) (let u = (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a))) in ({a = true , b = (((\x: Bool .\y: Nat .y) false ) true) }.b))) }.a)
(( \f: Bool .((f (( \f: Unit .((f ({a = (let u = 0 in 0) , b = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) }.a) ) (unfold [ Unit ] (fold [ Nat ] 1 )) ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Unit .\y: Bool .y) (fix (\x: Bool . (if (((\x: Bool .\y: Rec X. X .x) true ) false) then true else false) )) ) ({a = (((\x: Nat .\y: Bool .y) true ) 0) , b = ({a = (((\x: Unit .\y: Nat .x) 1 ) false) , b = (unfold [ Bool ] (fold [ Bool ] false )) , c =  ({a = 1 , b = 0 }.b) }.b) , c = ({a = false , b = ({a = 1 , b = true }.a) }.b) }.c)) ) ) (\a: Rec X. X .\b: Nat .a))
(fix (\x: Rec X. X . ({a = (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) true ) (unfold [ Unit ] (fold [ Nat ] false ))) ) ({a = true , b = false }.b) ) ) (\a: Unit .\b: Bool .a)) , b = (let u = ({a = (((\x: Unit .\y: Unit .x) true ) true) , b = 1 }.a) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 ))) }.a) ))
({a = ({a = (((\x: Nat .\y: Nat .x) (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) ({a = 0 , b = true }.b)) , b = ({a = (( \f: Rec X. X .((f (let u = 0 in u) ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) , b = (((\x: Rec X. X .\y: Nat .x) ({a = true , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a))) }.b) , c = ({a = (let u = false in (((\x: Rec X. X .\y: Bool .y) false ) 1)) , b = (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] 0 )) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Unit .a)) )) }.b) }.c) , b = (( \f: Rec X. X .((f (succ (let u = 1 in u)) ) (succ (((\x: Unit .\y: Nat .x) (fix (\x: Bool . 0 )) ) false)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
(if (if ({a = (((\x: Rec X. X .\y: Unit .y) (let u = 0 in false) ) ({a = 1 , b = true , c =  0 }.b)) , b = (( \f: Bool .((f (case <l = (pred 1) > as Bool of < l = x > => x | < r = y > => y) ) (let u = 1 in 1) ) ) (\a: Bool .\b: Unit .b)) }.a) then (((\x: Unit .\y: Nat .x) (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .y) false ) false) )) ) (unfold [ Nat ] (fold [ Rec X. X ] false ))) else (iszero (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)))) then (pred (let u = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = false }.b) in ({a = ({a = 1 , b = false , c =  0 }.b) , b = ({a = true , b = 1 }.b) }.b))) else (let u = (((\x: Rec X. X .\y: Unit .y) false ) (((\x: Unit .\y: Nat .x) 1 ) false)) in u))
(fix (\x: Nat . (if (case <r = (unfold [ Nat ] (fold [ Unit ] false )) > as Bool of < l = x > => x | < r = y > => y) then (let u = ({a = (iszero 1) , b = true }.b) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) false ) true) ))) else (( \f: Bool .((f ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = false }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ))
(case <l = ({a = (fix (\x: Unit . false )) , b = (unfold [ Unit ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) )) }.b) > as Bool of < l = x > => x | < r = y > => y)
({a = (( \f: Bool .((f (( \f: Unit .((f (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) ) (\a: Nat .\b: Nat .a)) ) (let u = (pred 1) in ({a = false , b = false }.b)) ) ) (\a: Nat .\b: Unit .a)) , b = (((\x: Nat .\y: Unit .y) ({a = (if ({a = false , b = true }.b) then 1 else (succ 1)) , b = ({a = 1 , b = (if false then true else true) }.b) }.b) ) (let u = (let u = false in u) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )))) }.b)
(let u = (if (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) in ({a = 1 , b = false }.b)) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) else (pred 1)) in (( \f: Nat .((f ({a = (fix (\x: Bool . true )) , b = 0 }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) )) ) ) (\a: Unit .\b: Bool .a)))
(unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f ({a = (let u = true in false) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] 1 )) )) ) ) (\a: Rec X. X .\b: Nat .a)) ))
(( \f: Bool .((f (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = (if false then true else false) }.b) )) ) (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Nat .x) (let u = 0 in true) ) (let u = true in u)) )) ) ) (\a: Nat .\b: Bool .a))
(let u = (((\x: Rec X. X .\y: Bool .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false }.a) )) ) ({a = true , b = (iszero 0) }.b)) in u)
(if ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = (succ 1) , b = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .b)) , c =  (fix (\x: Nat . 0 )) }.b) }.b) then (let u = (( \f: Nat .((f (pred 0) ) 0 ) ) (\a: Bool .\b: Bool .a)) in (((\x: Bool .\y: Bool .x) ({a = (let u = true in 1) , b = true , c =  1 }.b) ) (iszero (if true then 1 else 1)))) else ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = false , b = false }.b) )) , b = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = false , b = 1 }.a) }.a) }.a))
(if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero (pred 1)) )) then (let u = ({a = (pred (let u = 0 in 1)) , b = (if (fix (\x: Unit . (let u = true in false) )) then ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . true )) }.b) else (unfold [ Rec X. X ] (fold [ Bool ] true ))) }.a) in (unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) true ) ) (\a: Nat .\b: Rec X. X .b)) ))) else (fix (\x: Bool . (if (iszero (pred 1)) then (( \f: Nat .((f true ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Nat .a)) else ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , b = true }.b)) )))
(iszero (succ ({a = (if false then true else false) , b = ({a = (((\x: Unit .\y: Unit .x) 0 ) true) , b = false }.a) }.b)))
(( \f: Nat .((f (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Unit .x) (let u = (( \f: Bool .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .b)) ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .b)) in (if true then true else false)) ) (let u = true in (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)))) )) ) (let u = ({a = 1 , b = 1 }.b) in (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Unit .x) false ) false) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y))) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Unit .\y: Bool .x) ({a = (let u = (let u = true in 0) in u) , b = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) in (((\x: Bool .\y: Unit .y) false ) true)) }.a) ) (let u = ({a = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = true }.b) in ({a = (let u = 0 in false) , b = ({a = false , b = 1 }.a) }.b)))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (case <r = (if (let u = false in false) then ({a = false , b = false }.b) else true) > as Bool of < l = x > => x | < r = y > => y) ))
(( \f: Unit .((f (if (let u = (let u = true in false) in u) then ({a = ({a = true , b = false }.b) , b = ({a = 0 , b = false }.a) }.a) else (((\x: Bool .\y: Nat .x) ({a = 1 , b = true , c =  1 }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )))) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = (unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f ({a = 1 , b = true , c =  0 }.b) ) (let u = false in u) ) ) (\a: Bool .\b: Unit .b)) )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.a) )) ) ) (\a: Unit .\b: Bool .b))
(let u = (case <l = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (succ 0) )) > as Unit of < l = x > => x | < r = y > => y) in (let u = (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f ({a = false , b = 0 }.a) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) )) in u))
({a = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in u) )) , b = (let u = (let u = (pred 0) in (let u = true in u)) in u) }.b) , b = (((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] (fix (\x: Bool . true )) )) ) (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) , b = true }.b) in ({a = 0 , b = (((\x: Bool .\y: Bool .y) true ) true) }.a))) }.a)
({a = ({a = (( \f: Nat .((f (let u = false in false) ) ({a = true , b = 0 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Nat .\y: Rec X. X .y) false ) 1) }.b) , b = (( \f: Nat .((f ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (if (((\x: Bool .\y: Rec X. X .y) true ) true) then ({a = 1 , b = true }.b) else (let u = 0 in false)) }.b) ) ({a = (let u = (if true then 0 else 1) in u) , b = ({a = true , b = 0 }.a) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) , c = ({a = ({a = (succ 0) , b = (let u = 0 in 0) }.b) , b = (pred (let u = 0 in u)) }.b) }.c)
({a = (case <l = (let u = (let u = ({a = 0 , b = true }.a) in u) in ({a = 0 , b = ({a = 0 , b = true , c =  0 }.b) }.a)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Bool .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = true in 1) ) ) (\a: Unit .\b: Nat .b)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = true , b = 1 }.b) , b = false }.b) )) , c =  (( \f: Bool .((f 0 ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Unit .b)) }.b) , c = (pred ({a = false , b = 1 }.b)) }.c)
(unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f (succ (case <l = (if false then 0 else 1) > as Unit of < l = x > => x | < r = y > => y)) ) (( \f: Bool .((f (succ 1) ) ({a = 1 , b = (let u = false in u) }.a) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Bool .a)) ))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (if ({a = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (let u = true in false) }.b) then ({a = (iszero 0) , b = 1 }.a) else (( \f: Rec X. X .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ))
(if ({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) false ) false) )) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 0 , b = false }.b) ) false) }.b) then ({a = (iszero ({a = (let u = (unfold [ Rec X. X ] (fold [ Unit ] true )) in 1) , b = (unfold [ Unit ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) )) }.a)) , b = (let u = ({a = 0 , b = true , c =  1 }.b) in (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a))) }.b) else (let u = (if true then false else ({a = true , b = true }.b)) in ({a = 1 , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) }.b)))
(let u = (((\x: Unit .\y: Nat .y) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .y) true ) false) )) in (((\x: Nat .\y: Unit .y) true ) (fix (\x: Bool . false )))) ) (( \f: Rec X. X .((f (let u = 0 in u) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Bool .b))) in (fix (\x: Unit . (let u = ({a = 1 , b = true }.a) in (if (((\x: Rec X. X .\y: Unit .y) false ) true) then (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) else 1)) )))
(pred (if (fix (\x: Bool . ({a = false , b = 0 }.a) )) then (((\x: Rec X. X .\y: Bool .y) (let u = true in false) ) (if ({a = 0 , b = false }.b) then (fix (\x: Bool . 1 )) else ({a = 1 , b = false }.a))) else (((\x: Unit .\y: Nat .x) ({a = 0 , b = false , c = 1 }.c) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a)))))
(( \f: Rec X. X .((f (fix (\x: Nat . ({a = (if (fix (\x: Bool . false )) then (pred 0) else ({a = 0 , b = true , c = 1 }.c)) , b = ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) false ) false) , c =  1 }.b) }.b) )) ) (((\x: Rec X. X .\y: Unit .y) (fix (\x: Nat . (unfold [ Nat ] (fold [ Unit ] (let u = (let u = true in 1) in false) )) )) ) (((\x: Bool .\y: Rec X. X .x) ({a = true , b = false }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .b)))) ) ) (\a: Nat .\b: Nat .a))
(((\x: Nat .\y: Unit .y) (let u = (case <l = (if false then 0 else 1) > as Unit of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = false }.b) ))) ) (pred (let u = (if (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) then ({a = true , b = 0 }.a) else ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false ))) in (let u = 1 in u))))
({a = (fix (\x: Rec X. X . ({a = false , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.b) )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Unit .x) ({a = 1 , b = true , c = 1 }.c) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false ))) in u) )) }.a)
(succ (( \f: Bool .((f (succ ({a = (((\x: Rec X. X .\y: Nat .y) false ) 1) , b = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in u) , c = (let u = ({a = false , b = 1 }.b) in u) }.c)) ) (((\x: Unit .\y: Bool .y) ({a = ({a = 0 , b = false , c =  0 }.b) , b = (let u = 0 in false) }.b) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) (fix (\x: Bool . 0 )) ) ) (\a: Bool .\b: Nat .b)) ))) ) ) (\a: Nat .\b: Rec X. X .b)))
(let u = (case <r = (let u = (let u = 0 in u) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) > as Bool of < l = x > => x | < r = y > => y) in (let u = (let u = (if false then true else true) in u) in (((\x: Nat .\y: Nat .y) true ) (((\x: Nat .\y: Unit .x) 0 ) false))))
(((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f ({a = (pred 0) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , c =  (fix (\x: Rec X. X . (((\x: Unit .\y: Nat .y) false ) 0) )) }.b) ) (( \f: Bool .((f ({a = false , b = true }.b) ) (let u = true in (((\x: Bool .\y: Bool .x) false ) true)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = (iszero (((\x: Bool .\y: Rec X. X .x) 0 ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .a)))) in u))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Bool ] ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = ({a = 0 , b = (let u = true in u) }.b) }.b) )) ))
(( \f: Rec X. X .((f (( \f: Bool .((f (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in (let u = false in false)) ) (let u = ({a = (let u = false in 0) , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) , c =  ({a = true , b = 1 }.b) }.b) in u) ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = ({a = 1 , b = false }.a) in (((\x: Unit .\y: Unit .x) (let u = 1 in true) ) (let u = 1 in false))) ) ) (\a: Rec X. X .\b: Unit .a))
(unfold [ Unit ] (fold [ Bool ] (case <l = (( \f: Unit .((f 0 ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) ))
(let u = (((\x: Unit .\y: Bool .x) (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (fix (\x: Bool . (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (pred ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 ))) }.a)) in (case <l = (let u = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) in (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b))) > as Nat of < l = x > => x | < r = y > => y))
({a = (case <r = (if (iszero 0) then (fix (\x: Bool . false )) else ({a = true , b = true }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = (fix (\x: Unit . true )) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b))) )) }.a)
(fix (\x: Unit . (let u = (let u = (let u = true in 0) in u) in u) ))
(((\x: Bool .\y: Rec X. X .x) (((\x: Bool .\y: Unit .y) (case <r = (let u = true in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ({a = 0 , b = false }.b) , b = (((\x: Bool .\y: Rec X. X .y) (fix (\x: Rec X. X . false )) ) 0) }.a)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f ({a = 1 , b = true , c =  0 }.b) ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Rec X. X .a)) )))
({a = ({a = ({a = (succ ({a = 0 , b = 1 }.b)) , b = (((\x: Unit .\y: Bool .x) (if true then false else false) ) false) , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) , b = (pred 0) }.b) , b = ({a = (let u = (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Unit .x) 1 ) false) ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b))) in u) , b = (( \f: Unit .((f ({a = 0 , b = false , c =  1 }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) }.b) , c = (unfold [ Nat ] (fold [ Bool ] (case <l = (let u = 1 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.c)
({a = (pred (case <l = (((\x: Nat .\y: Bool .x) (let u = 0 in 0) ) false) > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = (((\x: Bool .\y: Unit .x) ({a = 1 , b = true }.a) ) (if true then true else true)) , b = (let u = ({a = true , b = 0 }.b) in (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Bool .x) true ) false) ) (unfold [ Rec X. X ] (fold [ Nat ] false )))) }.b) }.a)
({a = (( \f: Nat .((f (succ (let u = 0 in 0)) ) (let u = (fix (\x: Rec X. X . (case <l = (((\x: Nat .\y: Unit .x) 0 ) false) > as Unit of < l = x > => x | < r = y > => y) )) in u) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (iszero (((\x: Nat .\y: Unit .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) (iszero (fix (\x: Nat . 1 ))))) , c =  (let u = (succ (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = true , c = 1 }.c) ))) in u) }.b)
({a = (let u = (((\x: Nat .\y: Unit .x) ({a = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) then (unfold [ Unit ] (fold [ Bool ] true )) else true) , b = ({a = true , b = ({a = 0 , b = true , c = 1 }.c) }.a) }.b) ) (( \f: Unit .((f (let u = 1 in false) ) ({a = 1 , b = (let u = 1 in true) , c =  0 }.b) ) ) (\a: Bool .\b: Bool .b))) in ({a = (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b))) , b = (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Nat ] 0 )) )) }.b)) , b = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = false }.b) )) , c =  (succ ({a = (let u = true in 1) , b = ({a = 1 , b = true }.b) , c = 1 }.c)) }.b) }.a)
({a = (( \f: Unit .((f (if false then 1 else 0) ) ({a = (if true then (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) else (fix (\x: Unit . 1 ))) , b = (let u = 0 in 0) }.b) ) ) (\a: Nat .\b: Bool .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] ({a = (if (((\x: Nat .\y: Bool .y) true ) true) then (let u = 1 in 0) else ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 ))) , b = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = true , b = (fix (\x: Bool . false )) }.b) }.b) , c =  (((\x: Unit .\y: Bool .y) (let u = false in false) ) 0) }.b) )) }.a)
({a = (fix (\x: Bool . (pred ({a = ({a = 0 , b = 1 }.b) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .b)) , c = (let u = true in 0) }.c)) )) , b = (let u = (( \f: Nat .((f (fix (\x: Bool . 1 )) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Unit .b)) in ({a = 0 , b = (iszero 1) , c =  0 }.b)) }.a)
(( \f: Nat .((f ({a = (let u = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .b)) in u) , b = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 )) in u) }.a) ) (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (if false then true else true) )) )) in (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Bool .x) false ) (if true then true else true)) ) ({a = 1 , b = false }.b))) ) ) (\a: Nat .\b: Bool .a))
(((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) true ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b))) )) ) ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Unit .((f (let u = 0 in u) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (if (let u = true in true) then (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) else 1) }.b) }.a)) ) (((\x: Bool .\y: Unit .x) (if (case <r = (let u = true in false) > as Bool of < l = x > => x | < r = y > => y) then (unfold [ Nat ] (fold [ Unit ] false )) else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = (iszero 0) in u)))
(( \f: Unit .((f (((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (((\x: Nat .\y: Bool .y) true ) false) , b = (unfold [ Rec X. X ] (fold [ Bool ] false )) }.b)) ) ({a = (if true then 1 else 0) , b = ({a = true , b = (succ 1) }.b) }.b)) ) ({a = (fix (\x: Unit . ({a = 0 , b = true }.b) )) , b = (( \f: Rec X. X .((f (pred 0) ) (((\x: Bool .\y: Rec X. X .x) 0 ) false) ) ) (\a: Bool .\b: Unit .a)) }.b) ) ) (\a: Rec X. X .\b: Nat .b))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f true ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Nat .b)) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) in (fix (\x: Nat . true ))) , c =  ({a = (pred 0) , b = false }.a) }.b) ))
(fix (\x: Rec X. X . ({a = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = true , c = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.c) , b = (((\x: Bool .\y: Unit .y) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .b)) ) ({a = ({a = false , b = false }.b) , b = ({a = false , b = 0 }.b) }.b)) }.b) ))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f (unfold [ Bool ] (fold [ Bool ] false )) ) (iszero 1) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = 0 , b = 0 }.b) }.b) ))
({a = (let u = ({a = ({a = 0 , b = true }.b) , b = (((\x: Rec X. X .\y: Nat .y) false ) 0) }.b) in ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (if false then false else true) ))) , b = (fix (\x: Rec X. X . (((\x: Nat .\y: Nat .y) true ) ({a = 1 , b = false }.a)) )) }.a)
({a = (((\x: Nat .\y: Unit .x) (succ (((\x: Rec X. X .\y: Unit .y) true ) 0)) ) (((\x: Nat .\y: Nat .x) (if false then false else true) ) (let u = false in true))) , b = (fix (\x: Nat . ({a = (fix (\x: Rec X. X . true )) , b = ({a = (fix (\x: Nat . (iszero 0) )) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.a) }.b) )) , c =  (let u = (if (let u = true in false) then ({a = (pred 1) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.a) else ({a = 0 , b = 0 }.b)) in u) }.b)
(let u = (let u = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) , b = (let u = 1 in false) }.b) in u) in ({a = (if (if true then false else false) then (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Rec X. X .\y: Unit .x) false ) false) )) else (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .b))) , b = (case <r = (unfold [ Bool ] (fold [ Unit ] false )) > as Bool of < l = x > => x | < r = y > => y) }.b))
(fix (\x: Bool . (let u = (( \f: Unit .((f (let u = (let u = 0 in u) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a))) ) (fix (\x: Unit . 0 )) ) ) (\a: Unit .\b: Nat .a)) in (((\x: Nat .\y: Rec X. X .y) (fix (\x: Bool . true )) ) ({a = false , b = false }.b))) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] (if ({a = (fix (\x: Bool . 0 )) , b = ({a = 0 , b = false , c =  1 }.b) , c =  (succ 0) }.b) then (let u = 1 in ({a = 0 , b = true , c = 1 }.c)) else (let u = ({a = 0 , b = false , c = 1 }.c) in (pred 1))) )) ))
(( \f: Unit .((f ({a = (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (if true then 1 else 0) , b = (fix (\x: Rec X. X . false )) , c = ({a = 0 , b = true }.a) }.c) }.a) ) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .a)) , c =  0 }.b) }.b) ) ) (\a: Nat .\b: Nat .a))
(( \f: Rec X. X .((f ({a = ({a = (fix (\x: Rec X. X . true )) , b = ({a = ({a = 1 , b = 0 }.b) , b = (let u = 0 in 0) }.b) }.a) , b = (if (let u = true in u) then (((\x: Rec X. X .\y: Unit .y) false ) 1) else ({a = 0 , b = false }.a)) }.a) ) ({a = (unfold [ Unit ] (fold [ Bool ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) , b = (let u = ({a = 0 , b = false }.b) in u) , c =  ({a = false , b = ({a = 1 , b = 0 }.b) }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
(fix (\x: Unit . (succ (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Rec X. X . ({a = 0 , b = true , c = 0 }.c) )) ))) ))
({a = ({a = (pred (if true then ({a = 1 , b = false , c = 0 }.c) else 0)) , b = (pred (succ (let u = 0 in 1))) }.b) , b = (iszero ({a = (if false then false else true) , b = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Nat ] 0 )) ) (if true then 0 else 0) ) ) (\a: Unit .\b: Unit .a)) }.b)) }.a)
(iszero (succ (let u = (if (((\x: Nat .\y: Nat .y) ({a = true , b = false }.b) ) (if false then true else false)) then ({a = false , b = false }.b) else (let u = ({a = 0 , b = false , c =  1 }.b) in u)) in ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = (((\x: Unit .\y: Rec X. X .y) true ) false) , c = ({a = 1 , b = true , c = 1 }.c) }.c))))
({a = (if ({a = (fix (\x: Bool . true )) , b = ({a = (let u = true in ({a = false , b = 0 }.a)) , b = (succ 1) }.b) }.a) then (if (unfold [ Rec X. X ] (fold [ Nat ] false )) then (( \f: Nat .((f (let u = true in 0) ) 1 ) ) (\a: Nat .\b: Unit .a)) else (let u = false in 1)) else (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Nat .y) (iszero 1) ) true) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Unit .b))) , b = (((\x: Bool .\y: Bool .x) (((\x: Bool .\y: Bool .y) false ) (if true then false else true)) ) (let u = (fix (\x: Nat . false )) in u)) , c =  (( \f: Nat .((f (pred (if ({a = false , b = 0 }.a) then ({a = 1 , b = true }.a) else 0)) ) (pred (let u = 0 in u)) ) ) (\a: Unit .\b: Unit .b)) }.b)
(( \f: Rec X. X .((f (( \f: Nat .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (iszero 1) )) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .a)) ) (case <r = (iszero (let u = 0 in u)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b))
(( \f: Rec X. X .((f ({a = (let u = (iszero 0) in u) , b = (fix (\x: Bool . (( \f: Bool .((f (if true then ({a = 1 , b = 0 }.b) else ({a = 0 , b = true , c = 0 }.c)) ) (let u = 1 in ({a = 0 , b = true , c = 0 }.c)) ) ) (\a: Unit .\b: Nat .b)) )) }.b) ) ({a = ({a = ({a = false , b = (((\x: Nat .\y: Unit .x) 1 ) false) }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (pred 0) )) }.b) ) ) (\a: Bool .\b: Rec X. X .a))
(unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .x) (let u = ({a = 0 , b = false , c =  0 }.b) in u) ) (let u = (( \f: Bool .((f ({a = 1 , b = false , c = 0 }.c) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in (let u = (((\x: Bool .\y: Unit .x) false ) false) in (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a))))) ))
((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Bool . ({a = (let u = (fix (\x: Nat . 1 )) in u) , b = (fix (\x: Nat . (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) )) }.b) )) ))
(unfold [ Bool ] (fold [ Nat ] ({a = (if ({a = 1 , b = false }.b) then (if true then 1 else 1) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) then ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] false )) else (iszero 1)) in u) }.a) ))
(((\x: Bool .\y: Bool .y) ({a = ({a = (if true then false else true) , b = (fix (\x: Rec X. X . ({a = 1 , b = 0 }.b) )) }.a) , b = (((\x: Nat .\y: Rec X. X .x) (let u = 0 in false) ) (((\x: Bool .\y: Nat .y) false ) false)) }.b) ) (iszero (succ ({a = false , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b))))
(iszero (unfold [ Bool ] (fold [ Bool ] (fix (\x: Unit . (pred 1) )) )))
(((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Rec X. X .y) (let u = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) in ({a = true , b = false }.b)) ) ({a = (let u = 0 in 0) , b = true }.b)) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (if true then 1 else 1) )) , b = (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) > as Bool of < l = x > => x | < r = y > => y) }.b))
(fix (\x: Bool . (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] false )) )) ) (let u = (( \f: Rec X. X .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) true ) ) (\a: Unit .\b: Unit .a)) in (((\x: Nat .\y: Unit .x) ({a = false , b = 0 }.a) ) ({a = 0 , b = (((\x: Rec X. X .\y: Nat .x) false ) false) , c =  1 }.b))) ) ) (\a: Unit .\b: Unit .b)) ))
(fix (\x: Unit . (unfold [ Bool ] (fold [ Rec X. X ] (if ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) then (if false then false else ({a = 0 , b = false }.b)) else ({a = 1 , b = true }.b)) )) ))
(if (if ({a = (((\x: Rec X. X .\y: Nat .y) true ) true) , b = (iszero 1) }.b) then (let u = ({a = 0 , b = false , c =  1 }.b) in u) else (((\x: Nat .\y: Nat .y) ({a = 1 , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) }.b) ) (let u = (((\x: Unit .\y: Bool .y) false ) true) in true))) then (((\x: Nat .\y: Unit .y) (unfold [ Unit ] (fold [ Unit ] (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) ) false) )) )) ) (( \f: Bool .((f ({a = true , b = 1 }.b) ) ({a = 0 , b = true }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b))) else (((\x: Bool .\y: Unit .x) (( \f: Nat .((f ({a = 1 , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) }.a) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = (( \f: Nat .((f ({a = 0 , b = 0 }.b) ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) in (let u = true in true))))
(((\x: Rec X. X .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Bool .x) (((\x: Unit .\y: Unit .x) 0 ) ({a = false , b = false }.b)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false ))) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ))) ) (((\x: Bool .\y: Bool .y) (fix (\x: Nat . true )) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = false , c =  (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.b)))
(case <l = ({a = (fix (\x: Unit . ({a = ({a = 1 , b = false , c = 1 }.c) , b = (fix (\x: Bool . false )) , c =  (fix (\x: Rec X. X . 1 )) }.b) )) , b = (unfold [ Rec X. X ] (fold [ Bool ] ({a = 0 , b = true }.a) )) }.b) > as Unit of < l = x > => x | < r = y > => y)
(if (let u = (pred (let u = false in 1)) in (( \f: Rec X. X .((f (fix (\x: Nat . true )) ) (let u = false in true) ) ) (\a: Nat .\b: Bool .b))) then (case <l = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = 0 in u) )) > as Nat of < l = x > => x | < r = y > => y) else (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Nat .y) false ) true) ) (let u = true in ({a = 1 , b = 0 }.b))))
(((\x: Rec X. X .\y: Bool .y) ({a = ({a = (if (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .b)) then (fix (\x: Bool . 1 )) else ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .y) true ) 1) ))) , b = (( \f: Rec X. X .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) , b = (((\x: Rec X. X .\y: Nat .x) (fix (\x: Unit . (let u = 1 in (unfold [ Nat ] (fold [ Unit ] false ))) )) ) (if (((\x: Unit .\y: Nat .x) true ) false) then (((\x: Bool .\y: Unit .x) true ) false) else (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y))) }.b) ) ({a = ({a = ({a = 0 , b = (((\x: Nat .\y: Nat .y) true ) true) , c = 1 }.c) , b = ({a = (unfold [ Bool ] (fold [ Unit ] 1 )) , b = ({a = 1 , b = true }.a) }.b) }.b) , b = (let u = (iszero 1) in ({a = ({a = 1 , b = true , c = 0 }.c) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , c =  (pred 0) }.b)) }.b))
(let u = (((\x: Unit .\y: Unit .y) (if false then (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) else (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .b))) ) ({a = false , b = (let u = true in u) }.b)) in (let u = (( \f: Nat .((f ({a = 0 , b = false , c =  0 }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) ) ) (\a: Nat .\b: Rec X. X .a)) in u))
(if ({a = (case <r = (unfold [ Bool ] (fold [ Unit ] false )) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = false in 1) }.a) then (case <l = (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Rec X. X . false )) ) (pred 1)) > as Bool of < l = x > => x | < r = y > => y) else (if (( \f: Unit .((f ({a = (if true then false else true) , b = 1 }.a) ) (let u = 0 in false) ) ) (\a: Unit .\b: Nat .b)) then ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = (((\x: Unit .\y: Nat .x) 1 ) true) }.b) else ({a = (fix (\x: Nat . 0 )) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b)))
(((\x: Bool .\y: Rec X. X .y) (( \f: Unit .((f ({a = 1 , b = (fix (\x: Rec X. X . false )) }.b) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) )) , b = (fix (\x: Rec X. X . true )) }.b) ) ) (\a: Nat .\b: Bool .b)) ) ({a = (((\x: Rec X. X .\y: Nat .y) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a)) ) 0) , b = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .a)) in u) , c = (unfold [ Nat ] (fold [ Bool ] (let u = false in 0) )) }.c))
(( \f: Unit .((f ({a = (let u = (let u = 1 in 0) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) , b = (pred (succ 1)) }.b) ) ({a = (((\x: Rec X. X .\y: Bool .y) false ) 1) , b = ({a = 1 , b = ({a = true , b = 0 }.a) }.b) , c = (let u = 1 in 0) }.c) ) ) (\a: Rec X. X .\b: Nat .a))
(( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .y) ({a = (let u = true in u) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a)) }.b) ) (fix (\x: Unit . (if (if false then true else false) then true else ({a = false , b = 1 }.a)) ))) ) (let u = (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (if true then 0 else 0) ) ) (\a: Bool .\b: Bool .a)) in (( \f: Bool .((f (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) true ) false) ) (if false then ({a = 1 , b = false , c =  1 }.b) else (((\x: Bool .\y: Rec X. X .x) false ) true)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (((\x: Bool .\y: Unit .y) (if false then true else false) ) true) ) ) (\a: Unit .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Unit .b))
(let u = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Rec X. X . ({a = false , b = false }.b) )) )) )) in u)
(let u = (fix (\x: Rec X. X . (let u = ({a = (( \f: Bool .((f (iszero 1) ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = (fix (\x: Unit . 1 )) }.a) in u) )) in u)
(unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] (if false then (unfold [ Bool ] (fold [ Unit ] true )) else true) )) ))
(fix (\x: Rec X. X . ({a = (pred (let u = (unfold [ Unit ] (fold [ Nat ] 0 )) in u)) , b = (if (case <r = (iszero (succ 1)) > as Unit of < l = x > => x | < r = y > => y) then ({a = (pred 1) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) , c =  ({a = 1 , b = 1 }.b) }.b) else ({a = 1 , b = ({a = true , b = false }.b) }.b)) }.a) ))
({a = ({a = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true }.a) )) ) (let u = (( \f: Nat .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) 1 ) ) (\a: Bool .\b: Nat .a)) in u) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = (fix (\x: Bool . 0 )) , b = (let u = 1 in false) , c =  (if (((\x: Nat .\y: Rec X. X .x) false ) true) then ({a = 1 , b = false }.a) else (fix (\x: Bool . 0 ))) }.b) , c = ({a = (let u = (let u = 1 in u) in (fix (\x: Nat . 0 ))) , b = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = (((\x: Unit .\y: Bool .y) false ) false) , c =  (fix (\x: Rec X. X . 1 )) }.b) , c = ({a = ({a = 1 , b = true }.b) , b = (((\x: Nat .\y: Rec X. X .x) 0 ) false) }.b) }.c) }.c) , b = ({a = (let u = (let u = (let u = true in 1) in (((\x: Nat .\y: Bool .x) ({a = true , b = false }.b) ) false)) in u) , b = (let u = (fix (\x: Rec X. X . 1 )) in u) }.a) , c =  (fix (\x: Bool . ({a = (if false then true else false) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.b) )) }.b)
(let u = (unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) )) in ({a = ({a = ({a = true , b = true }.b) , b = 1 }.b) , b = (((\x: Unit .\y: Nat .x) true ) ({a = 0 , b = true , c =  1 }.b)) }.b))
(case <r = (unfold [ Rec X. X ] (fold [ Unit ] (iszero 0) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Unit .y) (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false )) )) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (fix (\x: Unit . ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 )) )) , b = (( \f: Rec X. X .((f (iszero 1) ) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) ) (\a: Bool .\b: Unit .a)) }.b)) ) (case <r = (let u = ({a = 0 , b = false }.a) in ({a = ({a = 0 , b = false }.b) , b = 0 }.a)) > as Bool of < l = x > => x | < r = y > => y))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . (let u = false in u) )) )) , b = (let u = (let u = ({a = 0 , b = true }.b) in u) in (let u = (if true then true else true) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )))) }.b)
(fix (\x: Unit . (( \f: Rec X. X .((f (pred (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))) ) ({a = (((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Bool .x) false ) false) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 ))) , b = ({a = (let u = 0 in u) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .b)) , c =  (fix (\x: Unit . 1 )) }.b) }.a) ) ) (\a: Unit .\b: Unit .a)) ))
(if ({a = ({a = ({a = true , b = true }.b) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b) , b = ({a = (let u = false in u) , b = 1 }.a) , c =  (if ({a = false , b = 1 }.a) then 1 else (unfold [ Nat ] (fold [ Nat ] 0 ))) }.b) then (pred (let u = ({a = true , b = 1 }.b) in 0)) else (unfold [ Nat ] (fold [ Unit ] (succ ({a = 0 , b = 1 }.b)) )))
(case <r = (fix (\x: Unit . ({a = (let u = 0 in 1) , b = (fix (\x: Nat . true )) , c =  (succ (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
(iszero (( \f: Bool .((f ({a = (((\x: Unit .\y: Rec X. X .y) false ) 1) , b = ({a = false , b = 0 }.a) }.a) ) (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Nat .y) false ) 1)) ) ) (\a: Nat .\b: Unit .b)))
(((\x: Rec X. X .\y: Nat .y) (let u = (( \f: Rec X. X .((f (( \f: Bool .((f (( \f: Rec X. X .((f ({a = true , b = true }.b) ) true ) ) (\a: Unit .\b: Nat .a)) ) (( \f: Rec X. X .((f ({a = 0 , b = false , c =  1 }.b) ) true ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) ) (let u = ({a = 0 , b = true }.b) in ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) ) ) (\a: Unit .\b: Unit .b)) in u) ) ({a = (if (( \f: Unit .((f false ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (iszero 1) else ({a = 1 , b = (let u = 1 in false) , c =  0 }.b)) , b = ({a = (fix (\x: Nat . false )) , b = (let u = false in false) }.b) }.b))
(unfold [ Nat ] (fold [ Bool ] (let u = ({a = (succ (unfold [ Rec X. X ] (fold [ Unit ] 0 ))) , b = (( \f: Nat .((f 0 ) (pred 0) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) in ({a = ({a = false , b = ({a = 0 , b = 0 }.b) }.a) , b = (if (let u = true in u) then ({a = 1 , b = 1 }.b) else ({a = 1 , b = false }.a)) }.b)) ))
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f (( \f: Bool .((f false ) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Bool .\y: Nat .x) false ) true) ) ) (\a: Bool .\b: Nat .a)) ))
(case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Nat . false )) )) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (( \f: Unit .((f (iszero (( \f: Bool .((f (let u = 1 in u) ) (if false then 1 else 1) ) ) (\a: Rec X. X .\b: Bool .b))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = false , b = 1 }.a) )) ) ) (\a: Unit .\b: Bool .a)) ) (fix (\x: Rec X. X . (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Rec X. X .a))
(case <l = (succ (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) in 0)) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (( \f: Rec X. X .((f ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) , b = (( \f: Bool .((f true ) (let u = true in true) ) ) (\a: Nat .\b: Bool .b)) }.b) ) ({a = (let u = 0 in u) , b = (((\x: Nat .\y: Nat .x) (let u = 1 in false) ) (fix (\x: Bool . false ))) , c =  ({a = 0 , b = true }.a) }.b) ) ) (\a: Nat .\b: Nat .b)) ) (unfold [ Bool ] (fold [ Bool ] (if ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (let u = true in u) )) then (iszero 1) else (unfold [ Nat ] (fold [ Nat ] true ))) )) ) ) (\a: Unit .\b: Unit .b))
(let u = (( \f: Unit .((f ({a = (iszero 1) , b = (fix (\x: Bool . 0 )) }.a) ) (( \f: Nat .((f (if false then false else true) ) false ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a)) in ({a = (( \f: Rec X. X .((f ({a = ({a = true , b = 1 }.b) , b = (fix (\x: Nat . 0 )) }.b) ) (succ (pred (succ 0))) ) ) (\a: Nat .\b: Nat .a)) , b = ({a = (if true then true else (let u = false in false)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 )) }.a) }.b))
(( \f: Nat .((f (( \f: Bool .((f (fix (\x: Unit . (if true then false else true) )) ) ({a = 0 , b = true , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Nat .\b: Unit .a)) ) (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) 1 ) true) )) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Bool .b))
({a = (unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f false ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Bool .a)) )) , b = (((\x: Unit .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) )) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) , b = ({a = 1 , b = true }.b) }.b)) }.b)
(fix (\x: Rec X. X . (iszero (if (unfold [ Bool ] (fold [ Rec X. X ] (let u = 0 in true) )) then (if false then 0 else 1) else (((\x: Rec X. X .\y: Bool .x) 1 ) false))) ))
({a = (((\x: Bool .\y: Rec X. X .x) (if (case <r = ({a = false , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Nat .\y: Bool .y) true ) ({a = true , b = 1 }.b)) else (if (((\x: Nat .\y: Bool .x) true ) true) then 0 else 1)) ) ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = (let u = 1 in false) }.a) , b = (unfold [ Bool ] (fold [ Unit ] (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) )) , c =  ({a = (fix (\x: Nat . 1 )) , b = ({a = (let u = 1 in 1) , b = true }.b) }.a) }.b)) , b = (((\x: Rec X. X .\y: Unit .y) ({a = ({a = ({a = false , b = 1 }.a) , b = (let u = 1 in u) }.b) , b = (( \f: Rec X. X .((f (iszero (let u = 0 in 0)) ) ({a = ({a = 1 , b = false }.b) , b = 0 }.a) ) ) (\a: Rec X. X .\b: Bool .a)) , c =  ({a = 0 , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , c = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.c) }.b) ) (let u = ({a = (fix (\x: Rec X. X . 0 )) , b = (fix (\x: Rec X. X . false )) , c =  1 }.b) in ({a = false , b = (pred 0) }.a))) }.a)
(if (( \f: Bool .((f (let u = (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then false else (((\x: Unit .\y: Rec X. X .y) true ) false)) in u) ) ({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) , b = (iszero 0) , c = (if false then 1 else 0) }.c) , b = (let u = (((\x: Bool .\y: Nat .y) true ) 1) in (fix (\x: Nat . false ))) , c =  (fix (\x: Unit . 1 )) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) then (let u = (( \f: Unit .((f (let u = (let u = false in true) in (iszero (let u = 0 in u))) ) (( \f: Unit .((f (iszero 0) ) (let u = 0 in false) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .b)) in ({a = (( \f: Rec X. X .((f 1 ) ({a = false , b = 1 }.b) ) ) (\a: Unit .\b: Unit .a)) , b = (let u = ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) false) , b = 0 }.b) in (((\x: Rec X. X .\y: Rec X. X .x) (let u = false in true) ) ({a = true , b = true }.b))) , c =  (((\x: Unit .\y: Rec X. X .y) (if false then false else false) ) ({a = true , b = 0 }.b)) }.b)) else (let u = (iszero 1) in u))
(let u = (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f (let u = (succ 0) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 ))) ) (case <l = (let u = 1 in 1) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) )) in (let u = (( \f: Unit .((f (unfold [ Bool ] (fold [ Nat ] 0 )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Nat .\b: Rec X. X .a)) in u))
(( \f: Nat .((f (((\x: Bool .\y: Nat .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (((\x: Unit .\y: Nat .y) true ) false) in false) )) ) (let u = (let u = 1 in 0) in (let u = false in u))) ) (let u = (fix (\x: Nat . (iszero 1) )) in (fix (\x: Bool . true ))) ) ) (\a: Bool .\b: Unit .b))
(if (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in (fix (\x: Nat . true ))) )) in u) then (fix (\x: Unit . ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = true in 0) )) , b = (if (( \f: Bool .((f (((\x: Unit .\y: Unit .x) true ) true) ) false ) ) (\a: Unit .\b: Unit .b)) then (if true then true else true) else (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] true )) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Rec X. X .b))) , c = (succ (unfold [ Unit ] (fold [ Rec X. X ] 0 ))) }.c) )) else ({a = (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] 1 )) ) (((\x: Bool .\y: Bool .y) false ) 1) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Bool .\y: Rec X. X .y) (fix (\x: Unit . false )) ) (let u = (((\x: Unit .\y: Bool .x) 1 ) false) in ({a = true , b = 0 }.a))) }.a))
({a = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) , b = (case <l = (((\x: Rec X. X .\y: Bool .x) 0 ) false) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (iszero (( \f: Rec X. X .((f (if ({a = false , b = (let u = 0 in false) }.b) then (((\x: Bool .\y: Unit .x) 1 ) true) else (fix (\x: Bool . 0 ))) ) (let u = ({a = true , b = 1 }.b) in 0) ) ) (\a: Rec X. X .\b: Unit .a))) }.b)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) , b = ({a = false , b = false }.b) }.a) ) (fix (\x: Bool . (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) in ({a = true , b = 0 }.a)) ))) ))
(unfold [ Nat ] (fold [ Bool ] (if ({a = ({a = ({a = 0 , b = true }.a) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a)) )) }.b) then (( \f: Rec X. X .((f ({a = true , b = true }.b) ) (iszero ({a = 0 , b = false }.a)) ) ) (\a: Rec X. X .\b: Unit .a)) else ({a = (( \f: Nat .((f ({a = 1 , b = 0 }.b) ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = (unfold [ Unit ] (fold [ Unit ] true )) , c =  (let u = 1 in 0) }.b)) ))
(((\x: Bool .\y: Unit .x) (let u = (fix (\x: Nat . (let u = 1 in false) )) in ({a = ({a = 0 , b = false , c =  1 }.b) , b = false }.b)) ) (((\x: Unit .\y: Nat .x) ({a = (let u = 1 in u) , b = false , c =  (let u = false in 0) }.b) ) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = 1 in u) )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) }.b)))
(unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Rec X. X . (if (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = false }.b) )) then (pred (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) else (( \f: Nat .((f ({a = true , b = 1 }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) ) (\a: Bool .\b: Rec X. X .a))) )) ))
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero ({a = (fix (\x: Bool . 1 )) , b = false }.a)) )) , b = (( \f: Unit .((f ({a = ({a = 0 , b = true }.a) , b = (iszero 1) }.a) ) (if ({a = 0 , b = false , c =  (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) then ({a = 0 , b = true }.a) else (((\x: Unit .\y: Bool .x) 0 ) true)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)
(fix (\x: Unit . ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (if (let u = 1 in false) then false else false) )) )) ))
(case <r = (((\x: Nat .\y: Unit .x) (let u = (if (((\x: Unit .\y: Nat .x) false ) false) then true else false) in (let u = false in (((\x: Unit .\y: Unit .x) true ) false))) ) (( \f: Bool .((f (let u = (((\x: Bool .\y: Rec X. X .y) false ) true) in u) ) (( \f: Nat .((f true ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .b))) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (pred (let u = (let u = (let u = true in u) in 1) in (let u = ({a = 0 , b = true , c = 1 }.c) in u))) ) (let u = ({a = (if true then 1 else (((\x: Bool .\y: Nat .x) 1 ) false)) , b = (let u = 1 in true) , c = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) }.c) in ({a = 0 , b = (if false then 1 else 0) }.b)) ) ) (\a: Unit .\b: Unit .a))
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = (((\x: Rec X. X .\y: Nat .x) 0 ) false) in false) )) , b = (( \f: Unit .((f (let u = false in u) ) (((\x: Nat .\y: Nat .y) (fix (\x: Rec X. X . true )) ) ({a = true , b = 1 }.a)) ) ) (\a: Nat .\b: Rec X. X .b)) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) (if (unfold [ Bool ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) ) ({a = 1 , b = true }.b)) )) then ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) , b = (((\x: Bool .\y: Rec X. X .y) false ) (((\x: Rec X. X .\y: Unit .y) true ) true)) }.b) else (fix (\x: Rec X. X . (fix (\x: Rec X. X . false )) ))) ) (( \f: Rec X. X .((f (( \f: Bool .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) false ) ) (\a: Nat .\b: Bool .b)) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = false in false) )) ) ) (\a: Rec X. X .\b: Nat .a))) ))
({a = (let u = (((\x: Unit .\y: Rec X. X .x) false ) ({a = true , b = false }.b)) in ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . 0 )) }.b)) , b = (iszero ({a = (( \f: Bool .((f (fix (\x: Unit . ({a = 1 , b = false }.a) )) ) (unfold [ Unit ] (fold [ Unit ] 0 )) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) in (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a))) , c = ({a = ({a = 0 , b = ({a = false , b = false }.b) }.a) , b = (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.b) }.c)) , c =  (if (((\x: Rec X. X .\y: Bool .y) ({a = true , b = ({a = true , b = true }.b) }.b) ) (let u = true in true)) then (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = 1 }.b) )) else (succ (let u = true in 1))) }.b)
(fix (\x: Nat . ({a = ({a = (( \f: Unit .((f 1 ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = false in 0) }.b) , b = (let u = (let u = true in u) in u) , c =  ({a = (let u = false in 0) , b = (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) }.a) }.b) ))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (((\x: Unit .\y: Rec X. X .x) false ) false) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.a) )) , b = (fix (\x: Rec X. X . (iszero 1) )) }.b)
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Rec X. X . (( \f: Unit .((f ({a = 0 , b = false }.a) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Bool .b)) )) )) in (if (((\x: Unit .\y: Nat .x) ({a = 1 , b = ({a = 0 , b = true }.b) , c =  (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.b) ) (((\x: Rec X. X .\y: Bool .x) ({a = true , b = (if true then 1 else 0) }.a) ) (unfold [ Rec X. X ] (fold [ Nat ] true )))) then (( \f: Rec X. X .((f (( \f: Nat .((f (if true then false else true) ) false ) ) (\a: Unit .\b: Bool .a)) ) ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .x) 0 ) ({a = true , b = false }.b)) }.a) ) ) (\a: Unit .\b: Unit .b)) else (let u = (( \f: Bool .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (let u = false in true))))
(if ({a = ({a = ({a = false , b = 0 }.b) , b = ({a = 0 , b = false }.b) }.a) , b = (let u = (unfold [ Nat ] (fold [ Bool ] true )) in u) }.b) then (((\x: Rec X. X .\y: Unit .x) (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Unit .\b: Rec X. X .a)) ) (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y)) else (let u = (((\x: Bool .\y: Bool .y) ({a = false , b = 0 }.a) ) (let u = false in 0)) in (((\x: Unit .\y: Nat .x) (let u = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) in (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b))) ) (( \f: Rec X. X .((f ({a = true , b = true }.b) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Nat ] false )) )) ) ) (\a: Unit .\b: Rec X. X .a)))))
(let u = (( \f: Nat .((f ({a = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Unit .\y: Nat .y) false ) false) , c =  (succ 1) }.b) , b = (let u = true in true) }.b) ) (case <r = (let u = true in (let u = 1 in true)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) in (((\x: Rec X. X .\y: Bool .y) (let u = ({a = 1 , b = false }.b) in ({a = true , b = 0 }.a)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Bool .y) (iszero 1) ) ({a = false , b = false }.b)) ))))
(iszero (if ({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] false )) , b = (((\x: Bool .\y: Rec X. X .y) (((\x: Bool .\y: Bool .y) false ) false) ) 0) }.a) , b = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = false , b = 1 }.a)) }.b) then (let u = (succ 0) in u) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = 1 }.b) )) ))))
(let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = (( \f: Bool .((f ({a = true , b = 1 }.b) ) (let u = (((\x: Unit .\y: Unit .x) 0 ) true) in 1) ) ) (\a: Nat .\b: Bool .b)) in (if true then true else true)) )) in u)
(fix (\x: Rec X. X . (( \f: Unit .((f ({a = (((\x: Nat .\y: Nat .y) true ) true) , b = (let u = ({a = false , b = 0 }.b) in u) }.b) ) (((\x: Bool .\y: Nat .y) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = true , b = 0 }.b)) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(let u = ({a = (let u = (let u = (if false then true else true) in (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) in (if false then false else ({a = 0 , b = true , c =  0 }.b))) , b = (if (fix (\x: Unit . true )) then (let u = true in 1) else (let u = 1 in u)) }.a) in u)
(((\x: Nat .\y: Rec X. X .x) (succ (succ 1)) ) (unfold [ Unit ] (fold [ Unit ] (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in (let u = false in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )))) )))
({a = ({a = ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) }.b) , b = (succ (let u = 0 in 0)) }.a) , b = (let u = (succ (let u = 1 in u)) in (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) in u)) }.a)
(( \f: Bool .((f ({a = (( \f: Nat .((f true ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = ({a = 1 , b = 0 }.b) , b = ({a = true , b = (pred 1) }.a) }.a) }.b) ) (let u = (case <l = (let u = false in (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) > as Unit of < l = x > => x | < r = y > => y) in (let u = (fix (\x: Unit . 0 )) in (fix (\x: Nat . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) )))) ) ) (\a: Bool .\b: Rec X. X .a))
(((\x: Nat .\y: Unit .y) (case <r = (let u = (((\x: Unit .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) in u) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (unfold [ Nat ] (fold [ Bool ] (let u = (iszero 0) in (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a))) )) in ({a = (((\x: Nat .\y: Bool .y) false ) 1) , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) , c =  ({a = 1 , b = 1 }.b) }.b)))
(let u = ({a = (((\x: Bool .\y: Unit .y) (let u = (let u = (let u = 1 in 0) in u) in (if false then true else true)) ) (pred ({a = 1 , b = true }.a))) , b = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) in u) , c =  (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) else (let u = true in ({a = 1 , b = true , c = 0 }.c))) }.b) in (let u = (((\x: Nat .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) in (((\x: Bool .\y: Nat .y) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .a)) ) true)))
(succ (( \f: Unit .((f (let u = (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Unit .y) false ) 0) ) (((\x: Bool .\y: Bool .x) false ) true)) in (( \f: Unit .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) (let u = false in 0) ) ) (\a: Nat .\b: Bool .a))) ) ({a = (let u = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) in (pred 1)) , b = (iszero 0) }.a) ) ) (\a: Rec X. X .\b: Nat .a)))
(if ({a = (pred (( \f: Bool .((f (if true then 1 else 1) ) (succ (((\x: Nat .\y: Rec X. X .y) true ) 0)) ) ) (\a: Rec X. X .\b: Bool .a))) , b = (iszero (succ (((\x: Rec X. X .\y: Unit .x) 1 ) true))) , c =  (unfold [ Nat ] (fold [ Nat ] (succ 1) )) }.b) then (let u = (( \f: Bool .((f ({a = true , b = 1 }.b) ) (pred ({a = false , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Bool .a)) in (( \f: Bool .((f ({a = 0 , b = true , c = 1 }.c) ) (((\x: Unit .\y: Bool .x) 1 ) true) ) ) (\a: Rec X. X .\b: Unit .a))) else ({a = (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) )) , b = (let u = true in ({a = false , b = 1 }.a)) , c = (succ ({a = 0 , b = 1 }.b)) }.c))
(succ (case <l = (( \f: Unit .((f ({a = 0 , b = ({a = 1 , b = true , c =  0 }.b) }.a) ) (let u = (let u = 1 in u) in u) ) ) (\a: Rec X. X .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y))
(((\x: Bool .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Unit ] (iszero (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = false in 0) )) > as Bool of < l = x > => x | < r = y > => y)) )) ) (let u = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) in (succ (let u = 1 in 1))) in (let u = ({a = (succ 1) , b = (( \f: Unit .((f ({a = true , b = 0 }.a) ) ({a = true , b = 0 }.a) ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (( \f: Rec X. X .((f 1 ) (unfold [ Bool ] (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) in u)))
({a = ({a = (fix (\x: Nat . ({a = ({a = 0 , b = false }.b) , b = 0 }.b) )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) }.a) , b = (((\x: Rec X. X .\y: Unit .y) (if ({a = 1 , b = (iszero 0) , c =  0 }.b) then (( \f: Rec X. X .((f (let u = false in u) ) false ) ) (\a: Nat .\b: Bool .b)) else (fix (\x: Bool . (let u = true in u) ))) ) (let u = true in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )))) }.b)
(unfold [ Bool ] (fold [ Rec X. X ] (( \f: Unit .((f ({a = (( \f: Unit .((f (succ 1) ) (succ 1) ) ) (\a: Nat .\b: Bool .a)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] true )) )) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) ({a = ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = false }.b) , b = (pred (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a))) }.a) ) ) (\a: Rec X. X .\b: Unit .b)) ))
(( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] (if (((\x: Bool .\y: Rec X. X .y) true ) true) then (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) else (fix (\x: Unit . 1 ))) )) ) (fix (\x: Unit . (let u = (let u = false in 0) in (((\x: Nat .\y: Bool .y) true ) 0)) )) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Rec X. X .\y: Nat .y) (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .y) (let u = 0 in false) ) (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in false)) )) ) ({a = (( \f: Bool .((f (let u = false in 0) ) ({a = (let u = 1 in 0) , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (fix (\x: Rec X. X . (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) false ) false) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = false in u) )) ) ) (\a: Nat .\b: Nat .a)) }.b) , c = (((\x: Nat .\y: Bool .y) (fix (\x: Unit . ({a = true , b = false }.b) )) ) (if ({a = false , b = 0 }.a) then (pred 0) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) }.c))
(succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (case <l = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) )))
(case <l = (unfold [ Unit ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .x) (let u = 0 in u) ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(if (let u = (if false then (let u = true in true) else true) in u) then (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Rec X. X .\y: Bool .x) true ) true)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (iszero 1) in u) ))) else (((\x: Unit .\y: Nat .y) (( \f: Unit .((f (((\x: Unit .\y: Bool .y) true ) ({a = 0 , b = false , c =  0 }.b)) ) (let u = (pred 0) in ({a = true , b = 0 }.a)) ) ) (\a: Unit .\b: Bool .a)) ) (((\x: Bool .\y: Bool .y) ({a = true , b = 1 }.a) ) (let u = 0 in u))))
((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) ({a = true , b = false }.b) ) (if false then true else true)) ) (let u = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .b)) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) ) ) (\a: Nat .\b: Unit .a)) ))
(let u = (case <l = (fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .x) (let u = false in 1) ) false) )) > as Unit of < l = x > => x | < r = y > => y) in ({a = (( \f: Rec X. X .((f ({a = (((\x: Unit .\y: Nat .y) true ) true) , b = ({a = 1 , b = true }.a) }.a) ) (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) true ) true) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Unit .a)) else (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Bool .b)) , b = ({a = (let u = (((\x: Rec X. X .\y: Bool .x) (fix (\x: Bool . true )) ) (let u = false in false)) in u) , b = (succ (fix (\x: Nat . 1 ))) }.b) }.a))
({a = (((\x: Unit .\y: Bool .x) (case <r = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b)) )) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . ({a = 1 , b = false , c =  (((\x: Unit .\y: Nat .y) false ) 1) }.b) ))) , b = ({a = (( \f: Bool .((f (let u = true in u) ) (if false then false else true) ) ) (\a: Unit .\b: Bool .a)) , b = (let u = (((\x: Rec X. X .\y: Unit .y) (let u = true in true) ) true) in (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b))) }.a) }.b)
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = 1 }.b) )) )) ))
({a = (( \f: Unit .((f (succ (pred (if false then 0 else 1))) ) (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Rec X. X .((f (iszero (fix (\x: Unit . 1 ))) ) (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Bool . false )) )) in u) ) ) (\a: Unit .\b: Rec X. X .b)) , c =  ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = 1 , b = false , c =  (let u = false in 1) }.b) )) , b = ({a = (if false then (let u = false in u) else ({a = false , b = true }.b)) , b = ({a = (((\x: Rec X. X .\y: Unit .y) true ) 1) , b = (let u = false in (let u = false in u)) }.a) }.b) }.b) }.b)
(case <l = (( \f: Bool .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) (succ (let u = 0 in 1)) ) ) (\a: Unit .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Nat .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Bool . (let u = false in (fix (\x: Rec X. X . false ))) )) )) ) (let u = (iszero (((\x: Unit .\y: Nat .y) (if true then false else true) ) ({a = true , b = 0 }.b))) in u))
(unfold [ Bool ] (fold [ Rec X. X ] (( \f: Nat .((f (((\x: Nat .\y: Unit .x) false ) ({a = 1 , b = true }.b)) ) (iszero (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) ) ) (\a: Nat .\b: Unit .a)) ))
({a = (iszero (let u = (let u = 1 in u) in ({a = (let u = true in 0) , b = ({a = 1 , b = false , c =  1 }.b) , c = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.c))) , b = (let u = (let u = (( \f: Rec X. X .((f (let u = false in u) ) false ) ) (\a: Unit .\b: Unit .b)) in u) in (unfold [ Unit ] (fold [ Bool ] (let u = false in u) ))) }.b)
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (((\x: Bool .\y: Rec X. X .x) 1 ) false) , b = true }.b) )) , b = (let u = (unfold [ Nat ] (fold [ Nat ] (fix (\x: Unit . false )) )) in u) }.b)
({a = (if (fix (\x: Bool . (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) in (((\x: Rec X. X .\y: Unit .y) true ) true)) )) then (iszero 0) else (let u = true in ({a = 0 , b = false , c =  1 }.b))) , b = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = true in true) )) in (((\x: Bool .\y: Unit .x) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) (fix (\x: Bool . ({a = false , b = false }.b) )))) }.a)
(fix (\x: Rec X. X . (if (fix (\x: Unit . (if false then false else false) )) then (if false then (pred 0) else 0) else (succ 0)) ))
(( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = 1 , b = (let u = false in u) }.a) , b = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) , c =  (unfold [ Rec X. X ] (fold [ Unit ] 1 )) }.b) ) (fix (\x: Unit . (((\x: Unit .\y: Nat .x) true ) ({a = 1 , b = true , c =  0 }.b)) ))) ) (case <r = (( \f: Unit .((f (if false then true else true) ) true ) ) (\a: Bool .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a))
(let u = (((\x: Nat .\y: Unit .y) (( \f: Nat .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ({a = false , b = 1 }.a) ) ) (\a: Nat .\b: Nat .a)) ) (let u = ({a = ({a = 1 , b = true }.a) , b = (unfold [ Nat ] (fold [ Nat ] true )) , c =  (let u = (((\x: Rec X. X .\y: Bool .y) true ) 0) in (let u = 0 in u)) }.b) in ({a = 0 , b = (fix (\x: Nat . true )) }.b))) in u)
(let u = (((\x: Unit .\y: Unit .y) (let u = (let u = true in (let u = false in u)) in (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .a))) ) ({a = (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) , b = (let u = (let u = true in (iszero 1)) in u) }.b)) in u)
(if (((\x: Bool .\y: Nat .y) (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Nat .x) false ) true) )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false ))) then (let u = (((\x: Unit .\y: Unit .y) ({a = 1 , b = false }.b) ) 0) in (fix (\x: Rec X. X . ({a = 1 , b = true , c = 0 }.c) ))) else (let u = (let u = (( \f: Unit .((f (pred 0) ) (fix (\x: Bool . 0 )) ) ) (\a: Bool .\b: Rec X. X .b)) in u) in (let u = (unfold [ Bool ] (fold [ Nat ] 1 )) in (if false then 0 else 1))))
(unfold [ Nat ] (fold [ Rec X. X ] ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (if true then (let u = 1 in 1) else (succ 0)) )) , b = (((\x: Nat .\y: Unit .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) (iszero 1)) , c =  (let u = ({a = false , b = 0 }.a) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) }.b) ))
(case <r = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if false then 1 else (pred 0)) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if false then false else true) )) }.b) > as Nat of < l = x > => x | < r = y > => y)
(unfold [ Bool ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Rec X. X . false )) )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = ({a = false , b = false }.b) in u) ))) ))
(succ (if (((\x: Nat .\y: Unit .x) (fix (\x: Rec X. X . ({a = true , b = true }.b) )) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) then (succ (succ (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Nat .x) 1 ) true) ) false))) else (let u = (let u = 1 in true) in (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in 0))))
(((\x: Nat .\y: Nat .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (case <l = (succ 0) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) (case <r = ({a = false , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Bool .y) (let u = 0 in false) ) ({a = 1 , b = true , c =  1 }.b))) ) (iszero (( \f: Nat .((f 1 ) (let u = 1 in 0) ) ) (\a: Nat .\b: Nat .b)))))
({a = (((\x: Unit .\y: Bool .y) (let u = (let u = 1 in false) in (fix (\x: Nat . (if true then false else false) ))) ) (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = true , b = 1 }.a))) , b = ({a = (succ (let u = ({a = 0 , b = true , c = 1 }.c) in 1)) , b = (let u = 1 in true) }.a) }.a)
(((\x: Rec X. X .\y: Nat .y) (iszero (( \f: Bool .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) ) (\a: Rec X. X .\b: Unit .b))) ) (unfold [ Bool ] (fold [ Nat ] (let u = (if true then 0 else 1) in u) )))
({a = (succ (succ (pred (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .y) false ) 0) ))))) , b = ({a = (let u = (unfold [ Unit ] (fold [ Bool ] true )) in (let u = 0 in u)) , b = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = true , c = 0 }.c) )) , b = (let u = false in true) }.b) , c =  (if ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = true }.b) then (pred (let u = true in 1)) else (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) }.b) , c =  (case <l = ({a = (let u = true in 0) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = (fix (\x: Unit . 0 )) }.c) > as Nat of < l = x > => x | < r = y > => y) }.b)
(unfold [ Bool ] (fold [ Unit ] (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = ({a = true , b = true }.b) }.b) )) in u) ))
(let u = (((\x: Unit .\y: Bool .x) (( \f: Bool .((f ({a = true , b = 0 }.b) ) (fix (\x: Rec X. X . (fix (\x: Bool . 0 )) )) ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Bool .\y: Bool .y) ({a = false , b = 0 }.a) ) (((\x: Unit .\y: Rec X. X .y) (((\x: Unit .\y: Unit .x) false ) true) ) (let u = 0 in true)))) in ({a = (case <l = (let u = true in 0) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) (fix (\x: Bool . (iszero 1) )) ) ) (\a: Bool .\b: Rec X. X .b)) , c =  ({a = (let u = 0 in (unfold [ Unit ] (fold [ Nat ] 0 ))) , b = (((\x: Nat .\y: Bool .x) (iszero 1) ) false) , c = (succ ({a = false , b = 0 }.b)) }.c) }.b))
(pred ({a = ({a = (pred 1) , b = (iszero 1) }.a) , b = (let u = true in 0) }.b))
(succ ({a = ({a = 0 , b = 1 }.b) , b = ({a = 0 , b = ({a = false , b = 0 }.b) }.b) }.b))
({a = ({a = (case <r = (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a)) in u) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = true }.a) )) }.a) , b = (((\x: Nat .\y: Rec X. X .x) ({a = (((\x: Nat .\y: Rec X. X .x) (let u = 0 in 1) ) ({a = true , b = (pred 0) }.a)) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) (pred 1) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) (if (unfold [ Nat ] (fold [ Bool ] false )) then (( \f: Bool .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) true ) ) (\a: Nat .\b: Rec X. X .b)) else (if true then true else false))) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (let u = ({a = (fix (\x: Unit . 0 )) , b = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.b) in u) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = true in u) )) , c = (( \f: Nat .((f ({a = 1 , b = true }.a) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.c) ))
(case <l = (((\x: Bool .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (succ 1) )) ) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in false) , c =  ({a = 1 , b = false , c = 0 }.c) }.b)) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) (unfold [ Bool ] (fold [ Unit ] true )) ) (unfold [ Unit ] (fold [ Unit ] false ))) )) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) in u)
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = (fix (\x: Rec X. X . 1 )) , b = (pred 1) }.b) , b = (((\x: Bool .\y: Bool .x) ({a = ({a = 0 , b = false }.a) , b = (iszero 1) , c =  (((\x: Unit .\y: Nat .y) true ) (let u = 0 in 1)) }.b) ) (fix (\x: Nat . (let u = false in false) ))) , c = ({a = (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 )) ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.a) }.c) ))
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) (if (if (iszero 0) then true else ({a = true , b = 0 }.a)) then ({a = 1 , b = true , c =  1 }.b) else ({a = 1 , b = false , c =  0 }.b)) ) (fix (\x: Rec X. X . (( \f: Nat .((f true ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Nat .b)) ))) ) ({a = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) , b = (if (((\x: Unit .\y: Bool .y) true ) true) then ({a = 0 , b = false }.b) else (((\x: Unit .\y: Nat .x) false ) false)) }.b) ) ) (\a: Bool .\b: Bool .a))
({a = (succ ({a = false , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.b)) , b = (let u = ({a = (let u = 1 in u) , b = (if false then true else false) }.b) in (case <r = (unfold [ Nat ] (fold [ Rec X. X ] false )) > as Nat of < l = x > => x | < r = y > => y)) , c =  (let u = ({a = (pred 1) , b = (let u = (let u = false in 1) in true) , c = (succ 1) }.c) in u) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Unit . (fix (\x: Bool . (let u = false in false) )) )) ))
(( \f: Bool .((f (let u = (succ (succ 0)) in ({a = ({a = false , b = false }.b) , b = ({a = 0 , b = true }.a) }.a)) ) (fix (\x: Nat . (case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) > as Unit of < l = x > => x | < r = y > => y) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(( \f: Nat .((f (( \f: Unit .((f (((\x: Unit .\y: Nat .y) (let u = false in u) ) (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) ) (fix (\x: Nat . (pred (if false then 0 else 1)) )) ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = false in false) , c = ({a = ({a = 0 , b = false , c = 1 }.c) , b = false }.a) }.c) , b = (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) true ) 1) ) (let u = 0 in u) ) ) (\a: Bool .\b: Bool .a)) }.b) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) )) , b = (((\x: Bool .\y: Unit .y) (let u = true in u) ) (unfold [ Unit ] (fold [ Bool ] false ))) , c =  (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) }.b) , c = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Nat .x) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) (let u = false in u)) }.b) }.c) ) ) (\a: Bool .\b: Bool .a))
(( \f: Rec X. X .((f ({a = ({a = ({a = 1 , b = false , c = 1 }.c) , b = (let u = false in true) , c = 1 }.c) , b = ({a = 0 , b = (((\x: Nat .\y: Nat .y) false ) true) }.b) , c = (let u = ({a = false , b = ({a = false , b = true }.b) }.b) in (fix (\x: Nat . 0 ))) }.c) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Nat . ({a = true , b = 1 }.b) )) )) ) ) (\a: Bool .\b: Nat .a))
(iszero (( \f: Bool .((f (let u = (let u = (((\x: Unit .\y: Rec X. X .x) true ) true) in false) in (let u = ({a = 0 , b = false }.b) in ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )))) ) (let u = (if true then ({a = true , b = true }.b) else (if false then true else false)) in (fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .x) 0 ) false) ))) ) ) (\a: Nat .\b: Nat .b)))
(if (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = false , c =  ({a = true , b = 1 }.b) }.b)) then (let u = (pred (let u = ({a = ({a = 1 , b = 0 }.b) , b = 0 }.b) in (unfold [ Bool ] (fold [ Rec X. X ] 0 )))) in (let u = (if true then 0 else 1) in (if (unfold [ Bool ] (fold [ Bool ] true )) then false else true))) else (( \f: Unit .((f (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in u) ) (let u = 1 in (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Unit .\b: Unit .a)))
(( \f: Bool .((f (((\x: Nat .\y: Nat .x) (succ (((\x: Rec X. X .\y: Nat .y) false ) 0)) ) (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = false , c =  0 }.b) ))) ) (let u = ({a = (((\x: Rec X. X .\y: Unit .y) (let u = true in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Bool .y) true ) false) ))) , b = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (let u = 0 in true) }.b) }.b) in (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) (if (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .b)) then true else true) ) (fix (\x: Unit . 0 ))) ) (( \f: Rec X. X .((f (let u = 1 in 1) ) (let u = 0 in u) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .b))) ) ) (\a: Rec X. X .\b: Bool .b))
(unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) ({a = ({a = true , b = 1 }.a) , b = ({a = 1 , b = (let u = false in u) }.b) }.b) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) true ) ({a = 1 , b = false }.a)) ) (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] 0 )) ) (let u = true in 1) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ))
({a = (let u = ({a = (if false then (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) else (let u = true in 0)) , b = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .b)) in ({a = 0 , b = false , c = 0 }.c)) }.b) in (( \f: Unit .((f (if false then 0 else (let u = 1 in 0)) ) (let u = 0 in u) ) ) (\a: Bool .\b: Rec X. X .b))) , b = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Unit .((f ({a = 0 , b = false }.b) ) true ) ) (\a: Unit .\b: Unit .b)) )) ) (( \f: Nat .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 1) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a)) }.a)
(( \f: Nat .((f ({a = ({a = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)) , b = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) , b = (((\x: Nat .\y: Unit .y) false ) true) , c = 1 }.c) }.a) , b = ({a = 0 , b = 1 }.b) }.a) ) (iszero ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ))) ) ) (\a: Nat .\b: Unit .b))
(case <r = ({a = (if (let u = true in u) then ({a = false , b = 1 }.b) else (let u = 0 in 0)) , b = (fix (\x: Bool . ({a = ({a = 1 , b = true }.b) , b = 0 }.a) )) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Bool .y) false ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) (((\x: Rec X. X .\y: Bool .y) false ) true)) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Rec X. X .x) false ) false) )) , b = (( \f: Bool .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) ) ({a = 1 , b = true }.a) ) ) (\a: Rec X. X .\b: Unit .b)) }.a) }.b)
({a = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (let u = 1 in 0) )) , b = (iszero 1) }.b) , b = (fix (\x: Bool . (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) )) }.b)
(if (case <r = (unfold [ Nat ] (fold [ Rec X. X ] (if true then true else false) )) > as Unit of < l = x > => x | < r = y > => y) then (let u = (let u = (let u = 0 in u) in (((\x: Bool .\y: Bool .x) true ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)))) in u) else (let u = ({a = ({a = 1 , b = ({a = 0 , b = true , c =  1 }.b) , c = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.c) , b = (((\x: Bool .\y: Nat .y) (fix (\x: Rec X. X . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) )) ) (((\x: Bool .\y: Rec X. X .y) false ) true)) , c =  (unfold [ Bool ] (fold [ Rec X. X ] ({a = (let u = 1 in 1) , b = 1 }.b) )) }.b) in u))
(fix (\x: Nat . (( \f: Rec X. X .((f ({a = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) , b = 1 }.a) , b = (((\x: Unit .\y: Nat .y) true ) 1) }.a) ) (( \f: Unit .((f (let u = true in true) ) (if true then false else true) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .b)) ))
(((\x: Nat .\y: Bool .x) ({a = (let u = (((\x: Bool .\y: Unit .x) false ) false) in 1) , b = (if (((\x: Rec X. X .\y: Unit .x) (unfold [ Nat ] (fold [ Nat ] false )) ) true) then ({a = 0 , b = false , c =  0 }.b) else ({a = (let u = false in 1) , b = true }.b)) }.b) ) (case <r = (iszero (case <l = (let u = false in 1) > as Bool of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y))
(case <r = (let u = (if false then 1 else (((\x: Unit .\y: Bool .y) false ) 1)) in ({a = 0 , b = (if true then true else false) }.b)) > as Nat of < l = x > => x | < r = y > => y)
(if (( \f: Unit .((f (if (case <r = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Nat .x) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ({a = false , b = false }.b)) else ({a = (((\x: Rec X. X .\y: Bool .y) true ) (fix (\x: Bool . true ))) , b = (((\x: Bool .\y: Rec X. X .y) false ) true) }.b)) ) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Unit ] false )) )) , b = (let u = (((\x: Unit .\y: Bool .y) true ) true) in (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b))) }.b) ) ) (\a: Nat .\b: Unit .a)) then (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b))) )) in ({a = (let u = 0 in u) , b = (unfold [ Unit ] (fold [ Unit ] (if false then false else false) )) }.a)) else (unfold [ Rec X. X ] (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] (unfold [ Nat ] (fold [ Unit ] 0 )) )) )))
({a = (pred (( \f: Rec X. X .((f (if false then 0 else 0) ) ({a = 0 , b = 1 }.b) ) ) (\a: Bool .\b: Nat .b))) , b = (let u = (( \f: Rec X. X .((f (if true then false else false) ) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) , b = true , c =  (succ 0) }.b) ) ) (\a: Bool .\b: Nat .b)) in u) }.b)
(let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (if ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero (pred 0)) )) then (((\x: Rec X. X .\y: Nat .x) (iszero (if false then 1 else 0)) ) ({a = 1 , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .b)) }.b)) else ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.b)) )) in (let u = (succ (pred 1)) in ({a = (if false then (pred 0) else (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a))) , b = (let u = true in u) , c =  (let u = 0 in 1) }.b)))
(let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (iszero ({a = 1 , b = true , c = 1 }.c)) ) ({a = ({a = 1 , b = true }.a) , b = (let u = 0 in true) }.a)) , b = ({a = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = (pred 0) }.b) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) , c = ({a = ({a = ({a = true , b = 0 }.b) , b = (let u = true in true) , c = 1 }.c) , b = (case <r = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) }.a) }.c) in (let u = (case <l = (((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Bool .y) false ) 0) ) ({a = false , b = (((\x: Unit .\y: Bool .x) false ) false) }.b)) > as Nat of < l = x > => x | < r = y > => y) in (let u = ({a = 1 , b = true }.b) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )))))
(((\x: Unit .\y: Nat .x) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u) )) , b = (if (( \f: Bool .((f true ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Nat .\b: Nat .a)) then (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .a)) in u) else (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (if true then true else false) ) ) (\a: Nat .\b: Bool .b))) }.a) ) (unfold [ Unit ] (fold [ Unit ] (fix (\x: Unit . (if true then false else true) )) )))
(((\x: Bool .\y: Unit .x) (let u = (( \f: Rec X. X .((f ({a = (succ 1) , b = (let u = 0 in false) }.a) ) (pred 0) ) ) (\a: Bool .\b: Nat .a)) in u) ) ({a = (let u = (let u = ({a = true , b = 1 }.b) in (succ (let u = true in 1))) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (if (let u = 1 in true) then (unfold [ Unit ] (fold [ Unit ] false )) else (((\x: Nat .\y: Rec X. X .x) false ) (let u = false in u))) }.b))
(fix (\x: Rec X. X . (let u = (let u = (((\x: Rec X. X .\y: Nat .x) 0 ) (fix (\x: Nat . false ))) in ({a = 1 , b = false , c = 1 }.c)) in (((\x: Nat .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) (let u = 0 in true))) ))
(( \f: Bool .((f ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Nat . (iszero 1) )) )) , b = (let u = (( \f: Unit .((f (iszero 0) ) false ) ) (\a: Unit .\b: Bool .b)) in u) }.b) ) ({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , b = (iszero 1) }.b) }.a) , b = (let u = 0 in (let u = 0 in true)) , c =  (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] 1 )) )) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (let u = (((\x: Nat .\y: Nat .x) 0 ) true) in (let u = 1 in ({a = true , b = 0 }.b))) )) , b = (((\x: Unit .\y: Rec X. X .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = false , c =  (if false then 1 else 1) }.b)) }.b)
(let u = ({a = ({a = (((\x: Rec X. X .\y: Bool .x) false ) true) , b = ({a = false , b = true }.b) }.b) , b = (let u = (((\x: Bool .\y: Nat .y) false ) false) in (let u = ({a = false , b = 0 }.b) in u)) }.b) in (fix (\x: Rec X. X . (((\x: Bool .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) false) )))
(let u = (pred (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Unit .x) (let u = 0 in u) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a))) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (iszero 0) )))) in u)
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .y) false ) false) ) true ) ) (\a: Rec X. X .\b: Bool .b))) ) (fix (\x: Nat . ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) )) ) ) (\a: Bool .\b: Rec X. X .b)) ))
({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) true) )) , b = ({a = (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Bool . 1 )) , b = (((\x: Bool .\y: Unit .x) true ) true) , c = (let u = 0 in u) }.c) }.a) }.b)
(( \f: Unit .((f ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if false then 1 else 0) )) )) , b = (case <r = (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .b)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true ))) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = false , b = 0 }.a) )) ) ) (\a: Unit .\b: Unit .a))
(( \f: Bool .((f (((\x: Unit .\y: Unit .y) ({a = (fix (\x: Rec X. X . (if ({a = 0 , b = true , c =  0 }.b) then false else false) )) , b = ({a = 0 , b = (unfold [ Bool ] (fold [ Nat ] false )) }.a) }.a) ) (case <l = ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = true }.a) > as Nat of < l = x > => x | < r = y > => y)) ) (unfold [ Unit ] (fold [ Unit ] (let u = ({a = 1 , b = 0 }.b) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a))) )) ) ) (\a: Bool .\b: Rec X. X .b))
(( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) (let u = 0 in (fix (\x: Unit . 1 ))) ) (( \f: Nat .((f (unfold [ Unit ] (fold [ Rec X. X ] false )) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a))) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .y) (( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false )) ) (((\x: Unit .\y: Unit .y) false ) false) ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y)) )) ) ) (\a: Bool .\b: Rec X. X .a))
(iszero (fix (\x: Unit . (pred (let u = 0 in 0)) )))
(( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) ({a = 0 , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) (( \f: Unit .((f ({a = (let u = 1 in 1) , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (((\x: Unit .\y: Unit .y) false ) 0) }.b) ) (let u = 0 in true) ) ) (\a: Bool .\b: Nat .b))) ) ({a = ({a = ({a = false , b = 1 }.b) , b = (let u = false in true) }.a) , b = (let u = true in ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true ))) }.b) ) ) (\a: Nat .\b: Bool .a))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (iszero (let u = ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = 1 }.b) in u)) ))
(((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Unit .y) ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .a)) }.b) ) (let u = (((\x: Rec X. X .\y: Nat .x) false ) false) in (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) false ) true) )))) ) ({a = (succ (let u = 0 in 1)) , b = (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Nat . true )) ) 1) }.b))
(if (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = true , b = 1 }.a) )) in u) then (let u = (let u = ({a = 1 , b = false }.a) in (let u = false in 1)) in (((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Bool .((f (if true then 1 else 1) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Unit .a)))) else ({a = (case <l = (let u = 0 in ({a = 0 , b = true }.a)) > as Nat of < l = x > => x | < r = y > => y) , b = (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (fix (\x: Unit . true )) else (if (((\x: Nat .\y: Rec X. X .x) false ) false) then false else false)) , c = ({a = ({a = (let u = true in u) , b = (((\x: Nat .\y: Bool .y) (let u = false in true) ) (fix (\x: Nat . false ))) }.b) , b = (( \f: Unit .((f (pred 1) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .a)) }.b) }.c))
(let u = ({a = (case <r = ({a = 0 , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . (fix (\x: Bool . false )) )) }.b) in u)
({a = ({a = (let u = (let u = 1 in true) in 1) , b = (((\x: Nat .\y: Nat .x) ({a = 1 , b = true }.b) ) false) }.a) , b = (let u = (iszero ({a = 0 , b = false }.a)) in u) , c =  ({a = (fix (\x: Bool . (((\x: Nat .\y: Unit .x) false ) true) )) , b = (( \f: Rec X. X .((f ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = (let u = false in (((\x: Unit .\y: Nat .y) false ) true)) , c = (let u = 1 in 1) }.c) ) (((\x: Rec X. X .\y: Nat .y) (if true then false else false) ) 1) ) ) (\a: Bool .\b: Bool .b)) }.b) }.b)
(let u = (pred ({a = (((\x: Bool .\y: Rec X. X .x) ({a = 0 , b = false , c = 1 }.c) ) (unfold [ Rec X. X ] (fold [ Bool ] true ))) , b = (iszero (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , c = (pred (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) }.c)) in u)
(let u = (( \f: Nat .((f (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (fix (\x: Unit . ({a = true , b = 1 }.a) )) , b = (let u = false in true) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) in (((\x: Nat .\y: Rec X. X .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) true ) true) )) ) (let u = (((\x: Unit .\y: Rec X. X .y) true ) (iszero 1)) in u)))
(let u = (fix (\x: Unit . (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (if false then true else true) else (let u = ({a = 0 , b = false }.b) in u)) )) in u)
(case <r = ({a = (let u = 0 in (fix (\x: Rec X. X . 0 ))) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) in (let u = true in (let u = 0 in false))) , c =  (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (( \f: Rec X. X .((f (let u = 0 in u) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) in (let u = (if (((\x: Nat .\y: Unit .y) false ) false) then (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false ))) in (if true then 0 else 1))) in u)
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (succ ({a = (let u = (let u = 0 in u) in u) , b = (fix (\x: Unit . ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) )) }.a)) ))
({a = (((\x: Bool .\y: Bool .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = ({a = 1 , b = false , c =  1 }.b) in u)) , b = (((\x: Bool .\y: Nat .y) ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) , c =  ({a = 0 , b = true }.a) }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) }.b)
({a = (let u = (succ (succ ({a = 0 , b = false , c = 0 }.c))) in u) , b = ({a = (if (unfold [ Nat ] (fold [ Nat ] true )) then ({a = 1 , b = false , c = 0 }.c) else (fix (\x: Rec X. X . 0 ))) , b = (let u = (succ 1) in (let u = true in (((\x: Nat .\y: Unit .x) true ) true))) }.b) , c =  ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = false }.b) )) , b = (pred ({a = 1 , b = false }.a)) }.b) )) }.b)
({a = (fix (\x: Bool . ({a = (pred (let u = true in 1)) , b = (if false then false else false) , c =  ({a = ({a = 1 , b = false , c = 1 }.c) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b) }.b) )) , b = (unfold [ Unit ] (fold [ Bool ] (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in ({a = false , b = ({a = 1 , b = false , c = 1 }.c) }.b)) )) }.b)
(((\x: Nat .\y: Nat .x) (((\x: Rec X. X .\y: Unit .y) ({a = (( \f: Rec X. X .((f true ) (fix (\x: Unit . false )) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .a)) }.b) ) (let u = (fix (\x: Bool . true )) in 1)) ) ({a = (( \f: Nat .((f (succ 0) ) ({a = 0 , b = false , c = (succ 1) }.c) ) ) (\a: Unit .\b: Nat .a)) , b = (( \f: Rec X. X .((f ({a = (((\x: Bool .\y: Unit .y) true ) true) , b = (( \f: Unit .((f (if true then false else false) ) (iszero 1) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) ) (let u = (((\x: Bool .\y: Rec X. X .x) false ) true) in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  (unfold [ Rec X. X ] (fold [ Bool ] ({a = true , b = ({a = 1 , b = false }.a) }.b) )) }.b))
(( \f: Rec X. X .((f (fix (\x: Unit . (let u = (let u = (((\x: Rec X. X .\y: Nat .x) true ) ({a = true , b = true }.b)) in ({a = false , b = false }.b)) in (( \f: Unit .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) false ) ) (\a: Bool .\b: Nat .a)) ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Nat .\b: Bool .b))) )) ) (case <r = (fix (\x: Nat . (if (unfold [ Bool ] (fold [ Bool ] false )) then (fix (\x: Unit . (let u = true in u) )) else (unfold [ Rec X. X ] (fold [ Nat ] true ))) )) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a))
(( \f: Nat .((f (((\x: Nat .\y: Unit .y) (let u = ({a = false , b = 1 }.a) in u) ) (let u = (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) )) in u)) ) (((\x: Bool .\y: Unit .y) (unfold [ Unit ] (fold [ Rec X. X ] (let u = false in u) )) ) (let u = (iszero 1) in ({a = false , b = 0 }.a))) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Bool .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (iszero (fix (\x: Bool . 0 ))) ) ) (\a: Nat .\b: Nat .a)) )) ) (if (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) (let u = 1 in false) ) ) (\a: Unit .\b: Bool .a)) then ({a = (case <r = (let u = true in false) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = false in (((\x: Nat .\y: Nat .y) false ) false)) }.b) else (unfold [ Bool ] (fold [ Bool ] (( \f: Nat .((f (unfold [ Bool ] (fold [ Nat ] false )) ) (let u = 1 in false) ) ) (\a: Nat .\b: Nat .a)) ))))
(let u = (fix (\x: Unit . ({a = (pred (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) , b = (iszero 1) }.a) )) in (let u = (if (let u = false in u) then (pred 0) else ({a = ({a = false , b = true }.b) , b = 1 }.b)) in u))
(case <l = (( \f: Bool .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (pred 0) ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = true in 1) ) ) (\a: Unit .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y)
(let u = (((\x: Rec X. X .\y: Nat .y) (( \f: Rec X. X .((f false ) ({a = true , b = 0 }.a) ) ) (\a: Nat .\b: Nat .b)) ) ({a = (pred 1) , b = (let u = 1 in true) , c =  (if true then 0 else 0) }.b)) in u)
(if ({a = (( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (fix (\x: Unit . (let u = true in u) )) , c =  (let u = (if ({a = false , b = 1 }.a) then true else (fix (\x: Bool . true ))) in (if false then 1 else 1)) }.b) then (let u = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.a) in (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u)) else ({a = (if (let u = (((\x: Nat .\y: Unit .y) false ) true) in false) then (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .y) true ) 1) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) else (((\x: Rec X. X .\y: Nat .x) 1 ) false)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) }.b))
({a = (let u = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = ({a = false , b = 0 }.a) in (let u = true in u)) }.a) in ({a = (if true then 1 else 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) }.a)) , b = ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = 1 , b = true , c =  1 }.b)) , c =  (if ({a = false , b = true }.b) then ({a = (if true then 1 else 0) , b = 1 }.b) else (succ 1)) }.b) }.b)
(pred (let u = ({a = ({a = false , b = 0 }.b) , b = ({a = ({a = true , b = 1 }.a) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) }.a) }.b) in (let u = ({a = (case <l = (((\x: Nat .\y: Unit .x) 1 ) false) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = true , c =  1 }.b) }.a) in (((\x: Rec X. X .\y: Bool .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) (fix (\x: Unit . true ))))))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .y) false ) (((\x: Rec X. X .\y: Rec X. X .y) true ) false)) )) in (let u = true in true)) )) ))
(unfold [ Nat ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) )) ))
(let u = ({a = (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Nat ] false )) )) , b = ({a = (((\x: Bool .\y: Unit .x) 0 ) (iszero 0)) , b = (case <l = ({a = 1 , b = false , c = 1 }.c) > as Bool of < l = x > => x | < r = y > => y) }.b) }.a) in (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Bool ] (fix (\x: Nat . true )) )) )))
({a = (unfold [ Bool ] (fold [ Nat ] (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) in u) )) , b = (fix (\x: Nat . ({a = true , b = 1 }.a) )) }.b)
(succ ({a = (( \f: Nat .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = false , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) }.b) }.a))
({a = ({a = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) then 0 else 1) , b = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (iszero 1) )) in (((\x: Rec X. X .\y: Nat .x) false ) true)) , c =  (( \f: Unit .((f (((\x: Bool .\y: Unit .x) 0 ) true) ) 0 ) ) (\a: Bool .\b: Unit .a)) }.b) , b = (let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.b) in ({a = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Nat ] 1 ))) , b = (fix (\x: Rec X. X . true )) }.a)) }.b)
({a = ({a = ({a = (let u = false in u) , b = ({a = 1 , b = 1 }.b) }.a) , b = (let u = ({a = (if false then 0 else 0) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) in (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u)) }.b) , b = (if ({a = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) , b = (fix (\x: Rec X. X . true )) }.b) then ({a = (let u = false in true) , b = (let u = false in false) }.b) else (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) in (fix (\x: Unit . (((\x: Bool .\y: Bool .x) true ) true) )))) }.a)
({a = ({a = ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = true }.a) , b = ({a = (if false then 0 else 1) , b = ({a = true , b = 0 }.a) }.b) }.b) , b = ({a = (((\x: Nat .\y: Unit .x) (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) ) (case <r = (let u = false in false) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = ({a = 1 , b = true }.a) , b = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .a)) }.a) }.b) }.a)
(iszero (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) 0 ) (fix (\x: Bool . true ))) ) (((\x: Bool .\y: Bool .y) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) ) (((\x: Rec X. X .\y: Unit .x) false ) false))))
(case <r = ({a = (( \f: Rec X. X .((f (let u = 1 in 1) ) (let u = 1 in (((\x: Rec X. X .\y: Bool .y) true ) 1)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (if ({a = 0 , b = false }.b) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) else (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) )) , c =  ({a = (pred (fix (\x: Nat . 0 ))) , b = (let u = 0 in (((\x: Unit .\y: Rec X. X .x) true ) false)) }.a) }.b) > as Nat of < l = x > => x | < r = y > => y)
({a = (( \f: Bool .((f ({a = (let u = 0 in u) , b = (let u = 0 in false) }.a) ) ({a = (let u = 0 in false) , b = (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = true , c =  1 }.b) ) (let u = 1 in u)) }.b) ) ) (\a: Bool .\b: Nat .b)) , b = ({a = (((\x: Unit .\y: Unit .y) (( \f: Bool .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (let u = 0 in true) , b = ({a = 0 , b = 1 }.b) }.b)) , b = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) }.b) , c = (let u = (fix (\x: Rec X. X . (case <l = ({a = true , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) )) in ({a = (let u = 1 in 1) , b = (let u = (((\x: Unit .\y: Bool .x) 1 ) true) in 1) }.b)) }.c)
(( \f: Rec X. X .((f (( \f: Unit .((f (case <l = (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (case <l = (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Bool .x) false ) false) ) 1) > as Unit of < l = x > => x | < r = y > => y) in u) ) ) (\a: Bool .\b: Unit .a)) ) (succ (((\x: Rec X. X .\y: Nat .x) ({a = (let u = 1 in u) , b = 0 }.b) ) (iszero ({a = 0 , b = true }.a)))) ) ) (\a: Nat .\b: Rec X. X .a))
(((\x: Rec X. X .\y: Rec X. X .y) ({a = (( \f: Bool .((f (let u = false in 0) ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) ) (let u = (pred 0) in true) ) ) (\a: Bool .\b: Bool .a)) }.b) ) ({a = (case <l = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) in (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Bool .a))) , c =  ({a = ({a = 1 , b = true , c =  0 }.b) , b = ({a = 1 , b = 1 }.b) }.b) }.b))
({a = (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Bool .x) (if false then true else true) ) (if true then false else true)) ) (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (iszero ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 ))) )) , c =  (case <l = (( \f: Bool .((f (pred (fix (\x: Nat . 1 ))) ) (case <l = ({a = false , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(if (( \f: Unit .((f (((\x: Bool .\y: Unit .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (let u = true in false)) ) (( \f: Rec X. X .((f ({a = 1 , b = false }.b) ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .b)) then (iszero (fix (\x: Rec X. X . ({a = 1 , b = 0 }.b) ))) else ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) in u) )))
(case <l = ({a = (case <l = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) in u) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (let u = 0 in ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 ))) in ({a = 0 , b = false }.b)) , c = ({a = (fix (\x: Unit . 0 )) , b = (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .b)) )) }.a) }.c) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (let u = (unfold [ Nat ] (fold [ Rec X. X ] (iszero 0) )) in ({a = (if (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) then 1 else ({a = 1 , b = true , c = 0 }.c)) , b = ({a = 0 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.c) }.b)) in ({a = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Bool . (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .a)) )) )) , b = (case <l = ({a = ({a = 1 , b = false }.b) , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) }.a))
(pred (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = ({a = 1 , b = true }.b) }.a) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) )))
({a = (let u = (unfold [ Unit ] (fold [ Unit ] ({a = true , b = (fix (\x: Bool . 1 )) }.a) )) in ({a = (((\x: Bool .\y: Unit .y) true ) 1) , b = (if (let u = 1 in false) then (fix (\x: Rec X. X . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) else (iszero ({a = 0 , b = 0 }.b))) , c = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) ({a = true , b = 1 }.b) ) (iszero 1)) ) (let u = 0 in 1) ) ) (\a: Unit .\b: Rec X. X .b)) }.c)) , b = ({a = (case <r = (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Rec X. X .y) false ) true) ) ({a = 0 , b = true , c =  0 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <l = (pred (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a))) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.b)
({a = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = 0 , b = 1 }.b) in (pred 1)) )) in ({a = (fix (\x: Rec X. X . (((\x: Unit .\y: Bool .y) false ) false) )) , b = (unfold [ Unit ] (fold [ Unit ] (let u = (succ 1) in u) )) }.b)) , b = ({a = ({a = ({a = false , b = 1 }.b) , b = ({a = 0 , b = false }.a) }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) true ) false) )) , c =  ({a = 0 , b = 0 }.b) }.b) }.b)
({a = ({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) 1 ) false) ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = ({a = (if ({a = true , b = false }.b) then false else true) , b = ({a = false , b = 0 }.b) }.a) }.a) , b = ({a = ({a = (if (let u = 0 in false) then (if true then true else false) else true) , b = (succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 ))) }.b) , b = ({a = 0 , b = false }.b) }.b) }.a)
(( \f: Bool .((f (succ (((\x: Nat .\y: Unit .y) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) ({a = true , b = 1 }.b))) ) ({a = (((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f ({a = true , b = true }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Unit .a)) ) (succ 1)) , b = (((\x: Nat .\y: Rec X. X .y) (((\x: Bool .\y: Nat .y) true ) (let u = false in true)) ) ({a = (((\x: Rec X. X .\y: Nat .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) true) , b = ({a = 0 , b = true , c =  1 }.b) }.a)) }.b) ) ) (\a: Unit .\b: Rec X. X .b))
(if (((\x: Unit .\y: Bool .x) (let u = (( \f: Rec X. X .((f (pred 1) ) (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ) ) (\a: Unit .\b: Bool .a)) in (iszero 0)) ) (iszero (let u = (succ 0) in ({a = 0 , b = true }.a)))) then (fix (\x: Rec X. X . (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (let u = false in 1)) )) else (( \f: Rec X. X .((f (( \f: Nat .((f (fix (\x: Nat . (if false then 0 else 1) )) ) (unfold [ Nat ] (fold [ Rec X. X ] (pred 1) )) ) ) (\a: Bool .\b: Nat .b)) ) (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = true , c = 0 }.c) )) ) ) (\a: Rec X. X .\b: Nat .b)))
(iszero (let u = (if ({a = false , b = 1 }.a) then (pred 1) else (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a))) in u))
(((\x: Bool .\y: Nat .x) ({a = (( \f: Nat .((f (let u = (unfold [ Unit ] (fold [ Bool ] false )) in (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a))) ) (( \f: Nat .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) 1 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Unit .((f (let u = ({a = ({a = 0 , b = 1 }.b) , b = ({a = 1 , b = false }.a) }.b) in u) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) , b = ({a = true , b = 1 }.a) , c = (let u = 1 in ({a = false , b = 0 }.b)) }.c) ) ) (\a: Nat .\b: Bool .b)) }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = (fix (\x: Bool . 1 )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.b) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) }.b) )))
(( \f: Bool .((f ({a = ({a = ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = 1 }.b) , b = (((\x: Nat .\y: Rec X. X .y) true ) true) }.b) , b = (let u = ({a = (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Nat .y) true ) true) ) true) , b = (let u = true in 0) }.a) in ({a = (let u = 0 in u) , b = ({a = false , b = true }.b) }.a)) }.a) ) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero 0) )) in u) ) ) (\a: Unit .\b: Unit .a))
(((\x: Nat .\y: Unit .x) ({a = (let u = (((\x: Nat .\y: Nat .y) (iszero 1) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a))) , b = (fix (\x: Nat . ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.a) )) }.b) ) ({a = (((\x: Rec X. X .\y: Unit .x) (let u = (((\x: Nat .\y: Nat .y) false ) 0) in (((\x: Nat .\y: Bool .x) (let u = 1 in true) ) (let u = 0 in false))) ) (let u = (let u = false in 0) in ({a = 0 , b = true }.b))) , b = (succ ({a = (let u = false in u) , b = (pred 0) }.b)) }.a))
({a = ({a = (((\x: Rec X. X .\y: Bool .y) false ) 1) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) in false) )) , c = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) )) }.c) , b = (((\x: Bool .\y: Rec X. X .x) (let u = (unfold [ Bool ] (fold [ Nat ] true )) in ({a = true , b = 1 }.a)) ) (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Rec X. X .x) true ) ({a = 1 , b = false }.b)) ) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)))) }.a)
(succ (( \f: Rec X. X .((f (case <l = (((\x: Nat .\y: Bool .x) (unfold [ Nat ] (fold [ Bool ] 1 )) ) ({a = 1 , b = false , c =  1 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (let u = false in 0) , b = (fix (\x: Bool . false )) }.a) ) ) (\a: Nat .\b: Unit .b)))
(( \f: Bool .((f (if (iszero ({a = false , b = 1 }.b)) then (case <l = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) > as Unit of < l = x > => x | < r = y > => y) else (let u = (fix (\x: Unit . true )) in (let u = false in 1))) ) (let u = (if (iszero 1) then (iszero (fix (\x: Rec X. X . 1 ))) else (if (let u = 1 in true) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = 1 in false))) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) 1 ) true) ))) ) ) (\a: Rec X. X .\b: Bool .a))
(( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Nat .y) true ) 0) in ({a = 0 , b = true , c =  1 }.b)) )) )) )) ) (let u = ({a = (case <r = (let u = false in u) > as Unit of < l = x > => x | < r = y > => y) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) in ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Unit .\y: Unit .x) 0 ) true) in false) , c =  (pred 1) }.b)) ) ) (\a: Nat .\b: Unit .a))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = (( \f: Unit .((f (unfold [ Nat ] (fold [ Bool ] true )) ) (let u = 0 in true) ) ) (\a: Bool .\b: Nat .b)) in (fix (\x: Bool . (iszero 1) ))) ))
(let u = ({a = (let u = ({a = 1 , b = true , c =  0 }.b) in ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 ))) , b = (succ (if ({a = false , b = 0 }.a) then 0 else 1)) }.b) in (fix (\x: Unit . (( \f: Nat .((f (let u = false in false) ) (iszero 1) ) ) (\a: Bool .\b: Unit .a)) )))
(fix (\x: Rec X. X . (fix (\x: Bool . (let u = ({a = 0 , b = 0 }.b) in (iszero 0)) )) ))
(let u = ({a = (fix (\x: Unit . ({a = (if true then 1 else 1) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.a) )) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) )) , c = (let u = (if (((\x: Bool .\y: Bool .x) false ) ({a = false , b = 0 }.a)) then ({a = 0 , b = (((\x: Nat .\y: Bool .x) false ) true) , c = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) }.c) else (if false then 0 else 0)) in u) }.c) in (( \f: Rec X. X .((f (let u = ({a = false , b = 1 }.a) in u) ) (if true then (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) else true) ) ) (\a: Bool .\b: Nat .b)))
(( \f: Unit .((f ({a = (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in true) )) , b = ({a = (let u = 1 in false) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = 1 , b = false , c = 0 }.c) )) }.b) }.b) ) (((\x: Bool .\y: Bool .y) (((\x: Nat .\y: Rec X. X .y) true ) (fix (\x: Bool . false ))) ) (if ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) then (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Nat .x) 1 ) true) ) true) else ({a = true , b = 0 }.b))) ) ) (\a: Unit .\b: Nat .a))
(( \f: Bool .((f (( \f: Nat .((f (fix (\x: Unit . (( \f: Nat .((f (let u = true in (((\x: Bool .\y: Nat .y) true ) true)) ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) ) (((\x: Bool .\y: Unit .y) ({a = 0 , b = false , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Nat .((f (iszero (let u = 0 in u)) ) ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) , b = ({a = false , b = 0 }.a) }.b) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Bool .\b: Rec X. X .a))
({a = (if (((\x: Nat .\y: Rec X. X .x) ({a = (iszero 1) , b = (let u = (pred 1) in u) }.a) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) then (let u = ({a = false , b = 0 }.a) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 ))) else (succ (((\x: Nat .\y: Nat .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = 1 }.b)))) , b = (let u = (fix (\x: Bool . (((\x: Bool .\y: Bool .y) true ) true) )) in ({a = (unfold [ Unit ] (fold [ Unit ] 1 )) , b = (let u = 1 in true) , c =  (((\x: Bool .\y: Nat .y) true ) 0) }.b)) , c = (( \f: Rec X. X .((f (let u = 1 in 0) ) (let u = false in 1) ) ) (\a: Bool .\b: Rec X. X .b)) }.c)
({a = (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Rec X. X .y) (let u = true in u) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a))) ) ({a = (let u = true in false) , b = ({a = 0 , b = true }.b) }.b)) ) (((\x: Bool .\y: Rec X. X .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Bool . ({a = 1 , b = true }.b) )) )) ) ({a = ({a = 0 , b = (iszero 0) }.a) , b = (( \f: Rec X. X .((f true ) (let u = false in u) ) ) (\a: Nat .\b: Unit .b)) }.b))) , b = (let u = (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Nat .x) true ) false) ) (let u = true in u)) in (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) ) (let u = 1 in false) ) ) (\a: Bool .\b: Rec X. X .b))) , c = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Bool . 1 )) ) ({a = (unfold [ Bool ] (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) )) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a)) }.c)
(let u = ({a = (pred (unfold [ Unit ] (fold [ Bool ] 1 ))) , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) }.a) in ({a = ({a = (let u = false in 0) , b = (((\x: Unit .\y: Rec X. X .x) ({a = false , b = true }.b) ) ({a = 0 , b = false }.b)) }.a) , b = (let u = ({a = false , b = 1 }.a) in u) }.a))
(((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .x) (case <r = (let u = 0 in (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . (iszero 0) ))) ) (if (let u = ({a = 1 , b = true }.b) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true ))) then (((\x: Unit .\y: Nat .y) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true ))) else (iszero ({a = true , b = 0 }.b))))
(( \f: Unit .((f ({a = (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) (let u = false in 0) ) ) (\a: Nat .\b: Unit .a)) )) }.b) ) (let u = ({a = (if (let u = 1 in false) then (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .b)) else true) , b = ({a = (pred 0) , b = true , c = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.c) }.b) in u) ) ) (\a: Bool .\b: Bool .a))
({a = ({a = (let u = (case <l = ({a = (let u = true in 0) , b = (succ 1) }.b) > as Unit of < l = x > => x | < r = y > => y) in u) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if (let u = false in u) then true else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) )) }.b) , b = (let u = (iszero 1) in (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) (if true then 0 else 1))) }.a)
(let u = ({a = (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .y) (unfold [ Nat ] (fold [ Nat ] true )) ) true) )) , b = (case <r = (if false then true else true) > as Unit of < l = x > => x | < r = y > => y) }.b) in u)
({a = ({a = ({a = (let u = (((\x: Nat .\y: Bool .x) 0 ) true) in u) , b = (let u = 1 in 1) }.b) , b = (( \f: Bool .((f (((\x: Bool .\y: Bool .y) false ) 0) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false ))) )) , c =  (succ (pred (pred 1))) }.b)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (unfold [ Unit ] (fold [ Rec X. X ] ({a = ({a = true , b = 0 }.b) , b = (iszero 1) , c = 1 }.c) )) in u) ))
({a = (let u = (succ ({a = 1 , b = 1 }.b)) in u) , b = (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .y) true ) (let u = false in u)) )) }.a)
(case <l = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = false , c = 0 }.c) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(iszero ({a = (((\x: Rec X. X .\y: Unit .x) 1 ) (let u = false in u)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = 0 , b = false , c =  1 }.b) )) , c = ({a = 0 , b = (let u = 0 in 0) }.b) }.c))
(let u = (if (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = false in true) )) in u) then (let u = (((\x: Bool .\y: Rec X. X .x) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) true) in (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b))) else (((\x: Rec X. X .\y: Bool .x) (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Bool .y) true ) true)) ) (let u = (((\x: Bool .\y: Unit .x) (let u = 0 in u) ) false) in ({a = (fix (\x: Bool . false )) , b = false }.b)))) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (if true then (fix (\x: Nat . false )) else ({a = 0 , b = false , c =  1 }.b)) )))
({a = (fix (\x: Bool . (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) in (((\x: Unit .\y: Bool .y) (let u = false in u) ) 0)) )) , b = (((\x: Nat .\y: Rec X. X .x) ({a = ({a = (unfold [ Bool ] (fold [ Bool ] true )) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) }.b) , b = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = false in u) , c = ({a = false , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b) }.c) }.b) ) ({a = (((\x: Unit .\y: Rec X. X .x) ({a = 1 , b = true , c =  1 }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false ))) , b = (let u = ({a = 0 , b = false , c = 1 }.c) in true) }.b)) }.b)
(let u = (case <r = ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (if false then true else true) }.b) > as Nat of < l = x > => x | < r = y > => y) in (( \f: Unit .((f (let u = (fix (\x: Nat . true )) in u) ) (if false then true else false) ) ) (\a: Bool .\b: Unit .a)))
(let u = ({a = (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (succ (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))) , b = (((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) false) }.b) }.b) in (((\x: Bool .\y: Nat .y) ({a = ({a = true , b = 0 }.a) , b = (let u = 0 in (fix (\x: Nat . 0 ))) }.a) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)))
(iszero (((\x: Unit .\y: Bool .y) (let u = (fix (\x: Unit . 0 )) in (if false then true else false)) ) (let u = (((\x: Bool .\y: Nat .x) false ) false) in ({a = false , b = 1 }.b))))
(case <l = ({a = (let u = (((\x: Unit .\y: Unit .y) false ) 1) in u) , b = (( \f: Unit .((f (((\x: Bool .\y: Unit .y) ({a = true , b = true }.b) ) (let u = ({a = 0 , b = 0 }.b) in (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)))) ) (( \f: Nat .((f (let u = false in u) ) (let u = true in false) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .b)) , c = (fix (\x: Unit . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) }.c) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Nat . (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) )) in (let u = ({a = (pred 1) , b = (succ 0) }.b) in (case <r = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = true }.a) )) in (fix (\x: Nat . false ))) > as Unit of < l = x > => x | < r = y > => y)))
(((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Unit ] (pred (let u = true in (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)))) )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) true ) true) ) ({a = 0 , b = 0 }.b)) , b = ({a = ({a = false , b = 0 }.b) , b = ({a = true , b = 0 }.a) , c =  ({a = 0 , b = true }.a) }.b) , c =  (( \f: Bool .((f (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) ) (( \f: Nat .((f (if false then 0 else 0) ) 0 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .b)) }.b) )))
(( \f: Nat .((f (( \f: Unit .((f (( \f: Bool .((f (case <r = (if false then false else false) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = false , b = (if false then 0 else 0) }.a) ) ) (\a: Bool .\b: Rec X. X .b)) ) (iszero (unfold [ Nat ] (fold [ Nat ] (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) in u) ))) ) ) (\a: Nat .\b: Nat .b)) ) (let u = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) in u) ) ) (\a: Unit .\b: Unit .b))
(succ (pred ({a = ({a = 0 , b = (let u = false in true) , c = 1 }.c) , b = (((\x: Unit .\y: Bool .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) ) (( \f: Unit .((f 1 ) ({a = true , b = 0 }.b) ) ) (\a: Rec X. X .\b: Bool .b))) }.b)))
(let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (pred ({a = 1 , b = false }.a)) in u) )) in (let u = (let u = (( \f: Unit .((f (let u = 0 in true) ) false ) ) (\a: Unit .\b: Unit .b)) in u) in ({a = (pred 0) , b = (if true then true else false) , c =  1 }.b)))
({a = ({a = (if (if (((\x: Rec X. X .\y: Nat .x) false ) false) then false else (((\x: Bool .\y: Nat .y) false ) false)) then (( \f: Bool .((f (let u = (((\x: Nat .\y: Nat .y) true ) 1) in (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .b))) ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Bool .a)) else (fix (\x: Rec X. X . ({a = 0 , b = true , c =  1 }.b) ))) , b = (let u = (((\x: Bool .\y: Nat .y) true ) (fix (\x: Rec X. X . 1 ))) in u) }.b) , b = (case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) )) > as Nat of < l = x > => x | < r = y > => y) }.a)
({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (unfold [ Unit ] (fold [ Bool ] (if (unfold [ Bool ] (fold [ Unit ] true )) then ({a = true , b = 0 }.a) else (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ))) , b = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = false in true) )) , b = ({a = (let u = 0 in u) , b = (let u = 0 in false) }.a) }.a) }.b)
(let u = (( \f: Bool .((f (let u = (( \f: Nat .((f (iszero 1) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (let u = (fix (\x: Bool . 0 )) in (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)))) ) (let u = (unfold [ Nat ] (fold [ Bool ] 0 )) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Nat .a)) in u)
(unfold [ Bool ] (fold [ Bool ] (if (( \f: Rec X. X .((f (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Nat ] false )) )) ) (let u = ({a = 0 , b = 1 }.b) in ({a = false , b = 0 }.a)) ) ) (\a: Bool .\b: Rec X. X .b)) then (((\x: Bool .\y: Bool .y) ({a = 1 , b = (fix (\x: Nat . true )) }.b) ) (if true then 1 else 0)) else (unfold [ Rec X. X ] (fold [ Nat ] (let u = 0 in u) ))) ))
(( \f: Rec X. X .((f ({a = (fix (\x: Nat . ({a = true , b = 0 }.a) )) , b = ({a = (let u = (iszero 0) in (if false then 0 else 1)) , b = (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b)) }.a) }.b) ) ({a = (( \f: Unit .((f 0 ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = ({a = ({a = (let u = (fix (\x: Bool . 0 )) in (unfold [ Bool ] (fold [ Nat ] false ))) , b = (fix (\x: Bool . (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) }.b) , b = (let u = (unfold [ Nat ] (fold [ Nat ] ({a = ({a = false , b = true }.b) , b = 1 }.a) )) in (( \f: Bool .((f (let u = ({a = false , b = 0 }.b) in false) ) ({a = 0 , b = (((\x: Rec X. X .\y: Nat .y) false ) true) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.b) in (fix (\x: Unit . (unfold [ Unit ] (fold [ Unit ] (( \f: Rec X. X .((f ({a = false , b = 1 }.b) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Nat .a)) )) )))
(((\x: Rec X. X .\y: Rec X. X .y) (case <r = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (pred 0) }.a) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Unit ] ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) , b = (((\x: Nat .\y: Rec X. X .y) false ) false) , c = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in (((\x: Unit .\y: Bool .y) true ) 1)) }.c) )))
(fix (\x: Rec X. X . ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (fix (\x: Nat . true )) , c =  ({a = (let u = 1 in u) , b = true }.a) }.b) ))
(succ (if (let u = (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) in u) then (unfold [ Nat ] (fold [ Bool ] (succ 1) )) else (let u = ({a = ({a = true , b = 0 }.b) , b = false , c = 1 }.c) in u)))
((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = (fix (\x: Rec X. X . true )) , b = ({a = 1 , b = false , c = 1 }.c) }.b) , b = (fix (\x: Bool . (let u = false in false) )) , c =  (( \f: Unit .((f ({a = (let u = 1 in u) , b = 1 }.b) ) (((\x: Rec X. X .\y: Bool .x) 0 ) false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ))
({a = ({a = ({a = ({a = 1 , b = false , c = 0 }.c) , b = (let u = 1 in false) , c = (fix (\x: Nat . ({a = 0 , b = 1 }.b) )) }.c) , b = (fix (\x: Bool . 0 )) }.b) , b = (((\x: Bool .\y: Rec X. X .y) (( \f: Nat .((f ({a = (iszero 0) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Bool ] 1 )) )) }.a) ) ({a = (unfold [ Unit ] (fold [ Unit ] 1 )) , b = (fix (\x: Rec X. X . true )) , c =  0 }.b) ) ) (\a: Bool .\b: Unit .b)) ) (let u = (succ 0) in (succ 0))) }.b)
({a = (unfold [ Unit ] (fold [ Bool ] ({a = (( \f: Nat .((f (if false then ({a = true , b = 0 }.b) else ({a = 1 , b = true , c = 0 }.c)) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (iszero (let u = ({a = 1 , b = true , c =  0 }.b) in ({a = 0 , b = false , c = 1 }.c))) }.a) )) , b = ({a = (pred (let u = (if false then 1 else 0) in u)) , b = (( \f: Bool .((f (iszero 0) ) false ) ) (\a: Unit .\b: Unit .b)) }.b) }.a)
(((\x: Nat .\y: Unit .y) ({a = (fix (\x: Rec X. X . ({a = 1 , b = false , c =  0 }.b) )) , b = ({a = (let u = (iszero 1) in (let u = false in u)) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.a) }.b) ) (iszero (( \f: Nat .((f (pred 0) ) (let u = 1 in 0) ) ) (\a: Rec X. X .\b: Unit .b))))
(( \f: Rec X. X .((f ({a = (fix (\x: Rec X. X . 1 )) , b = (let u = 0 in false) , c = (if (iszero 0) then 0 else (succ 1)) }.c) ) (let u = (( \f: Rec X. X .((f (if false then 1 else 0) ) (if (let u = false in u) then ({a = 1 , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b)) }.a) else (unfold [ Bool ] (fold [ Unit ] 1 ))) ) ) (\a: Nat .\b: Bool .a)) in (unfold [ Nat ] (fold [ Rec X. X ] (pred (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a))) ))) ) ) (\a: Nat .\b: Bool .a))
({a = ({a = (let u = (fix (\x: Bool . (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) in u) , b = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Nat .x) 1 ) true) ) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) in (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)))) }.a) , b = (iszero (( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] 1 )) ) (if false then 0 else 1) ) ) (\a: Nat .\b: Rec X. X .b))) }.b)
(let u = (let u = (iszero (if ({a = 0 , b = true , c =  0 }.b) then 0 else 0)) in u) in ({a = (let u = (let u = true in (((\x: Nat .\y: Bool .x) true ) false)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) , b = (case <l = (if (iszero 0) then (let u = 0 in u) else (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) > as Unit of < l = x > => x | < r = y > => y) }.a))
({a = (( \f: Unit .((f (unfold [ Unit ] (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] 1 )) )) ) (( \f: Nat .((f ({a = (let u = 0 in u) , b = true , c = 0 }.c) ) ({a = true , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] false )) ) (let u = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) in ({a = 0 , b = (let u = true in false) }.b)) ) ) (\a: Nat .\b: Nat .a)) )) }.b)
(fix (\x: Unit . (fix (\x: Nat . ({a = ({a = (iszero 1) , b = 1 }.b) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b) )) ))
(( \f: Unit .((f (fix (\x: Bool . (let u = (let u = true in 1) in u) )) ) (( \f: Nat .((f ({a = ({a = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b)) , b = (succ (if true then 0 else 1)) }.b) , b = (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b))) }.a) ) (fix (\x: Unit . (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) (((\x: Unit .\y: Rec X. X .y) true ) 1) ) ) (\a: Nat .\b: Nat .a)) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .a))
(if ({a = (fix (\x: Unit . (let u = true in 0) )) , b = (iszero ({a = 0 , b = false }.a)) }.b) then (let u = (((\x: Rec X. X .\y: Bool .x) (let u = false in false) ) (let u = 0 in true)) in u) else (let u = (let u = ({a = 0 , b = 1 }.b) in (((\x: Nat .\y: Nat .x) true ) false)) in (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .y) false ) true) ))))
(case <r = (if (if ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b)) )) then ({a = false , b = 1 }.a) else (((\x: Unit .\y: Unit .x) false ) true)) then ({a = (((\x: Bool .\y: Nat .x) false ) false) , b = (fix (\x: Unit . 1 )) }.a) else (unfold [ Bool ] (fold [ Nat ] (fix (\x: Bool . true )) ))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] ({a = (case <l = ({a = false , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Bool .x) ({a = true , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) ) (( \f: Unit .((f true ) ({a = 0 , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .b))) }.b) )) ) (if ({a = (((\x: Bool .\y: Unit .y) false ) false) , b = (let u = false in u) }.b) then (let u = (let u = ({a = true , b = 1 }.b) in u) in (iszero 0)) else (if (((\x: Bool .\y: Nat .y) (iszero (unfold [ Bool ] (fold [ Unit ] 0 ))) ) (let u = (let u = false in true) in u)) then ({a = true , b = ({a = 1 , b = true , c = 0 }.c) }.a) else ({a = (fix (\x: Bool . 1 )) , b = false , c =  0 }.b))))
(pred (let u = (((\x: Rec X. X .\y: Bool .y) true ) false) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))))
({a = ({a = (case <l = ({a = true , b = (((\x: Unit .\y: Unit .y) false ) 0) }.b) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (unfold [ Nat ] (fold [ Unit ] true )) , b = false }.b) , c = (pred 1) }.c) , b = (unfold [ Nat ] (fold [ Rec X. X ] (if false then (((\x: Nat .\y: Nat .y) false ) 0) else (let u = 0 in 1)) )) }.b)
({a = (( \f: Bool .((f (((\x: Unit .\y: Nat .y) true ) 0) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) , b = (case <r = (if ({a = 1 , b = true }.b) then (fix (\x: Bool . true )) else (let u = 0 in true)) > as Bool of < l = x > => x | < r = y > => y) , c = (let u = (let u = (fix (\x: Rec X. X . 0 )) in 1) in (pred (fix (\x: Unit . 1 )))) }.c)
(let u = (let u = (unfold [ Bool ] (fold [ Unit ] false )) in (let u = true in (unfold [ Rec X. X ] (fold [ Nat ] true )))) in (let u = ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , c = 1 }.c) in ({a = false , b = ({a = true , b = 0 }.b) }.a)))
(((\x: Nat .\y: Nat .y) (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) (iszero (let u = false in 0)) ) (if true then ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) else false)) ) ({a = (iszero (let u = 1 in u)) , b = (let u = 0 in u) }.a) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Bool .\y: Bool .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = true in true) )) ) (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = true , c =  1 }.b) ))))
(case <l = (pred (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . 0 )) ))) > as Unit of < l = x > => x | < r = y > => y)
(succ (let u = (succ (pred (((\x: Nat .\y: Rec X. X .x) 0 ) (let u = false in u)))) in u))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = ({a = (fix (\x: Nat . false )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = 1 }.b) )) }.a) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) )) ))
(iszero (((\x: Unit .\y: Unit .x) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in 0) }.b) ) (let u = (fix (\x: Rec X. X . (pred 1) )) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = (pred 1) , b = false , c =  1 }.b) )))))
(let u = ({a = ({a = (fix (\x: Unit . false )) , b = (if false then 1 else 0) }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = (if (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .b)) then ({a = false , b = false }.b) else false) , b = (let u = true in 1) }.a) )) , c = (succ (case <l = (pred 1) > as Unit of < l = x > => x | < r = y > => y)) }.c) in (let u = (let u = (let u = false in false) in (let u = true in true)) in ({a = (let u = ({a = 1 , b = true , c =  0 }.b) in u) , b = (let u = (fix (\x: Rec X. X . 0 )) in u) }.a)))
(iszero (succ ({a = (case <l = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = true }.b) }.a)))
(if (unfold [ Bool ] (fold [ Rec X. X ] (case <r = (((\x: Unit .\y: Rec X. X .x) false ) false) > as Bool of < l = x > => x | < r = y > => y) )) then (fix (\x: Bool . (iszero ({a = 0 , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.a)) )) else (( \f: Rec X. X .((f (( \f: Unit .((f (( \f: Nat .((f (fix (\x: Unit . true )) ) false ) ) (\a: Unit .\b: Unit .a)) ) (unfold [ Nat ] (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = (let u = (let u = false in true) in ({a = false , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) , b = (((\x: Nat .\y: Bool .x) 0 ) true) }.a) ) ) (\a: Unit .\b: Unit .a)))
(if (( \f: Unit .((f ({a = ({a = 1 , b = (let u = true in false) , c =  1 }.b) , b = (let u = false in true) }.b) ) (if ({a = 1 , b = false , c =  1 }.b) then ({a = true , b = 1 }.a) else (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a))) ) ) (\a: Bool .\b: Nat .b)) then ({a = (fix (\x: Rec X. X . ({a = (unfold [ Bool ] (fold [ Bool ] 1 )) , b = (((\x: Nat .\y: Nat .x) false ) true) , c = (( \f: Rec X. X .((f ({a = true , b = 1 }.b) ) 1 ) ) (\a: Bool .\b: Nat .a)) }.c) )) , b = (( \f: Bool .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .y) false ) true) ) ) (\a: Unit .\b: Nat .a)) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] (pred 1) )) }.b) else ({a = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (fix (\x: Nat . true )) }.b))
({a = (( \f: Unit .((f ({a = ({a = 1 , b = 0 }.b) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a)) }.b) ) (( \f: Bool .((f false ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) ({a = 0 , b = (pred 1) }.b) ) ) (\a: Nat .\b: Nat .a)) )) }.b)
(let u = (iszero (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Bool .x) ({a = 0 , b = true , c =  1 }.b) ) ({a = 1 , b = (((\x: Unit .\y: Bool .x) true ) false) }.b)) ) (let u = 0 in 1))) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) 0 ) true) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )))
({a = (((\x: Unit .\y: Unit .x) ({a = (if true then ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) else (((\x: Nat .\y: Bool .y) true ) false)) , b = (let u = false in u) }.b) ) (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if true then true else false) )) ) (iszero (succ 1)) ) ) (\a: Bool .\b: Rec X. X .a))) , b = (( \f: Bool .((f ({a = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] true )) )) , b = (if (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) then ({a = 0 , b = false , c = 1 }.c) else (((\x: Nat .\y: Bool .y) false ) 1)) }.b) ) ({a = (( \f: Nat .((f 0 ) (let u = 0 in u) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (let u = 1 in ({a = 0 , b = true , c =  1 }.b)) , c = (fix (\x: Bool . 1 )) }.c) ) ) (\a: Nat .\b: Bool .b)) }.b)
(let u = ({a = (if true then 0 else (let u = false in 1)) , b = (( \f: Nat .((f ({a = 0 , b = false , c =  1 }.b) ) (((\x: Nat .\y: Unit .x) false ) false) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) in (let u = (let u = (let u = true in true) in u) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = 1 in u) )) ))))
(if ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) in (unfold [ Bool ] (fold [ Unit ] true ))) )) , b = ({a = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) (iszero 1) ) ) (\a: Nat .\b: Nat .b)) , b = (let u = (fix (\x: Unit . false )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 1 in 1) ))) }.a) }.b) then ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = 1 }.b) )) else (( \f: Nat .((f (if (if true then false else true) then (pred (fix (\x: Unit . 1 ))) else (let u = 1 in 1)) ) (if ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) , b = ({a = ({a = true , b = 1 }.b) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) , c = (succ 0) }.c) }.a) then (case <l = (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Bool .x) 1 ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Bool .x) 1 ) true)) ) ) (\a: Rec X. X .\b: Unit .a)))
({a = ({a = ({a = 0 , b = (unfold [ Nat ] (fold [ Bool ] true )) }.b) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.a) , b = (case <l = (pred ({a = false , b = 0 }.b)) > as Unit of < l = x > => x | < r = y > => y) }.b)
(( \f: Bool .((f (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (fix (\x: Unit . (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) )) )) in u) ) (( \f: Rec X. X .((f (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Nat ] (let u = false in u) )) )) ) (case <r = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 0 , b = false }.b) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .a))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Nat .a))
(unfold [ Rec X. X ] (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) true ) true) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Unit .b)) )) ))
(fix (\x: Bool . (fix (\x: Bool . (let u = ({a = (let u = (((\x: Bool .\y: Bool .y) false ) true) in u) , b = ({a = 0 , b = (let u = 0 in 0) }.b) }.b) in ({a = ({a = 0 , b = 1 }.b) , b = (let u = true in u) , c =  (if false then 0 else 1) }.b)) )) ))
(let u = (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Nat .x) (let u = 0 in true) ) (case <r = ({a = 1 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y)) ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .b))) in (unfold [ Nat ] (fold [ Unit ] (fix (\x: Unit . (let u = (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = false }.b) )) in u) )) )))
(let u = (( \f: Unit .((f (( \f: Unit .((f (((\x: Unit .\y: Nat .x) ({a = 0 , b = false }.a) ) (let u = 1 in false)) ) (succ (succ 1)) ) ) (\a: Unit .\b: Bool .a)) ) (fix (\x: Unit . (pred 1) )) ) ) (\a: Rec X. X .\b: Unit .a)) in (let u = (let u = ({a = false , b = 0 }.a) in true) in u))
({a = (( \f: Unit .((f (let u = (fix (\x: Bool . false )) in u) ) (let u = ({a = false , b = 0 }.b) in (iszero 0)) ) ) (\a: Unit .\b: Unit .b)) , b = (let u = (if (((\x: Unit .\y: Bool .x) true ) false) then ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) in u) }.b)
({a = (succ (succ (pred 0))) , b = (pred (if (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) then 1 else ({a = true , b = 0 }.b))) }.b)
(( \f: Unit .((f (case <r = (unfold [ Rec X. X ] (fold [ Nat ] (let u = (let u = false in u) in (let u = false in u)) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (( \f: Rec X. X .((f 1 ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (((\x: Nat .\y: Bool .x) (let u = true in u) ) ({a = false , b = 0 }.a)) }.b) ) ) (\a: Nat .\b: Unit .a))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) (if ({a = false , b = 0 }.a) then ({a = (unfold [ Rec X. X ] (fold [ Bool ] false )) , b = (iszero 0) }.b) else ({a = 0 , b = true , c =  (succ 1) }.b)) ) (( \f: Bool .((f ({a = 0 , b = (let u = 1 in true) }.b) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Rec X. X .b))) ))
(iszero (succ (case <l = (if (((\x: Unit .\y: Nat .x) true ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .a))) then (let u = false in 1) else ({a = true , b = 0 }.b)) > as Bool of < l = x > => x | < r = y > => y)))
(( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f (((\x: Nat .\y: Nat .y) true ) true) ) (fix (\x: Nat . false )) ) ) (\a: Bool .\b: Bool .b)) ) (case <r = (iszero 1) > as Bool of < l = x > => x | < r = y > => y)) ) (let u = (let u = (let u = ({a = 1 , b = false }.b) in ({a = 1 , b = true }.b)) in (if ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a)) )) then (let u = 0 in 1) else (succ 0))) in (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f true ) (let u = false in false) ) ) (\a: Nat .\b: Nat .b)) ))) ) ) (\a: Bool .\b: Unit .b))
(let u = ({a = (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Bool ] true )) )) , c =  (case <l = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) }.b) in (let u = (unfold [ Unit ] (fold [ Bool ] ({a = (((\x: Nat .\y: Bool .x) 0 ) true) , b = (iszero 0) }.b) )) in ({a = (let u = ({a = 1 , b = true }.b) in 0) , b = (if (let u = 0 in false) then ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .y) false ) true) )) else ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false ))) }.b)))
(( \f: Bool .((f (if (unfold [ Nat ] (fold [ Rec X. X ] false )) then (iszero (((\x: Unit .\y: Bool .y) false ) 0)) else (( \f: Bool .((f false ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .a))) ) (( \f: Nat .((f (( \f: Bool .((f (let u = true in u) ) ({a = true , b = 0 }.a) ) ) (\a: Nat .\b: Unit .a)) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .a))
(fix (\x: Bool . ({a = (case <r = ({a = false , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (let u = true in u) , b = (let u = false in u) }.b) }.b) }.b) ))
(let u = ({a = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) in u) , b = (let u = (fix (\x: Nat . (let u = true in false) )) in (let u = true in true)) , c =  (((\x: Nat .\y: Nat .x) (let u = 1 in 0) ) ({a = false , b = 0 }.a)) }.b) in (let u = (((\x: Nat .\y: Bool .y) true ) ({a = 1 , b = false }.a)) in u))
(( \f: Nat .((f (fix (\x: Rec X. X . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 0 , b = true }.b) )) )) ) (iszero (let u = (pred ({a = 0 , b = true }.a)) in (( \f: Bool .((f ({a = 0 , b = 0 }.b) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)))) ) ) (\a: Rec X. X .\b: Bool .a))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f 1 ) (pred 0) ) ) (\a: Nat .\b: Nat .b)) )) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Unit . 0 )) )) , b = ({a = (((\x: Nat .\y: Nat .y) (((\x: Bool .\y: Bool .y) true ) true) ) ({a = 0 , b = 1 }.b)) , b = (if true then false else false) , c =  (((\x: Rec X. X .\y: Nat .x) 1 ) true) }.b) }.b) , c = (((\x: Nat .\y: Bool .x) ({a = true , b = 1 }.b) ) (let u = 1 in true)) }.c) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (((\x: Rec X. X .\y: Bool .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .b)) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .b))) , b = (let u = true in u) }.b) )) ))
({a = ({a = (fix (\x: Bool . true )) , b = ({a = (if ({a = 0 , b = true , c =  0 }.b) then false else true) , b = (let u = 0 in 1) }.b) }.b) , b = (((\x: Bool .\y: Bool .x) (if (let u = false in false) then ({a = true , b = 0 }.a) else (iszero 1)) ) (iszero (succ 0))) }.a)
(let u = (if ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero (fix (\x: Nat . 1 ))) )) then (if (((\x: Bool .\y: Nat .x) ({a = 1 , b = true , c =  1 }.b) ) ({a = 0 , b = true , c =  1 }.b)) then ({a = (((\x: Bool .\y: Rec X. X .x) true ) true) , b = (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in 0) }.a) else (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) (if (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) then ({a = false , b = 1 }.a) else ({a = true , b = 0 }.a)))) else (fix (\x: Unit . (fix (\x: Bool . ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) )) ))) in (( \f: Unit .((f (succ (succ (if true then 0 else 0))) ) (fix (\x: Bool . (fix (\x: Bool . 0 )) )) ) ) (\a: Unit .\b: Nat .b)))
(((\x: Unit .\y: Nat .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Bool .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (if true then false else false) ) ) (\a: Nat .\b: Bool .b)) )) ) (fix (\x: Rec X. X . (if (if (iszero 0) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) else (iszero 1)) then (let u = (( \f: Bool .((f (let u = 1 in true) ) true ) ) (\a: Unit .\b: Rec X. X .b)) in (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (let u = false in false) else (if false then true else true))) else (fix (\x: Rec X. X . (let u = false in u) ))) )))
(( \f: Unit .((f (let u = (let u = (let u = true in u) in u) in u) ) (if ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) then (let u = (succ 1) in (fix (\x: Unit . false ))) else (if ({a = false , b = ({a = 0 , b = true }.a) }.a) then ({a = true , b = 1 }.a) else (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)))) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = (( \f: Bool .((f (if true then true else false) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Nat .a)) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.a) )) , b = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = (let u = (let u = true in 0) in ({a = false , b = 0 }.a)) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b)) }.b)
(((\x: Bool .\y: Rec X. X .x) (let u = (pred (let u = ({a = 0 , b = true , c = 0 }.c) in u)) in (( \f: Unit .((f (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] true )) ) (let u = false in u) ) ) (\a: Bool .\b: Nat .a)) ) (let u = false in u) ) ) (\a: Nat .\b: Nat .a))) ) (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Unit .((f (let u = (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = false }.a) )) in (unfold [ Nat ] (fold [ Unit ] (iszero 0) ))) ) (iszero (((\x: Nat .\y: Unit .x) 0 ) (iszero 0))) ) ) (\a: Nat .\b: Nat .b)) )))
(( \f: Rec X. X .((f (case <r = ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = (pred 1) }.a) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (if true then (case <r = true > as Nat of < l = x > => x | < r = y > => y) else false) ) ({a = (let u = (((\x: Nat .\y: Nat .y) false ) 1) in 0) , b = ({a = 1 , b = false , c =  1 }.b) , c =  (((\x: Bool .\y: Nat .x) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) true) }.b) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b))
({a = (succ (let u = (fix (\x: Unit . 1 )) in u)) , b = (iszero (((\x: Bool .\y: Unit .x) (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = true in true))) , c = (fix (\x: Nat . (( \f: Unit .((f (let u = 1 in 1) ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) }.c)
(((\x: Nat .\y: Rec X. X .y) ({a = (( \f: Unit .((f 1 ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = (( \f: Bool .((f 0 ) (succ 0) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a)) , c =  (let u = 1 in 1) }.b) }.b) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = 0 , b = 1 }.b) , b = ({a = true , b = true }.b) , c =  ({a = false , b = 1 }.b) }.b) ) (case <r = ({a = (if true then 0 else (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a))) , b = ({a = false , b = true }.b) , c =  (let u = false in (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b))) }.b) > as Bool of < l = x > => x | < r = y > => y)))
(( \f: Bool .((f (let u = (let u = true in u) in (( \f: Rec X. X .((f (let u = 0 in true) ) false ) ) (\a: Rec X. X .\b: Unit .a))) ) ({a = (( \f: Bool .((f (let u = (fix (\x: Rec X. X . 1 )) in ({a = ({a = true , b = false }.b) , b = ({a = 1 , b = false }.a) }.a)) ) (let u = (((\x: Unit .\y: Unit .y) false ) 0) in (unfold [ Nat ] (fold [ Bool ] true ))) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = ({a = ({a = (let u = true in 1) , b = (if true then true else true) }.a) , b = (((\x: Nat .\y: Rec X. X .y) false ) false) , c =  (let u = 0 in 1) }.b) , b = (( \f: Rec X. X .((f (let u = 1 in false) ) (((\x: Nat .\y: Unit .y) true ) false) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) }.b) ) ) (\a: Nat .\b: Unit .a))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (unfold [ Nat ] (fold [ Nat ] (let u = false in 0) )) , b = (iszero (let u = 1 in u)) , c = (succ ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 ))) }.c) ))
(((\x: Unit .\y: Unit .y) (( \f: Nat .((f (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] 0 )) )) in (( \f: Rec X. X .((f (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Bool .b))) ) (((\x: Bool .\y: Nat .y) (if ({a = 1 , b = false , c =  (let u = 1 in 1) }.b) then ({a = 0 , b = true }.b) else (let u = (iszero 0) in true)) ) ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = (iszero 1) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 )) }.b)) ) ) (\a: Nat .\b: Bool .a)) ) (( \f: Nat .((f (if (iszero 0) then (let u = ({a = 1 , b = ({a = 1 , b = false }.b) , c =  0 }.b) in u) else (fix (\x: Unit . (let u = 0 in false) ))) ) (( \f: Unit .((f (fix (\x: Nat . (unfold [ Bool ] (fold [ Bool ] false )) )) ) (iszero 1) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Nat .b)))
(((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Nat .y) (( \f: Unit .((f (let u = 1 in false) ) (let u = false in false) ) ) (\a: Rec X. X .\b: Nat .a)) ) (( \f: Nat .((f ({a = 1 , b = (unfold [ Nat ] (fold [ Unit ] true )) }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a))) ) (case <r = (( \f: Rec X. X .((f (case <r = (iszero 0) > as Nat of < l = x > => x | < r = y > => y) ) (iszero (let u = 0 in u)) ) ) (\a: Nat .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y))
(unfold [ Unit ] (fold [ Bool ] (if (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .y) true ) false) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Bool .b)) then ({a = (((\x: Rec X. X .\y: Unit .y) false ) false) , b = (let u = true in 0) }.a) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) ))
(((\x: Nat .\y: Unit .x) (case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (if (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) then ({a = 1 , b = false , c =  0 }.b) else (if false then false else false)) )) > as Unit of < l = x > => x | < r = y > => y) ) (case <r = (let u = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .y) false ) true) )) in u) > as Nat of < l = x > => x | < r = y > => y))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Bool .x) ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = 1 }.a) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = true }.b)) ))
(( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = (let u = false in ({a = 1 , b = false , c = 1 }.c)) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (pred (fix (\x: Bool . 1 ))) }.b) )) ) (fix (\x: Nat . (let u = (iszero 1) in (if true then 1 else 1)) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(if (if ({a = (let u = (let u = 0 in true) in (((\x: Bool .\y: Bool .x) 0 ) false)) , b = ({a = (unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) (let u = true in true)) }.b) }.b) then (let u = (((\x: Unit .\y: Nat .y) false ) 0) in ({a = true , b = false }.b)) else ({a = (let u = false in ({a = false , b = 0 }.a)) , b = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) in u) }.b)) then ({a = (case <r = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (if false then false else false)) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Rec X. X .\y: Unit .y) false ) true) , b = (let u = true in 1) }.a) }.b) else (unfold [ Unit ] (fold [ Nat ] ({a = (((\x: Unit .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) (iszero (fix (\x: Unit . 1 )))) , b = (iszero (( \f: Rec X. X .((f (fix (\x: Bool . 1 )) ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Unit .b))) }.b) )))
((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) , b = (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) false ) 0) ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) in u) }.b) ))
({a = (((\x: Unit .\y: Unit .y) (( \f: Bool .((f (( \f: Bool .((f ({a = 0 , b = true }.b) ) false ) ) (\a: Nat .\b: Nat .b)) ) (unfold [ Unit ] (fold [ Unit ] true )) ) ) (\a: Nat .\b: Bool .b)) ) ({a = (((\x: Unit .\y: Bool .x) (((\x: Nat .\y: Unit .y) true ) false) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b))) , b = (let u = 1 in u) }.b)) , b = (unfold [ Nat ] (fold [ Unit ] (case <l = (((\x: Nat .\y: Rec X. X .x) 0 ) false) > as Bool of < l = x > => x | < r = y > => y) )) }.b)
(let u = (pred (((\x: Bool .\y: Rec X. X .x) ({a = (let u = false in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) , b = (succ 1) }.b) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = false , c =  1 }.b) )))) in u)
({a = (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f ({a = 1 , b = false , c = 1 }.c) ) (fix (\x: Nat . 1 )) ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = (((\x: Bool .\y: Bool .x) (unfold [ Nat ] (fold [ Rec X. X ] (iszero (((\x: Nat .\y: Nat .x) 1 ) true)) )) ) (let u = (((\x: Bool .\y: Unit .x) (let u = false in true) ) (iszero 0)) in (case <r = (((\x: Unit .\y: Unit .y) true ) false) > as Nat of < l = x > => x | < r = y > => y))) , c =  (( \f: Nat .((f (case <l = (if (let u = 0 in false) then 0 else 0) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Nat ] (fold [ Nat ] (let u = true in 1) )) , b = (succ 0) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) }.b)
({a = ({a = ({a = (let u = (let u = false in true) in 0) , b = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (let u = true in u) }.b) }.a) , b = ({a = (let u = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .a)) in u) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) }.b) }.a) , b = ({a = (let u = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) in (((\x: Nat .\y: Rec X. X .y) true ) 1)) , b = (( \f: Unit .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) (let u = true in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false ))) ) ) (\a: Unit .\b: Bool .a)) }.b) }.b)
(let u = (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = false , c =  0 }.b) ) false) ) (unfold [ Nat ] (fold [ Bool ] ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = true , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ))) in (((\x: Rec X. X .\y: Nat .x) (((\x: Rec X. X .\y: Bool .x) (let u = true in true) ) ({a = 1 , b = false }.b)) ) (((\x: Nat .\y: Nat .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) ) (let u = 1 in (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a))))))
({a = (case <l = (((\x: Rec X. X .\y: Unit .y) false ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (if (if (((\x: Bool .\y: Bool .x) false ) true) then ({a = 1 , b = true }.b) else (let u = 1 in false)) then (unfold [ Rec X. X ] (fold [ Bool ] 1 )) else (( \f: Nat .((f ({a = 1 , b = false }.a) ) (succ 1) ) ) (\a: Rec X. X .\b: Rec X. X .b))) in (( \f: Rec X. X .((f (( \f: Unit .((f true ) (fix (\x: Unit . false )) ) ) (\a: Nat .\b: Unit .a)) ) (((\x: Nat .\y: Bool .x) (let u = false in true) ) (fix (\x: Rec X. X . false ))) ) ) (\a: Nat .\b: Unit .b))) , c =  (case <l = (pred ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) > as Nat of < l = x > => x | < r = y > => y) }.b)
({a = (unfold [ Unit ] (fold [ Rec X. X ] ({a = (pred 1) , b = true , c = 1 }.c) )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = true , b = 0 }.a) , b = ({a = (let u = true in 0) , b = (((\x: Bool .\y: Rec X. X .y) false ) false) }.a) }.a) )) }.b)
(let u = (iszero (((\x: Bool .\y: Unit .x) (let u = ({a = 1 , b = true }.b) in (fix (\x: Unit . 0 ))) ) (let u = (let u = true in u) in (let u = 0 in false)))) in (pred ({a = ({a = ({a = 1 , b = false , c = 1 }.c) , b = ({a = true , b = 1 }.b) }.b) , b = (if false then true else (let u = 1 in true)) , c = (succ 1) }.c)))
(fix (\x: Unit . (( \f: Unit .((f (( \f: Bool .((f (((\x: Bool .\y: Bool .y) true ) true) ) (iszero 1) ) ) (\a: Bool .\b: Unit .a)) ) (if (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b)) then (let u = 1 in true) else ({a = 0 , b = false }.b)) ) ) (\a: Unit .\b: Nat .a)) ))
(((\x: Nat .\y: Bool .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) 0 ) true) ) (if false then 0 else 0) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ({a = (let u = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .a)) in (((\x: Nat .\y: Nat .x) 1 ) true)) , b = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (let u = false in u) }.b) , c =  ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = ({a = false , b = true }.b) }.a) }.b))
(if (((\x: Rec X. X .\y: Unit .y) (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) in (((\x: Nat .\y: Bool .x) true ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .b)))) ) ({a = (unfold [ Bool ] (fold [ Nat ] (let u = true in false) )) , b = ({a = true , b = true }.b) }.b)) then (let u = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Bool .\y: Unit .x) (let u = 1 in 0) ) true) )) in (fix (\x: Unit . ({a = 1 , b = (if false then false else true) , c = 0 }.c) ))) else (((\x: Nat .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (pred 1) )) ) (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in (let u = 1 in (let u = 0 in false)))))
(iszero (((\x: Bool .\y: Rec X. X .y) (let u = (iszero 1) in (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) true ) true) ))) ) (if (( \f: Unit .((f true ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) then (fix (\x: Bool . (((\x: Nat .\y: Nat .x) 0 ) true) )) else (pred (let u = true in 1)))))
({a = ({a = (if (if true then false else true) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) else ({a = (let u = false in 0) , b = ({a = 0 , b = true }.b) }.a)) , b = ({a = (if false then 1 else ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 ))) , b = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = true }.a) }.b) }.b) , b = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .y) false ) (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .a))) )) then (let u = ({a = (let u = (pred 1) in false) , b = (if true then 0 else 0) }.b) in (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = true , c =  0 }.b) ) (((\x: Unit .\y: Nat .x) true ) (let u = true in true)))) else ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Bool .\y: Bool .y) false ) 0) ) true) }.a)) }.b)
({a = (case <l = (let u = 1 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = ({a = ({a = 1 , b = true , c = 1 }.c) , b = (((\x: Rec X. X .\y: Bool .x) 0 ) true) }.b) in ({a = ({a = (let u = true in true) , b = 1 }.a) , b = (pred 0) }.a)) }.a)
(pred (fix (\x: Bool . (succ ({a = false , b = (fix (\x: Bool . 1 )) }.b)) )))
(let u = (( \f: Bool .((f (let u = (let u = ({a = (let u = 1 in u) , b = (((\x: Nat .\y: Bool .x) true ) false) }.b) in u) in (fix (\x: Nat . 1 ))) ) ({a = (pred ({a = 0 , b = 1 }.b)) , b = ({a = (let u = (pred 0) in u) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) }.b) }.a) ) ) (\a: Unit .\b: Bool .a)) in (if (let u = (((\x: Bool .\y: Rec X. X .y) false ) false) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) then (pred ({a = 0 , b = 0 }.b)) else (let u = (((\x: Nat .\y: Unit .y) false ) false) in (pred (((\x: Unit .\y: Unit .y) false ) 0)))))
({a = (let u = (pred (( \f: Nat .((f ({a = 0 , b = 1 }.b) ) (let u = false in 1) ) ) (\a: Nat .\b: Rec X. X .b))) in ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.a)) , b = (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .y) ({a = false , b = true }.b) ) 1) )) }.a)
(((\x: Nat .\y: Bool .x) (((\x: Bool .\y: Unit .x) (unfold [ Nat ] (fold [ Unit ] ({a = (fix (\x: Unit . 1 )) , b = (((\x: Rec X. X .\y: Nat .y) false ) true) }.a) )) ) (fix (\x: Nat . (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) false ) true) ) (((\x: Bool .\y: Unit .y) false ) true) ) ) (\a: Nat .\b: Unit .a)) ))) ) (( \f: Rec X. X .((f (( \f: Nat .((f ({a = (let u = false in false) , b = ({a = 1 , b = false , c = 0 }.c) }.a) ) ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (fix (\x: Unit . true )) }.b) ) ) (\a: Nat .\b: Bool .a)) ) (((\x: Unit .\y: Bool .y) ({a = ({a = false , b = false }.b) , b = true }.b) ) (unfold [ Nat ] (fold [ Rec X. X ] true ))) ) ) (\a: Unit .\b: Nat .a)))
(let u = ({a = (let u = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) , b = (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .b)) then true else ({a = true , b = 0 }.a)) }.a) in (( \f: Nat .((f ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) , b = ({a = 1 , b = true , c = 0 }.c) }.a) ) (( \f: Nat .((f (case <r = (let u = 1 in true) > as Bool of < l = x > => x | < r = y > => y) ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(( \f: Unit .((f (fix (\x: Nat . ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Bool .x) false ) true) }.a) )) ) (let u = (case <l = (fix (\x: Bool . (((\x: Nat .\y: Unit .y) true ) 0) )) > as Bool of < l = x > => x | < r = y > => y) in u) ) ) (\a: Unit .\b: Bool .a))
(let u = (((\x: Nat .\y: Unit .x) ({a = (let u = 0 in true) , b = (fix (\x: Bool . 1 )) }.a) ) (let u = (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) )) in u)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) )))
(case <r = (((\x: Nat .\y: Bool .x) (if (( \f: Nat .((f (( \f: Unit .((f ({a = 0 , b = true , c =  1 }.b) ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = ({a = false , b = false }.b) , b = (if false then 0 else 1) }.a) ) ) (\a: Bool .\b: Nat .b)) then (unfold [ Unit ] (fold [ Rec X. X ] (let u = true in true) )) else ({a = (( \f: Unit .((f ({a = false , b = true }.b) ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = (((\x: Rec X. X .\y: Unit .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) ) false) }.b)) ) ({a = (pred 1) , b = (iszero 0) }.b)) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = ({a = ({a = 1 , b = true }.b) , b = (let u = 0 in u) }.b) , b = ({a = 0 , b = (((\x: Nat .\y: Nat .y) false ) false) }.a) }.b) in (( \f: Rec X. X .((f (( \f: Rec X. X .((f (succ 1) ) ({a = 1 , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (succ 0) }.c) ) ) (\a: Unit .\b: Nat .b)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) )) ) ) (\a: Bool .\b: Bool .a)))
({a = (let u = (if ({a = ({a = 0 , b = 0 }.b) , b = false }.b) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) else ({a = (((\x: Unit .\y: Bool .x) true ) true) , b = (((\x: Nat .\y: Unit .x) 0 ) false) }.a)) in (fix (\x: Unit . ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  (pred ({a = 0 , b = 0 }.b)) }.b) ))) , b = ({a = ({a = 1 , b = (if false then false else true) , c =  0 }.b) , b = (( \f: Bool .((f (iszero 0) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Unit .a)) }.b) }.b)
({a = (if (iszero ({a = 0 , b = 0 }.b)) then (case <l = (unfold [ Unit ] (fold [ Bool ] 1 )) > as Nat of < l = x > => x | < r = y > => y) else (fix (\x: Rec X. X . (case <l = (( \f: Rec X. X .((f ({a = false , b = 0 }.b) ) (((\x: Nat .\y: Nat .x) 0 ) true) ) ) (\a: Bool .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) ))) , b = ({a = (let u = ({a = true , b = 0 }.a) in true) , b = (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.a) }.b)
({a = (( \f: Nat .((f (let u = (((\x: Unit .\y: Unit .x) (pred 0) ) (let u = 0 in true)) in (let u = (((\x: Nat .\y: Bool .x) false ) false) in u)) ) ({a = (((\x: Bool .\y: Bool .y) false ) false) , b = (((\x: Bool .\y: Unit .y) (if false then false else false) ) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (let u = true in false) , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.c)) }.a) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = (let u = (((\x: Rec X. X .\y: Bool .x) (let u = 0 in false) ) (iszero 0)) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) ))) in ({a = false , b = (fix (\x: Nat . false )) }.b)) }.b)
(let u = (( \f: Rec X. X .((f (( \f: Nat .((f (succ (succ ({a = 1 , b = 1 }.b))) ) (let u = 0 in u) ) ) (\a: Nat .\b: Bool .b)) ) (fix (\x: Unit . (fix (\x: Unit . (if ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] false )) then (let u = true in 0) else 1) )) )) ) ) (\a: Nat .\b: Unit .a)) in (unfold [ Unit ] (fold [ Bool ] (case <l = (succ 0) > as Nat of < l = x > => x | < r = y > => y) )))
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (( \f: Bool .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = (((\x: Rec X. X .\y: Unit .y) false ) 0) }.b) )) , b = (let u = (( \f: Bool .((f (let u = true in u) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) in (( \f: Bool .((f (fix (\x: Bool . false )) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a))) , c =  (let u = (unfold [ Rec X. X ] (fold [ Nat ] (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) )) in ({a = (let u = (((\x: Bool .\y: Unit .y) true ) false) in 1) , b = ({a = 1 , b = true }.b) }.a)) }.b)
({a = ({a = (((\x: Unit .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) ({a = false , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) }.a)) , b = (fix (\x: Unit . (let u = 1 in 1) )) }.b) , b = (((\x: Bool .\y: Unit .x) (let u = ({a = false , b = false }.b) in u) ) (( \f: Unit .((f (iszero (let u = 0 in 0)) ) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 0 , b = true , c =  1 }.b) , c =  1 }.b) ) ) (\a: Nat .\b: Bool .a))) }.a)
({a = (succ ({a = ({a = false , b = false }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b)) , b = (let u = (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) in (fix (\x: Nat . (fix (\x: Nat . (let u = true in true) )) ))) , c =  (fix (\x: Bool . (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) )) ) (succ ({a = 1 , b = true , c = 0 }.c)) ) ) (\a: Unit .\b: Unit .a)) )) }.b)
(if (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.b) ) ({a = 1 , b = true , c =  0 }.b)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) )) ) ) (\a: Rec X. X .\b: Bool .a)) then (let u = ({a = (if false then 0 else 1) , b = false }.a) in (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a))) else (let u = (let u = (fix (\x: Unit . (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) in (( \f: Nat .((f (((\x: Unit .\y: Nat .x) false ) false) ) (((\x: Rec X. X .\y: Bool .y) true ) ({a = 1 , b = true }.b)) ) ) (\a: Unit .\b: Nat .a))) in u))
(((\x: Unit .\y: Unit .y) (( \f: Nat .((f ({a = ({a = 0 , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) , c =  ({a = 1 , b = 0 }.b) }.b) , b = (fix (\x: Nat . 1 )) }.a) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) false ) true) ) (fix (\x: Nat . true )) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Bool .b)) ) (unfold [ Unit ] (fold [ Nat ] (case <l = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) )))
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Bool .x) false ) true) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a))) )) , b = (((\x: Rec X. X .\y: Rec X. X .y) (case <r = (let u = true in (((\x: Rec X. X .\y: Bool .x) true ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (unfold [ Bool ] (fold [ Nat ] 0 )) in u)) }.b)
(let u = ({a = (let u = (if false then 0 else 1) in u) , b = (let u = (let u = false in 0) in u) }.b) in ({a = ({a = ({a = false , b = (succ 1) }.a) , b = (if (let u = 0 in true) then 0 else 1) }.b) , b = (let u = (let u = false in 0) in u) }.b))
({a = (let u = (pred (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )))) in (if (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) then ({a = 0 , b = 0 }.b) else (((\x: Bool .\y: Rec X. X .y) true ) 0))) , b = ({a = (case <r = (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (succ (fix (\x: Unit . (case <l = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) > as Unit of < l = x > => x | < r = y > => y) ))) }.b) }.b)
({a = (( \f: Rec X. X .((f (( \f: Unit .((f ({a = 0 , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) }.b) ) ({a = 1 , b = true }.a) ) ) (\a: Rec X. X .\b: Unit .a)) ) (( \f: Rec X. X .((f (succ ({a = 1 , b = true , c = 0 }.c)) ) (let u = 0 in u) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (if (fix (\x: Bool . ({a = ({a = 1 , b = true }.a) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) then ({a = (let u = (let u = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) in 1) in ({a = 0 , b = true }.a)) , b = (let u = false in (unfold [ Nat ] (fold [ Unit ] true ))) , c =  ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b)) , b = (let u = false in 1) }.b) }.b) else (let u = (let u = (fix (\x: Bool . 1 )) in u) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (iszero ({a = 0 , b = true }.a)) )))) }.b)
(((\x: Bool .\y: Bool .y) (unfold [ Unit ] (fold [ Nat ] (if (unfold [ Rec X. X ] (fold [ Bool ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) then (iszero (case <l = (((\x: Rec X. X .\y: Nat .y) false ) 1) > as Nat of < l = x > => x | < r = y > => y)) else (fix (\x: Bool . (let u = false in u) ))) )) ) (if ({a = (let u = (let u = 1 in true) in false) , b = (if (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) then (let u = 0 in true) else false) }.b) then (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = ({a = 1 , b = true , c =  1 }.b) in true) )) else (((\x: Rec X. X .\y: Bool .x) ({a = ({a = 1 , b = true , c = 0 }.c) , b = ({a = true , b = true }.b) }.b) ) (iszero ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.b)))))
(fix (\x: Unit . (iszero ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) 0 ) ) (\a: Nat .\b: Unit .a)) }.b)) ))
(( \f: Rec X. X .((f (( \f: Rec X. X .((f (case <l = (((\x: Bool .\y: Nat .x) 1 ) false) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) ) ) (\a: Bool .\b: Unit .b)) ) (((\x: Nat .\y: Nat .y) ({a = (fix (\x: Rec X. X . false )) , b = (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Unit .x) false ) true) ) (fix (\x: Bool . false ))) }.b) ) ({a = (if false then false else false) , b = (let u = true in 1) }.b)) ) ) (\a: Unit .\b: Rec X. X .a))
(let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Nat . (unfold [ Nat ] (fold [ Bool ] true )) )) )) in (let u = ({a = (fix (\x: Bool . 0 )) , b = ({a = true , b = ({a = 0 , b = false , c = 1 }.c) }.a) , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b) in u)) in u)
(if (case <r = (let u = (let u = false in 0) in (if false then false else true)) > as Unit of < l = x > => x | < r = y > => y) then (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) false ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a))) )) else (fix (\x: Bool . (unfold [ Nat ] (fold [ Rec X. X ] (let u = 1 in u) )) )))
(if (let u = (let u = (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in true) )) in (let u = 0 in (fix (\x: Nat . 0 )))) in (unfold [ Nat ] (fold [ Unit ] (let u = false in false) ))) then (unfold [ Bool ] (fold [ Bool ] (((\x: Unit .\y: Nat .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ({a = ({a = true , b = true }.b) , b = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] 0 )) ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Nat .b)) }.a)) )) else ({a = (((\x: Rec X. X .\y: Nat .x) ({a = false , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b))) , b = ({a = ({a = 1 , b = 0 }.b) , b = (unfold [ Rec X. X ] (fold [ Unit ] ({a = true , b = false }.b) )) , c =  ({a = true , b = 1 }.b) }.b) }.a))
(pred (case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) )) > as Unit of < l = x > => x | < r = y > => y))
(( \f: Bool .((f (iszero ({a = (let u = (let u = false in 0) in 0) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .a)) )) )) ) ) (\a: Nat .\b: Rec X. X .b))
(((\x: Nat .\y: Bool .x) (((\x: Nat .\y: Unit .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) in (if true then false else false)) )) ) (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in u)) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) )) ) (if false then false else ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true ))) ) ) (\a: Rec X. X .\b: Bool .a)))
(iszero (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) )) in (let u = ({a = 1 , b = false , c = 0 }.c) in ({a = 0 , b = true }.a))))
({a = (let u = (if (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) then true else (if true then false else true)) in (( \f: Unit .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ({a = true , b = (fix (\x: Bool . 0 )) }.b) ) ) (\a: Rec X. X .\b: Bool .a))) , b = (unfold [ Bool ] (fold [ Nat ] ({a = (succ 1) , b = ({a = 1 , b = true , c =  1 }.b) }.b) )) }.b)
(if (unfold [ Unit ] (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = (iszero (pred 0)) }.b) )) then ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = ({a = false , b = true }.b) , b = false }.b) )) else (let u = (unfold [ Bool ] (fold [ Nat ] (let u = 0 in true) )) in u))
({a = (let u = (let u = (if true then false else false) in u) in u) , b = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) }.a) ) (fix (\x: Bool . ({a = 0 , b = false }.a) ))) ) (fix (\x: Rec X. X . (( \f: Nat .((f (case <l = (((\x: Unit .\y: Rec X. X .x) 0 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) false ) 0) ) ) (\a: Unit .\b: Bool .a)) )) ) ) (\a: Rec X. X .\b: Bool .b)) }.b)
(((\x: Unit .\y: Nat .x) (case <l = (( \f: Bool .((f 1 ) (unfold [ Nat ] (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = 0 }.b) )) , b = (if true then false else true) }.b))
(((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f (if (let u = (let u = true in false) in true) then (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) else (let u = false in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) ) (fix (\x: Unit . ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) )) ) ) (\a: Bool .\b: Unit .a)) ) (( \f: Unit .((f (( \f: Unit .((f ({a = true , b = 1 }.b) ) (( \f: Nat .((f ({a = 0 , b = true , c = 1 }.c) ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .b)) ) (succ (pred 1)) ) ) (\a: Rec X. X .\b: Unit .a)))
(let u = (fix (\x: Rec X. X . (pred ({a = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = 0 }.b) , b = (case <r = (unfold [ Bool ] (fold [ Nat ] false )) > as Nat of < l = x > => x | < r = y > => y) , c = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.c)) )) in (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) )) in u))
(case <r = (( \f: Nat .((f (case <r = (let u = false in u) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (succ ({a = 0 , b = false , c = 0 }.c)) in (((\x: Rec X. X .\y: Bool .y) false ) true)) ) ) (\a: Nat .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y)
(case <r = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) ) (( \f: Bool .((f false ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Nat .y) (iszero (succ (((\x: Nat .\y: Unit .x) 0 ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)))) ) (((\x: Rec X. X .\y: Bool .y) (fix (\x: Nat . (((\x: Unit .\y: Bool .y) ({a = false , b = true }.b) ) false) )) ) ({a = (pred 1) , b = (fix (\x: Unit . (iszero 1) )) , c = (let u = (let u = 0 in u) in u) }.c)))
({a = (( \f: Unit .((f (succ (((\x: Bool .\y: Unit .y) ({a = 1 , b = true , c =  1 }.b) ) 1)) ) (fix (\x: Bool . (let u = (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) 0 ) ) (\a: Bool .\b: Nat .b)) in (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a))) )) ) ) (\a: Bool .\b: Bool .a)) , b = (unfold [ Unit ] (fold [ Unit ] (((\x: Bool .\y: Unit .y) (unfold [ Unit ] (fold [ Bool ] true )) ) (if false then false else false)) )) }.a)
(fix (\x: Nat . ({a = (if ({a = 1 , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .b)) , c =  0 }.b) then (( \f: Rec X. X .((f false ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Bool .a)) else (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b))) , b = (((\x: Nat .\y: Nat .x) (let u = false in u) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false ))) }.b) ))
(if (fix (\x: Nat . (let u = ({a = false , b = 1 }.a) in ({a = 1 , b = true }.b)) )) then (let u = ({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) }.b) , b = ({a = (let u = 0 in 0) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , c =  0 }.b) }.b) in (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = true }.a) ))) else (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = 0 , b = false , c = 0 }.c) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b) )) in ({a = ({a = (((\x: Nat .\y: Unit .x) 1 ) false) , b = true , c =  0 }.b) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 1 in 0) )) }.b)))
(case <r = (let u = (let u = (( \f: Nat .((f ({a = 1 , b = true , c =  1 }.b) ) false ) ) (\a: Unit .\b: Rec X. X .a)) in u) in u) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (case <l = (succ (let u = (((\x: Unit .\y: Unit .y) true ) true) in 1)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . ({a = (if (let u = false in true) then false else true) , b = ({a = 0 , b = true , c =  0 }.b) }.b) )) , c = (pred (pred ({a = true , b = ({a = 0 , b = 1 }.b) }.b))) }.c)
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Bool . ({a = (let u = 0 in true) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) }.b) )) ))
(( \f: Unit .((f (let u = (fix (\x: Nat . (if true then (pred 1) else ({a = 1 , b = 0 }.b)) )) in ({a = (let u = (fix (\x: Nat . true )) in (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) , b = ({a = 0 , b = false }.b) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if true then 0 else 0) )) }.b)) ) (( \f: Rec X. X .((f (let u = false in u) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = false in true) )) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .b))
({a = (let u = (let u = (if false then (unfold [ Unit ] (fold [ Rec X. X ] true )) else (let u = true in u)) in (succ (if false then 1 else 0))) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) false ) false) ))) , b = (let u = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .b)) }.a) in (((\x: Nat .\y: Rec X. X .x) (let u = false in true) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .b)))) }.b)
(case <r = ({a = ({a = ({a = 0 , b = true , c =  0 }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) }.b) , b = (((\x: Bool .\y: Rec X. X .y) (let u = true in true) ) true) , c =  (case <l = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = (if (((\x: Nat .\y: Rec X. X .x) (let u = 0 in true) ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a))) then (fix (\x: Nat . (( \f: Bool .((f 1 ) ({a = 0 , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .b)) )) else (succ (((\x: Rec X. X .\y: Nat .x) 1 ) true))) , b = (((\x: Bool .\y: Bool .y) ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) , b = (let u = 0 in 0) }.a) ) (unfold [ Bool ] (fold [ Unit ] (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) ))) }.b)
(unfold [ Rec X. X ] (fold [ Nat ] (let u = ({a = ({a = ({a = 0 , b = true , c =  0 }.b) , b = ({a = 1 , b = 0 }.b) }.a) , b = (let u = (let u = (let u = false in 0) in u) in (let u = true in true)) }.b) in u) ))
(let u = (if (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Nat ] true )) )) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (if (iszero 0) then (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) else 1) )) else ({a = (let u = 0 in u) , b = (fix (\x: Nat . true )) }.a)) in (( \f: Nat .((f (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Bool .x) 1 ) false) ) ({a = 1 , b = false , c =  1 }.b)) ) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (fix (\x: Bool . false )) }.a) ) ) (\a: Unit .\b: Rec X. X .a)))
(pred ({a = ({a = ({a = 1 , b = 0 }.b) , b = (((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Nat .y) false ) false) ) ({a = 0 , b = 0 }.b)) }.b) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] true )) , b = (((\x: Nat .\y: Bool .x) 1 ) true) }.b) }.b))
(let u = ({a = (fix (\x: Unit . (( \f: Nat .((f false ) ({a = false , b = true }.b) ) ) (\a: Unit .\b: Unit .a)) )) , b = ({a = ({a = false , b = 1 }.b) , b = (((\x: Unit .\y: Nat .x) true ) (fix (\x: Bool . true ))) , c = (fix (\x: Rec X. X . 1 )) }.c) }.a) in (( \f: Rec X. X .((f (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = false in u) )) in u) ) ({a = (let u = false in u) , b = (pred 0) }.a) ) ) (\a: Bool .\b: Rec X. X .a)))
({a = (if (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .x) false ) (iszero 1)) )) then (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ))) else ({a = ({a = 0 , b = 0 }.b) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.a)) , b = (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f ({a = (let u = true in 0) , b = false , c =  1 }.b) ) ({a = (fix (\x: Bool . false )) , b = ({a = 0 , b = true , c =  1 }.b) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <r = (case <r = (let u = true in true) > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)) }.a)
(unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f (((\x: Nat .\y: Unit .x) ({a = 0 , b = true }.a) ) ({a = 1 , b = ({a = true , b = 0 }.a) }.b)) ) (fix (\x: Nat . ({a = (if true then false else true) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) ) ) (\a: Rec X. X .\b: Bool .a)) ))
(if ({a = (case <r = (let u = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) in (( \f: Nat .((f (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Nat .a))) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ({a = (((\x: Nat .\y: Unit .y) false ) false) , b = 0 }.b) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (fix (\x: Nat . 0 )) }.b) }.b) then (unfold [ Unit ] (fold [ Unit ] (unfold [ Nat ] (fold [ Bool ] ({a = true , b = true }.b) )) )) else ({a = (pred (if true then 1 else 1)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = true , c =  0 }.b) )) , c =  (let u = ({a = false , b = 0 }.b) in u) }.b))
({a = ({a = (((\x: Unit .\y: Nat .y) ({a = 1 , b = true }.b) ) (let u = 0 in u)) , b = (let u = ({a = false , b = ({a = 1 , b = false }.b) }.b) in ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.b)) }.b) , b = (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) ({a = (if true then 0 else 1) , b = (iszero 1) }.b) ) ) (\a: Bool .\b: Unit .b)) ) (let u = (case <r = ({a = 0 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) in u)) }.b)
(succ ({a = (let u = (pred ({a = (fix (\x: Rec X. X . 1 )) , b = (succ 0) }.b)) in (let u = ({a = 1 , b = 0 }.b) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )))) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = false , c = (let u = 0 in u) }.c) )) }.b))
(succ ({a = ({a = (((\x: Rec X. X .\y: Nat .y) (((\x: Nat .\y: Unit .y) false ) true) ) 0) , b = (((\x: Nat .\y: Rec X. X .y) false ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) }.a) , b = (( \f: Nat .((f (let u = false in true) ) false ) ) (\a: Unit .\b: Bool .a)) , c = ({a = (let u = ({a = false , b = 1 }.a) in 1) , b = ({a = 1 , b = (((\x: Rec X. X .\y: Unit .y) false ) true) }.b) , c = ({a = 0 , b = (let u = 1 in false) , c = 1 }.c) }.c) }.c))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Bool . 0 )) )) , b = (( \f: Unit .((f (fix (\x: Nat . true )) ) (let u = false in u) ) ) (\a: Nat .\b: Nat .a)) }.b) ))
({a = (pred (( \f: Nat .((f (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 1) > as Nat of < l = x > => x | < r = y > => y) ) (let u = false in 1) ) ) (\a: Nat .\b: Rec X. X .a))) , b = ({a = ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = (let u = false in (let u = true in false)) , c =  ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) 1 ) true) )) }.b) , b = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = ({a = 0 , b = true , c =  1 }.b) }.a) }.a) , c = (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) true) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) (let u = 1 in false)) )) ) ) (\a: Rec X. X .\b: Unit .b)) }.c)
({a = (case <l = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Nat .\y: Bool .y) (let u = 1 in true) ) (iszero 0)) in (if (if false then false else true) then (iszero 1) else (unfold [ Bool ] (fold [ Bool ] true )))) }.a)
({a = (pred (let u = 0 in u)) , b = (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = (((\x: Nat .\y: Bool .x) 1 ) false) , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , c = 0 }.c) , b = (let u = false in u) , c =  (((\x: Bool .\y: Unit .y) false ) 0) }.b) ) (((\x: Nat .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) (fix (\x: Rec X. X . true )))) ) ({a = ({a = 1 , b = (((\x: Nat .\y: Bool .y) true ) false) }.a) , b = ({a = (let u = 1 in false) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.a) }.b)) , c = (succ (let u = true in (let u = 0 in u))) }.c)
({a = (case <r = (( \f: Rec X. X .((f (if (if false then false else true) then true else false) ) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Rec X. X .y) (( \f: Unit .((f (((\x: Nat .\y: Nat .y) false ) true) ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f ({a = 1 , b = 0 }.b) ) 1 ) ) (\a: Nat .\b: Nat .a))) }.b)
(case <r = ({a = ({a = ({a = false , b = 0 }.b) , b = (let u = 1 in true) }.b) , b = (((\x: Rec X. X .\y: Unit .x) 0 ) true) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f false ) (let u = 0 in false) ) ) (\a: Nat .\b: Bool .a)) ) (fix (\x: Unit . ({a = 1 , b = false }.b) ))) ) (fix (\x: Bool . (let u = 1 in true) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = (iszero (((\x: Unit .\y: Bool .y) true ) 0)) , b = (( \f: Unit .((f (case <r = (let u = (succ 1) in true) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) false) ) ) (\a: Rec X. X .\b: Unit .a)) }.b))
(( \f: Rec X. X .((f ({a = (((\x: Bool .\y: Nat .x) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . true ))) , b = (((\x: Nat .\y: Nat .y) (if (fix (\x: Nat . true )) then ({a = 1 , b = (if true then false else true) , c =  1 }.b) else (let u = 0 in true)) ) (if (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) then ({a = false , b = true }.b) else (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .a)))) }.a) ) (( \f: Rec X. X .((f (pred 0) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) )) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (case <l = (if (let u = false in (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b))) then (unfold [ Nat ] (fold [ Bool ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) else (((\x: Rec X. X .\y: Rec X. X .x) ({a = (succ 0) , b = 1 }.b) ) (let u = 0 in true))) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] 1 )) )) }.b)
(((\x: Unit .\y: Bool .y) ({a = (((\x: Bool .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .x) (if true then true else false) ) (fix (\x: Unit . true ))) ) (case <r = (((\x: Unit .\y: Unit .y) false ) true) > as Unit of < l = x > => x | < r = y > => y)) , b = (((\x: Nat .\y: Bool .x) (let u = 0 in (((\x: Bool .\y: Unit .x) true ) true)) ) (let u = (let u = false in 1) in ({a = true , b = 1 }.a))) }.b) ) (let u = (let u = ({a = true , b = (pred 1) }.a) in u) in ({a = 0 , b = ({a = 0 , b = 1 }.b) }.b)))
(let u = ({a = (((\x: Unit .\y: Rec X. X .x) (if ({a = 1 , b = false }.b) then true else (if true then true else false)) ) (unfold [ Bool ] (fold [ Rec X. X ] true ))) , b = (if (let u = true in u) then (case <r = ({a = 0 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) else (((\x: Rec X. X .\y: Nat .x) true ) false)) }.b) in (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = true , c =  0 }.b) ) (let u = 0 in true)))
(let u = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) 1 ) false) )) ) ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = 0 in u) }.b) ) ) (\a: Bool .\b: Bool .a)) in (if (let u = ({a = (succ 0) , b = false , c =  0 }.b) in u) then ({a = (succ (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a))) , b = (let u = ({a = 1 , b = true , c =  1 }.b) in ({a = false , b = true }.b)) , c =  ({a = (let u = false in 1) , b = ({a = 0 , b = true , c = 0 }.c) }.b) }.b) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = (let u = 1 in u) , b = ({a = 0 , b = true , c =  1 }.b) , c =  0 }.b) ))))
(((\x: Nat .\y: Nat .y) (unfold [ Unit ] (fold [ Rec X. X ] ({a = (case <l = ({a = true , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . false )) , c =  (((\x: Bool .\y: Nat .x) 1 ) true) }.b) )) ) (iszero ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = true in 0) ))))
(case <l = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Unit .x) ({a = 1 , b = true , c = 1 }.c) ) false) , b = ({a = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) in ({a = 1 , b = false }.a)) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Unit .((f ({a = (( \f: Bool .((f ({a = ({a = true , b = 0 }.a) , b = true }.b) ) (iszero 0) ) ) (\a: Unit .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Nat .x) (unfold [ Unit ] (fold [ Unit ] 0 )) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b))) }.a) ) (( \f: Unit .((f ({a = ({a = (let u = false in 0) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , c = 0 }.c) , b = ({a = (unfold [ Unit ] (fold [ Bool ] true )) , b = (let u = 0 in u) }.a) , c =  (succ 0) }.b) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(iszero (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = true , c = 0 }.c) )) in u))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) ({a = (unfold [ Nat ] (fold [ Unit ] true )) , b = ({a = 1 , b = false , c =  0 }.b) }.b) ) (( \f: Nat .((f (((\x: Unit .\y: Unit .x) ({a = true , b = 1 }.a) ) (let u = true in true)) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) in (let u = 0 in false)) ) ) (\a: Nat .\b: Bool .a))) ) (let u = (if ({a = (iszero 1) , b = true }.b) then (let u = ({a = false , b = 1 }.b) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 ))) else (pred (if true then 0 else 1))) in (( \f: Bool .((f (((\x: Nat .\y: Unit .y) (if false then true else true) ) true) ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Rec X. X .\b: Bool .b))
(let u = (let u = (((\x: Unit .\y: Unit .x) (((\x: Unit .\y: Nat .x) 1 ) false) ) (let u = (fix (\x: Nat . false )) in u)) in u) in u)
(((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Nat .x) (let u = false in false) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false ))) ) ({a = (((\x: Nat .\y: Unit .x) 1 ) false) , b = (let u = false in 0) }.b)) ) (case <r = ({a = (let u = true in u) , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y))
(let u = (iszero (((\x: Unit .\y: Nat .x) (let u = 0 in u) ) (( \f: Nat .((f ({a = false , b = 1 }.a) ) (((\x: Nat .\y: Rec X. X .x) true ) false) ) ) (\a: Bool .\b: Unit .a)))) in u)
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) (( \f: Bool .((f (fix (\x: Rec X. X . (let u = 1 in u) )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = false in 1) )) ) ) (\a: Nat .\b: Bool .a)) ) ({a = (let u = (unfold [ Bool ] (fold [ Nat ] 1 )) in u) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = true , c =  0 }.b) )) , c =  ({a = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) )) , b = (let u = 1 in (fix (\x: Bool . true ))) , c = (unfold [ Unit ] (fold [ Bool ] 1 )) }.c) }.b)) ))
(if ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (if true then false else true) )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) )) }.b) then (if (unfold [ Nat ] (fold [ Nat ] (if false then false else false) )) then (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Rec X. X .x) 1 ) false) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = false }.b) ) (let u = true in u))) else (((\x: Bool .\y: Nat .x) (let u = true in 0) ) false)) else ({a = (fix (\x: Nat . 1 )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) )) , c = ({a = (fix (\x: Unit . 0 )) , b = (let u = 0 in true) , c = (pred 0) }.c) }.c))
({a = (succ (( \f: Nat .((f (let u = 1 in 0) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Bool .b))) , b = (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = false , b = false }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (( \f: Rec X. X .((f (( \f: Bool .((f (pred 1) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ) (case <l = (pred (pred 1)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) }.b)
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Unit . (( \f: Bool .((f ({a = 1 , b = false }.b) ) (((\x: Bool .\y: Unit .y) false ) false) ) ) (\a: Unit .\b: Rec X. X .a)) )) ))
(let u = (let u = (let u = (let u = 0 in false) in u) in (let u = (((\x: Bool .\y: Rec X. X .y) false ) 1) in u)) in ({a = ({a = (((\x: Nat .\y: Unit .x) 0 ) true) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.b) , b = ({a = (let u = true in u) , b = (( \f: Unit .((f (let u = true in 1) ) (((\x: Bool .\y: Rec X. X .x) 0 ) false) ) ) (\a: Rec X. X .\b: Bool .a)) }.a) }.b))
(case <l = (case <l = (case <l = (fix (\x: Bool . 0 )) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
(fix (\x: Unit . (((\x: Rec X. X .\y: Nat .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.a) )) ) (let u = (case <r = (if false then false else false) > as Unit of < l = x > => x | < r = y > => y) in u)) ))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] (fix (\x: Unit . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) )) ))
(if ({a = (((\x: Bool .\y: Nat .y) (let u = false in u) ) (let u = true in 1)) , b = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) in (( \f: Nat .((f (let u = true in false) ) true ) ) (\a: Bool .\b: Unit .b))) , c =  (if true then 1 else 0) }.b) then (unfold [ Nat ] (fold [ Bool ] (let u = (((\x: Nat .\y: Unit .x) (if true then 1 else 1) ) (fix (\x: Rec X. X . true ))) in (((\x: Nat .\y: Nat .x) (unfold [ Nat ] (fold [ Unit ] 0 )) ) (((\x: Rec X. X .\y: Rec X. X .x) false ) false))) )) else (case <l = (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) 0 ) false) ) 1 ) ) (\a: Unit .\b: Unit .b)) in u) > as Unit of < l = x > => x | < r = y > => y))
({a = ({a = (pred (fix (\x: Rec X. X . ({a = 1 , b = true }.a) ))) , b = ({a = (iszero (let u = 0 in u)) , b = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.b) }.b) , b = (iszero ({a = (( \f: Nat .((f ({a = 0 , b = false , c = 1 }.c) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (unfold [ Unit ] (fold [ Unit ] ({a = true , b = 0 }.a) )) , c = (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) )) }.c)) }.a)
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) true) , b = (if true then 0 else 0) }.a) in u) ) ({a = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) , b = (let u = (let u = false in (pred 1)) in (let u = true in u)) }.b)) ))
({a = (( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .y) (iszero 1) ) (let u = true in 0)) ) (unfold [ Unit ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Unit ] 1 )) )) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (if false then (iszero 0) else (if false then true else true)) )) )) }.b)
(let u = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (fix (\x: Nat . (fix (\x: Rec X. X . true )) )) }.b) in (( \f: Rec X. X .((f ({a = (((\x: Rec X. X .\y: Rec X. X .x) (if false then false else (let u = 0 in true)) ) ({a = (succ 0) , b = ({a = true , b = 0 }.a) , c =  0 }.b)) , b = (if (fix (\x: Nat . false )) then (( \f: Bool .((f 0 ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Bool .\b: Bool .a)) else (let u = 0 in u)) }.b) ) (succ (( \f: Unit .((f (succ 1) ) (pred 0) ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Bool .\b: Nat .b)))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) (if false then true else false) ) (if (((\x: Bool .\y: Unit .y) false ) false) then true else (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)))) )) in u)
(fix (\x: Unit . ({a = ({a = (((\x: Rec X. X .\y: Bool .x) ({a = false , b = 1 }.b) ) true) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) }.a) , b = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .a)) }.b) ))
({a = ({a = (fix (\x: Unit . (unfold [ Nat ] (fold [ Rec X. X ] 0 )) )) , b = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = (unfold [ Unit ] (fold [ Bool ] false )) }.b) , c = (let u = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) in (unfold [ Rec X. X ] (fold [ Unit ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ))) }.c) , b = (let u = (let u = (let u = (let u = 0 in u) in (fix (\x: Bool . 1 ))) in u) in (((\x: Unit .\y: Nat .x) (iszero 0) ) (((\x: Unit .\y: Rec X. X .y) ({a = false , b = true }.b) ) false))) }.a)
(fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (if (let u = false in u) then (if true then 0 else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) else ({a = 0 , b = false , c = (let u = false in 0) }.c)) )) ))
(pred (if (let u = ({a = 1 , b = false }.b) in ({a = 0 , b = (unfold [ Nat ] (fold [ Bool ] false )) , c =  0 }.b)) then (if (( \f: Unit .((f (((\x: Bool .\y: Bool .y) true ) false) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Bool .a)) then (let u = ({a = 0 , b = true , c = 0 }.c) in u) else (pred 0)) else (( \f: Rec X. X .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b))))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Nat . (if (if (let u = true in u) then true else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) then (((\x: Unit .\y: Rec X. X .x) (((\x: Unit .\y: Unit .x) 0 ) true) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) true)) else (succ 1)) )) ))
(let u = (( \f: Unit .((f (unfold [ Unit ] (fold [ Unit ] ({a = false , b = false }.b) )) ) (if (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = false }.b) )) then (((\x: Unit .\y: Nat .y) true ) true) else ({a = true , b = 1 }.a)) ) ) (\a: Unit .\b: Unit .b)) in (fix (\x: Unit . ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in false) ) 0) }.a) )))
(pred (let u = ({a = true , b = 1 }.a) in (succ (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true))))
(((\x: Nat .\y: Bool .y) ({a = ({a = (pred (fix (\x: Unit . 0 ))) , b = ({a = ({a = true , b = 1 }.a) , b = 1 }.a) , c =  (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) }.b) , b = (fix (\x: Unit . ({a = 0 , b = 0 }.b) )) }.a) ) (let u = (let u = (( \f: Bool .((f ({a = false , b = 0 }.a) ) (let u = 1 in false) ) ) (\a: Bool .\b: Rec X. X .b)) in (( \f: Rec X. X .((f ({a = true , b = true }.b) ) false ) ) (\a: Nat .\b: Unit .a))) in ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (iszero ({a = ({a = 1 , b = false , c = 0 }.c) , b = (if false then false else false) , c = 1 }.c)) , c = (let u = (succ (((\x: Rec X. X .\y: Bool .x) 1 ) true)) in u) }.c)))
(let u = (((\x: Bool .\y: Unit .x) ({a = (succ 0) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) ))) in ({a = (if (((\x: Bool .\y: Nat .y) false ) true) then ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = 1 }.b) else ({a = 1 , b = true , c = 0 }.c)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Unit . false )) )) , c = ({a = (fix (\x: Nat . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) , b = (((\x: Nat .\y: Rec X. X .y) true ) 1) }.b) }.c))
(if ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = false in 1) )) , b = ({a = (if (( \f: Unit .((f ({a = 0 , b = false , c =  1 }.b) ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Bool .b)) then (let u = (let u = true in u) in false) else (((\x: Rec X. X .\y: Unit .y) true ) false)) , b = ({a = (let u = false in u) , b = false }.b) }.b) }.b) then (let u = (((\x: Rec X. X .\y: Bool .x) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = false , b = 0 }.a) }.b) ) (((\x: Bool .\y: Nat .y) ({a = true , b = true }.b) ) (unfold [ Unit ] (fold [ Bool ] true )))) in u) else (let u = (( \f: Bool .((f ({a = (succ ({a = false , b = 0 }.b)) , b = (let u = false in false) , c = (if false then 0 else 0) }.c) ) (fix (\x: Nat . (fix (\x: Rec X. X . 0 )) )) ) ) (\a: Rec X. X .\b: Bool .b)) in ({a = ({a = true , b = 1 }.b) , b = ({a = false , b = false }.b) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.b)))
(let u = (let u = (let u = ({a = true , b = 1 }.a) in u) in ({a = (case <l = ({a = true , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (( \f: Bool .((f (fix (\x: Unit . false )) ) true ) ) (\a: Nat .\b: Bool .b)) ) ({a = true , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.a) ) ) (\a: Unit .\b: Nat .a)) , c =  (( \f: Unit .((f ({a = 0 , b = false , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.c) ) (unfold [ Bool ] (fold [ Bool ] 1 )) ) ) (\a: Nat .\b: Rec X. X .a)) }.b)) in u)
(if ({a = (unfold [ Unit ] (fold [ Bool ] (if false then true else true) )) , b = (( \f: Bool .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .y) false ) 0) ) ) (\a: Unit .\b: Bool .a)) }.a) then ({a = (((\x: Unit .\y: Bool .x) ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Rec X. X .\y: Nat .x) 0 ) ({a = 0 , b = false }.b)) }.b) ) (if (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) then ({a = false , b = false }.b) else (((\x: Rec X. X .\y: Nat .y) false ) false))) , b = (( \f: Bool .((f (iszero 0) ) (iszero (let u = 1 in 1)) ) ) (\a: Nat .\b: Nat .a)) , c =  (let u = (succ (if true then 1 else 1)) in u) }.b) else (( \f: Bool .((f (let u = ({a = false , b = 1 }.a) in u) ) (fix (\x: Bool . (let u = true in u) )) ) ) (\a: Nat .\b: Unit .a)))
(((\x: Bool .\y: Unit .y) (let u = (fix (\x: Nat . ({a = true , b = 1 }.b) )) in (let u = (((\x: Nat .\y: Nat .y) false ) false) in u)) ) (( \f: Bool .((f ({a = (((\x: Nat .\y: Nat .x) (let u = 0 in false) ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .a))) , b = ({a = false , b = 0 }.b) }.a) ) (((\x: Rec X. X .\y: Nat .y) (fix (\x: Bool . false )) ) ({a = true , b = 1 }.a)) ) ) (\a: Bool .\b: Nat .a)))
(fix (\x: Rec X. X . (let u = ({a = (((\x: Bool .\y: Bool .y) false ) 1) , b = ({a = 0 , b = true , c = 1 }.c) }.b) in (((\x: Nat .\y: Rec X. X .y) false ) false)) ))
(let u = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) (((\x: Rec X. X .\y: Nat .y) (let u = 1 in false) ) ({a = 1 , b = false , c =  1 }.b)) ) ) (\a: Nat .\b: Bool .b)) in (pred (fix (\x: Unit . ({a = 0 , b = 0 }.b) ))))
(( \f: Unit .((f (( \f: Rec X. X .((f ({a = (pred 1) , b = ({a = false , b = true }.b) }.b) ) (let u = ({a = false , b = 1 }.a) in u) ) ) (\a: Rec X. X .\b: Unit .a)) ) (if (let u = (fix (\x: Bool . true )) in u) then (unfold [ Nat ] (fold [ Rec X. X ] (if false then true else ({a = 0 , b = true , c =  0 }.b)) )) else (fix (\x: Nat . (let u = (((\x: Bool .\y: Rec X. X .y) false ) false) in true) ))) ) ) (\a: Bool .\b: Rec X. X .a))
({a = (((\x: Rec X. X .\y: Unit .y) ({a = (((\x: Unit .\y: Nat .x) false ) true) , b = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) ) ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Nat .((f false ) (let u = 1 in true) ) ) (\a: Nat .\b: Bool .a)) in (let u = true in 0)) }.b)) , b = ({a = (( \f: Bool .((f (( \f: Nat .((f true ) ({a = true , b = false }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = (if ({a = true , b = 0 }.a) then 0 else 0) , b = (let u = true in true) , c =  (((\x: Bool .\y: Rec X. X .x) 0 ) false) }.b) ) ) (\a: Nat .\b: Nat .b)) , b = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Nat .a)) }.a) }.b)
(( \f: Unit .((f (let u = ({a = ({a = ({a = 1 , b = false }.a) , b = (if false then true else true) }.b) , b = (((\x: Unit .\y: Unit .y) ({a = 0 , b = true }.b) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b))) }.a) in (let u = ({a = (succ 0) , b = (((\x: Unit .\y: Unit .x) 1 ) false) }.b) in (if (iszero 1) then (iszero 0) else ({a = false , b = true }.b)))) ) (iszero (pred (((\x: Unit .\y: Nat .x) ({a = 1 , b = 0 }.b) ) ({a = 1 , b = false }.b)))) ) ) (\a: Nat .\b: Bool .a))
(let u = (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Bool ] false )) ) false) ) ({a = (((\x: Unit .\y: Bool .y) true ) true) , b = ({a = true , b = 1 }.a) }.b)) ) (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Nat .x) (fix (\x: Nat . false )) ) (fix (\x: Nat . true ))) ) (iszero (if ({a = true , b = false }.b) then (pred 0) else 0))) ) ) (\a: Nat .\b: Rec X. X .b)) in u)
(((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Unit . true )) )) ) (((\x: Bool .\y: Bool .x) ({a = ({a = true , b = true }.b) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) }.b) ) (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) in u)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (pred (if (let u = true in ({a = false , b = true }.b)) then (let u = 0 in u) else (let u = (if false then 1 else 1) in u))))
({a = ({a = (( \f: Rec X. X .((f ({a = 1 , b = true , c = 0 }.c) ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = (let u = false in true) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in 0) )) }.b) , b = ({a = ({a = (let u = true in (unfold [ Bool ] (fold [ Nat ] true ))) , b = ({a = (let u = true in (((\x: Bool .\y: Nat .x) 0 ) false)) , b = ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) false ) true) , c =  (pred 0) }.b) , c =  (let u = false in 1) }.b) }.b) , b = (let u = (( \f: Bool .((f ({a = ({a = false , b = false }.b) , b = ({a = false , b = true }.b) }.b) ) ({a = 0 , b = ({a = false , b = 1 }.a) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) in (case <l = (let u = 0 in u) > as Nat of < l = x > => x | < r = y > => y)) }.b) }.b)
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) in u) )) , b = (((\x: Unit .\y: Rec X. X .y) (case <r = (fix (\x: Unit . true )) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = 1 , b = true , c =  0 }.b) in (pred 0)) }.b)) }.a)
(let u = (((\x: Bool .\y: Unit .x) (if (unfold [ Unit ] (fold [ Unit ] false )) then 0 else 1) ) (let u = false in u)) in u)
({a = (let u = (succ ({a = (fix (\x: Rec X. X . false )) , b = 0 }.b)) in (case <l = (((\x: Unit .\y: Unit .y) true ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 ))) > as Unit of < l = x > => x | < r = y > => y)) , b = (( \f: Rec X. X .((f ({a = (let u = 0 in u) , b = ({a = true , b = 0 }.a) }.b) ) (if ({a = 0 , b = false , c =  0 }.b) then (if false then false else false) else (((\x: Bool .\y: Rec X. X .y) false ) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)))) ) ) (\a: Unit .\b: Nat .a)) , c =  (( \f: Rec X. X .((f (pred (let u = 0 in 0)) ) (let u = (((\x: Bool .\y: Unit .y) ({a = false , b = 0 }.a) ) (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = true , c =  0 }.b) ) 0)) in u) ) ) (\a: Bool .\b: Nat .b)) }.b)
(let u = (case <l = (succ 0) > as Bool of < l = x > => x | < r = y > => y) in (iszero (let u = (let u = true in 1) in (((\x: Rec X. X .\y: Nat .x) 0 ) true))))
(let u = (( \f: Nat .((f (unfold [ Bool ] (fold [ Bool ] (fix (\x: Unit . 1 )) )) ) (pred (succ ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )))) ) ) (\a: Unit .\b: Bool .b)) in (unfold [ Bool ] (fold [ Bool ] ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) )) )))
({a = ({a = (succ (fix (\x: Nat . 0 ))) , b = (fix (\x: Rec X. X . (let u = (let u = false in false) in u) )) , c = ({a = (if true then true else true) , b = (((\x: Rec X. X .\y: Unit .y) false ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a))) }.b) }.c) , b = (let u = (( \f: Rec X. X .((f (if true then true else false) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Nat .a)) in (( \f: Unit .((f (fix (\x: Bool . true )) ) (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = 0 in true)) ) ) (\a: Unit .\b: Nat .b))) , c = (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = true , c = 0 }.c) )) ) (if ({a = 0 , b = false , c =  0 }.b) then 0 else (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a))) ) ) (\a: Bool .\b: Nat .a)) }.c)
({a = (((\x: Nat .\y: Bool .x) (((\x: Bool .\y: Nat .y) (let u = (((\x: Bool .\y: Bool .y) false ) true) in (let u = false in u)) ) (iszero 1)) ) (( \f: Bool .((f ({a = 0 , b = false }.b) ) (let u = true in true) ) ) (\a: Bool .\b: Unit .a))) , b = ({a = (pred 0) , b = (let u = 0 in true) }.a) }.b)
(let u = (let u = (((\x: Bool .\y: Unit .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) (let u = 1 in true)) in (((\x: Bool .\y: Nat .y) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = ({a = 1 , b = 0 }.b) }.a) ) (let u = ({a = 0 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) in u))) in (unfold [ Nat ] (fold [ Unit ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f true ) (((\x: Unit .\y: Nat .y) true ) true) ) ) (\a: Unit .\b: Bool .b)) )) )))
(case <r = ({a = ({a = ({a = (unfold [ Unit ] (fold [ Unit ] 1 )) , b = ({a = 0 , b = true , c =  0 }.b) }.b) , b = (case <l = (((\x: Unit .\y: Bool .y) false ) 1) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (((\x: Unit .\y: Unit .y) (let u = true in u) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .b))) }.b) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Bool .y) (unfold [ Bool ] (fold [ Unit ] (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then true else (((\x: Bool .\y: Unit .x) false ) false)) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (if ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) then (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) else ({a = 0 , b = 1 }.b)) )))
({a = (if (if (let u = true in true) then (let u = true in u) else (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .a))) then (case <l = ({a = ({a = false , b = 0 }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b) > as Nat of < l = x > => x | < r = y > => y) else ({a = (if true then 1 else 0) , b = 1 }.b)) , b = (let u = (( \f: Unit .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) ) (\a: Rec X. X .\b: Bool .a)) in (( \f: Bool .((f 1 ) ({a = true , b = 0 }.b) ) ) (\a: Rec X. X .\b: Bool .b))) }.b)
({a = (case <l = (fix (\x: Rec X. X . 1 )) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (let u = ({a = 1 , b = false , c = 0 }.c) in (( \f: Nat .((f ({a = 1 , b = false , c =  0 }.b) ) (let u = false in true) ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Unit .\b: Bool .a)) , c =  ({a = (let u = (( \f: Unit .((f (unfold [ Nat ] (fold [ Bool ] false )) ) (((\x: Unit .\y: Bool .y) true ) true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) ) (unfold [ Nat ] (fold [ Bool ] true ))) , c = (if (( \f: Rec X. X .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) ) false ) ) (\a: Nat .\b: Bool .b)) then (((\x: Unit .\y: Unit .x) ({a = 1 , b = (if false then true else false) , c = 1 }.c) ) (iszero 1)) else (let u = ({a = 1 , b = 0 }.b) in 0)) }.c) }.b)
(iszero (succ (case <l = (fix (\x: Nat . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y)))
({a = (let u = (case <l = (succ (if true then 1 else 1)) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Unit .((f false ) ({a = false , b = false }.b) ) ) (\a: Nat .\b: Bool .b)))) , b = (iszero (let u = (let u = false in 0) in u)) }.b)
(((\x: Unit .\y: Rec X. X .y) ({a = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .y) false ) false) )) , b = (fix (\x: Bool . (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) }.b) ) (((\x: Nat .\y: Rec X. X .x) (iszero (fix (\x: Unit . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))) ) (( \f: Bool .((f (let u = true in u) ) true ) ) (\a: Rec X. X .\b: Bool .a))))
(fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) (( \f: Nat .((f false ) (unfold [ Bool ] (fold [ Bool ] true )) ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Unit .\y: Bool .x) false ) false)) )) ))
(((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Bool . ({a = (let u = ({a = 1 , b = false }.b) in (unfold [ Rec X. X ] (fold [ Unit ] true ))) , b = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Rec X. X . (fix (\x: Nat . false )) )) ) (unfold [ Unit ] (fold [ Unit ] 0 ))) }.a) )) ) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .y) true ) 0) )) in (pred (( \f: Bool .((f (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in 1) ) (unfold [ Nat ] (fold [ Unit ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Nat .\b: Nat .b)))))
(let u = (case <r = (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) )) > as Unit of < l = x > => x | < r = y > => y) in ({a = ({a = 1 , b = ({a = 0 , b = false }.b) }.a) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f true ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Bool .a)) )) , c = (let u = (if true then true else false) in 1) }.c))
({a = ({a = (((\x: Unit .\y: Unit .x) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (let u = 1 in true) , b = true }.b)) , b = (((\x: Unit .\y: Nat .x) (let u = true in true) ) (((\x: Unit .\y: Unit .y) true ) true)) }.b) , b = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false )) )) ) (((\x: Bool .\y: Bool .x) (let u = true in u) ) true) ) ) (\a: Unit .\b: Unit .a)) }.b)
({a = (((\x: Bool .\y: Bool .x) (if true then (if false then 0 else 1) else 0) ) ({a = (let u = (fix (\x: Rec X. X . true )) in u) , b = (( \f: Bool .((f 1 ) ({a = 1 , b = false , c = 1 }.c) ) ) (\a: Nat .\b: Rec X. X .b)) }.a)) , b = ({a = (((\x: Unit .\y: Nat .x) 1 ) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b))) , b = (((\x: Nat .\y: Nat .y) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) ) (((\x: Rec X. X .\y: Unit .x) true ) false)) }.b) }.a)
(( \f: Nat .((f (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Nat .y) (((\x: Rec X. X .\y: Bool .x) true ) true) ) ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = (let u = false in false) }.a)) )) ) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (pred 0) )) in u) ) ) (\a: Bool .\b: Bool .a))
(fix (\x: Rec X. X . (let u = (if (( \f: Bool .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .a)) then (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) else ({a = 1 , b = false }.a)) in u) ))
(succ (((\x: Unit .\y: Bool .y) (fix (\x: Nat . (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) )) ) ({a = (let u = false in u) , b = 0 }.b)))
(fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Nat ] (iszero (unfold [ Nat ] (fold [ Bool ] 0 ))) )) ))
(unfold [ Nat ] (fold [ Nat ] ({a = (( \f: Rec X. X .((f (if true then 0 else 0) ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) , b = (iszero 1) , c =  ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) }.b) , c = (((\x: Rec X. X .\y: Nat .x) 0 ) (if true then true else false)) }.c) ))
(let u = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false )) in u) in u)
(let u = (pred (((\x: Bool .\y: Unit .y) ({a = 1 , b = false , c =  1 }.b) ) (pred 1))) in ({a = (( \f: Nat .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) (case <l = (((\x: Nat .\y: Bool .y) true ) 0) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = (((\x: Bool .\y: Rec X. X .x) 1 ) false) , b = (let u = true in false) }.b) , c = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f true ) (let u = false in false) ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = 1 in 0)) }.c))
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (case <r = (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) )) > as Bool of < l = x > => x | < r = y > => y) ))
({a = (pred (if (let u = false in true) then (let u = ({a = 0 , b = false }.a) in (if false then 1 else 1)) else (let u = 1 in 1))) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) ({a = false , b = true }.b)) ) ({a = (pred (((\x: Unit .\y: Rec X. X .y) false ) 1)) , b = (iszero 1) }.b) ) ) (\a: Nat .\b: Nat .a)) , c =  (if (( \f: Rec X. X .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .a)) then (let u = (if true then true else false) in (let u = 1 in u)) else ({a = ({a = 0 , b = 1 }.b) , b = (((\x: Bool .\y: Nat .x) false ) false) }.a)) }.b)
(((\x: Bool .\y: Bool .x) (succ (let u = (let u = 0 in (succ 0)) in (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)))) ) ({a = (((\x: Rec X. X .\y: Nat .x) (iszero 0) ) true) , b = (((\x: Unit .\y: Bool .y) (let u = false in false) ) ({a = 0 , b = true }.b)) }.b))
(let u = (((\x: Bool .\y: Unit .y) (let u = (( \f: Bool .((f (fix (\x: Nat . 1 )) ) ({a = 1 , b = 1 }.b) ) ) (\a: Unit .\b: Bool .b)) in (let u = 0 in (let u = 1 in true))) ) (let u = (pred 1) in u)) in u)
({a = ({a = (if (let u = true in u) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) else (((\x: Bool .\y: Rec X. X .x) (let u = false in 0) ) true)) , b = ({a = ({a = (let u = 1 in false) , b = 1 }.b) , b = (((\x: Unit .\y: Bool .x) true ) true) , c = (if false then 0 else 0) }.c) }.b) , b = (if (let u = (let u = true in 0) in (fix (\x: Bool . (((\x: Bool .\y: Unit .x) true ) true) ))) then (fix (\x: Nat . ({a = false , b = 0 }.a) )) else (case <r = (unfold [ Nat ] (fold [ Bool ] true )) > as Bool of < l = x > => x | < r = y > => y)) }.a)
({a = ({a = (let u = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = (if false then 1 else 1) }.b) in ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true ))) , b = (let u = false in 0) }.b) , b = (( \f: Rec X. X .((f ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , b = (let u = 1 in false) }.b) ) (fix (\x: Rec X. X . (( \f: Rec X. X .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (let u = true in false) ) ) (\a: Bool .\b: Nat .b)) )) ) ) (\a: Rec X. X .\b: Nat .a)) }.b)
({a = (((\x: Nat .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) (let u = (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in u)) , b = (let u = ({a = (succ 1) , b = (((\x: Unit .\y: Nat .x) ({a = true , b = true }.b) ) false) }.b) in (case <r = ({a = true , b = false }.b) > as Bool of < l = x > => x | < r = y > => y)) }.b)
({a = (( \f: Unit .((f ({a = (((\x: Nat .\y: Nat .x) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) true) , b = ({a = (if true then false else true) , b = 1 }.a) }.b) ) (unfold [ Bool ] (fold [ Unit ] true )) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = ({a = ({a = (fix (\x: Nat . 0 )) , b = (let u = ({a = 0 , b = false }.a) in false) }.b) , b = (succ (unfold [ Bool ] (fold [ Unit ] 1 ))) }.b) , b = (let u = (let u = false in true) in ({a = 0 , b = false }.b)) , c =  (if (let u = true in u) then (succ 0) else (succ 0)) }.b) }.b)
({a = ({a = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) , b = (let u = true in u) , c =  (let u = true in 0) }.b) , b = (let u = (((\x: Nat .\y: Nat .y) true ) 1) in u) }.a) , b = ({a = (((\x: Bool .\y: Rec X. X .y) ({a = true , b = 0 }.a) ) (let u = (iszero 1) in 0)) , b = (let u = ({a = 1 , b = false }.b) in u) }.b) }.b)
(case <r = ({a = (( \f: Nat .((f false ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (((\x: Bool .\y: Unit .x) 1 ) true) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.b) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (case <l = (succ 0) > as Bool of < l = x > => x | < r = y > => y) ) (if (let u = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) in u) in u) then (let u = (if (let u = false in true) then true else (fix (\x: Bool . true ))) in (let u = true in 1)) else ({a = (succ 1) , b = (let u = true in u) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c)) ) ) (\a: Nat .\b: Rec X. X .a))
(pred (pred ({a = (let u = 1 in 0) , b = (let u = ({a = true , b = true }.b) in u) , c = (succ ({a = 0 , b = true }.a)) }.c)))
({a = ({a = ({a = (let u = true in true) , b = ({a = 1 , b = false }.a) }.b) , b = (((\x: Rec X. X .\y: Nat .y) (( \f: Bool .((f (unfold [ Bool ] (fold [ Unit ] false )) ) (if false then false else true) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = 1 , b = true }.a)) }.b) , b = (( \f: Bool .((f ({a = (let u = true in u) , b = (let u = false in u) }.b) ) (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) true ) true) ) (((\x: Bool .\y: Bool .y) false ) true) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .b)) , c = (case <l = (( \f: Nat .((f (succ 0) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y) }.c)
(((\x: Rec X. X .\y: Unit .y) ({a = (let u = (((\x: Rec X. X .\y: Nat .x) 1 ) true) in (let u = 1 in 1)) , b = (fix (\x: Nat . (((\x: Rec X. X .\y: Unit .y) false ) true) )) , c =  ({a = ({a = ({a = 1 , b = false }.a) , b = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Nat . ({a = false , b = false }.b) )) )) , c = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (let u = 0 in u) )) }.c) }.b) ) (((\x: Unit .\y: Rec X. X .x) (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .x) (let u = 1 in false) ) (let u = (let u = 0 in 1) in false)) )) ) (case <r = (case <r = false > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)))
(fix (\x: Nat . (iszero ({a = ({a = false , b = ({a = 0 , b = false , c = 0 }.c) }.b) , b = ({a = 0 , b = true , c =  1 }.b) }.a)) ))
(iszero (( \f: Unit .((f (if (let u = true in (iszero 1)) then (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = true , b = (let u = false in 1) }.b)) ) (fix (\x: Nat . 1 )) ) ) (\a: Unit .\b: Rec X. X .a)))
(pred (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) )))
(if ({a = (succ (succ 1)) , b = (iszero (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.b) then (unfold [ Unit ] (fold [ Unit ] (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y) )) else (let u = (case <r = (let u = 0 in ({a = 0 , b = true }.b)) > as Nat of < l = x > => x | < r = y > => y) in (let u = (iszero (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) in u)))
({a = (if ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (let u = true in 0) , b = (unfold [ Bool ] (fold [ Unit ] false )) , c =  1 }.b) )) then ({a = ({a = (if false then 1 else 1) , b = false , c = ({a = 0 , b = true }.a) }.c) , b = ({a = 1 , b = 0 }.b) }.b) else (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) ) (( \f: Bool .((f (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) 1 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) (((\x: Rec X. X .\y: Nat .x) 1 ) true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = 1 , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.a) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Unit .((f (iszero (pred 0)) ) (fix (\x: Nat . (let u = true in u) )) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) }.a)
({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u) , b = (pred ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = (( \f: Rec X. X .((f ({a = 0 , b = 0 }.b) ) 0 ) ) (\a: Nat .\b: Nat .a)) }.b)) }.b)
(let u = (case <r = (iszero 0) > as Nat of < l = x > => x | < r = y > => y) in u)
(if (let u = ({a = (pred ({a = 1 , b = false }.a)) , b = ({a = 0 , b = false , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) , c =  (( \f: Rec X. X .((f (if true then 1 else (let u = 1 in u)) ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Unit .b)) }.b) in u) then ({a = (( \f: Rec X. X .((f 1 ) (((\x: Unit .\y: Bool .y) true ) 0) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = ({a = true , b = 0 }.a) }.b) , c =  (unfold [ Nat ] (fold [ Bool ] (if true then 0 else 0) )) }.b) else (iszero ({a = (((\x: Unit .\y: Unit .x) 1 ) true) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = (if false then 0 else 0) }.c)))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f ({a = 1 , b = (fix (\x: Unit . true )) }.a) ) (((\x: Nat .\y: Bool .y) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .y) false ) 0) ))) ) ) (\a: Bool .\b: Nat .a)) ))
(iszero ({a = ({a = (let u = 0 in 0) , b = true }.b) , b = ({a = 0 , b = (let u = true in u) , c = 1 }.c) }.b))
({a = (( \f: Nat .((f ({a = ({a = (let u = true in 0) , b = 1 }.b) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.b) ) ({a = (((\x: Nat .\y: Bool .y) false ) 1) , b = (if false then (let u = true in false) else true) , c = (( \f: Nat .((f (succ 1) ) (((\x: Bool .\y: Nat .y) false ) 0) ) ) (\a: Rec X. X .\b: Unit .a)) }.c) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = (let u = 1 in (((\x: Rec X. X .\y: Rec X. X .x) false ) false)) , b = (((\x: Rec X. X .\y: Bool .x) true ) true) }.b) }.a)
(case <r = (iszero (pred ({a = 0 , b = true , c = 0 }.c))) > as Bool of < l = x > => x | < r = y > => y)
({a = (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .x) (let u = true in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) ) (((\x: Rec X. X .\y: Bool .x) ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = (if true then 0 else 0) }.a) ) ({a = true , b = false }.b))) )) , b = (let u = ({a = (let u = false in false) , b = ({a = false , b = 0 }.b) }.a) in u) }.b)
(( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Unit .y) ({a = 0 , b = true , c =  (if true then 1 else 0) }.b) ) (unfold [ Bool ] (fold [ Bool ] 0 ))) )) ) (pred (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) in u)) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (((\x: Unit .\y: Rec X. X .x) (let u = (pred 1) in ({a = false , b = 1 }.a)) ) (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (case <l = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) false) )) > as Unit of < l = x > => x | < r = y > => y) }.b)
(( \f: Unit .((f (succ (fix (\x: Unit . ({a = (((\x: Unit .\y: Bool .y) false ) false) , b = 1 }.b) ))) ) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] 1 )) )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Bool .\y: Bool .x) 0 ) false)) )) }.b) ) ) (\a: Rec X. X .\b: Bool .a))
(case <l = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (if (fix (\x: Rec X. X . false )) then (unfold [ Unit ] (fold [ Bool ] false )) else ({a = 1 , b = true , c =  1 }.b)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (case <r = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) in (((\x: Bool .\y: Unit .x) true ) false)) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (let u = true in (if true then 0 else 0)) in u) }.b)
(( \f: Bool .((f ({a = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .a)) )) in ({a = (fix (\x: Bool . true )) , b = false }.b)) , b = ({a = (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a))) , b = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (if false then 0 else 0) )) , b = (((\x: Bool .\y: Nat .x) 0 ) true) }.b) }.b) }.b) ) (let u = (fix (\x: Unit . 1 )) in u) ) ) (\a: Unit .\b: Unit .a))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = ({a = false , b = true }.b) , c = ({a = 0 , b = false }.a) }.c) )) in (( \f: Rec X. X .((f ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = ({a = true , b = false }.b) }.b) ) (((\x: Unit .\y: Bool .x) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Unit .b)))
({a = (if (iszero (if true then (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) else ({a = 1 , b = 0 }.b))) then (let u = (succ ({a = 0 , b = false , c = 0 }.c)) in (let u = true in (succ 1))) else ({a = ({a = 0 , b = true , c =  0 }.b) , b = (let u = ({a = true , b = 0 }.b) in u) }.b)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = true in u) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) }.b) )) }.b)
(pred (fix (\x: Bool . (((\x: Nat .\y: Unit .x) (let u = (iszero 0) in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (succ 0) , b = (unfold [ Nat ] (fold [ Unit ] false )) , c =  ({a = 1 , b = true }.a) }.b)) )))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (succ 1) in ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) , b = true }.b)) ))
(fix (\x: Rec X. X . (( \f: Nat .((f (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ) (((\x: Rec X. X .\y: Unit .y) true ) 1) ) ) (\a: Nat .\b: Nat .b)) ) (let u = (succ (if (if true then false else false) then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else 1)) in u) ) ) (\a: Unit .\b: Bool .a)) ))
(( \f: Unit .((f (( \f: Nat .((f (((\x: Unit .\y: Bool .x) (( \f: Unit .((f (let u = 1 in u) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) (iszero ({a = (pred 1) , b = true , c = 0 }.c))) ) (case <l = (fix (\x: Bool . (fix (\x: Unit . 0 )) )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) ) (fix (\x: Unit . (let u = 0 in 1) )) ) ) (\a: Rec X. X .\b: Nat .a))
(if (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y) then (unfold [ Bool ] (fold [ Rec X. X ] (pred 1) )) else (if (if (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Unit . false )) )) then ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) else (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) (((\x: Bool .\y: Rec X. X .y) false ) true))) then (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = true , c = (((\x: Nat .\y: Nat .y) true ) 1) }.c) ) (fix (\x: Rec X. X . false ))) else (pred (let u = 1 in u))))
(succ (( \f: Rec X. X .((f (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) in (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) ) (succ (pred ({a = (if false then 1 else 0) , b = ({a = 1 , b = false }.a) }.b))) ) ) (\a: Bool .\b: Bool .b)))
(let u = (unfold [ Unit ] (fold [ Bool ] (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] true )) )) )) in (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) ({a = (if true then 0 else 1) , b = 1 }.b) ) ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = true }.b)) ) (( \f: Unit .((f (let u = 1 in ({a = 0 , b = false }.a)) ) ({a = (let u = false in 1) , b = ({a = true , b = true }.b) , c = 1 }.c) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Unit .a)))
(let u = (unfold [ Nat ] (fold [ Bool ] ({a = ({a = 0 , b = 1 }.b) , b = (let u = true in u) , c =  (if (iszero 1) then 1 else 1) }.b) )) in ({a = (let u = ({a = 1 , b = true , c = 1 }.c) in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (let u = (pred 1) in (fix (\x: Nat . false ))) , c =  (pred ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 ))) }.b))
(if (let u = ({a = (let u = (fix (\x: Unit . false )) in u) , b = (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Bool .y) false ) false) ) true) }.b) in u) then (( \f: Bool .((f (let u = (unfold [ Bool ] (fold [ Nat ] true )) in (((\x: Rec X. X .\y: Nat .x) 0 ) false)) ) ({a = 1 , b = (let u = 0 in true) }.a) ) ) (\a: Rec X. X .\b: Nat .b)) else (((\x: Bool .\y: Unit .y) (let u = (iszero 1) in ({a = false , b = false }.b)) ) (succ (succ (if true then 0 else 0)))))
({a = (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 0 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) )) then (( \f: Nat .((f ({a = 1 , b = ({a = 1 , b = false , c =  0 }.b) }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) )) ) ) (\a: Rec X. X .\b: Bool .b)) else ({a = ({a = (let u = 0 in false) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) , b = (((\x: Bool .\y: Nat .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) ) ({a = 0 , b = false , c =  (fix (\x: Bool . 1 )) }.b)) }.b)) , b = (let u = (case <l = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) > as Bool of < l = x > => x | < r = y > => y) in u) }.a)
(let u = (( \f: Rec X. X .((f (fix (\x: Nat . true )) ) (( \f: Bool .((f ({a = 1 , b = true , c =  1 }.b) ) ({a = (let u = 0 in 0) , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .a)) in u)
(((\x: Bool .\y: Bool .y) ({a = (( \f: Rec X. X .((f (let u = false in 0) ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = (let u = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b)) in true) }.b) ) (( \f: Rec X. X .((f (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (let u = 1 in 1) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , c = (if false then 0 else 1) }.c) ) ) (\a: Rec X. X .\b: Nat .a)))
(let u = (let u = (let u = ({a = 0 , b = 1 }.b) in (let u = false in false)) in (case <r = ({a = true , b = (let u = true in false) }.b) > as Bool of < l = x > => x | < r = y > => y)) in (succ ({a = false , b = 1 }.b)))
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred (let u = 0 in 0)) )) ))
(succ (( \f: Unit .((f ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = true }.a) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Bool .a)))
(let u = (let u = (let u = (( \f: Unit .((f (succ 1) ) 0 ) ) (\a: Nat .\b: Unit .a)) in u) in u) in (iszero (let u = 0 in u)))
(( \f: Nat .((f (if (( \f: Unit .((f ({a = (fix (\x: Unit . true )) , b = (unfold [ Bool ] (fold [ Nat ] 0 )) }.a) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (pred 1) )) , b = (let u = false in true) , c =  (fix (\x: Nat . (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) )) }.b) ) ) (\a: Bool .\b: Bool .b)) then (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then ({a = 1 , b = false }.b) else ({a = (let u = 1 in u) , b = false , c =  1 }.b)) else ({a = (fix (\x: Nat . 1 )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Unit .\y: Bool .y) false ) true) )) , c =  (let u = true in 0) }.b)) ) (let u = (pred (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) (succ 0) ) ) (\a: Bool .\b: Bool .a))) in (if (let u = true in u) then (if true then true else false) else (((\x: Nat .\y: Unit .y) (let u = true in false) ) false))) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Rec X. X . ({a = ({a = false , b = true }.b) , b = false }.b) )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (if (fix (\x: Rec X. X . false )) then ({a = false , b = 0 }.b) else 1) ))) , b = (((\x: Unit .\y: Nat .x) (let u = (((\x: Rec X. X .\y: Bool .x) true ) true) in u) ) (( \f: Rec X. X .((f (let u = 1 in false) ) (let u = true in false) ) ) (\a: Nat .\b: Nat .a))) }.b)
({a = (let u = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Unit ] true )) )) in u) , b = (if (let u = true in u) then (((\x: Nat .\y: Bool .x) true ) ({a = false , b = true }.b)) else (if (let u = false in true) then (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .b)) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) else (((\x: Unit .\y: Rec X. X .y) false ) false))) }.b)
({a = ({a = ({a = (((\x: Unit .\y: Rec X. X .x) true ) true) , b = ({a = true , b = 0 }.b) }.b) , b = (if ({a = 1 , b = true , c =  0 }.b) then (fix (\x: Nat . ({a = 1 , b = true }.a) )) else ({a = 1 , b = true , c = 0 }.c)) }.b) , b = (case <r = (( \f: Unit .((f ({a = 1 , b = true , c =  ({a = 1 , b = 1 }.b) }.b) ) ({a = false , b = (if true then true else false) }.b) ) ) (\a: Nat .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) }.b)
({a = ({a = (let u = true in (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .b))) , b = (( \f: Bool .((f (let u = true in 1) ) (pred 1) ) ) (\a: Bool .\b: Bool .b)) }.b) , b = (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) (((\x: Rec X. X .\y: Nat .y) true ) false) ) ) (\a: Unit .\b: Rec X. X .b)) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) ({a = ({a = true , b = 1 }.a) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) }.a) ) (((\x: Nat .\y: Bool .y) (case <r = ({a = 0 , b = true , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)))) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Nat .b)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (if (let u = false in u) then 0 else (let u = 0 in u)) ))) ))
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = true }.b) )) , b = (case <r = (let u = ({a = ({a = true , b = false }.b) , b = (let u = 0 in u) }.a) in u) > as Unit of < l = x > => x | < r = y > => y) }.b)
(fix (\x: Bool . (( \f: Nat .((f (if (iszero (pred 1)) then (((\x: Nat .\y: Unit .x) false ) true) else (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) false)) ) (let u = (((\x: Nat .\y: Nat .y) false ) true) in ({a = true , b = true }.b)) ) ) (\a: Unit .\b: Bool .a)) ))
(let u = (unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f (case <l = (fix (\x: Rec X. X . 0 )) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . ({a = true , b = 1 }.b) )) ) ) (\a: Nat .\b: Bool .b)) )) in (let u = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = ({a = true , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.a) }.b)) in u))
(let u = (let u = (( \f: Rec X. X .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Nat .a)) in (( \f: Unit .((f true ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Rec X. X .a))) in u)
(let u = (if ({a = (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) in ({a = 0 , b = 0 }.b)) , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.b) then (let u = 0 in (fix (\x: Bool . true ))) else ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  1 }.b)) in u)
(let u = (( \f: Unit .((f (let u = true in ({a = 0 , b = false , c =  0 }.b)) ) ({a = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false )) then (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .b)) else false) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Bool .\b: Unit .a)) in u)
(case <r = (((\x: Nat .\y: Unit .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f 0 ) (fix (\x: Unit . 0 )) ) ) (\a: Nat .\b: Rec X. X .b)) in (unfold [ Bool ] (fold [ Unit ] (((\x: Bool .\y: Unit .x) false ) true) ))) )) ) (((\x: Unit .\y: Nat .y) (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = true }.b) )) ) (if true then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else true))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (((\x: Nat .\y: Rec X. X .x) ({a = (( \f: Nat .((f (((\x: Unit .\y: Unit .y) true ) false) ) (fix (\x: Rec X. X . true )) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) , b = true , c = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.c) }.a) ) (iszero ({a = 1 , b = false , c = 1 }.c))) in (((\x: Nat .\y: Rec X. X .x) (case <l = (let u = 0 in 1) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (iszero 0) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = true in u) )))))
(let u = (case <r = (if (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) then (let u = ({a = 0 , b = true }.b) in false) else (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .b))) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = ({a = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = false , b = true }.b) }.b) , b = (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f (succ 1) ) 0 ) ) (\a: Unit .\b: Nat .b)) ) ({a = 0 , b = true }.b)) }.a))
(let u = (let u = (( \f: Bool .((f false ) (((\x: Rec X. X .\y: Unit .x) false ) false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (iszero ({a = 0 , b = false , c = 1 }.c))) in (case <l = (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Nat . 0 )) ) ({a = 0 , b = true }.b)) ) (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) )) ) ) (\a: Bool .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y))
({a = (let u = (((\x: Bool .\y: Nat .y) ({a = (let u = 1 in u) , b = ({a = (fix (\x: Bool . 1 )) , b = ({a = false , b = 0 }.a) }.b) }.b) ) (fix (\x: Unit . 0 ))) in (let u = (let u = (iszero (((\x: Nat .\y: Rec X. X .x) 1 ) false)) in u) in (let u = (let u = (((\x: Rec X. X .\y: Nat .x) false ) true) in ({a = 1 , b = false , c = 0 }.c)) in u))) , b = (fix (\x: Nat . (if (((\x: Nat .\y: Bool .x) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) true) then (((\x: Bool .\y: Rec X. X .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) 1) else (fix (\x: Bool . (let u = 1 in u) ))) )) }.b)
(((\x: Bool .\y: Bool .x) (let u = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) in u) in (((\x: Nat .\y: Nat .y) true ) false)) ) (( \f: Rec X. X .((f ({a = 0 , b = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) , c =  0 }.b) ) (((\x: Bool .\y: Nat .y) ({a = 0 , b = true }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Nat .a)))
({a = (( \f: Nat .((f (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .x) (pred 0) ) false) ) ({a = 0 , b = ({a = true , b = 0 }.a) }.a) ) ) (\a: Nat .\b: Bool .b)) ) (pred (let u = 0 in (pred 0))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = (let u = ({a = 0 , b = true , c = 1 }.c) in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (iszero (((\x: Nat .\y: Rec X. X .y) false ) 0)) , c =  ({a = ({a = 1 , b = 1 }.b) , b = (iszero 1) }.a) }.b) }.b)
(( \f: Bool .((f ({a = ({a = (fix (\x: Rec X. X . false )) , b = ({a = 1 , b = false , c = 1 }.c) }.b) , b = (if false then false else false) , c =  (let u = 0 in u) }.b) ) ({a = ({a = (iszero (fix (\x: Bool . (((\x: Nat .\y: Rec X. X .y) true ) 0) ))) , b = ({a = (if false then true else false) , b = 1 }.b) }.a) , b = (unfold [ Unit ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (iszero 1) )) )) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(( \f: Bool .((f (case <r = (if ({a = 1 , b = false }.b) then (((\x: Bool .\y: Unit .y) false ) true) else (unfold [ Unit ] (fold [ Bool ] true ))) > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = (( \f: Bool .((f ({a = true , b = false }.b) ) (let u = true in u) ) ) (\a: Unit .\b: Unit .b)) , b = (succ 1) }.a) )) ) ) (\a: Nat .\b: Rec X. X .a))
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) (iszero (if false then 0 else 0)) ) (( \f: Unit .((f (let u = true in u) ) (if true then false else false) ) ) (\a: Unit .\b: Rec X. X .b))) ))
(fix (\x: Bool . (unfold [ Bool ] (fold [ Bool ] (unfold [ Nat ] (fold [ Bool ] (((\x: Bool .\y: Nat .y) false ) 1) )) )) ))
(fix (\x: Unit . (unfold [ Nat ] (fold [ Nat ] (succ (let u = true in 0)) )) ))
({a = (((\x: Nat .\y: Unit .y) (if (fix (\x: Bool . false )) then ({a = 1 , b = (fix (\x: Nat . false )) }.b) else (unfold [ Unit ] (fold [ Bool ] (let u = false in u) ))) ) ({a = ({a = (let u = 1 in 0) , b = (if false then false else true) }.a) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) , c =  (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Nat .y) false ) 1) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) }.b)) , b = (succ (( \f: Bool .((f (let u = ({a = true , b = false }.b) in (pred 0)) ) (pred (fix (\x: Unit . 0 ))) ) ) (\a: Bool .\b: Nat .a))) }.b)
(let u = (let u = (((\x: Unit .\y: Unit .y) ({a = true , b = false }.b) ) (((\x: Nat .\y: Rec X. X .x) 0 ) true)) in (unfold [ Bool ] (fold [ Rec X. X ] true ))) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = 0 , b = true , c = 0 }.c) in u) )))
(((\x: Nat .\y: Rec X. X .x) (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f ({a = (fix (\x: Nat . (((\x: Unit .\y: Unit .y) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) 1) )) , b = (( \f: Unit .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Rec X. X .x) false ) false) ) ) (\a: Unit .\b: Bool .a)) }.b) ) (let u = ({a = true , b = 0 }.a) in ({a = false , b = true }.b)) ) ) (\a: Unit .\b: Rec X. X .a)))
({a = (let u = (((\x: Unit .\y: Unit .y) (let u = 0 in (if false then false else false)) ) (((\x: Rec X. X .\y: Nat .y) false ) (let u = true in true))) in u) , b = ({a = ({a = false , b = ({a = 0 , b = false , c = 0 }.c) }.b) , b = (case <r = (((\x: Rec X. X .\y: Bool .x) false ) true) > as Unit of < l = x > => x | < r = y > => y) }.a) }.b)
(((\x: Bool .\y: Rec X. X .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) )) ) (if (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . false )) )) )) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = false , b = 1 }.b) )) else (((\x: Unit .\y: Bool .y) ({a = (unfold [ Bool ] (fold [ Unit ] false )) , b = 1 }.a) ) (unfold [ Unit ] (fold [ Unit ] 1 )))))
(if (unfold [ Unit ] (fold [ Bool ] (( \f: Nat .((f (( \f: Nat .((f (unfold [ Nat ] (fold [ Nat ] (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) ) (\a: Nat .\b: Bool .b)) ) (iszero ({a = 0 , b = 0 }.b)) ) ) (\a: Nat .\b: Unit .b)) )) then (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) ({a = 0 , b = true }.b) ) (unfold [ Unit ] (fold [ Nat ] false ))) ) (succ (succ (((\x: Bool .\y: Rec X. X .x) 0 ) true)))) else (((\x: Nat .\y: Unit .x) (( \f: Unit .((f (((\x: Nat .\y: Unit .y) true ) 1) ) (let u = (fix (\x: Nat . 0 )) in ({a = false , b = 1 }.b)) ) ) (\a: Nat .\b: Bool .b)) ) (let u = (((\x: Rec X. X .\y: Nat .y) false ) true) in u)))
({a = (let u = (let u = (fix (\x: Unit . true )) in u) in u) , b = ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in u) , b = (let u = (unfold [ Nat ] (fold [ Nat ] (unfold [ Unit ] (fold [ Unit ] true )) )) in (let u = ({a = 0 , b = true }.b) in (if false then 0 else 0))) }.a) }.b)
({a = ({a = (((\x: Unit .\y: Unit .y) (let u = false in true) ) ({a = ({a = 1 , b = 0 }.b) , b = (((\x: Bool .\y: Rec X. X .y) true ) false) }.a)) , b = (((\x: Rec X. X .\y: Unit .y) (if false then false else false) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true ))) , c =  (if true then 0 else 1) }.b) , b = (unfold [ Unit ] (fold [ Unit ] (succ (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b))) )) }.b)
(fix (\x: Rec X. X . ({a = (succ (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )))) , b = (( \f: Bool .((f (unfold [ Unit ] (fold [ Unit ] false )) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Nat .b)) , c = (( \f: Nat .((f (succ (fix (\x: Bool . ({a = 1 , b = 1 }.b) ))) ) (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (let u = false in 0) else (let u = 0 in 1)) ) ) (\a: Unit .\b: Rec X. X .b)) }.c) ))
({a = (((\x: Bool .\y: Nat .y) (iszero (let u = (((\x: Bool .\y: Nat .y) ({a = true , b = true }.b) ) false) in (let u = true in 0))) ) ({a = (fix (\x: Nat . 1 )) , b = (((\x: Nat .\y: Nat .y) true ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) , c =  ({a = 1 , b = false , c = 1 }.c) }.b)) , b = ({a = (((\x: Nat .\y: Rec X. X .x) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = false }.a) ) (let u = true in u)) , b = (iszero (fix (\x: Rec X. X . 0 ))) , c =  (( \f: Nat .((f 0 ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) }.b)
(fix (\x: Unit . ({a = (let u = ({a = false , b = 1 }.b) in (let u = true in 0)) , b = ({a = ({a = (if (((\x: Rec X. X .\y: Rec X. X .y) true ) false) then false else (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .a))) , b = (succ (let u = 0 in 1)) }.a) , b = (((\x: Unit .\y: Unit .x) true ) true) }.b) }.b) ))
(unfold [ Nat ] (fold [ Bool ] (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Unit .y) (((\x: Nat .\y: Bool .x) ({a = 0 , b = true }.b) ) false) ) ({a = 1 , b = 1 }.b)) ) ({a = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .b)) , b = ({a = (((\x: Unit .\y: Rec X. X .y) true ) 1) , b = 1 }.b) }.a)) ))
(fix (\x: Rec X. X . (((\x: Nat .\y: Nat .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (((\x: Nat .\y: Nat .y) true ) false) in (let u = true in false)) )) ) (((\x: Bool .\y: Rec X. X .y) (let u = (let u = 1 in u) in ({a = ({a = 0 , b = 0 }.b) , b = true }.b)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = false in 1) , b = true , c =  (if false then 0 else 0) }.b) )))) ))
({a = (iszero (succ ({a = (fix (\x: Unit . (unfold [ Unit ] (fold [ Nat ] 1 )) )) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 )) }.b))) , b = (((\x: Bool .\y: Nat .y) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) > as Unit of < l = x > => x | < r = y > => y) , c =  (unfold [ Rec X. X ] (fold [ Unit ] (let u = ({a = 1 , b = 0 }.b) in u) )) }.b) ) (( \f: Bool .((f (if false then false else (if false then false else false)) ) (let u = (unfold [ Unit ] (fold [ Unit ] true )) in (let u = false in true)) ) ) (\a: Rec X. X .\b: Nat .a))) }.b)
({a = (( \f: Unit .((f ({a = ({a = (fix (\x: Nat . 1 )) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) , b = (iszero 0) }.b) ) (((\x: Unit .\y: Nat .x) ({a = false , b = 1 }.a) ) ({a = true , b = 0 }.a)) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Bool .((f ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = 0 , b = false }.b) }.b) }.b) ) (((\x: Nat .\y: Unit .x) true ) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)
(if ({a = ({a = (((\x: Bool .\y: Nat .x) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ) (iszero 0)) , b = (unfold [ Rec X. X ] (fold [ Nat ] (pred (((\x: Nat .\y: Bool .x) 0 ) true)) )) }.b) , b = (let u = ({a = false , b = 1 }.a) in ({a = (fix (\x: Bool . 1 )) , b = ({a = true , b = true }.b) , c =  (let u = 1 in 1) }.b)) , c =  (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y) }.b) then (((\x: Bool .\y: Nat .x) (let u = ({a = ({a = 0 , b = true }.a) , b = (let u = false in false) }.b) in u) ) (case <r = ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .a)) , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) else (let u = (((\x: Unit .\y: Rec X. X .y) (iszero 0) ) (unfold [ Unit ] (fold [ Unit ] true ))) in u))
(if (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .x) (if false then true else true) ) (unfold [ Nat ] (fold [ Bool ] true ))) ) ({a = (let u = false in u) , b = true }.b) ) ) (\a: Nat .\b: Nat .b)) then ({a = ({a = (fix (\x: Rec X. X . 0 )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) , c =  ({a = (((\x: Bool .\y: Unit .y) true ) 0) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b) , b = (unfold [ Bool ] (fold [ Bool ] true )) }.b) else ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = ({a = 1 , b = false }.a) , b = (fix (\x: Bool . false )) }.b) )) , b = ({a = ({a = (fix (\x: Unit . false )) , b = ({a = 1 , b = 0 }.b) }.b) , b = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = true in u) , c =  ({a = 0 , b = 1 }.b) }.b) , c = (let u = (let u = 1 in u) in ({a = 0 , b = 1 }.b)) }.c) }.a))
(case <r = (( \f: Bool .((f (fix (\x: Rec X. X . ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) )) ) (let u = (iszero (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) in (let u = 0 in u))) in (((\x: Nat .\y: Bool .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) ) (let u = 0 in true))) ) ) (\a: Nat .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y)
({a = ({a = (let u = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) in (( \f: Unit .((f ({a = false , b = 1 }.a) ) false ) ) (\a: Nat .\b: Rec X. X .b))) , b = (((\x: Bool .\y: Rec X. X .x) 1 ) false) }.b) , b = (let u = (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) (let u = 0 in u) ) ) (\a: Bool .\b: Nat .b)) in u) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) in (if false then true else true)) ) (let u = ({a = ({a = 1 , b = false }.a) , b = 1 }.b) in (let u = 0 in true))) )) ))
(((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Unit .y) (let u = false in false) ) (fix (\x: Bool . false ))) ) (pred (let u = (unfold [ Unit ] (fold [ Unit ] false )) in 1))) ) (let u = ({a = ({a = true , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.a) , b = (let u = (( \f: Bool .((f true ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a)) in u) }.b) in u))
(( \f: Nat .((f (((\x: Nat .\y: Nat .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true ))) ) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = false , b = 0 }.a) }.b) ) ) (\a: Nat .\b: Bool .b))
(let u = ({a = (let u = (((\x: Rec X. X .\y: Unit .x) (fix (\x: Bool . true )) ) false) in (pred 1)) , b = (case <r = (let u = false in false) > as Bool of < l = x > => x | < r = y > => y) , c =  (((\x: Rec X. X .\y: Unit .x) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) (iszero 1)) }.b) in u)
({a = (unfold [ Bool ] (fold [ Bool ] ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) )) , b = (( \f: Unit .((f (fix (\x: Bool . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) )) ) (let u = (pred 0) in u) ) ) (\a: Bool .\b: Unit .b)) }.a)
({a = (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) (fix (\x: Unit . false ))) ) (case <r = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = true , b = (if true then true else true) }.b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Bool .\y: Rec X. X .x) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) in (unfold [ Rec X. X ] (fold [ Nat ] true ))) ) (((\x: Nat .\y: Unit .x) (let u = 0 in false) ) ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .b)) , b = 0 }.a))) }.b)
({a = (succ (((\x: Unit .\y: Nat .y) ({a = true , b = true }.b) ) (unfold [ Nat ] (fold [ Nat ] (if false then 0 else 0) )))) , b = ({a = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Nat .y) false ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) , b = ({a = ({a = (let u = 0 in true) , b = (let u = false in false) }.b) , b = (let u = false in 1) }.a) }.b) }.b)
(fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] true )) )) ) (if (let u = true in u) then (let u = false in u) else (let u = false in u))) ))
({a = ({a = (((\x: Bool .\y: Unit .x) ({a = 1 , b = (let u = false in u) }.b) ) (((\x: Nat .\y: Rec X. X .x) true ) true)) , b = ({a = ({a = 1 , b = false }.b) , b = (((\x: Rec X. X .\y: Bool .x) 1 ) false) }.b) }.a) , b = ({a = ({a = (fix (\x: Rec X. X . false )) , b = (((\x: Nat .\y: Bool .x) 1 ) true) }.b) , b = ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = (if false then false else false) }.b) , c = (( \f: Unit .((f (if false then 1 else 0) ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.c) }.a)
({a = ({a = (fix (\x: Nat . 0 )) , b = (if true then ({a = 0 , b = false , c =  1 }.b) else false) , c =  (((\x: Bool .\y: Bool .y) (let u = true in true) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) }.b) , b = ({a = (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Nat .x) ({a = 1 , b = false }.b) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] false )) in u)) , c =  (fix (\x: Rec X. X . (( \f: Bool .((f 0 ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Nat .b)) )) }.b) }.b)
(pred ({a = (unfold [ Nat ] (fold [ Bool ] (case <l = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (unfold [ Unit ] (fold [ Nat ] ({a = ({a = ({a = 0 , b = false }.a) , b = (unfold [ Unit ] (fold [ Nat ] 1 )) }.b) , b = (let u = ({a = false , b = true }.b) in u) , c =  (let u = 0 in u) }.b) )) , c = (if (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = true }.b) )) then (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = ({a = 0 , b = false }.a) in (unfold [ Rec X. X ] (fold [ Nat ] 1 )))) }.c))
(if ({a = ({a = (case <r = (let u = true in u) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Nat .x) true ) true) }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = (if true then 0 else 0) in u) )) }.a) then ({a = ({a = (fix (\x: Nat . 0 )) , b = (iszero 0) }.b) , b = ({a = (succ (let u = 0 in 0)) , b = (succ (((\x: Nat .\y: Bool .y) true ) 1)) }.b) }.b) else ({a = (( \f: Bool .((f (let u = 0 in u) ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (( \f: Nat .((f (let u = true in u) ) (if true then true else false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (let u = ({a = false , b = 0 }.a) in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) }.c))
(unfold [ Unit ] (fold [ Rec X. X ] ({a = ({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = true }.b) , b = (fix (\x: Unit . (if false then 0 else 1) )) }.b) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (iszero 0) )) , c =  (succ (let u = 1 in u)) }.b) ))
({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = (pred 1) in (pred (( \f: Rec X. X .((f 0 ) (succ 1) ) ) (\a: Unit .\b: Unit .b)))) )) , b = (( \f: Unit .((f (let u = true in 0) ) (pred ({a = 0 , b = ({a = true , b = 1 }.a) }.a)) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(let u = (case <l = ({a = ({a = 1 , b = ({a = 0 , b = false , c = 0 }.c) }.b) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .a)) , c = (unfold [ Bool ] (fold [ Nat ] 0 )) }.c) > as Bool of < l = x > => x | < r = y > => y) in (succ (let u = (let u = (((\x: Rec X. X .\y: Bool .y) false ) 0) in ({a = 1 , b = false , c = 0 }.c)) in u)))
(let u = (fix (\x: Nat . (((\x: Unit .\y: Rec X. X .y) (let u = 0 in true) ) (let u = 1 in (((\x: Nat .\y: Nat .x) false ) true))) )) in (let u = (fix (\x: Bool . (unfold [ Bool ] (fold [ Unit ] 0 )) )) in (((\x: Nat .\y: Rec X. X .y) (let u = (fix (\x: Bool . 0 )) in (let u = false in false)) ) ({a = 0 , b = true }.a))))
({a = ({a = (( \f: Nat .((f ({a = false , b = 0 }.b) ) (succ 1) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (fix (\x: Nat . true )) }.a) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (succ ({a = 0 , b = true , c = 0 }.c)) , b = (let u = true in false) , c =  (succ 1) }.b) )) , c = ({a = (( \f: Unit .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) (((\x: Bool .\y: Rec X. X .x) (succ 1) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true ))) ) ) (\a: Nat .\b: Nat .a)) , b = ({a = ({a = 1 , b = 0 }.b) , b = (unfold [ Unit ] (fold [ Unit ] (if false then ({a = 0 , b = true }.b) else true) )) }.a) }.b) }.c)
({a = ({a = (case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (fix (\x: Rec X. X . 1 )) , b = (let u = true in u) , c =  (let u = false in 1) }.b) )) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (let u = (let u = 0 in true) in (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) in u) }.b) , b = (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = false }.b) ) (let u = true in false)) in (if true then true else true)) in ({a = (if (iszero 1) then (let u = 1 in 1) else 0) , b = (if (let u = 0 in true) then ({a = false , b = false }.b) else ({a = (let u = 0 in 1) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) }.b)) }.a)) }.b)
(unfold [ Bool ] (fold [ Rec X. X ] (let u = ({a = (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) false ) false) ) (((\x: Rec X. X .\y: Bool .y) false ) true)) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) }.b) in u) ))
({a = (case <r = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (if false then false else true) )) ) (let u = (((\x: Unit .\y: Nat .y) true ) 1) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) , b = (case <l = (let u = false in (succ 0)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
({a = ({a = (pred ({a = 0 , b = (succ 0) }.b)) , b = (let u = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in 1) in (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = false , c =  0 }.b) ))) , c = (case <l = (fix (\x: Bool . ({a = false , b = 0 }.b) )) > as Bool of < l = x > => x | < r = y > => y) }.c) , b = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) (let u = false in 1) ) (case <r = (case <r = true > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)) ) ({a = (let u = false in ({a = 1 , b = true , c = 1 }.c)) , b = (((\x: Unit .\y: Unit .x) false ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a))) }.a) ) ) (\a: Nat .\b: Bool .a)) }.b)
(iszero (let u = (( \f: Rec X. X .((f false ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) ) ) (\a: Nat .\b: Nat .a)) in (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then ({a = 1 , b = 0 }.b) else (let u = 1 in u))))
(pred (let u = (((\x: Bool .\y: Nat .x) ({a = true , b = 0 }.a) ) ({a = false , b = false }.b)) in (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) 1 ) true) ) 1 ) ) (\a: Nat .\b: Bool .a))))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f (let u = (let u = false in true) in (((\x: Bool .\y: Bool .y) false ) 1)) ) (((\x: Unit .\y: Rec X. X .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (if false then ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) else (let u = false in 1))) ) ) (\a: Bool .\b: Unit .a)) ))
({a = (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Rec X. X .y) (iszero 0) ) (let u = false in 0)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false ))) , b = (let u = (if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) then (((\x: Unit .\y: Nat .x) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) false) else ({a = 0 , b = true , c =  ({a = 1 , b = 0 }.b) }.b)) in u) }.b)
(let u = ({a = ({a = (let u = true in true) , b = 1 }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = ({a = 0 , b = true }.a) , b = true }.b) )) }.b) in u)
(((\x: Unit .\y: Bool .y) ({a = (((\x: Unit .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (let u = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) in u)) , b = (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .b)) )) }.b) ) (case <r = ({a = (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in (if false then 0 else 0)) }.a) > as Nat of < l = x > => x | < r = y > => y))
(fix (\x: Nat . ({a = (fix (\x: Bool . (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = ({a = true , b = 1 }.a) }.b) )) )) , b = (unfold [ Unit ] (fold [ Nat ] ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) , b = ({a = (((\x: Unit .\y: Nat .x) true ) true) , b = 1 }.b) }.a) )) }.b) ))
(let u = (( \f: Unit .((f ({a = (let u = ({a = 0 , b = false }.b) in 0) , b = (((\x: Unit .\y: Nat .x) (succ 0) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false ))) }.b) ) (let u = (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) true) in u) in u) ) ) (\a: Nat .\b: Bool .b)) in ({a = ({a = (fix (\x: Rec X. X . ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )) )) , b = (fix (\x: Bool . 0 )) }.b) , b = (unfold [ Nat ] (fold [ Unit ] (let u = ({a = (fix (\x: Nat . true )) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.a) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) )) , c = (( \f: Bool .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Rec X. X .a)) }.c))
(((\x: Unit .\y: Unit .x) (let u = ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (fix (\x: Nat . true )) , c = (pred ({a = 1 , b = false }.a)) }.c) , b = (let u = 1 in u) }.b) in u) ) (unfold [ Rec X. X ] (fold [ Bool ] (case <r = (( \f: Unit .((f true ) (if false then false else true) ) ) (\a: Bool .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) )))
(((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Bool .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = 0 , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .b)) }.b)) ) (case <r = (let u = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = (if true then false else false) , c =  (pred 0) }.b) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y))
(if (let u = (( \f: Bool .((f ({a = true , b = 1 }.a) ) false ) ) (\a: Bool .\b: Nat .b)) in (iszero (fix (\x: Rec X. X . 0 )))) then (((\x: Unit .\y: Unit .x) (let u = 0 in true) ) ({a = 1 , b = true }.b)) else (fix (\x: Unit . (let u = (fix (\x: Rec X. X . true )) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = true in u) ))) )))
(fix (\x: Bool . (let u = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = true }.b) )) ) ({a = (((\x: Unit .\y: Unit .y) true ) 1) , b = (let u = 0 in false) }.b) ) ) (\a: Nat .\b: Nat .a)) in (((\x: Unit .\y: Bool .y) (let u = 0 in (unfold [ Bool ] (fold [ Unit ] true ))) ) (if ({a = true , b = false }.b) then (unfold [ Unit ] (fold [ Rec X. X ] true )) else (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b))))) ))
({a = (case <l = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (case <r = ({a = true , b = 1 }.a) > as Bool of < l = x > => x | < r = y > => y) }.a) }.b)
({a = (succ (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Bool .y) false ) 0) ) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = (let u = 0 in false) , c =  1 }.b))) , b = ({a = (fix (\x: Bool . (succ 1) )) , b = ({a = (let u = 1 in 0) , b = (iszero 0) , c =  (((\x: Nat .\y: Nat .x) (if false then 1 else 1) ) ({a = false , b = true }.b)) }.b) , c =  (if (let u = ({a = false , b = false }.b) in u) then (let u = 1 in 1) else (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) }.b) }.a)
(let u = (let u = ({a = (((\x: Rec X. X .\y: Unit .x) 1 ) true) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) in (let u = (let u = 1 in false) in u)) in (unfold [ Bool ] (fold [ Nat ] (pred (((\x: Nat .\y: Nat .y) true ) 1)) )))
(((\x: Bool .\y: Nat .y) (( \f: Nat .((f (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = 1 , b = false , c =  0 }.b)) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .x) false ) true) ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .b)) ) (case <l = (( \f: Rec X. X .((f 0 ) (let u = 0 in 0) ) ) (\a: Unit .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y))
({a = (if ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Bool .a)) , c =  (let u = false in 1) }.b) then (succ (((\x: Unit .\y: Unit .x) 1 ) false)) else (if (case <r = (iszero 0) > as Nat of < l = x > => x | < r = y > => y) then (let u = ({a = true , b = 0 }.b) in (if true then 1 else 1)) else ({a = (let u = 1 in 1) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , c = (if true then 1 else 1) }.c))) , b = ({a = (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) (let u = false in 0) ) (fix (\x: Bool . false ))) ) ({a = (let u = 0 in 1) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = ({a = (let u = 0 in 1) , b = 0 }.b) }.c) ) ) (\a: Unit .\b: Nat .a)) , b = (let u = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Unit .x) 0 ) true) ) true) ) (((\x: Nat .\y: Nat .y) true ) 0) ) ) (\a: Nat .\b: Bool .a)) in (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) }.b)
(iszero (unfold [ Bool ] (fold [ Nat ] (if ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) false ) true) )) then ({a = 0 , b = true }.a) else (let u = 1 in 1)) )))
(case <r = (unfold [ Unit ] (fold [ Rec X. X ] (case <r = (iszero 0) > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (if ({a = ({a = false , b = 0 }.b) , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a)) , c =  (succ ({a = 0 , b = true , c = 0 }.c)) }.b) then (succ (if true then 0 else 1)) else (if (iszero 0) then 0 else (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)))) , b = ({a = ({a = (pred 1) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.b) , b = ({a = 1 , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) , c =  0 }.b) , c =  (case <l = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b)
(let u = (if ({a = (((\x: Nat .\y: Nat .y) (fix (\x: Nat . false )) ) true) , b = (iszero 1) }.b) then (iszero ({a = (succ 0) , b = true }.a)) else (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) in (fix (\x: Nat . ({a = false , b = 0 }.a) )))) in (((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f (( \f: Bool .((f false ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) ) ) (\a: Nat .\b: Nat .b)) ) (( \f: Nat .((f ({a = 1 , b = true }.b) ) (unfold [ Nat ] (fold [ Rec X. X ] (let u = 0 in true) )) ) ) (\a: Bool .\b: Nat .b))))
(case <l = (((\x: Nat .\y: Unit .y) (let u = ({a = (let u = true in true) , b = 0 }.b) in (fix (\x: Bool . (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .a)) ))) ) (((\x: Rec X. X .\y: Bool .x) ({a = ({a = 0 , b = false , c = 0 }.c) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)))) > as Unit of < l = x > => x | < r = y > => y)
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (iszero (unfold [ Bool ] (fold [ Bool ] 1 ))) )) in (pred ({a = (let u = 0 in u) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)))
(let u = (iszero (fix (\x: Bool . (succ (((\x: Bool .\y: Unit .y) false ) 0)) ))) in u)
({a = (let u = (if (( \f: Nat .((f (((\x: Nat .\y: Unit .y) false ) true) ) false ) ) (\a: Nat .\b: Unit .a)) then ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , b = 0 }.b) else (pred 1)) in (fix (\x: Bool . (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y) ))) , b = (( \f: Rec X. X .((f (pred (succ 0)) ) ({a = (((\x: Nat .\y: Nat .x) false ) false) , b = (let u = 1 in u) }.b) ) ) (\a: Bool .\b: Unit .b)) }.a)
(let u = (let u = ({a = (fix (\x: Rec X. X . (fix (\x: Rec X. X . 1 )) )) , b = (fix (\x: Unit . false )) , c =  (((\x: Unit .\y: Bool .y) (let u = false in true) ) (pred 0)) }.b) in (fix (\x: Rec X. X . (let u = true in true) ))) in (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .x) ({a = false , b = false }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .a))) ) (fix (\x: Nat . ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = 1 , b = false }.b) )) ))))
({a = (((\x: Rec X. X .\y: Nat .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Unit . false )) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Nat . false )) ))) , b = ({a = (let u = (if false then 1 else 0) in ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 ))) , b = (let u = 0 in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) }.b) }.b)
({a = ({a = ({a = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) , b = (((\x: Bool .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Bool ] true )) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) , b = ({a = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) in (fix (\x: Nat . 1 ))) , b = (((\x: Rec X. X .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] true )) ) false) }.a) }.b) , b = ({a = ({a = (((\x: Bool .\y: Unit .y) false ) false) , b = 1 }.b) , b = (iszero (let u = true in 0)) }.a) }.b)
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f ({a = (let u = ({a = true , b = 0 }.b) in 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (iszero 0) )) }.b) ) ({a = false , b = false }.b) ) ) (\a: Nat .\b: Nat .a)) )) , b = (((\x: Bool .\y: Rec X. X .y) (if (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) then (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) else ({a = false , b = 1 }.a)) ) (((\x: Nat .\y: Nat .x) ({a = 0 , b = false }.a) ) (let u = false in u))) }.b)
(((\x: Nat .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Bool ] (unfold [ Nat ] (fold [ Bool ] (let u = true in u) )) )) ) ({a = (iszero 1) , b = (( \f: Unit .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Nat .\b: Rec X. X .a)) }.b))
(let u = (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Nat .y) (( \f: Unit .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Nat .\y: Unit .y) false ) false)) ) (iszero (((\x: Nat .\y: Bool .x) 0 ) true))) in ({a = (( \f: Bool .((f (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (let u = true in true) , b = ({a = true , b = true }.b) }.b) ) ) (\a: Bool .\b: Unit .a)) , b = ({a = (succ ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) )) , c = (unfold [ Rec X. X ] (fold [ Bool ] (let u = 1 in u) )) }.c) }.b))
(( \f: Bool .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Bool . 0 )) )) ) (let u = (((\x: Unit .\y: Unit .x) ({a = 0 , b = false }.a) ) (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y)) in (fix (\x: Unit . (let u = false in ({a = 1 , b = true , c = 1 }.c)) ))) ) ) (\a: Bool .\b: Unit .b))
(fix (\x: Nat . (let u = (( \f: Rec X. X .((f (iszero 1) ) (if (fix (\x: Bool . true )) then (iszero 0) else (((\x: Unit .\y: Bool .y) true ) true)) ) ) (\a: Unit .\b: Bool .a)) in u) ))
(((\x: Rec X. X .\y: Bool .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .x) (let u = (let u = false in false) in u) ) (unfold [ Nat ] (fold [ Nat ] true ))) )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .x) ({a = ({a = (succ 0) , b = 1 }.b) , b = ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = (((\x: Bool .\y: Rec X. X .x) true ) true) }.b) , c =  (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) ) (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] true )) )) > as Nat of < l = x > => x | < r = y > => y)) )))
(let u = (if (((\x: Bool .\y: Unit .y) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in true) , c =  (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ({a = ({a = 1 , b = true }.a) , b = (if ({a = 0 , b = false }.b) then true else (((\x: Nat .\y: Bool .y) false ) true)) }.b)) then (succ (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) else (((\x: Rec X. X .\y: Unit .y) (fix (\x: Unit . ({a = (((\x: Unit .\y: Nat .y) true ) 1) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) )) ) (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . 1 )) )))) in (( \f: Unit .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) )) ) (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Nat .x) false ) true) ) ({a = (((\x: Unit .\y: Unit .y) false ) false) , b = 1 }.a)) ) ) (\a: Bool .\b: Bool .b)))
(((\x: Rec X. X .\y: Bool .y) (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Nat .x) (((\x: Rec X. X .\y: Nat .y) true ) false) ) (let u = true in true)) )) ) (let u = (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .x) (let u = false in false) ) false) ) (let u = (let u = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) in 1) in ({a = 1 , b = true }.b)) ) ) (\a: Unit .\b: Rec X. X .a)) in (if (let u = true in u) then (let u = true in u) else ({a = (let u = 0 in u) , b = true , c =  0 }.b))))
({a = (let u = (let u = (let u = true in 1) in (let u = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .a)) in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)))) in (((\x: Rec X. X .\y: Unit .x) ({a = true , b = 1 }.a) ) ({a = false , b = 0 }.a))) , b = (( \f: Rec X. X .((f (let u = false in ({a = 0 , b = true , c = 0 }.c)) ) (( \f: Bool .((f ({a = 0 , b = 0 }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .a)) }.a)
(if (((\x: Bool .\y: Bool .x) (let u = (if true then false else true) in (fix (\x: Bool . false ))) ) (case <r = (let u = true in true) > as Rec X. X of < l = x > => x | < r = y > => y)) then (succ (case <l = (let u = (let u = 1 in 0) in u) > as Bool of < l = x > => x | < r = y > => y)) else (succ (let u = 0 in 1)))
(if ({a = (let u = (( \f: Nat .((f (succ 1) ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) in (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)))) , b = (let u = (let u = true in true) in (let u = 1 in u)) }.a) then (if (iszero ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in (pred 0)) ))) then (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) (succ 0) ) ({a = true , b = 1 }.a)) )) else ({a = ({a = false , b = 1 }.b) , b = ({a = ({a = 1 , b = false }.a) , b = true }.a) }.b)) else (((\x: Rec X. X .\y: Nat .x) ({a = ({a = (let u = false in 0) , b = true }.a) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b))) in (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .y) true ) false) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .a)))))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Nat ] (if ({a = (let u = (succ 0) in true) , b = (let u = true in false) }.b) then (((\x: Nat .\y: Rec X. X .y) (let u = true in u) ) false) else (case <r = (let u = false in true) > as Rec X. X of < l = x > => x | < r = y > => y)) )) ))
(case <l = (case <l = (if (( \f: Unit .((f (( \f: Nat .((f ({a = 1 , b = false }.b) ) (if true then false else true) ) ) (\a: Bool .\b: Nat .a)) ) (let u = ({a = 0 , b = false }.b) in true) ) ) (\a: Unit .\b: Rec X. X .b)) then (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) true ) (((\x: Bool .\y: Nat .x) 0 ) false)) )) else (let u = true in 0)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <l = (fix (\x: Rec X. X . (let u = (let u = (let u = true in 0) in u) in (fix (\x: Bool . (((\x: Bool .\y: Nat .y) false ) 0) ))) )) > as Bool of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (iszero ({a = (fix (\x: Unit . (if true then 0 else 0) )) , b = (let u = 1 in 0) }.b)) ))
(let u = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = true in (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a))) )) ) (succ (let u = false in 0)) ) ) (\a: Nat .\b: Unit .a)) in (((\x: Nat .\y: Rec X. X .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.b) )) ) ({a = (((\x: Unit .\y: Bool .x) 0 ) false) , b = ({a = true , b = false }.b) , c =  1 }.b)))
(succ (let u = (if ({a = 0 , b = true }.b) then (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .a)) else ({a = 0 , b = false , c =  0 }.b)) in (pred (((\x: Unit .\y: Nat .y) false ) 1))))
(iszero (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .y) (iszero 0) ) ({a = (iszero 0) , b = (unfold [ Nat ] (fold [ Bool ] 0 )) }.b)) )))
(if (case <r = ({a = (succ 0) , b = ({a = true , b = true }.b) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = (iszero (let u = false in 1)) in (fix (\x: Unit . (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) false ) false) ) (((\x: Nat .\y: Nat .y) false ) false) ) ) (\a: Unit .\b: Unit .b)) ))) else (let u = ({a = ({a = (pred 0) , b = (let u = 0 in (let u = false in false)) , c =  (fix (\x: Nat . (pred 1) )) }.b) , b = (fix (\x: Rec X. X . false )) }.b) in (unfold [ Unit ] (fold [ Bool ] (fix (\x: Unit . true )) ))))
({a = ({a = (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 ))) , b = ({a = false , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.b) }.b) , b = ({a = (fix (\x: Bool . ({a = true , b = 0 }.b) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Rec X. X . true )) )) }.b) }.b)
(let u = (case <l = (((\x: Unit .\y: Nat .x) (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) )) ) (let u = ({a = (let u = true in 0) , b = ({a = 0 , b = false }.b) , c =  (((\x: Bool .\y: Rec X. X .x) 0 ) true) }.b) in u)) > as Unit of < l = x > => x | < r = y > => y) in (let u = (case <l = (let u = 1 in u) > as Unit of < l = x > => x | < r = y > => y) in u))
(fix (\x: Unit . (( \f: Unit .((f (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) false ) ) (\a: Bool .\b: Nat .a)) ) ({a = false , b = (let u = 0 in u) }.a) ) ) (\a: Nat .\b: Rec X. X .a)) ))
(succ (if ({a = (succ (unfold [ Nat ] (fold [ Unit ] 0 ))) , b = (( \f: Unit .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) then (succ (let u = 0 in 0)) else (( \f: Nat .((f (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 ))) ) (let u = 0 in u) ) ) (\a: Unit .\b: Bool .a))))
(succ (succ (let u = 1 in u)))
(((\x: Rec X. X .\y: Bool .y) (case <r = ({a = (case <r = (fix (\x: Bool . false )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <l = (( \f: Rec X. X .((f (let u = false in 1) ) (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ) ) (\a: Nat .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (( \f: Nat .((f ({a = false , b = ({a = false , b = 0 }.b) }.a) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Bool .b)) in u))
(fix (\x: Bool . (( \f: Unit .((f (( \f: Rec X. X .((f false ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Nat .b)) ) (unfold [ Nat ] (fold [ Rec X. X ] (let u = false in false) )) ) ) (\a: Unit .\b: Bool .a)) ))
(fix (\x: Unit . (let u = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ({a = 0 , b = 0 }.b) , b = (((\x: Nat .\y: Unit .y) true ) false) , c =  1 }.b) )) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.a) in (fix (\x: Unit . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ))) ))
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = true }.a) )) )) , b = (( \f: Unit .((f (let u = (((\x: Unit .\y: Bool .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y)) in u) ) (if (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) false ) true) )) then (let u = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) in u) else (iszero (succ 1))) ) ) (\a: Unit .\b: Bool .b)) }.a)
(pred ({a = (unfold [ Unit ] (fold [ Unit ] (case <r = (let u = (((\x: Unit .\y: Bool .x) true ) true) in u) > as Unit of < l = x > => x | < r = y > => y) )) , b = ({a = ({a = (fix (\x: Unit . 1 )) , b = 0 }.b) , b = (fix (\x: Bool . (let u = (let u = 1 in u) in true) )) }.a) }.b))
(((\x: Unit .\y: Bool .y) (( \f: Rec X. X .((f (iszero (succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )))) ) (case <r = ({a = 0 , b = false , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) ) ({a = (((\x: Bool .\y: Unit .y) ({a = (if (let u = 0 in true) then (((\x: Nat .\y: Rec X. X .y) true ) true) else (if true then false else true)) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) ) ({a = (let u = 1 in 0) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) }.a)) , b = (( \f: Unit .((f (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = false }.a) )) in (let u = 1 in true)) ) (case <r = (((\x: Nat .\y: Nat .x) true ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) , c =  (if (if (let u = false in true) then ({a = (let u = false in u) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.b) else (if (let u = true in u) then true else true)) then (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) in u) else (succ (let u = (fix (\x: Unit . 1 )) in u))) }.b))
(iszero ({a = (pred (((\x: Rec X. X .\y: Nat .x) 0 ) true)) , b = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) in (((\x: Bool .\y: Unit .x) false ) false)) }.a))
(( \f: Rec X. X .((f (if ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.a) )) then ({a = 1 , b = (let u = true in true) , c = 0 }.c) else ({a = 0 , b = (let u = 0 in false) }.a)) ) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in u) )) , b = (((\x: Bool .\y: Bool .y) false ) (fix (\x: Unit . false ))) , c = (( \f: Nat .((f ({a = 1 , b = 0 }.b) ) (pred (let u = 1 in u)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.c) ) ) (\a: Nat .\b: Bool .a))
(let u = (let u = (((\x: Nat .\y: Bool .y) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false ))) in (((\x: Bool .\y: Bool .y) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) false)) in (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = false }.b) )) )))
(let u = (succ (( \f: Unit .((f 0 ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))) in (pred ({a = (fix (\x: Nat . (((\x: Bool .\y: Bool .x) 0 ) true) )) , b = (((\x: Unit .\y: Rec X. X .y) (fix (\x: Unit . false )) ) false) }.a)))
(( \f: Unit .((f ({a = ({a = (pred 0) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (if false then (fix (\x: Bool . true )) else ({a = 1 , b = true }.b)) }.b) , c =  (let u = true in 0) }.b) ) (case <r = ({a = (let u = true in 0) , b = ({a = 0 , b = false }.b) , c =  (let u = true in 1) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (unfold [ Bool ] (fold [ Nat ] ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = 0 in 1) }.b) )) , b = (if ({a = (let u = (pred 1) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) , b = (( \f: Bool .((f (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) then (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) (((\x: Bool .\y: Unit .x) true ) false) ) ) (\a: Nat .\b: Nat .a)) else (let u = (if (unfold [ Nat ] (fold [ Bool ] false )) then false else false) in u)) }.b)
({a = ({a = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = 0 }.b) )) in u) , b = (fix (\x: Bool . (((\x: Bool .\y: Bool .y) true ) false) )) }.a) , b = ({a = (( \f: Nat .((f ({a = true , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) ) (fix (\x: Unit . ({a = false , b = 0 }.a) )) ) ) (\a: Nat .\b: Bool .b)) , b = (if (iszero 1) then (((\x: Nat .\y: Nat .x) (iszero 1) ) false) else (( \f: Rec X. X .((f (case <r = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = false in false) ) ) (\a: Unit .\b: Rec X. X .b))) }.b) }.b)
({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) , b = (if false then (fix (\x: Nat . 1 )) else (if true then 0 else 0)) }.b) , b = ({a = (case <l = (if (let u = 0 in true) then (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) else (let u = false in 1)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ({a = 0 , b = true }.b) , b = 0 }.a) }.b) , c = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (pred (let u = 0 in u)) )) }.c)
(let u = ({a = (((\x: Nat .\y: Rec X. X .x) ({a = 1 , b = true }.b) ) true) , b = (( \f: Bool .((f ({a = 1 , b = true }.a) ) (let u = true in (let u = 0 in 1)) ) ) (\a: Unit .\b: Rec X. X .b)) }.a) in u)
(fix (\x: Unit . (((\x: Rec X. X .\y: Unit .x) ({a = (let u = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) ))) , b = (pred (let u = ({a = 1 , b = false , c = 0 }.c) in u)) }.b) ) (if (let u = (( \f: Bool .((f 1 ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b)) in (if false then (((\x: Unit .\y: Rec X. X .x) false ) true) else true)) then ({a = true , b = ({a = 1 , b = 1 }.b) }.a) else (fix (\x: Unit . (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) )))) ))
(let u = ({a = ({a = ({a = 0 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = (let u = 0 in false) }.b) , b = (fix (\x: Rec X. X . ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) )) }.b) in (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .y) (iszero ({a = 1 , b = (succ 1) }.b)) ) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) false ) ) (\a: Bool .\b: Rec X. X .a))) ) (let u = (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ) false) in (unfold [ Bool ] (fold [ Unit ] false ))) ) ) (\a: Bool .\b: Unit .b)))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Nat .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) ) ({a = (let u = 1 in true) , b = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) )) }.a)) )) , b = ({a = (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f (if true then 0 else 1) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) ) ) (\a: Bool .\b: Bool .a)) ) (fix (\x: Unit . (case <r = false > as Unit of < l = x > => x | < r = y > => y) ))) , b = (let u = ({a = true , b = false }.b) in (((\x: Nat .\y: Nat .x) true ) false)) , c = (succ (pred 0)) }.c) }.b)
(case <r = (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] (let u = 1 in true) )) ) (let u = false in false) ) ) (\a: Bool .\b: Bool .a)) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Bool . true )) )) )) in (fix (\x: Unit . (( \f: Unit .((f ({a = 0 , b = true , c =  0 }.b) ) (unfold [ Unit ] (fold [ Unit ] false )) ) ) (\a: Unit .\b: Bool .b)) )))
(fix (\x: Nat . ({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) false)) , b = (let u = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) in u) }.a) ))
(pred (if (fix (\x: Rec X. X . (if true then true else true) )) then ({a = true , b = 0 }.b) else (succ (let u = false in 0))))
(case <l = ({a = ({a = (let u = false in 1) , b = (pred 1) }.b) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = true , b = 1 }.a) )) }.a) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Rec X. X .x) (if (if (iszero 0) then ({a = true , b = (((\x: Unit .\y: Rec X. X .x) 0 ) false) }.a) else (unfold [ Unit ] (fold [ Bool ] false ))) then (pred (case <l = ({a = ({a = false , b = 0 }.b) , b = true }.a) > as Nat of < l = x > => x | < r = y > => y)) else ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ({a = ({a = true , b = 1 }.b) , b = (if true then 0 else 0) }.b) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) }.a) ))) ) (( \f: Nat .((f (((\x: Nat .\y: Bool .y) ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = 0 }.a) ) (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y)) ) (let u = ({a = (let u = true in u) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) }.b) in ({a = (pred 0) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = true , b = true }.b) )) }.b)) ) ) (\a: Unit .\b: Rec X. X .b)))
(unfold [ Rec X. X ] (fold [ Nat ] (let u = (let u = (fix (\x: Unit . (let u = 0 in true) )) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) ))
({a = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f ({a = 0 , b = ({a = true , b = false }.b) , c = (unfold [ Bool ] (fold [ Unit ] 1 )) }.c) ) (if false then (fix (\x: Rec X. X . 1 )) else ({a = 0 , b = true }.a)) ) ) (\a: Nat .\b: Unit .a)) ) (case <r = (if true then false else false) > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (fix (\x: Unit . 1 )) in u) )) , b = (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .b)) in (((\x: Rec X. X .\y: Unit .y) ({a = true , b = false }.b) ) false)) , c =  (let u = (if true then 1 else 1) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 ))) }.b) , c = (let u = (((\x: Unit .\y: Rec X. X .y) false ) true) in (((\x: Nat .\y: Rec X. X .x) (let u = 0 in u) ) (let u = false in true))) }.c)
(( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Bool ] (let u = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)) in u) )) ) (unfold [ Nat ] (fold [ Rec X. X ] ({a = (if true then false else true) , b = (let u = ({a = 0 , b = true , c = 0 }.c) in (pred 0)) }.a) )) ) ) (\a: Rec X. X .\b: Unit .b))
(iszero (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 1 in u) )) ) (((\x: Unit .\y: Nat .x) 0 ) (let u = true in false)) ) ) (\a: Unit .\b: Bool .b)))
(let u = (((\x: Nat .\y: Unit .y) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) in (unfold [ Unit ] (fold [ Rec X. X ] false ))) ) (((\x: Unit .\y: Unit .y) false ) 0)) in u)
(let u = (iszero (let u = (if true then 0 else 0) in u)) in (((\x: Bool .\y: Rec X. X .x) ({a = (pred 0) , b = ({a = false , b = true }.b) , c =  (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.b) ) (((\x: Unit .\y: Nat .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) (unfold [ Bool ] (fold [ Rec X. X ] false )))))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Unit .x) (let u = 1 in ({a = 0 , b = true , c =  0 }.b)) ) ({a = 1 , b = (let u = 1 in true) , c =  1 }.b)) ) (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) in (( \f: Bool .((f (let u = 1 in 1) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) ) (\a: Unit .\b: Rec X. X .a)))) ))
(let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (pred ({a = 1 , b = true , c = 0 }.c)) )) in (iszero (let u = (if false then ({a = false , b = 0 }.a) else (((\x: Bool .\y: Unit .x) true ) false)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) )))))
(((\x: Nat .\y: Rec X. X .x) (if (let u = 1 in false) then (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) in u) else ({a = ({a = 0 , b = 1 }.b) , b = (fix (\x: Rec X. X . false )) }.b)) ) (iszero ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (pred (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) 1 ) ) (\a: Unit .\b: Unit .b))) ))))
(if (let u = (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 )) > as Nat of < l = x > => x | < r = y > => y) in (if (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) true ) ) (\a: Nat .\b: Nat .b)) then (let u = (fix (\x: Nat . 0 )) in (let u = true in true)) else ({a = true , b = false }.b))) then (((\x: Unit .\y: Unit .y) ({a = true , b = false }.b) ) (let u = (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) 0 ) true) )) in ({a = 0 , b = true }.b))) else (( \f: Unit .((f ({a = ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b) , b = (let u = (unfold [ Unit ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) )) in ({a = 1 , b = false , c =  0 }.b)) , c =  ({a = (if false then true else ({a = 0 , b = true }.b)) , b = ({a = 0 , b = false , c = 1 }.c) }.b) }.b) ) (fix (\x: Unit . ({a = (if false then true else ({a = 0 , b = false , c =  1 }.b)) , b = (((\x: Nat .\y: Unit .y) false ) 0) }.a) )) ) ) (\a: Rec X. X .\b: Nat .b)))
(let u = (let u = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) in u) in (((\x: Unit .\y: Bool .y) (let u = ({a = 1 , b = (((\x: Rec X. X .\y: Bool .x) false ) false) , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) }.b) in u) ) ({a = (((\x: Unit .\y: Rec X. X .x) 0 ) false) , b = (((\x: Nat .\y: Bool .y) ({a = 1 , b = true }.b) ) false) }.a)))
(pred (unfold [ Nat ] (fold [ Nat ] (if ({a = 1 , b = true , c =  0 }.b) then 1 else (let u = false in 0)) )))
({a = (case <l = ({a = (if false then true else false) , b = ({a = true , b = 1 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (let u = ({a = false , b = 0 }.a) in u) in u) }.b)
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) true ) true) )) ) (let u = true in u)) ) (let u = ({a = 1 , b = ({a = true , b = false }.b) }.b) in u) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(succ (let u = (let u = (fix (\x: Bool . 0 )) in (((\x: Rec X. X .\y: Rec X. X .y) false ) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)))) in (succ (fix (\x: Bool . 0 )))))
(fix (\x: Nat . (case <l = ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = (fix (\x: Nat . 1 )) }.b) > as Nat of < l = x > => x | < r = y > => y) ))
(let u = (case <r = (( \f: Unit .((f (iszero 1) ) (((\x: Unit .\y: Bool .x) false ) true) ) ) (\a: Bool .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) in u)
(fix (\x: Bool . (unfold [ Nat ] (fold [ Unit ] ({a = ({a = (succ 0) , b = (iszero (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a))) }.a) , b = ({a = 1 , b = (fix (\x: Rec X. X . true )) , c =  0 }.b) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) )) ))
(case <r = ({a = (fix (\x: Nat . (let u = (fix (\x: Unit . true )) in (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .b))) )) , b = (let u = (fix (\x: Nat . 0 )) in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) }.b) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Unit .((f ({a = (case <l = (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) , b = (if (((\x: Bool .\y: Rec X. X .y) false ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) then (let u = 0 in ({a = 1 , b = 0 }.b)) else ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = 0 }.b)) }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) , b = (fix (\x: Unit . true )) }.a) )) ) ) (\a: Rec X. X .\b: Unit .b))
(let u = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) (let u = 0 in true) ) (((\x: Bool .\y: Bool .y) false ) false)) ) ({a = (let u = ({a = 0 , b = false , c = 0 }.c) in u) , b = (if false then true else true) , c =  (let u = false in ({a = 0 , b = true }.a)) }.b) ) ) (\a: Unit .\b: Nat .a)) in u)
(( \f: Bool .((f (let u = ({a = (if false then false else (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a))) , b = (let u = false in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) }.b) in (( \f: Nat .((f (iszero 0) ) (let u = true in true) ) ) (\a: Bool .\b: Nat .a))) ) ({a = ({a = (let u = true in u) , b = (if (let u = true in u) then 1 else 1) }.a) , b = (( \f: Nat .((f (let u = 0 in true) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) ) ) (\a: Unit .\b: Unit .a))
(unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Unit .x) (let u = 1 in ({a = false , b = 1 }.a)) ) (let u = (((\x: Nat .\y: Unit .y) false ) true) in u)) ))
(let u = (if (let u = (unfold [ Nat ] (fold [ Rec X. X ] (let u = 1 in false) )) in (( \f: Rec X. X .((f (let u = true in u) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = false in u) )) ) ) (\a: Unit .\b: Rec X. X .a))) then (unfold [ Rec X. X ] (fold [ Bool ] ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = 0 }.b) }.b) )) else ({a = (let u = ({a = false , b = true }.b) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 ))) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) in (iszero (if ({a = 1 , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) then (( \f: Rec X. X .((f 0 ) (fix (\x: Unit . 1 )) ) ) (\a: Unit .\b: Bool .a)) else (let u = true in 1))))
(let u = (((\x: Unit .\y: Bool .x) (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Unit .x) ({a = (pred (((\x: Bool .\y: Nat .y) true ) 0)) , b = (fix (\x: Nat . false )) , c =  ({a = 0 , b = false }.a) }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (iszero (fix (\x: Nat . 1 ))) )))) in u)
(case <r = ({a = (( \f: Unit .((f (iszero ({a = 0 , b = ({a = false , b = true }.b) }.a)) ) (( \f: Rec X. X .((f (let u = true in u) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (if (if false then true else true) then (((\x: Unit .\y: Nat .y) true ) (let u = false in u)) else (if false then true else true)) }.b) > as Nat of < l = x > => x | < r = y > => y)
(pred (case <l = (((\x: Bool .\y: Nat .x) (if (iszero 0) then (pred 1) else (((\x: Unit .\y: Nat .x) (succ 0) ) ({a = true , b = false }.b))) ) (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) (let u = true in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = true , b = (let u = 1 in false) }.b))) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Bool .((f ({a = ({a = ({a = 1 , b = ({a = false , b = false }.b) }.a) , b = (((\x: Nat .\y: Nat .y) false ) true) , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) }.c) , b = (let u = (( \f: Bool .((f (((\x: Bool .\y: Bool .x) false ) false) ) true ) ) (\a: Nat .\b: Bool .b)) in u) }.b) ) (((\x: Nat .\y: Bool .x) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (if true then 1 else 0) )) , b = (( \f: Nat .((f false ) ({a = false , b = true }.b) ) ) (\a: Nat .\b: Bool .b)) }.b) ) (((\x: Bool .\y: Bool .x) ({a = 0 , b = (let u = false in u) , c =  0 }.b) ) (let u = ({a = true , b = 1 }.a) in (fix (\x: Unit . false ))))) ) ) (\a: Nat .\b: Unit .a))
(let u = (( \f: Bool .((f (fix (\x: Rec X. X . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Nat ] false )) )) ) ) (\a: Rec X. X .\b: Unit .a)) in u)
(unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Rec X. X . (( \f: Unit .((f (if false then 0 else 1) ) (let u = 0 in u) ) ) (\a: Bool .\b: Unit .b)) )) ))
(let u = (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f ({a = 1 , b = true }.b) ) (let u = 0 in ({a = true , b = false }.b)) ) ) (\a: Rec X. X .\b: Nat .b)) )) in (( \f: Unit .((f (succ (let u = (let u = (((\x: Nat .\y: Unit .x) false ) false) in false) in (let u = 0 in u))) ) ({a = (((\x: Rec X. X .\y: Nat .x) (let u = true in false) ) (let u = (succ 0) in (unfold [ Bool ] (fold [ Rec X. X ] false )))) , b = ({a = ({a = false , b = ({a = false , b = 0 }.b) }.b) , b = (if true then true else true) , c = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) }.c) }.b) ) ) (\a: Unit .\b: Unit .b)))
({a = ({a = (let u = (unfold [ Rec X. X ] (fold [ Unit ] false )) in 1) , b = (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ({a = (let u = (( \f: Bool .((f ({a = true , b = false }.b) ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Bool .a)) in ({a = ({a = 1 , b = true , c = 0 }.c) , b = false }.b)) , b = (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) (iszero (((\x: Rec X. X .\y: Bool .x) 0 ) true))) }.b) }.b)
(let u = (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Nat .y) (let u = true in u) ) false) ) ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = (iszero 0) , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Unit . 0 )) )) }.c)) in (let u = (let u = ({a = 0 , b = false , c =  1 }.b) in (if true then false else true)) in (fix (\x: Nat . (if (if (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) then true else ({a = 0 , b = false }.b)) then ({a = ({a = true , b = false }.b) , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) else ({a = 1 , b = true }.b)) ))))
(if (((\x: Bool .\y: Unit .y) (( \f: Nat .((f (let u = true in u) ) ({a = 1 , b = false , c =  (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.b) ) ) (\a: Unit .\b: Nat .b)) ) (((\x: Nat .\y: Rec X. X .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .x) true ) false) )) ) ({a = ({a = 0 , b = false }.a) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b))) then (((\x: Bool .\y: Bool .x) ({a = (case <r = (((\x: Nat .\y: Nat .x) false ) true) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.b) ) (fix (\x: Bool . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in true) )) ))) else (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = false , b = 0 }.b) )) ) ({a = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .a)) , b = (pred 1) }.b) ) ) (\a: Rec X. X .\b: Bool .b)))
({a = (let u = (if (((\x: Bool .\y: Bool .x) true ) true) then (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) else ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) , b = (((\x: Unit .\y: Nat .x) 0 ) false) }.b)) in (( \f: Unit .((f ({a = true , b = 1 }.b) ) (succ 1) ) ) (\a: Unit .\b: Rec X. X .a))) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .b))) )) }.b)
(case <l = ({a = (( \f: Unit .((f (let u = true in 0) ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = (case <r = ({a = 0 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) , c = (( \f: Unit .((f 1 ) (let u = 1 in u) ) ) (\a: Bool .\b: Nat .b)) }.c) > as Unit of < l = x > => x | < r = y > => y)
({a = (let u = ({a = ({a = (if false then 1 else 1) , b = (unfold [ Nat ] (fold [ Bool ] false )) }.a) , b = ({a = 1 , b = ({a = false , b = true }.b) , c =  ({a = 0 , b = 0 }.b) }.b) , c =  ({a = 1 , b = (if false then false else false) , c = ({a = 1 , b = false , c = 1 }.c) }.c) }.b) in (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (succ 0))) , b = (let u = (case <r = (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Unit .((f (( \f: Unit .((f (let u = true in true) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Nat .b)) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Nat .a))) , c = ({a = ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .x) false ) true) ) false ) ) (\a: Unit .\b: Bool .a)) }.a) }.c)
(((\x: Bool .\y: Unit .x) (if (unfold [ Unit ] (fold [ Rec X. X ] (let u = true in u) )) then ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) else (let u = (( \f: Bool .((f (let u = (succ 0) in u) ) (let u = false in 1) ) ) (\a: Rec X. X .\b: Nat .b)) in u)) ) (iszero ({a = (let u = 1 in u) , b = (( \f: Bool .((f ({a = true , b = 1 }.b) ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.b)))
(((\x: Rec X. X .\y: Bool .y) (( \f: Nat .((f (( \f: Bool .((f ({a = 1 , b = (let u = 1 in false) }.b) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) ) (let u = (iszero 1) in u) ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Rec X. X .((f (( \f: Unit .((f (let u = 0 in 1) ) (succ ({a = 0 , b = false , c = 0 }.c)) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (let u = true in 0) , b = ({a = 0 , b = true , c =  1 }.b) , c = (if (let u = false in false) then ({a = 1 , b = false , c = 0 }.c) else 1) }.c) ) ) (\a: Bool .\b: Nat .b)))
(fix (\x: Nat . ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (let u = false in false) else ({a = 0 , b = false , c =  1 }.b)) )) ))
(( \f: Unit .((f (pred (unfold [ Unit ] (fold [ Nat ] (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) 1 ) true) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) ))) ) (case <l = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b))
(unfold [ Bool ] (fold [ Bool ] (fix (\x: Bool . ({a = ({a = 1 , b = ({a = false , b = 0 }.a) }.a) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = true , b = (if false then true else true) }.b) , c =  (let u = ({a = 0 , b = false , c = 1 }.c) in 1) }.b) , c = (succ (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.c) )) ))
({a = ({a = (if (unfold [ Rec X. X ] (fold [ Bool ] false )) then ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 )) else (unfold [ Nat ] (fold [ Nat ] 1 ))) , b = (fix (\x: Rec X. X . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) )) }.b) , b = ({a = ({a = (let u = true in u) , b = 0 }.a) , b = (( \f: Unit .((f (let u = true in 0) ) 1 ) ) (\a: Nat .\b: Nat .a)) }.a) }.b)
(unfold [ Bool ] (fold [ Nat ] (let u = (((\x: Rec X. X .\y: Nat .y) ({a = false , b = 1 }.a) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b))) in u) ))
(fix (\x: Unit . ({a = (((\x: Rec X. X .\y: Bool .y) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) true) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.b) ) (((\x: Bool .\y: Rec X. X .x) 1 ) false)) , b = (let u = ({a = (if (let u = 1 in false) then 0 else ({a = 1 , b = false , c = 1 }.c)) , b = (let u = 0 in (unfold [ Unit ] (fold [ Bool ] true ))) , c = (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) }.c) in (fix (\x: Rec X. X . ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ))) }.b) ))
(unfold [ Rec X. X ] (fold [ Unit ] (let u = (if (iszero (pred 1)) then (let u = (let u = true in true) in u) else (iszero 1)) in (if ({a = true , b = true }.b) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) else (((\x: Rec X. X .\y: Unit .y) false ) true))) ))
(case <r = (if ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Unit ] false )) )) then ({a = (let u = 0 in true) , b = (pred 0) }.a) else (if (fix (\x: Unit . false )) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else (case <r = false > as Nat of < l = x > => x | < r = y > => y))) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (let u = (case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ))) , b = (let u = (((\x: Nat .\y: Rec X. X .x) ({a = 1 , b = false }.b) ) (((\x: Rec X. X .\y: Nat .y) false ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)))) in u) , c =  (let u = ({a = ({a = false , b = true }.b) , b = ({a = 0 , b = false }.a) }.a) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) }.b)
(( \f: Rec X. X .((f (case <l = (unfold [ Unit ] (fold [ Unit ] (fix (\x: Nat . 1 )) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (iszero (succ (let u = 1 in 0))) in (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in 1) )))) ) ) (\a: Nat .\b: Unit .b))
(let u = (case <l = (case <l = (let u = ({a = 1 , b = false }.b) in ({a = 1 , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in (case <l = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Bool .x) (case <l = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 0)) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(case <r = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (((\x: Bool .\y: Nat .x) 0 ) (let u = true in u)) , b = (let u = true in u) , c =  (((\x: Nat .\y: Bool .y) true ) 0) }.b) )) in u) > as Bool of < l = x > => x | < r = y > => y)
(let u = (pred (let u = 1 in u)) in (fix (\x: Bool . ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) , c =  ({a = 1 , b = 0 }.b) }.b) )))
(( \f: Nat .((f (let u = ({a = 1 , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) , c =  1 }.b) in ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.b)) ) (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .x) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) (((\x: Rec X. X .\y: Nat .x) true ) false)) )) in (if true then 1 else 0)) ) ) (\a: Bool .\b: Bool .a))
(succ (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .y) (if false then false else false) ) (pred 1)) ) (let u = (let u = 1 in u) in (let u = ({a = 1 , b = false , c = 1 }.c) in 0)) ) ) (\a: Unit .\b: Bool .b)) )))
((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 0 in u) )) , b = (((\x: Rec X. X .\y: Unit .y) ({a = 1 , b = true , c =  0 }.b) ) false) , c = (( \f: Bool .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Unit ] 1 )) ) ) (\a: Unit .\b: Nat .a)) }.c) > as Nat of < l = x > => x | < r = y > => y) ))
(let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (succ 1) )) )) in (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = ({a = 1 , b = false , c =  1 }.b) }.b) ) ({a = false , b = true }.b)))
(let u = (((\x: Unit .\y: Nat .x) (( \f: Nat .((f (iszero (unfold [ Nat ] (fold [ Bool ] (let u = true in 0) ))) ) ({a = ({a = true , b = 0 }.b) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) }.b) ) ) (\a: Nat .\b: Bool .b)) ) (iszero (if true then 0 else 1))) in (( \f: Unit .((f (case <r = (if false then true else false) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = (((\x: Bool .\y: Bool .x) true ) true) }.b) ) ) (\a: Nat .\b: Unit .a)))
(fix (\x: Nat . (((\x: Unit .\y: Rec X. X .x) (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) ) (iszero ({a = (pred 0) , b = ({a = 1 , b = false , c = 0 }.c) }.b))) ))
(( \f: Rec X. X .((f (let u = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true }.a) }.b) in u) ) (( \f: Unit .((f ({a = (pred 1) , b = (let u = 1 in false) }.a) ) (fix (\x: Nat . ({a = (let u = false in u) , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.b) )) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Unit .a))
(unfold [ Bool ] (fold [ Unit ] (case <r = (let u = true in false) > as Nat of < l = x > => x | < r = y > => y) ))
(fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Nat ] ({a = ({a = false , b = 1 }.b) , b = (((\x: Rec X. X .\y: Unit .x) true ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .a))) , c =  ({a = 0 , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.a) }.b) )) ))
({a = (let u = (succ ({a = 0 , b = true }.a)) in ({a = (fix (\x: Nat . true )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.b)) , b = (( \f: Rec X. X .((f (let u = ({a = false , b = 1 }.b) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ({a = (let u = 1 in 1) , b = (( \f: Unit .((f true ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Unit .b)) }.a) ) ) (\a: Nat .\b: Unit .b)) }.b)
(pred (unfold [ Unit ] (fold [ Bool ] (let u = (( \f: Bool .((f (let u = 0 in false) ) (( \f: Unit .((f false ) (let u = 0 in true) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .b)) in (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b))) )))
({a = ({a = (succ (fix (\x: Nat . 0 ))) , b = ({a = ({a = false , b = 0 }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) , c =  (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) }.b) , b = (let u = (let u = (((\x: Nat .\y: Nat .x) false ) false) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b))) in (iszero (( \f: Bool .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) 1 ) ) (\a: Nat .\b: Unit .a)))) }.b)
(succ (((\x: Bool .\y: Bool .y) (let u = 1 in (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) ) (unfold [ Unit ] (fold [ Nat ] 1 ))))
({a = ({a = (fix (\x: Bool . ({a = true , b = 1 }.b) )) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) }.a) , b = (iszero (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Bool .y) true ) 0))) }.a)
(let u = (let u = (case <r = ({a = 0 , b = false , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) in (pred (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)))) in u)
(let u = ({a = (((\x: Bool .\y: Bool .y) false ) 1) , b = (let u = (if false then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else (fix (\x: Rec X. X . 0 ))) in ({a = true , b = 0 }.a)) }.b) in ({a = (( \f: Unit .((f (( \f: Bool .((f (( \f: Bool .((f true ) (let u = false in u) ) ) (\a: Nat .\b: Bool .a)) ) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Nat .b)) ) ({a = ({a = 0 , b = false }.a) , b = false }.b) ) ) (\a: Unit .\b: Nat .b)) , b = (succ (((\x: Nat .\y: Nat .y) (let u = true in false) ) 1)) }.b))
(unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Unit . (case <r = ({a = 0 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) )) ))
(( \f: Unit .((f ({a = (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in ({a = (let u = true in false) , b = ({a = true , b = 0 }.b) }.b)) , b = (case <r = ({a = (pred 0) , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] (if false then true else true) )) )) ) (fix (\x: Unit . ({a = 0 , b = false , c =  0 }.b) )) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Rec X. X .b))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Rec X. X . ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (( \f: Unit .((f 0 ) (fix (\x: Nat . 0 )) ) ) (\a: Unit .\b: Nat .b)) )) )) ))
(( \f: Unit .((f (( \f: Unit .((f ({a = false , b = ({a = 0 , b = false }.a) }.a) ) (((\x: Bool .\y: Nat .x) (( \f: Unit .((f false ) (fix (\x: Rec X. X . false )) ) ) (\a: Bool .\b: Bool .a)) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (unfold [ Unit ] (fold [ Bool ] (if (let u = false in u) then true else true) )) ) ) (\a: Nat .\b: Nat .a))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Unit .\y: Unit .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a)) )) ) (if false then true else false)) )) in u)
({a = (((\x: Bool .\y: Rec X. X .x) ({a = ({a = false , b = 0 }.a) , b = 1 }.b) ) (iszero 1)) , b = (((\x: Bool .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .x) true ) (iszero 0)) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b))) , c = (((\x: Nat .\y: Nat .y) ({a = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Unit .y) true ) false) }.b) ) (let u = true in 0)) }.c)
(let u = (((\x: Bool .\y: Rec X. X .y) (fix (\x: Unit . true )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (if false then 0 else 0) ))) in u)
({a = (let u = (let u = ({a = 1 , b = false , c = 1 }.c) in ({a = 0 , b = 0 }.b)) in ({a = 1 , b = 0 }.b)) , b = (fix (\x: Rec X. X . (case <r = (if (let u = 1 in (iszero 0)) then (let u = false in u) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) > as Unit of < l = x > => x | < r = y > => y) )) , c =  (succ (if (( \f: Rec X. X .((f (let u = false in true) ) (if false then false else true) ) ) (\a: Rec X. X .\b: Nat .a)) then (succ 0) else (fix (\x: Unit . 0 )))) }.b)
({a = (((\x: Bool .\y: Rec X. X .y) (let u = (succ 1) in (unfold [ Nat ] (fold [ Unit ] true ))) ) (if ({a = (((\x: Bool .\y: Bool .x) true ) false) , b = (succ (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a))) }.a) then (let u = (let u = 1 in 0) in u) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 0 in u) )))) , b = (let u = ({a = (let u = 0 in (if true then 0 else 0)) , b = (let u = false in u) }.b) in u) }.b)
({a = (case <l = (((\x: Unit .\y: Rec X. X .y) (unfold [ Bool ] (fold [ Rec X. X ] (iszero 0) )) ) (let u = 1 in 1)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) }.b) )) }.a)
({a = (pred (let u = (( \f: Bool .((f 0 ) (if false then 1 else 0) ) ) (\a: Unit .\b: Rec X. X .a)) in u)) , b = (let u = (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Rec X. X ] false )) )) in u) }.b)
({a = ({a = (let u = ({a = 0 , b = 0 }.b) in ({a = true , b = 1 }.b)) , b = (let u = (case <r = ({a = 0 , b = true , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) in u) , c =  ({a = (let u = ({a = true , b = 0 }.b) in (let u = 1 in 1)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) }.a) }.b) , b = (let u = (iszero 0) in (pred ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = true }.a))) }.b)
(let u = (let u = (( \f: Bool .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) in (let u = 1 in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) in (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) (case <r = ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = (if false then true else true) , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y)))
(((\x: Rec X. X .\y: Nat .x) (( \f: Unit .((f ({a = (let u = (let u = false in 1) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (let u = (iszero (let u = 0 in u)) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.b) ) (unfold [ Bool ] (fold [ Unit ] (pred (let u = false in (((\x: Rec X. X .\y: Rec X. X .y) true ) 1))) )) ) ) (\a: Rec X. X .\b: Bool .a)) ) (((\x: Bool .\y: Nat .y) (let u = (((\x: Unit .\y: Rec X. X .x) false ) ({a = 0 , b = true }.b)) in u) ) (((\x: Unit .\y: Nat .x) (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )))))
({a = (fix (\x: Rec X. X . (let u = (((\x: Nat .\y: Bool .x) (let u = 0 in 0) ) (let u = true in false)) in (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y)) )) , b = (( \f: Rec X. X .((f ({a = (fix (\x: Unit . true )) , b = (let u = 1 in 0) }.a) ) (unfold [ Nat ] (fold [ Rec X. X ] ({a = ({a = 0 , b = false }.a) , b = (let u = false in u) }.b) )) ) ) (\a: Bool .\b: Unit .b)) , c = (unfold [ Nat ] (fold [ Nat ] (if (iszero 1) then (let u = 0 in u) else (( \f: Unit .((f (let u = 0 in u) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Nat .\b: Unit .b))) )) }.c)
(let u = (fix (\x: Bool . (let u = (let u = 0 in ({a = 0 , b = false , c =  1 }.b)) in (let u = 1 in (unfold [ Unit ] (fold [ Nat ] true )))) )) in (fix (\x: Rec X. X . ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Unit .\y: Rec X. X .y) true ) 1) }.b) )))
(let u = (let u = (let u = (pred 1) in ({a = (let u = true in false) , b = 0 }.a)) in (pred (((\x: Bool .\y: Nat .x) 0 ) false))) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (((\x: Rec X. X .\y: Bool .y) true ) true) in u) )))
({a = (((\x: Unit .\y: Unit .x) (if ({a = 0 , b = false }.b) then ({a = false , b = false }.b) else (((\x: Bool .\y: Rec X. X .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)))) ) (let u = true in u)) , b = (( \f: Unit .((f (let u = false in (fix (\x: Bool . false ))) ) (((\x: Rec X. X .\y: Nat .x) (fix (\x: Bool . (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) )) ) (fix (\x: Rec X. X . true ))) ) ) (\a: Unit .\b: Rec X. X .a)) }.b)
(fix (\x: Nat . (((\x: Bool .\y: Bool .y) (case <r = (let u = (fix (\x: Unit . false )) in (let u = true in u)) > as Bool of < l = x > => x | < r = y > => y) ) ({a = 0 , b = ({a = 1 , b = true }.b) , c =  1 }.b)) ))
(case <r = (case <r = (let u = 1 in ({a = false , b = false }.b)) > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = (succ (succ 1)) , b = (( \f: Bool .((f (let u = 1 in true) ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Bool .b)) }.b) in (let u = ({a = (unfold [ Rec X. X ] (fold [ Bool ] ({a = 0 , b = false }.a) )) , b = (((\x: Bool .\y: Bool .x) 0 ) false) }.b) in (case <l = (((\x: Bool .\y: Nat .y) (let u = true in u) ) ({a = ({a = true , b = 0 }.a) , b = (succ 1) }.b)) > as Bool of < l = x > => x | < r = y > => y)))
(fix (\x: Bool . (case <l = (((\x: Bool .\y: Nat .x) (let u = 1 in u) ) (let u = 0 in true)) > as Nat of < l = x > => x | < r = y > => y) ))
(unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f (((\x: Unit .\y: Unit .x) ({a = 1 , b = 0 }.b) ) false) ) ({a = (let u = 0 in 1) , b = (unfold [ Nat ] (fold [ Unit ] true )) , c = (let u = 0 in u) }.c) ) ) (\a: Unit .\b: Unit .b)) ))
(let u = (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) > as Unit of < l = x > => x | < r = y > => y) in u)
(succ (case <l = (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) false ) 1) ))) > as Nat of < l = x > => x | < r = y > => y))
(let u = (case <r = (if (let u = true in true) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b))) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(((\x: Rec X. X .\y: Bool .y) (let u = ({a = (case <r = (((\x: Bool .\y: Unit .y) true ) false) > as Nat of < l = x > => x | < r = y > => y) , b = (pred (fix (\x: Rec X. X . 0 ))) }.b) in (( \f: Nat .((f (let u = 0 in false) ) ({a = true , b = 1 }.a) ) ) (\a: Unit .\b: Unit .b))) ) (iszero (let u = (let u = 1 in u) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)))))
(fix (\x: Nat . (fix (\x: Bool . (if (( \f: Rec X. X .((f (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) false ) ) (\a: Nat .\b: Nat .b)) then (iszero 1) else ({a = ({a = false , b = 0 }.a) , b = (let u = false in 0) }.a)) )) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = (( \f: Bool .((f ({a = 1 , b = 1 }.b) ) (succ 0) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = ({a = true , b = false }.b) , b = 1 }.a) }.a) ))
(if (( \f: Rec X. X .((f ({a = ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = ({a = true , b = 1 }.a) , c =  1 }.b) , b = ({a = (let u = 1 in 1) , b = (iszero 0) }.a) }.a) ) (let u = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .y) false ) true) )) in (let u = (((\x: Rec X. X .\y: Unit .y) false ) true) in ({a = 0 , b = true }.b))) ) ) (\a: Nat .\b: Rec X. X .a)) then (let u = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) )) in u) else (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = ({a = (let u = 0 in 1) , b = false , c = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.c) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false )) ) true ) ) (\a: Unit .\b: Rec X. X .b)) , c = (succ 0) }.c) ) (if (if false then false else false) then (((\x: Nat .\y: Bool .y) false ) 0) else (((\x: Nat .\y: Rec X. X .y) (if false then false else true) ) 0)) ) ) (\a: Unit .\b: Rec X. X .a)) )))
(unfold [ Bool ] (fold [ Unit ] (let u = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)) )) in u) in ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 1 , b = false , c =  1 }.b) }.b)) ))
({a = ({a = ({a = ({a = (pred 0) , b = false }.a) , b = (fix (\x: Bool . false )) , c = (((\x: Bool .\y: Nat .x) 0 ) true) }.c) , b = ({a = (let u = true in 0) , b = (( \f: Unit .((f (let u = 1 in false) ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.a) }.b) , b = (let u = (let u = (((\x: Unit .\y: Unit .x) (((\x: Bool .\y: Nat .x) true ) true) ) (let u = 0 in true)) in u) in ({a = 0 , b = (let u = false in false) }.a)) }.b)
(((\x: Unit .\y: Bool .y) (let u = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) )) , b = ({a = true , b = 0 }.b) }.b) in (let u = (fix (\x: Rec X. X . (iszero 0) )) in u)) ) (((\x: Nat .\y: Bool .x) (pred ({a = ({a = (iszero 1) , b = (fix (\x: Nat . 1 )) }.a) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.b)) ) (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Bool . true )) ))))
(if (case <r = (let u = (let u = 1 in 1) in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) then (pred (( \f: Unit .((f (if (iszero 1) then 0 else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Bool .b))) else (let u = (succ ({a = 1 , b = false }.a)) in (( \f: Bool .((f 0 ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Rec X. X .\b: Unit .a))))
({a = (let u = (let u = ({a = ({a = 0 , b = false }.b) , b = (((\x: Nat .\y: Unit .y) true ) true) }.b) in u) in (if (unfold [ Rec X. X ] (fold [ Nat ] (iszero (fix (\x: Nat . 1 ))) )) then ({a = 1 , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) else (((\x: Nat .\y: Rec X. X .x) 1 ) (iszero 1)))) , b = ({a = (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .x) true ) true) ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (succ (pred 0)) }.a) , c =  (fix (\x: Nat . ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) )) )) }.b)
(fix (\x: Nat . (succ (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y)) ))
(unfold [ Bool ] (fold [ Bool ] ({a = ({a = 1 , b = false , c =  (if false then 0 else 1) }.b) , b = (((\x: Nat .\y: Rec X. X .x) (if false then 0 else 1) ) (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) ({a = true , b = false }.b) ) ) (\a: Unit .\b: Rec X. X .a))) }.a) ))
(if (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = 1 , b = true }.b)) ) (((\x: Unit .\y: Nat .x) ({a = 0 , b = true }.b) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then ({a = (if (iszero 0) then (fix (\x: Unit . 1 )) else ({a = ({a = true , b = 0 }.b) , b = (let u = false in 1) }.b)) , b = (let u = ({a = ({a = true , b = 1 }.a) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) in u) }.b) else (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f ({a = 0 , b = false , c = 1 }.c) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) )))
(pred ({a = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Rec X. X .\y: Nat .x) false ) false) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = false }.a) )) }.b))
(( \f: Rec X. X .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Unit .y) ({a = 0 , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) , c =  1 }.b) ) (if true then true else true)) )) ) ({a = (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (if true then 1 else 0) ) ) (\a: Unit .\b: Nat .a)) , b = (let u = (( \f: Rec X. X .((f 0 ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (let u = false in true)) }.b) ) ) (\a: Nat .\b: Unit .b))
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = (if (( \f: Unit .((f (case <r = (let u = true in u) > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) ) (\a: Unit .\b: Unit .a)) then (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b))) else (fix (\x: Nat . ({a = 1 , b = false }.b) ))) , b = (let u = ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .b)) , b = ({a = false , b = 1 }.a) }.b) in u) }.b) ))
(let u = (case <l = (pred (((\x: Unit .\y: Bool .y) ({a = 1 , b = false , c =  1 }.b) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = true }.a))) > as Nat of < l = x > => x | < r = y > => y) in (let u = ({a = 0 , b = (iszero 0) , c =  0 }.b) in (((\x: Bool .\y: Nat .x) (pred 1) ) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = true , c =  0 }.b))))
({a = (( \f: Unit .((f (case <r = ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) (iszero 0)) , b = (((\x: Unit .\y: Nat .x) true ) false) , c =  (fix (\x: Bool . 1 )) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (( \f: Bool .((f (let u = false in 1) ) (((\x: Rec X. X .\y: Nat .y) true ) 1) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (if ({a = ({a = 1 , b = false , c =  0 }.b) , b = (let u = false in false) }.b) then ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) else (iszero 1)) , c =  ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = (let u = true in false) , c = 0 }.c) }.b) ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Bool .\y: Bool .y) (iszero (((\x: Nat .\y: Nat .x) ({a = 0 , b = true , c = 1 }.c) ) (let u = true in u))) ) (iszero ({a = 0 , b = true }.a))) }.b)
(( \f: Rec X. X .((f ({a = (case <r = ({a = 1 , b = false , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) , b = (if true then false else true) , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Bool . 0 )) )) }.c) ) (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) in (fix (\x: Unit . 1 ))) ) ) (\a: Nat .\b: Bool .a)) }.b) ) ({a = (pred (pred 1)) , b = (pred (((\x: Rec X. X .\y: Nat .y) true ) 1)) }.b) ) ) (\a: Rec X. X .\b: Unit .b))
(iszero (((\x: Bool .\y: Rec X. X .y) (fix (\x: Nat . false )) ) (((\x: Unit .\y: Rec X. X .y) ({a = 0 , b = true }.b) ) (((\x: Unit .\y: Bool .y) false ) 1))))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b))) )) ))
({a = (if (fix (\x: Nat . ({a = false , b = 1 }.a) )) then ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (iszero 1) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b) )) else (let u = ({a = (((\x: Unit .\y: Nat .y) true ) 0) , b = (pred 0) }.b) in ({a = 0 , b = false , c = 0 }.c))) , b = (((\x: Bool .\y: Nat .x) (( \f: Bool .((f (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) )) ) (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) then true else false) ) ) (\a: Nat .\b: Unit .b)) ) (( \f: Unit .((f ({a = (unfold [ Bool ] (fold [ Bool ] 1 )) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  ({a = 1 , b = true , c = 0 }.c) }.b) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Nat .b))) , c = (fix (\x: Bool . (let u = (((\x: Unit .\y: Nat .y) false ) 0) in u) )) }.c)
(if (( \f: Unit .((f (fix (\x: Rec X. X . (((\x: Unit .\y: Bool .y) true ) ({a = false , b = true }.b)) )) ) (unfold [ Nat ] (fold [ Bool ] ({a = 0 , b = false }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) then ({a = ({a = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .x) true ) true) }.b) , b = (let u = (let u = 1 in 1) in 0) }.b) , b = ({a = ({a = (case <l = (let u = false in 1) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in false) , c =  (((\x: Bool .\y: Rec X. X .x) 1 ) true) }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) }.b) }.b) else (fix (\x: Nat . ({a = 0 , b = false , c =  1 }.b) )))
(pred ({a = (((\x: Rec X. X .\y: Rec X. X .y) (let u = 1 in false) ) (((\x: Rec X. X .\y: Unit .x) 1 ) false)) , b = (iszero (((\x: Nat .\y: Bool .x) 0 ) (((\x: Unit .\y: Rec X. X .y) true ) false))) }.a))
(if ({a = (((\x: Rec X. X .\y: Bool .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (let u = 1 in (iszero 1))) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = true , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) )) }.b) then ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (let u = 1 in (let u = true in 1))) )) else ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) )) )))
({a = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.b) ) (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .x) false ) true) ))) )) , b = (iszero (let u = (let u = 0 in 1) in u)) }.b)
(let u = (((\x: Bool .\y: Unit .y) (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) false ) true) ) (((\x: Nat .\y: Rec X. X .y) true ) true) ) ) (\a: Rec X. X .\b: Nat .a)) ) (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Rec X. X .y) false ) 1) ))) in (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .y) (( \f: Rec X. X .((f ({a = true , b = false }.b) ) true ) ) (\a: Nat .\b: Unit .b)) ) ({a = 1 , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.b)) ) (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) ) ) (\a: Rec X. X .\b: Nat .a)))
(let u = (( \f: Nat .((f ({a = (fix (\x: Nat . 0 )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false )) , c =  ({a = 1 , b = 1 }.b) }.b) ) ({a = (succ (let u = false in 1)) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = 1 }.a) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) in (unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f (((\x: Bool .\y: Bool .x) 1 ) true) ) (let u = ({a = 0 , b = true , c = 0 }.c) in 0) ) ) (\a: Unit .\b: Nat .a)) )))
(iszero (pred ({a = (let u = false in 1) , b = (((\x: Nat .\y: Rec X. X .x) false ) true) }.a)))
(let u = (( \f: Nat .((f ({a = ({a = 0 , b = false , c = 0 }.c) , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) , c = ({a = 1 , b = false , c = 0 }.c) }.c) ) ({a = (if (let u = 0 in true) then ({a = 0 , b = 1 }.b) else 1) , b = (if (if true then true else false) then (unfold [ Unit ] (fold [ Unit ] (fix (\x: Unit . true )) )) else ({a = 1 , b = false , c =  0 }.b)) , c = (succ (((\x: Unit .\y: Bool .y) false ) 0)) }.c) ) ) (\a: Unit .\b: Bool .b)) in u)
(if ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f true ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) ) (\a: Unit .\b: Bool .a)) )) then ({a = ({a = false , b = 0 }.a) , b = (((\x: Rec X. X .\y: Bool .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = true }.a)) }.b) else (((\x: Bool .\y: Rec X. X .x) (succ (((\x: Unit .\y: Bool .y) (let u = false in u) ) (( \f: Rec X. X .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)))) ) (((\x: Rec X. X .\y: Bool .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) (iszero (unfold [ Bool ] (fold [ Bool ] 1 ))))))
(( \f: Nat .((f (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a)) )) )) in ({a = (succ (( \f: Nat .((f 1 ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Nat .b))) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (let u = false in 1) , b = ({a = false , b = false }.b) }.b) )) }.a)) ) (( \f: Bool .((f (let u = (let u = (((\x: Nat .\y: Rec X. X .x) (let u = 0 in false) ) false) in (if false then false else true)) in ({a = false , b = 1 }.b)) ) (if (iszero 0) then (if ({a = true , b = true }.b) then (((\x: Nat .\y: Bool .y) false ) 0) else ({a = ({a = 0 , b = true }.b) , b = 1 }.b)) else (unfold [ Nat ] (fold [ Bool ] (pred 1) ))) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Bool .b))
(pred (unfold [ Bool ] (fold [ Bool ] ({a = (let u = (( \f: Rec X. X .((f (fix (\x: Bool . 1 )) ) (let u = false in 0) ) ) (\a: Rec X. X .\b: Bool .b)) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = (let u = 1 in u) , b = ({a = 1 , b = false , c =  1 }.b) , c =  (let u = true in 0) }.b) }.a) )))
(let u = ({a = (unfold [ Rec X. X ] (fold [ Nat ] ({a = (pred 0) , b = (let u = (iszero 0) in true) , c =  (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .b)) in (succ 1)) }.b) )) , b = ({a = (((\x: Nat .\y: Nat .y) ({a = 0 , b = true , c =  1 }.b) ) ({a = false , b = true }.b)) , b = (((\x: Unit .\y: Rec X. X .x) ({a = (let u = 0 in u) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  0 }.b) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a))) }.b) }.b) in u)
(( \f: Rec X. X .((f ({a = (succ (fix (\x: Rec X. X . 0 ))) , b = ({a = (if true then 0 else 1) , b = (unfold [ Nat ] (fold [ Unit ] true )) , c =  (((\x: Unit .\y: Unit .y) true ) 0) }.b) , c = (let u = (succ 1) in u) }.c) ) (pred (let u = 0 in u)) ) ) (\a: Rec X. X .\b: Nat .a))
(succ (( \f: Nat .((f ({a = (iszero 1) , b = (pred 0) }.b) ) (if (( \f: Rec X. X .((f (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .a)) ) (if false then false else false) ) ) (\a: Bool .\b: Bool .a)) then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else ({a = (succ 0) , b = (pred (pred 0)) }.b)) ) ) (\a: Nat .\b: Unit .b)))
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = (((\x: Nat .\y: Bool .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) (if true then (((\x: Bool .\y: Rec X. X .x) true ) false) else (((\x: Rec X. X .\y: Rec X. X .x) false ) false))) in u) ))
(unfold [ Unit ] (fold [ Unit ] (if (let u = false in u) then (let u = ({a = 0 , b = true , c = 1 }.c) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 ))) else (unfold [ Unit ] (fold [ Unit ] 0 ))) ))
(let u = (((\x: Bool .\y: Nat .x) ({a = ({a = 0 , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , c =  0 }.b) , b = (fix (\x: Nat . false )) }.b) ) (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)) in u)
(case <r = (if ({a = (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (if false then true else true) )) }.b) then (((\x: Nat .\y: Bool .x) ({a = (fix (\x: Nat . 0 )) , b = true }.b) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b))) else ({a = (((\x: Unit .\y: Bool .y) true ) true) , b = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)) }.b)) > as Unit of < l = x > => x | < r = y > => y)
(iszero (if ({a = ({a = ({a = 1 , b = true , c =  0 }.b) , b = ({a = 1 , b = 1 }.b) }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero 1) )) }.b) then (fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) 1 ) ) (\a: Bool .\b: Unit .a)) )) )) else ({a = (((\x: Rec X. X .\y: Unit .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) ) (if true then 0 else 0)) , b = (iszero (pred 0)) , c = (pred 0) }.c)))
(let u = (fix (\x: Unit . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (let u = false in false) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.b) )) )) in (let u = (fix (\x: Bool . ({a = true , b = 0 }.b) )) in ({a = true , b = 1 }.b)))
(fix (\x: Unit . (case <l = ({a = (if ({a = 1 , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) }.b) then (let u = true in 1) else (succ 1)) , b = (let u = (((\x: Nat .\y: Bool .x) true ) true) in (iszero ({a = 1 , b = true }.a))) }.a) > as Unit of < l = x > => x | < r = y > => y) ))
(case <r = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) true) in u) , b = ({a = (if true then false else true) , b = ({a = 0 , b = 1 }.b) }.b) }.a) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Rec X. X .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = (( \f: Nat .((f ({a = false , b = 1 }.a) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (((\x: Unit .\y: Nat .x) 0 ) true) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = true }.b) )) }.a) }.a) )) ) (( \f: Bool .((f ({a = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) ({a = 0 , b = true }.b)) }.b) ) (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) ) (\a: Unit .\b: Bool .a)))
({a = (( \f: Unit .((f ({a = ({a = true , b = 0 }.b) , b = (fix (\x: Nat . ({a = 1 , b = true , c =  0 }.b) )) }.a) ) (let u = 0 in u) ) ) (\a: Bool .\b: Unit .a)) , b = ({a = ({a = (iszero 0) , b = ({a = true , b = (if true then 1 else 1) }.b) }.a) , b = (fix (\x: Nat . 1 )) }.a) , c =  ({a = (((\x: Unit .\y: Nat .x) ({a = (succ 1) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) }.b) ) (( \f: Rec X. X .((f (let u = false in u) ) (((\x: Nat .\y: Bool .x) true ) false) ) ) (\a: Nat .\b: Nat .a))) , b = (pred (((\x: Bool .\y: Unit .y) false ) 1)) }.b) }.b)
({a = ({a = (( \f: Nat .((f false ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = 0 }.b) }.b) }.a) , b = ({a = ({a = ({a = (let u = false in 1) , b = true }.a) , b = (((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Nat .x) true ) true) ) (iszero 0)) , c = (case <l = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) }.c) , b = (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Unit .y) true ) false) ) ({a = false , b = 1 }.a)) , c =  (( \f: Rec X. X .((f (let u = (((\x: Bool .\y: Bool .x) 0 ) true) in u) ) (succ (let u = (fix (\x: Unit . 0 )) in ({a = 0 , b = true , c = 0 }.c))) ) ) (\a: Unit .\b: Nat .a)) }.b) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Rec X. X .x) false ) true) , b = (let u = true in true) }.b) )) ))
(fix (\x: Bool . ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f (fix (\x: Nat . false )) ) false ) ) (\a: Unit .\b: Rec X. X .a)) )) ))
(iszero (((\x: Rec X. X .\y: Unit .x) (let u = (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) )) in ({a = (pred 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = true , b = true }.b) )) }.a)) ) ({a = (( \f: Rec X. X .((f false ) (((\x: Nat .\y: Rec X. X .y) true ) false) ) ) (\a: Nat .\b: Bool .b)) , b = (if true then true else false) }.b)))
({a = (let u = (let u = (succ 1) in u) in (if (let u = false in u) then 1 else 1)) , b = (if (if false then ({a = true , b = 0 }.a) else true) then (let u = true in u) else (let u = (fix (\x: Rec X. X . true )) in (((\x: Bool .\y: Rec X. X .y) true ) true))) , c =  (((\x: Rec X. X .\y: Bool .y) ({a = (unfold [ Bool ] (fold [ Unit ] true )) , b = (( \f: Nat .((f ({a = 0 , b = true , c =  0 }.b) ) false ) ) (\a: Nat .\b: Bool .a)) }.b) ) ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , c = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) , b = false , c = ({a = true , b = 1 }.b) }.c) }.c)) }.b)
(((\x: Bool .\y: Nat .y) (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] (let u = (((\x: Bool .\y: Unit .y) true ) 0) in (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ))) )) ) (iszero (pred (((\x: Rec X. X .\y: Bool .y) true ) 0))) ) ) (\a: Bool .\b: Bool .b)) ) ({a = (( \f: Bool .((f (( \f: Rec X. X .((f (pred 1) ) (let u = 0 in u) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Nat .y) (iszero 0) ) 1) }.b) ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Unit .\y: Bool .y) (iszero 0) ) (fix (\x: Unit . false ))) , c =  (((\x: Bool .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = false }.b) )) ) (let u = (if true then 1 else 0) in 0)) }.b))
(( \f: Unit .((f (let u = (case <r = (((\x: Nat .\y: Unit .x) false ) false) > as Nat of < l = x > => x | < r = y > => y) in (pred (let u = 0 in 1))) ) (pred (case <l = ({a = 1 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Unit .a))
({a = (case <l = ({a = 1 , b = false , c = 0 }.c) > as Nat of < l = x > => x | < r = y > => y) , b = (iszero (if (let u = false in u) then (let u = false in 0) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 )))) , c =  (let u = (case <l = (if false then 1 else (((\x: Nat .\y: Bool .y) false ) 0)) > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.b)
({a = (unfold [ Nat ] (fold [ Nat ] (fix (\x: Nat . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in u) )) )) )) , b = (let u = (case <r = (fix (\x: Nat . false )) > as Rec X. X of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false ))) , c =  (if ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (iszero 0) in false) )) then ({a = (((\x: Bool .\y: Bool .x) 0 ) false) , b = (iszero 1) , c = (fix (\x: Nat . 0 )) }.c) else (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u)) }.b)
(pred (fix (\x: Unit . ({a = ({a = (((\x: Unit .\y: Bool .y) false ) 0) , b = 0 }.b) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) )))
({a = (pred (if ({a = (((\x: Rec X. X .\y: Unit .x) false ) false) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) then (if (((\x: Bool .\y: Nat .y) false ) false) then ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = false , c = ({a = true , b = 1 }.b) }.c) else ({a = 0 , b = 0 }.b)) else (((\x: Rec X. X .\y: Bool .y) ({a = true , b = true }.b) ) (let u = 1 in u)))) , b = (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Unit .y) ({a = ({a = false , b = false }.b) , b = (let u = true in false) }.b) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) ({a = (if true then false else false) , b = (((\x: Bool .\y: Nat .y) true ) true) }.b)) }.b)
(let u = (( \f: Bool .((f (succ (((\x: Bool .\y: Unit .x) (pred 0) ) (((\x: Rec X. X .\y: Bool .x) false ) ({a = 0 , b = true , c =  0 }.b)))) ) (((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Bool ] 0 )) ) ({a = true , b = false }.b)) ) ) (\a: Bool .\b: Rec X. X .a)) in u)
(unfold [ Bool ] (fold [ Nat ] (if (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Bool .x) (if true then true else false) ) true) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero 1) ))) then ({a = (let u = (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in 1) in ({a = ({a = false , b = 1 }.b) , b = (succ 1) }.b)) , b = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .a)) ) false) , c = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a))) }.c) else ({a = (let u = ({a = true , b = (let u = false in 1) }.a) in ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 ))) , b = (fix (\x: Rec X. X . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) , c = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = (let u = true in u) , c = ({a = false , b = 1 }.b) }.c) }.c)) ))
(let u = (if (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = (iszero 1) }.b) ) (let u = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) in true)) then (let u = (((\x: Unit .\y: Bool .x) true ) false) in ({a = 1 , b = true , c =  (pred 0) }.b)) else (unfold [ Bool ] (fold [ Bool ] (let u = (((\x: Unit .\y: Bool .y) false ) true) in u) ))) in (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = false , c = (succ 1) }.c) )))
(((\x: Unit .\y: Bool .x) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , b = (fix (\x: Nat . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) }.b) ) (let u = (iszero (fix (\x: Rec X. X . 1 ))) in u))
(case <l = (let u = (unfold [ Bool ] (fold [ Nat ] 0 )) in u) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = ({a = 0 , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .a)) }.a) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = (let u = 0 in 0) }.c) , b = (succ (((\x: Nat .\y: Bool .x) (pred (let u = 0 in 1)) ) (fix (\x: Bool . (let u = 1 in true) )))) }.b)
(fix (\x: Bool . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .y) (if true then true else true) ) ({a = 0 , b = 1 }.b)) ) (let u = (let u = 1 in 0) in (( \f: Nat .((f (succ 1) ) 0 ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Unit .\b: Rec X. X .b)) )) ))
(( \f: Rec X. X .((f (( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) false ) true) )) ) (( \f: Bool .((f ({a = true , b = false }.b) ) false ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .a)) ) ({a = ({a = false , b = (if true then 1 else 0) }.a) , b = (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) (if true then true else false)) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(case <l = (succ (fix (\x: Unit . (let u = false in 0) ))) > as Unit of < l = x > => x | < r = y > => y)
({a = (case <l = (case <l = (fix (\x: Bool . (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Nat . (iszero (((\x: Unit .\y: Unit .y) true ) 1)) )) , b = (fix (\x: Bool . ({a = false , b = false }.b) )) }.b) }.a)
(case <l = ({a = (pred 1) , b = ({a = (let u = 0 in u) , b = ({a = true , b = (let u = 1 in 0) }.a) , c =  (let u = false in 0) }.b) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(if (((\x: Bool .\y: Nat .x) ({a = (let u = true in u) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.a) ) ({a = (succ 1) , b = (let u = (case <l = (((\x: Bool .\y: Bool .y) true ) 0) > as Bool of < l = x > => x | < r = y > => y) in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.b)) then (let u = ({a = (let u = (if true then (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Nat .y) true ) 0)) in u) , b = ({a = 0 , b = false , c =  (((\x: Nat .\y: Bool .x) 0 ) true) }.b) , c = ({a = 1 , b = 0 }.b) }.c) in (pred (pred (succ 0)))) else (fix (\x: Rec X. X . (succ 1) )))
(fix (\x: Nat . (if (((\x: Rec X. X .\y: Nat .x) (iszero 0) ) ({a = 0 , b = false , c =  1 }.b)) then ({a = ({a = ({a = 0 , b = (succ 1) }.b) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.a) , b = (iszero 1) , c =  (((\x: Bool .\y: Rec X. X .y) true ) 1) }.b) else (let u = ({a = 0 , b = true , c =  0 }.b) in (((\x: Rec X. X .\y: Unit .y) false ) false))) ))
(let u = (if (let u = ({a = false , b = true }.b) in u) then (let u = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) in u) in u) else (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ))) in ({a = (if (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in u) )) ) ({a = ({a = 1 , b = true }.b) , b = 0 }.a)) then (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) in ({a = 1 , b = 1 }.b)) else (((\x: Nat .\y: Nat .x) (pred 1) ) (let u = false in (iszero 1)))) , b = (let u = (succ 1) in (fix (\x: Bool . (iszero 1) ))) , c = (let u = (if (fix (\x: Unit . false )) then 1 else (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) in u) }.c))
(if (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = true }.b) )) then ({a = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) in ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) , b = (( \f: Unit .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Nat .((f 0 ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = true in 1) )))
(fix (\x: Unit . (case <r = ({a = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) 0) , b = ({a = 1 , b = true , c =  1 }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) ))
(let u = (if (((\x: Bool .\y: Bool .x) true ) true) then ({a = ({a = (let u = 1 in u) , b = (let u = true in 1) }.b) , b = (fix (\x: Bool . 0 )) }.b) else ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (succ 1) }.b)) in (if (case <r = (let u = false in true) > as Rec X. X of < l = x > => x | < r = y > => y) then ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) else (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Bool . true )) ))))
(let u = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (let u = true in true) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) , b = (if true then 1 else 1) }.a)) in (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Unit .y) ({a = ({a = ({a = 0 , b = 1 }.b) , b = (let u = true in false) }.b) , b = (succ 0) }.a) ) (( \f: Rec X. X .((f (let u = (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) true ) 0) ) (((\x: Unit .\y: Rec X. X .y) true ) 1) ) ) (\a: Nat .\b: Rec X. X .b)) in u) ) (let u = (((\x: Rec X. X .\y: Bool .x) false ) false) in (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = false , c = 0 }.c) ))) ) ) (\a: Unit .\b: Unit .b)))
(let u = (let u = (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in u) )) in u) in (succ (succ (pred 1))))
(((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f (fix (\x: Rec X. X . (fix (\x: Rec X. X . (let u = true in u) )) )) ) (let u = (((\x: Unit .\y: Rec X. X .y) (let u = false in true) ) (let u = 1 in false)) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false ))) ) ) (\a: Unit .\b: Bool .b)) ) (fix (\x: Rec X. X . (fix (\x: Unit . (let u = true in u) )) )))
(((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f ({a = false , b = false }.b) ) true ) ) (\a: Nat .\b: Bool .a)) )) ) (let u = (if (if true then false else true) then (( \f: Rec X. X .((f true ) (let u = false in false) ) ) (\a: Rec X. X .\b: Unit .a)) else ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if false then false else true) ))) in u))
(let u = ({a = (( \f: Bool .((f (if true then 1 else 1) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) , b = (let u = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = 1 }.a) }.b) in u) }.b) in (let u = ({a = (( \f: Nat .((f false ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) ) (\a: Bool .\b: Bool .b)) , b = (( \f: Unit .((f (let u = 0 in true) ) (case <r = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) in (let u = ({a = 1 , b = true }.a) in u)))
(if ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = true , b = 1 }.a) )) then (( \f: Rec X. X .((f (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) in (let u = 0 in u)) ) (unfold [ Nat ] (fold [ Bool ] (let u = true in 1) )) ) ) (\a: Unit .\b: Bool .b)) else (case <l = ({a = (let u = 0 in u) , b = ({a = 0 , b = false }.a) }.b) > as Unit of < l = x > => x | < r = y > => y))
({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) )) , b = (((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Bool .x) false ) true) ) (if true then true else false)) }.b) , b = ({a = (( \f: Rec X. X .((f ({a = (case <l = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . 1 )) }.b) ) (( \f: Nat .((f (fix (\x: Nat . 1 )) ) (succ 0) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .b)) , b = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = 0 , b = false , c =  0 }.b) )) in (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a))) }.a) }.a)
(( \f: Bool .((f (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ({a = (case <l = (unfold [ Bool ] (fold [ Bool ] 1 )) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = 0 }.a) , c = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) }.c)) ) (((\x: Bool .\y: Nat .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )) )) ) (let u = (iszero (((\x: Unit .\y: Rec X. X .x) 1 ) false)) in u)) ) ) (\a: Rec X. X .\b: Bool .b)) ) (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))
(((\x: Unit .\y: Bool .y) (( \f: Unit .((f (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (((\x: Unit .\y: Unit .x) false ) true) else (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) > as Nat of < l = x > => x | < r = y > => y)) ) (((\x: Bool .\y: Nat .x) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) true) ) ) (\a: Unit .\b: Unit .b)) ) (fix (\x: Nat . ({a = (let u = true in u) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) }.a) )))
(succ (( \f: Unit .((f ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = true }.a) }.b) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (iszero 1) }.a) ) ) (\a: Unit .\b: Rec X. X .b)))
(succ (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) ({a = (((\x: Unit .\y: Rec X. X .y) true ) 0) , b = false }.b) ) (let u = (( \f: Bool .((f 1 ) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) ) (\a: Nat .\b: Unit .b)) in u)) ) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (if false then 0 else 0) }.a) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (case <l = ({a = 0 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) ))
({a = (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f ({a = false , b = ({a = 0 , b = true }.b) }.b) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) , b = (let u = true in u) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Nat .y) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .a)) ) false) ))) , b = (((\x: Nat .\y: Bool .y) ({a = (( \f: Rec X. X .((f (let u = (((\x: Rec X. X .\y: Nat .y) true ) 0) in ({a = 0 , b = false }.b)) ) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = false , c =  ({a = 1 , b = false , c = 1 }.c) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (if true then true else ({a = false , b = 0 }.a)) }.b) ) ({a = (succ 1) , b = (let u = (let u = 1 in true) in (iszero 0)) }.a)) }.a)
(case <l = ({a = (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) , b = ({a = ({a = true , b = 0 }.a) , b = (succ 0) }.a) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (let u = (( \f: Rec X. X .((f ({a = 1 , b = false }.b) ) (((\x: Rec X. X .\y: Unit .x) false ) true) ) ) (\a: Bool .\b: Unit .a)) in u) in ({a = (pred 0) , b = (fix (\x: Rec X. X . (fix (\x: Nat . true )) )) , c =  (case <l = (((\x: Nat .\y: Rec X. X .y) false ) 0) > as Rec X. X of < l = x > => x | < r = y > => y) }.b))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) ({a = ({a = 0 , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , c = 1 }.c) , b = (if true then true else true) }.b) ) (((\x: Nat .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .a)) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y))) ))
(iszero (fix (\x: Rec X. X . (( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) ) (fix (\x: Bool . 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) )))
(( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c = 1 }.c) )) ) ({a = ({a = ({a = 1 , b = false }.b) , b = (if false then 1 else 1) }.b) , b = (fix (\x: Bool . ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  (fix (\x: Bool . 1 )) }.b) )) }.a) ) ) (\a: Unit .\b: Bool .b))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) , b = (fix (\x: Rec X. X . 0 )) }.b)) ))
(let u = (let u = (unfold [ Unit ] (fold [ Unit ] (fix (\x: Bool . 1 )) )) in u) in (case <l = (( \f: Unit .((f (if false then 1 else 0) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) ) (\a: Bool .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (unfold [ Unit ] (fold [ Nat ] (let u = (let u = 0 in 0) in (((\x: Bool .\y: Unit .y) true ) true)) )) in (let u = (( \f: Bool .((f ({a = ({a = ({a = true , b = 1 }.b) , b = (let u = true in u) , c =  1 }.b) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) (fix (\x: Bool . ({a = 1 , b = true }.b) )) ) ) (\a: Bool .\b: Bool .a)) in (let u = (unfold [ Bool ] (fold [ Bool ] 1 )) in (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (let u = true in ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true ))) else ({a = 0 , b = false , c =  1 }.b)))))
(if ({a = (case <l = (let u = (unfold [ Unit ] (fold [ Nat ] 1 )) in (succ 0)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero ({a = (((\x: Nat .\y: Rec X. X .y) true ) ({a = 1 , b = true }.a)) , b = ({a = 0 , b = false , c =  1 }.b) , c = (succ 0) }.c)) , c =  (succ (if (unfold [ Bool ] (fold [ Bool ] false )) then (let u = 0 in u) else (succ ({a = 1 , b = false , c = 0 }.c)))) }.b) then (let u = (succ ({a = 0 , b = false }.a)) in ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = (case <l = (let u = 1 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) else (pred ({a = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 0 , b = 1 }.b) }.b)))
(if (((\x: Unit .\y: Nat .y) (let u = false in u) ) (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then (((\x: Nat .\y: Bool .y) false ) true) else ({a = false , b = false }.b))) then (let u = ({a = 0 , b = 0 }.b) in (( \f: Rec X. X .((f 0 ) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b))) else (fix (\x: Unit . (succ (let u = true in 0)) )))
(((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Bool .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) (((\x: Bool .\y: Bool .x) (let u = 0 in true) ) (((\x: Bool .\y: Rec X. X .x) true ) ({a = 0 , b = true , c =  1 }.b)))) ) (((\x: Bool .\y: Unit .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Unit ] true ))))
(unfold [ Nat ] (fold [ Rec X. X ] (let u = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = ({a = 1 , b = 0 }.b) , b = 1 }.b)) in u) ))
(if (case <r = (iszero (let u = ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Unit .\y: Unit .y) false ) 0) }.b) in u)) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = ({a = ({a = true , b = true }.b) , b = (((\x: Bool .\y: Unit .y) false ) 1) }.b) , b = (( \f: Bool .((f (( \f: Bool .((f ({a = false , b = 0 }.b) ) (let u = ({a = false , b = true }.b) in 0) ) ) (\a: Nat .\b: Rec X. X .b)) ) (unfold [ Bool ] (fold [ Unit ] (fix (\x: Bool . 0 )) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) else ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (((\x: Bool .\y: Bool .x) 0 ) true) , b = (((\x: Nat .\y: Unit .y) false ) false) }.a) )) , b = (case <r = (((\x: Bool .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) ) (unfold [ Unit ] (fold [ Bool ] true ))) > as Nat of < l = x > => x | < r = y > => y) }.a))
(iszero ({a = (let u = (let u = true in false) in u) , b = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .y) (iszero 1) ) 1) )) }.b))
(succ (pred ({a = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) in (fix (\x: Rec X. X . 0 ))) , b = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = true , c = 1 }.c) }.b)))
(((\x: Bool .\y: Nat .y) (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .x) true ) false) )) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = (unfold [ Nat ] (fold [ Bool ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) , b = (( \f: Nat .((f (iszero 0) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .b)) }.b) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = (pred ({a = ({a = 0 , b = true , c =  1 }.b) , b = (let u = 0 in 0) }.b)) in u))
(if ({a = (( \f: Nat .((f (let u = (((\x: Bool .\y: Bool .x) false ) false) in (let u = 1 in u)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 1 , b = 1 }.b) )) ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = 0 in false) ) (fix (\x: Unit . true ))) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (succ 1) )) }.b) then ({a = (let u = (((\x: Rec X. X .\y: Nat .y) ({a = false , b = true }.b) ) true) in (if false then 0 else (if true then 0 else 0))) , b = (let u = 1 in true) }.a) else (if (iszero (if (((\x: Nat .\y: Nat .y) false ) false) then 0 else (pred 0))) then ({a = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b)) , b = (pred 0) }.b) else ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] 0 )) ))))
({a = ({a = (let u = (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Unit .x) false ) false) ) 0) in u) , b = (unfold [ Unit ] (fold [ Unit ] (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .b)) )) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (succ (if true then 0 else 0)) )) }.c) , b = ({a = (( \f: Rec X. X .((f ({a = ({a = 1 , b = true , c = 0 }.c) , b = (if true then false else false) }.b) ) (( \f: Unit .((f (let u = true in false) ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (((\x: Bool .\y: Rec X. X .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = 1 , b = false , c =  1 }.b) )) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = (if true then true else false) }.b)) }.b) , c =  ({a = (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b)) ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (fix (\x: Nat . false ))) , b = (let u = (succ 0) in u) }.b) }.b)
({a = (((\x: Rec X. X .\y: Rec X. X .y) (let u = (((\x: Nat .\y: Bool .y) true ) false) in (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a))) ) (iszero (pred ({a = (let u = 1 in true) , b = (let u = 0 in u) }.b)))) , b = (case <l = ({a = (let u = false in 0) , b = (( \f: Nat .((f 0 ) ({a = 0 , b = 1 }.b) ) ) (\a: Nat .\b: Bool .a)) }.b) > as Bool of < l = x > => x | < r = y > => y) }.a)
(iszero ({a = (((\x: Unit .\y: Rec X. X .x) (let u = 1 in false) ) true) , b = (let u = (if true then 1 else 0) in ({a = 0 , b = 0 }.b)) }.b))
(unfold [ Unit ] (fold [ Bool ] ({a = (((\x: Rec X. X .\y: Bool .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = false , b = false }.b)) , b = (fix (\x: Nat . (let u = 0 in u) )) }.b) ))
(((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = ({a = true , b = 1 }.b) , b = (let u = ({a = false , b = true }.b) in false) , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) }.c) , b = (( \f: Rec X. X .((f ({a = false , b = (let u = 0 in u) }.a) ) ({a = (fix (\x: Rec X. X . 0 )) , b = (((\x: Unit .\y: Nat .y) false ) true) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) (let u = ({a = (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in 0) , b = (((\x: Bool .\y: Unit .x) false ) false) }.b) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (pred 0) ))))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (if ({a = (let u = (let u = false in 1) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false ))) , b = ({a = (( \f: Nat .((f ({a = false , b = 1 }.a) ) true ) ) (\a: Bool .\b: Nat .b)) , b = (fix (\x: Nat . (if true then false else true) )) }.b) }.b) then ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Bool .\y: Bool .y) false ) false) , c = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.c) else ({a = (( \f: Nat .((f ({a = 0 , b = false }.a) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = 0 , b = true , c = 1 }.c) }.b)) ))
(( \f: Rec X. X .((f (succ ({a = ({a = (let u = 0 in 0) , b = true , c = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.c) , b = (iszero 1) , c = (((\x: Rec X. X .\y: Unit .x) 1 ) true) }.c)) ) (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in (succ (if (let u = false in false) then ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) else (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b))))) ) ) (\a: Unit .\b: Rec X. X .a))
(case <l = (( \f: Rec X. X .((f ({a = (if false then 1 else 1) , b = (let u = 0 in true) , c = (if false then 0 else 1) }.c) ) (let u = ({a = 1 , b = 1 }.b) in ({a = 0 , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y)
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (pred 0) in (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a))) )) , b = (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] 1 )) )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) }.a)
(if (((\x: Nat .\y: Unit .x) (case <r = ({a = 0 , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Nat .y) false ) true) ) (let u = false in u))) then (( \f: Nat .((f (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) ) (( \f: Nat .((f ({a = (let u = false in (pred 0)) , b = (((\x: Rec X. X .\y: Unit .x) false ) true) , c =  (fix (\x: Rec X. X . 1 )) }.b) ) (fix (\x: Bool . (((\x: Nat .\y: Unit .x) false ) false) )) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Unit .\b: Unit .b)) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = true , b = (((\x: Bool .\y: Nat .x) 0 ) true) }.a) in u) )))
(fix (\x: Rec X. X . ({a = (((\x: Bool .\y: Nat .y) false ) 0) , b = ({a = ({a = 0 , b = false }.a) , b = (( \f: Rec X. X .((f false ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) , c =  (((\x: Nat .\y: Unit .x) (succ 0) ) true) }.b) }.a) ))
(succ (( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c = 0 }.c) )) ) (((\x: Bool .\y: Bool .y) false ) (pred 0)) ) ) (\a: Nat .\b: Bool .a)))
({a = (case <r = (if (fix (\x: Bool . true )) then ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] false )) else false) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Rec X. X .y) ({a = (let u = ({a = true , b = 1 }.a) in u) , b = ({a = false , b = false }.b) }.b) ) (((\x: Rec X. X .\y: Unit .x) (let u = false in u) ) (( \f: Rec X. X .((f ({a = 0 , b = false , c =  1 }.b) ) false ) ) (\a: Rec X. X .\b: Bool .b)))) }.b)
({a = (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) (fix (\x: Nat . false )) ) (( \f: Nat .((f (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) false ) 1) ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) ) (fix (\x: Nat . 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (((\x: Nat .\y: Rec X. X .x) (let u = 0 in u) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in false) ) (case <r = ({a = true , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = true , c =  1 }.b) )) ) (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .y) false ) true) ) (((\x: Rec X. X .\y: Bool .y) true ) true) ) ) (\a: Unit .\b: Bool .a)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true ))) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Bool .a)) , c = (( \f: Bool .((f (let u = (( \f: Nat .((f ({a = 1 , b = 1 }.b) ) ({a = false , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) in (let u = 1 in 0)) ) (pred (if (let u = false in u) then ({a = 1 , b = false , c = 1 }.c) else (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)))) ) ) (\a: Rec X. X .\b: Unit .b)) }.c)
(( \f: Bool .((f (iszero (((\x: Rec X. X .\y: Rec X. X .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)))) ) (fix (\x: Bool . (case <r = (let u = 0 in true) > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Bool .a))
({a = (let u = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) false ) false) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) in (((\x: Nat .\y: Rec X. X .x) (let u = 0 in 1) ) ({a = 1 , b = true }.b))) , b = (if (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) in false) then ({a = ({a = 0 , b = true }.b) , b = ({a = false , b = 1 }.b) }.a) else (if (iszero 0) then ({a = false , b = false }.b) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) )))) }.b)
({a = (( \f: Nat .((f (case <l = (((\x: Nat .\y: Nat .y) false ) 0) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (((\x: Unit .\y: Bool .y) true ) false) in (unfold [ Unit ] (fold [ Bool ] 1 ))) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (unfold [ Unit ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (pred 0) )) )) }.b)
({a = (let u = (( \f: Nat .((f (( \f: Nat .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 1) ) ) (\a: Bool .\b: Nat .a)) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (case <l = (((\x: Rec X. X .\y: Bool .x) (let u = true in ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 ))) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = (succ 0) , b = (let u = 0 in true) }.b) ) (fix (\x: Unit . true ))) , c =  (let u = (unfold [ Unit ] (fold [ Nat ] (pred 1) )) in u) }.b)
(let u = (((\x: Bool .\y: Rec X. X .x) (if (let u = true in u) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else ({a = 0 , b = (if false then true else false) }.b)) ) (unfold [ Unit ] (fold [ Nat ] (if true then false else false) ))) in (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .x) (let u = false in true) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) )))
({a = (if ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = true , c =  0 }.b) then (((\x: Unit .\y: Rec X. X .y) ({a = false , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) (((\x: Unit .\y: Unit .y) false ) 0)) else (( \f: Unit .((f 1 ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Nat .a))) , b = (let u = ({a = ({a = 1 , b = true , c =  1 }.b) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) in (case <r = (fix (\x: Bool . false )) > as Rec X. X of < l = x > => x | < r = y > => y)) , c = (fix (\x: Unit . (((\x: Nat .\y: Nat .x) ({a = 0 , b = 1 }.b) ) true) )) }.c)
({a = (if (if (let u = false in u) then ({a = true , b = true }.b) else ({a = 1 , b = false }.b)) then (( \f: Nat .((f (let u = (let u = (iszero 0) in 0) in (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b))) ) (let u = true in (let u = false in u)) ) ) (\a: Nat .\b: Rec X. X .b)) else ({a = ({a = true , b = 1 }.b) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (((\x: Bool .\y: Bool .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) (let u = false in 0)) }.b)) , b = (pred ({a = ({a = (let u = 0 in false) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (unfold [ Nat ] (fold [ Nat ] false )) }.a)) }.a)
({a = (let u = ({a = (if true then 1 else ({a = 0 , b = true , c = 0 }.c)) , b = (if ({a = 0 , b = true , c =  1 }.b) then (((\x: Unit .\y: Bool .y) false ) true) else false) }.a) in (case <l = (let u = ({a = false , b = true }.b) in 0) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (iszero (let u = ({a = 1 , b = true , c =  0 }.b) in (pred (if false then 0 else 1)))) , c = ({a = (fix (\x: Bool . (case <r = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) )) , b = ({a = (succ 0) , b = ({a = true , b = false }.b) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) }.c) }.b) }.c)
(fix (\x: Bool . (((\x: Rec X. X .\y: Nat .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (((\x: Nat .\y: Nat .x) false ) ({a = 0 , b = true , c =  1 }.b)) , b = (iszero 0) }.b) )) ) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.a) )) in (((\x: Bool .\y: Unit .y) false ) false))) ))
(( \f: Nat .((f ({a = (((\x: Bool .\y: Bool .y) ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = 1 }.a) ) (( \f: Unit .((f ({a = 1 , b = true }.b) ) true ) ) (\a: Bool .\b: Rec X. X .a))) , b = (let u = (let u = 1 in 0) in false) }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f (let u = 0 in false) ) (let u = 0 in (let u = true in true)) ) ) (\a: Nat .\b: Nat .b)) )) ) ) (\a: Nat .\b: Bool .b))
(let u = (fix (\x: Nat . (unfold [ Bool ] (fold [ Bool ] (((\x: Unit .\y: Unit .x) 0 ) false) )) )) in ({a = (fix (\x: Rec X. X . (fix (\x: Unit . false )) )) , b = ({a = (iszero (succ 0)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (iszero 1) )) }.b) }.b))
({a = (((\x: Bool .\y: Bool .y) ({a = ({a = (((\x: Unit .\y: Nat .y) true ) 1) , b = (if true then false else false) }.b) , b = (( \f: Bool .((f true ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) (let u = (iszero 0) in (fix (\x: Unit . 0 )))) , b = (succ (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u)) }.b)
(let u = (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) ({a = 1 , b = (let u = true in u) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u)
(((\x: Bool .\y: Nat .x) (pred (pred 1)) ) (let u = ({a = ({a = (let u = 0 in true) , b = ({a = (pred 1) , b = (((\x: Rec X. X .\y: Unit .y) false ) false) }.b) }.b) , b = ({a = ({a = (if true then true else true) , b = (let u = 1 in u) }.a) , b = (if ({a = 0 , b = true }.b) then (let u = 1 in true) else false) }.b) }.b) in u))
(case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (if false then false else true) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = ({a = (((\x: Unit .\y: Unit .x) 0 ) (let u = false in true)) , b = ({a = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .a)) }.b) , b = ({a = 0 , b = true , c =  1 }.b) }.b) }.a) in (((\x: Rec X. X .\y: Rec X. X .x) (if false then true else ({a = 0 , b = false , c =  1 }.b)) ) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = true , b = true }.b) )) in (fix (\x: Rec X. X . true ))))) in u)
(if (fix (\x: Unit . (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))) )) then (((\x: Nat .\y: Unit .x) (unfold [ Bool ] (fold [ Bool ] (unfold [ Nat ] (fold [ Rec X. X ] false )) )) ) (iszero (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .x) 1 ) false) ) 1 ) ) (\a: Nat .\b: Rec X. X .a)))) else (let u = (fix (\x: Rec X. X . 0 )) in (let u = 0 in (((\x: Unit .\y: Unit .x) false ) true))))
({a = ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .x) false ) (((\x: Nat .\y: Unit .x) false ) true)) )) , b = ({a = (let u = false in 1) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) , c = (unfold [ Nat ] (fold [ Unit ] 1 )) }.c) }.b) , b = ({a = (pred 1) , b = (pred 1) }.b) }.b) , b = (let u = (let u = (let u = false in false) in u) in u) }.b)
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (iszero (succ 0)) ) (let u = ({a = (let u = 1 in true) , b = (if true then 1 else 1) }.a) in u) ) ) (\a: Unit .\b: Rec X. X .a)) ))
({a = (let u = (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Unit .x) 1 ) true) ) (((\x: Nat .\y: Unit .x) false ) true)) in (case <r = (((\x: Unit .\y: Bool .y) true ) true) > as Nat of < l = x > => x | < r = y > => y)) , b = (( \f: Unit .((f (case <r = ({a = true , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) ) (iszero 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)
(succ (pred (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 )) ) ) (\a: Bool .\b: Bool .a))))
({a = (fix (\x: Rec X. X . (( \f: Nat .((f (succ 0) ) 0 ) ) (\a: Bool .\b: Bool .a)) )) , b = (let u = (succ ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) ))) in (if ({a = 0 , b = false }.b) then ({a = false , b = false }.b) else (let u = true in false))) }.a)
({a = (unfold [ Unit ] (fold [ Unit ] (let u = ({a = 1 , b = false }.a) in (let u = 0 in u)) )) , b = (( \f: Rec X. X .((f (case <l = (let u = (let u = 0 in 0) in ({a = 0 , b = 1 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . ({a = 1 , b = false , c = (((\x: Bool .\y: Nat .x) 1 ) false) }.c) )) ) ) (\a: Nat .\b: Bool .a)) }.b)
(( \f: Nat .((f (if (((\x: Bool .\y: Bool .y) (case <r = (if false then false else false) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Unit ] false ))) then ({a = (( \f: Rec X. X .((f (if false then 1 else 1) ) 1 ) ) (\a: Unit .\b: Bool .b)) , b = (unfold [ Bool ] (fold [ Nat ] 1 )) }.b) else (if (((\x: Rec X. X .\y: Bool .y) ({a = 0 , b = false }.b) ) ({a = 1 , b = true , c =  1 }.b)) then ({a = 1 , b = true }.a) else (pred 0))) ) (( \f: Unit .((f ({a = (let u = false in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 ))) , b = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.a) , c = (pred (( \f: Unit .((f 1 ) (((\x: Bool .\y: Bool .x) 1 ) false) ) ) (\a: Bool .\b: Unit .a))) }.c) ) (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) in (((\x: Unit .\y: Rec X. X .x) (succ 0) ) (let u = false in true))) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .b))
({a = ({a = (if (case <r = ({a = false , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .b)) }.b) > as Nat of < l = x > => x | < r = y > => y) then (unfold [ Nat ] (fold [ Unit ] (succ 0) )) else (((\x: Bool .\y: Bool .y) (if true then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else true) ) (succ 1))) , b = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = true , b = true }.b) )) in u) , c = (fix (\x: Nat . ({a = 0 , b = true , c = 1 }.c) )) }.c) , b = (if ({a = (let u = true in 1) , b = (let u = 1 in true) , c =  (unfold [ Nat ] (fold [ Nat ] 1 )) }.b) then (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (if false then 0 else ({a = true , b = 0 }.b))) else (let u = ({a = (((\x: Rec X. X .\y: Unit .y) false ) true) , b = 1 }.b) in u)) }.b)
(let u = (( \f: Unit .((f (if (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) then (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) else (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .b))) ) (if (unfold [ Unit ] (fold [ Rec X. X ] false )) then ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) else ({a = true , b = (succ 0) }.b)) ) ) (\a: Unit .\b: Rec X. X .b)) in (pred ({a = (succ 0) , b = true }.a)))
(((\x: Nat .\y: Bool .y) (fix (\x: Unit . (((\x: Rec X. X .\y: Rec X. X .x) (iszero ({a = 0 , b = true , c = 0 }.c)) ) (let u = 0 in false)) )) ) (case <l = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) (let u = true in u) ) false) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (((\x: Rec X. X .\y: Unit .x) (fix (\x: Unit . 0 )) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = true , b = 0 }.a) ))) }.a) ) (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) in (fix (\x: Rec X. X . ({a = ({a = false , b = false }.b) , b = 0 }.a) ))) ) ) (\a: Bool .\b: Unit .b))
(if ({a = (( \f: Unit .((f ({a = (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .y) true ) true) )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.b) ) (( \f: Unit .((f (let u = ({a = 1 , b = true , c = 1 }.c) in 0) ) (((\x: Bool .\y: Rec X. X .y) false ) 0) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Unit .((f ({a = (if ({a = 0 , b = true , c =  1 }.b) then (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) else true) , b = (let u = 0 in (unfold [ Bool ] (fold [ Nat ] false ))) }.b) ) (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Bool .x) true ) true)) ) ) (\a: Rec X. X .\b: Nat .b)) , c =  (let u = ({a = false , b = false }.b) in (((\x: Rec X. X .\y: Bool .y) true ) 1)) }.b) then (succ (succ ({a = 0 , b = true }.a))) else ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f (let u = true in u) ) (if true then true else false) ) ) (\a: Unit .\b: Rec X. X .b)) )) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Rec X. X . 1 )) )) }.b))
(iszero (let u = (let u = (((\x: Bool .\y: Nat .x) 1 ) true) in (let u = true in 0)) in u))
(((\x: Bool .\y: Bool .x) ({a = (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = false , b = (pred 1) }.a) , c =  (if false then 0 else (((\x: Bool .\y: Bool .y) false ) 0)) }.b) ) (( \f: Bool .((f ({a = false , b = (let u = 0 in 0) }.a) ) (fix (\x: Bool . ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(((\x: Rec X. X .\y: Rec X. X .x) (succ (((\x: Bool .\y: Rec X. X .x) 1 ) ({a = true , b = false }.b))) ) ({a = (iszero (let u = (let u = 0 in true) in (fix (\x: Unit . 1 )))) , b = ({a = (let u = ({a = true , b = false }.b) in (succ 0)) , b = (((\x: Bool .\y: Nat .y) (let u = (iszero 0) in u) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) }.a))
(((\x: Rec X. X .\y: Nat .y) (let u = (let u = true in (if true then false else true)) in (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (let u = (if true then true else true) in u) , b = (case <l = (pred 1) > as Rec X. X of < l = x > => x | < r = y > => y) }.b))
(let u = (((\x: Bool .\y: Bool .x) ({a = 1 , b = true }.b) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b))) in u)
(if ({a = (((\x: Bool .\y: Rec X. X .x) ({a = true , b = 0 }.a) ) (unfold [ Bool ] (fold [ Unit ] false ))) , b = (( \f: Rec X. X .((f (( \f: Unit .((f ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = true , c =  (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) ) (iszero 0) ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , b = (((\x: Nat .\y: Unit .y) false ) true) }.b) ) ) (\a: Bool .\b: Bool .b)) }.b) then (let u = (let u = (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) in false) in u) in u) else (case <r = (((\x: Nat .\y: Bool .x) (unfold [ Nat ] (fold [ Nat ] false )) ) (let u = false in false)) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Nat .((f (let u = (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = (fix (\x: Bool . (unfold [ Bool ] (fold [ Unit ] false )) )) in u)) ) (iszero (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) 0 ) false) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Unit .a))
(iszero (( \f: Nat .((f (( \f: Nat .((f (let u = (if (unfold [ Unit ] (fold [ Rec X. X ] true )) then (let u = false in 1) else 1) in u) ) (( \f: Unit .((f 0 ) (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Bool .((f (let u = (pred 1) in u) ) (succ 1) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .a)))
(fix (\x: Bool . ({a = ({a = ({a = 1 , b = true , c = 1 }.c) , b = ({a = 1 , b = false }.b) }.b) , b = (( \f: Bool .((f (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) ))
(succ (((\x: Rec X. X .\y: Bool .x) (let u = (if (case <r = (unfold [ Nat ] (fold [ Nat ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = ({a = 0 , b = false , c = 0 }.c) in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) else (succ 1)) in u) ) ({a = (let u = (iszero 1) in true) , b = (unfold [ Bool ] (fold [ Bool ] (let u = 0 in ({a = 1 , b = false }.a)) )) }.a)))
(( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Bool .((f ({a = (let u = true in false) , b = (let u = true in u) }.b) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) )) ) ) (\a: Unit .\b: Bool .b)) )) ) ({a = (succ 1) , b = ({a = 1 , b = (fix (\x: Unit . true )) }.b) }.b) ) ) (\a: Rec X. X .\b: Nat .b))
(succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Bool .y) true ) false) ) (fix (\x: Unit . (let u = false in 1) ))) )))
(let u = (( \f: Nat .((f (( \f: Nat .((f ({a = 1 , b = true , c =  0 }.b) ) (if ({a = false , b = 0 }.a) then false else false) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (if true then 0 else (let u = 0 in 0)) , b = (let u = 0 in false) }.b) ) ) (\a: Unit .\b: Bool .b)) in ({a = ({a = false , b = (((\x: Nat .\y: Bool .y) true ) 0) }.b) , b = (let u = ({a = (fix (\x: Nat . false )) , b = ({a = true , b = false }.b) }.b) in (pred 1)) }.b))
(((\x: Bool .\y: Bool .x) ({a = (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <l = (fix (\x: Unit . (((\x: Unit .\y: Bool .x) 1 ) true) )) > as Bool of < l = x > => x | < r = y > => y) }.a) ) (unfold [ Unit ] (fold [ Bool ] (if ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = true in true) )) then (( \f: Rec X. X .((f true ) (unfold [ Nat ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Bool .a)) else (((\x: Bool .\y: Bool .y) (((\x: Nat .\y: Bool .x) false ) false) ) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .a)))) )))
(let u = (( \f: Bool .((f (if false then (let u = false in u) else true) ) (((\x: Bool .\y: Unit .y) false ) false) ) ) (\a: Nat .\b: Unit .b)) in (unfold [ Unit ] (fold [ Unit ] (let u = ({a = 0 , b = false , c =  1 }.b) in (let u = true in false)) )))
(if (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .y) (let u = false in true) ) (((\x: Unit .\y: Bool .y) false ) false)) ) (let u = (if true then 0 else 0) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Nat .a)) then (case <l = (( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Bool .x) 1 ) true) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Bool .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) else (pred (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if false then false else true) )) in (let u = true in 1))))
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) then (((\x: Unit .\y: Rec X. X .x) 1 ) false) else 0) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) , b = ({a = (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = true , c =  1 }.b) ) (((\x: Nat .\y: Bool .x) false ) true)) , b = (if true then ({a = 0 , b = true , c = 1 }.c) else ({a = 0 , b = false }.a)) }.a) , c =  ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) }.b) ))
(fix (\x: Nat . (let u = (fix (\x: Unit . (pred (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))) )) in (fix (\x: Rec X. X . (let u = (((\x: Bool .\y: Rec X. X .y) true ) false) in ({a = false , b = false }.b)) ))) ))
(let u = ({a = (let u = (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in false) in (case <l = (succ 1) > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = ({a = (((\x: Unit .\y: Rec X. X .y) false ) true) , b = ({a = 1 , b = false }.b) }.b) , b = (if ({a = 1 , b = false , c =  1 }.b) then ({a = 0 , b = true , c = 0 }.c) else 0) }.a) }.a) in u)
(case <l = (let u = (succ ({a = 0 , b = true , c = 1 }.c)) in (pred 1)) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <l = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) in (let u = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Bool .x) 1 ) true) }.b) in (fix (\x: Nat . 0 )))) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <l = (let u = (if (let u = true in (fix (\x: Nat . false ))) then ({a = (let u = 0 in false) , b = 1 }.b) else (if false then 0 else 1)) in (let u = ({a = 0 , b = false }.b) in (((\x: Rec X. X .\y: Bool .x) (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) ) (iszero 1)))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = (let u = false in u) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ) (let u = 0 in 0) ) ) (\a: Nat .\b: Bool .b)) }.a) in u)
(((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f (let u = (let u = 1 in false) in (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) (unfold [ Nat ] (fold [ Unit ] ({a = ({a = true , b = 1 }.a) , b = 1 }.a) )) ) ) (\a: Unit .\b: Unit .b)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Nat . ({a = 1 , b = false , c = 1 }.c) )) )))
(pred ({a = (let u = (let u = 0 in 1) in (((\x: Unit .\y: Rec X. X .y) true ) 1)) , b = (let u = 0 in u) }.b))
({a = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) (fix (\x: Rec X. X . 1 )) ) (((\x: Nat .\y: Nat .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)))) )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = (unfold [ Bool ] (fold [ Rec X. X ] true )) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = true in 1) ) (let u = false in u)) }.b) )) }.b)
({a = (( \f: Bool .((f (( \f: Rec X. X .((f (case <l = ({a = 1 , b = true , c = 0 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Bool ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) )) ) ) (\a: Bool .\b: Unit .b)) ) ({a = ({a = true , b = 1 }.b) , b = ({a = ({a = 0 , b = false , c = 1 }.c) , b = (((\x: Bool .\y: Unit .y) true ) 0) }.b) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (((\x: Bool .\y: Unit .y) false ) true) , b = (let u = 1 in u) }.b) )) in ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in true) }.a)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f ({a = false , b = 1 }.a) ) (let u = true in true) ) ) (\a: Bool .\b: Rec X. X .a)) )) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = true in 0) )) ) ) (\a: Nat .\b: Nat .a)) )) }.b) }.a)
(let u = (let u = (pred (((\x: Unit .\y: Rec X. X .x) ({a = 1 , b = true , c = 0 }.c) ) false)) in (pred ({a = 1 , b = true , c = 0 }.c))) in (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (((\x: Nat .\y: Unit .y) (if true then ({a = false , b = 1 }.a) else false) ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .b))) ) (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = true , c =  0 }.b) )) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b)))
(unfold [ Unit ] (fold [ Rec X. X ] (( \f: Bool .((f ({a = 1 , b = 0 }.b) ) (((\x: Bool .\y: Rec X. X .y) ({a = 1 , b = false , c =  1 }.b) ) (let u = 0 in 0)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
({a = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = 1 , b = (if true then true else false) , c = (pred 0) }.c) , b = (fix (\x: Rec X. X . true )) , c = (((\x: Nat .\y: Rec X. X .y) true ) 1) }.c) )) , b = (let u = (fix (\x: Bool . (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in ({a = 1 , b = 1 }.b)) )) in (( \f: Nat .((f (((\x: Unit .\y: Nat .x) true ) true) ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , c = (fix (\x: Unit . (( \f: Rec X. X .((f 1 ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) }.c) , b = (( \f: Unit .((f ({a = (let u = 1 in (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) , b = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = (fix (\x: Bool . false )) , b = false }.b)) , c =  ({a = ({a = false , b = 0 }.b) , b = (((\x: Nat .\y: Rec X. X .y) true ) true) }.a) }.b) ) (case <r = (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in true) ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .a))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) }.a)
(succ ({a = (((\x: Unit .\y: Bool .y) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) ) (let u = 1 in false)) , b = (fix (\x: Nat . 0 )) }.b))
(( \f: Bool .((f (((\x: Unit .\y: Bool .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) true ) false) )) ) (unfold [ Unit ] (fold [ Bool ] true ))) ) (case <r = (let u = (fix (\x: Bool . ({a = 0 , b = true , c =  0 }.b) )) in u) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(( \f: Rec X. X .((f (let u = (succ 0) in (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = 0 }.a) )) ) (let u = true in false) ) ) (\a: Nat .\b: Rec X. X .b))) ) (unfold [ Nat ] (fold [ Bool ] (iszero (let u = 0 in 0)) )) ) ) (\a: Unit .\b: Nat .a))
({a = (let u = (( \f: Rec X. X .((f (case <l = (( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] 1 )) ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 0 , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u) , b = ({a = (unfold [ Bool ] (fold [ Bool ] ({a = true , b = false }.b) )) , b = (( \f: Nat .((f ({a = false , b = 1 }.a) ) (let u = 0 in false) ) ) (\a: Nat .\b: Nat .b)) }.b) , c = (let u = (fix (\x: Bool . (let u = (succ 0) in (pred 0)) )) in u) }.c)
({a = (((\x: Unit .\y: Unit .y) ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) }.a) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Bool .x) false ) true) ) (unfold [ Unit ] (fold [ Nat ] 1 )))) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (iszero ({a = (((\x: Bool .\y: Nat .x) 0 ) true) , b = (((\x: Unit .\y: Unit .x) 0 ) true) }.b)) )) , c =  (((\x: Rec X. X .\y: Unit .x) (let u = (fix (\x: Nat . (((\x: Bool .\y: Bool .y) false ) 1) )) in u) ) (if (( \f: Nat .((f (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) ({a = false , b = 0 }.a) ) ) (\a: Bool .\b: Rec X. X .a)) then ({a = true , b = true }.b) else (if false then true else true))) }.b)
(((\x: Unit .\y: Nat .y) (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) false) )) then ({a = ({a = 1 , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) }.b) , b = ({a = (let u = 0 in u) , b = ({a = 0 , b = ({a = false , b = false }.b) , c =  (let u = 1 in u) }.b) , c =  ({a = (pred 1) , b = (let u = true in u) }.a) }.b) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (succ 1) )) }.b) else ({a = ({a = 0 , b = false , c =  0 }.b) , b = (succ 0) }.a)) ) (fix (\x: Unit . (iszero (let u = false in 1)) )))
(((\x: Bool .\y: Bool .x) (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) ) (( \f: Bool .((f (((\x: Nat .\y: Nat .x) true ) true) ) (((\x: Nat .\y: Unit .x) true ) ({a = 1 , b = false , c =  0 }.b)) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Bool .\b: Rec X. X .a)) ) (((\x: Unit .\y: Unit .y) (if false then true else (iszero 0)) ) ({a = (if false then false else false) , b = ({a = ({a = false , b = true }.b) , b = 1 }.a) }.b)))
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (if (let u = (let u = 0 in false) in u) then (((\x: Unit .\y: Bool .x) (let u = 0 in u) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) else ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)) ))
(let u = ({a = (((\x: Bool .\y: Unit .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) false) , b = (((\x: Bool .\y: Bool .x) true ) false) }.b) in (fix (\x: Unit . ({a = ({a = (let u = 0 in 0) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) , c =  (let u = false in 0) }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = true , b = 0 }.a) )) }.b) )))
(if (( \f: Rec X. X .((f ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , b = (iszero (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) }.b) ) (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f (((\x: Bool .\y: Unit .y) true ) true) ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (if false then (let u = true in u) else (let u = 1 in true))) ) ) (\a: Nat .\b: Rec X. X .a)) then (((\x: Nat .\y: Bool .x) (( \f: Unit .((f ({a = ({a = 1 , b = true }.b) , b = true }.b) ) (let u = true in true) ) ) (\a: Unit .\b: Unit .a)) ) ({a = ({a = true , b = true }.b) , b = (unfold [ Bool ] (fold [ Unit ] 1 )) }.a)) else (((\x: Unit .\y: Bool .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f true ) ({a = 0 , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) ) ({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a))) , b = (let u = false in true) }.b)))
(fix (\x: Bool . (let u = (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = 0 }.b) )) in (pred (let u = 0 in u))) ))
({a = (let u = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) in u) in ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = ({a = true , b = 1 }.a) }.a)) , b = ({a = ({a = ({a = 1 , b = true , c = 0 }.c) , b = ({a = 0 , b = false }.b) , c = (unfold [ Unit ] (fold [ Unit ] 1 )) }.c) , b = (((\x: Rec X. X .\y: Rec X. X .y) (iszero 1) ) (unfold [ Rec X. X ] (fold [ Unit ] false ))) }.b) , c = (let u = (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] true )) ) (let u = 1 in true) ) ) (\a: Bool .\b: Bool .a)) in (pred ({a = (let u = 0 in u) , b = (succ 0) }.b))) }.c)
(((\x: Unit .\y: Nat .y) (let u = (case <r = ({a = ({a = true , b = 0 }.b) , b = false , c =  (((\x: Nat .\y: Rec X. X .y) true ) 1) }.b) > as Nat of < l = x > => x | < r = y > => y) in ({a = true , b = 0 }.a)) ) (let u = (( \f: Unit .((f (case <l = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Nat .y) false ) false) ) 1) ) ) (\a: Nat .\b: Unit .b)) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Nat . (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) ))))
({a = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 1 , b = false }.b) )) , b = (( \f: Rec X. X .((f (if false then 0 else 0) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) }.a) , b = (let u = ({a = (pred 0) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.b) in (let u = (((\x: Nat .\y: Nat .x) 1 ) (fix (\x: Nat . true ))) in u)) }.a)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = 0 }.b) )) ))
(if (let u = (case <r = ({a = 0 , b = false , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a))) then (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Nat . ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) , b = 1 }.a) )) )) else (( \f: Nat .((f (let u = 0 in (((\x: Nat .\y: Rec X. X .x) true ) false)) ) (unfold [ Unit ] (fold [ Bool ] true )) ) ) (\a: Rec X. X .\b: Bool .a)))
({a = ({a = ({a = (let u = 0 in u) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) }.a) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (((\x: Nat .\y: Unit .x) false ) false) , b = (let u = false in u) }.b) )) , c = (if (((\x: Nat .\y: Unit .x) ({a = false , b = 0 }.a) ) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b))) then ({a = false , b = (fix (\x: Nat . 0 )) }.b) else (if (unfold [ Nat ] (fold [ Nat ] (let u = 0 in false) )) then (let u = true in 0) else (unfold [ Bool ] (fold [ Unit ] 1 )))) }.c) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = true }.b) )) )) , c =  (((\x: Nat .\y: Nat .x) ({a = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = 0 in u) }.b) ) (((\x: Rec X. X .\y: Bool .x) (let u = false in false) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )))) }.b)
(((\x: Unit .\y: Nat .x) ({a = (let u = (let u = ({a = false , b = 1 }.b) in u) in u) , b = (let u = ({a = 0 , b = false , c =  1 }.b) in ({a = 1 , b = true , c =  1 }.b)) }.b) ) (((\x: Rec X. X .\y: Unit .y) (( \f: Unit .((f (case <r = (let u = true in false) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (case <r = (let u = 0 in true) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = false in false) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .a)) ) (( \f: Nat .((f (fix (\x: Nat . false )) ) (((\x: Unit .\y: Bool .x) (let u = false in true) ) false) ) ) (\a: Rec X. X .\b: Nat .b))))
(if (((\x: Bool .\y: Rec X. X .y) (let u = false in ({a = 1 , b = false , c =  0 }.b)) ) (((\x: Rec X. X .\y: Unit .y) (let u = (iszero 0) in true) ) (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) )))) then (((\x: Nat .\y: Bool .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) ) (succ (pred 0))) else (((\x: Rec X. X .\y: Unit .x) (let u = (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) )) in (( \f: Unit .((f (succ 0) ) ({a = 0 , b = true }.a) ) ) (\a: Unit .\b: Bool .b))) ) (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ({a = 1 , b = true }.b))))
(((\x: Unit .\y: Bool .x) (fix (\x: Bool . ({a = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) )) , b = (iszero (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) }.b) )) ) (let u = (( \f: Rec X. X .((f (fix (\x: Rec X. X . (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b)) )) ) ({a = 0 , b = true }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u))
(let u = (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = ({a = (let u = 0 in 0) , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) )) then (let u = (iszero (fix (\x: Rec X. X . 0 ))) in (((\x: Unit .\y: Rec X. X .y) true ) ({a = 1 , b = false }.b))) else ({a = (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) (let u = false in u) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (pred 1) }.b) }.a)) in ({a = (if (iszero 1) then ({a = true , b = 0 }.b) else ({a = true , b = 1 }.b)) , b = (if (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) in (let u = false in false)) then (let u = false in false) else (fix (\x: Nat . true ))) }.b))
(let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Nat .x) 0 ) true) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true ))) ) (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] 0 )) ) (let u = ({a = 1 , b = false , c =  0 }.b) in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .b)) in u)
(if (unfold [ Nat ] (fold [ Bool ] (case <r = ({a = (let u = false in 1) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (unfold [ Bool ] (fold [ Nat ] 0 )) }.b) > as Nat of < l = x > => x | < r = y > => y) )) then (((\x: Rec X. X .\y: Rec X. X .y) (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in 0) ))) ) (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u)) else ({a = (let u = (let u = 0 in 0) in u) , b = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) )) , c =  (if (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = true , c =  1 }.b) )) then (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) ) (if ({a = true , b = 1 }.a) then 1 else 0) ) ) (\a: Nat .\b: Bool .b)) else ({a = (let u = (((\x: Unit .\y: Bool .y) true ) true) in ({a = 1 , b = true }.a)) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) , c = ({a = true , b = 1 }.b) }.c)) }.b))
(((\x: Unit .\y: Bool .y) (( \f: Unit .((f (iszero (pred 0)) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) true ) true) ) true ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Bool .\b: Rec X. X .a)) ) (( \f: Bool .((f (if (let u = (let u = 1 in true) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true ))) then (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) else (((\x: Bool .\y: Rec X. X .x) true ) ({a = 1 , b = false , c =  0 }.b))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = true , c =  1 }.b) )) ) ) (\a: Bool .\b: Nat .a)))
(let u = (unfold [ Unit ] (fold [ Rec X. X ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) in ({a = (iszero (let u = 1 in 0)) , b = (( \f: Nat .((f (let u = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then true else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) in u) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Nat .\b: Rec X. X .b)) }.b))
(if (( \f: Unit .((f (case <r = (let u = true in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = ({a = true , b = 0 }.a) , c =  1 }.b) )) ) ) (\a: Rec X. X .\b: Bool .a)) then ({a = ({a = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) , b = ({a = 1 , b = false }.b) }.a) , b = (case <l = (pred (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) > as Bool of < l = x > => x | < r = y > => y) }.b) else (let u = (pred (unfold [ Bool ] (fold [ Bool ] 1 ))) in (((\x: Bool .\y: Bool .y) ({a = true , b = true }.b) ) (pred (succ 1)))))
(( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] (case <r = (((\x: Nat .\y: Nat .x) false ) true) > as Bool of < l = x > => x | < r = y > => y) )) ) (fix (\x: Bool . (let u = (( \f: Nat .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = ({a = true , b = 0 }.a) in (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)))) )) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = (iszero 1) in ({a = ({a = true , b = true }.b) , b = (iszero 1) }.b)) )) ))
({a = (fix (\x: Bool . ({a = ({a = false , b = (unfold [ Unit ] (fold [ Unit ] false )) }.b) , b = (let u = 0 in u) }.b) )) , b = (let u = (let u = (( \f: Bool .((f false ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) in (( \f: Rec X. X .((f (let u = ({a = 0 , b = false , c = 0 }.c) in 0) ) ({a = 0 , b = true }.a) ) ) (\a: Nat .\b: Unit .a))) in (( \f: Rec X. X .((f ({a = true , b = true }.b) ) (unfold [ Bool ] (fold [ Bool ] false )) ) ) (\a: Nat .\b: Nat .a))) }.b)
({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) in ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Bool .y) (fix (\x: Unit . true )) ) (let u = 0 in true)) }.a)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = false , b = (((\x: Nat .\y: Unit .x) true ) false) }.b) )) , c =  (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Rec X. X .y) ({a = 0 , b = true }.b) ) ({a = (pred 0) , b = (((\x: Bool .\y: Nat .x) 0 ) false) }.b)) ) (( \f: Nat .((f ({a = false , b = false }.b) ) (fix (\x: Rec X. X . (let u = true in u) )) ) ) (\a: Bool .\b: Bool .a))) }.b)
(fix (\x: Nat . (pred ({a = ({a = 1 , b = true }.b) , b = ({a = 0 , b = 0 }.b) }.b)) ))
(( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Bool ] (let u = (let u = true in true) in (let u = 1 in u)) )) ) (pred ({a = (fix (\x: Nat . 1 )) , b = (let u = 0 in true) }.a)) ) ) (\a: Bool .\b: Nat .b))
(((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Nat .x) (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ) ({a = true , b = (let u = false in 0) }.a)) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .y) ({a = ({a = 0 , b = 1 }.b) , b = true , c =  (let u = 1 in 0) }.b) ) ({a = 1 , b = false , c =  0 }.b)) ) (fix (\x: Nat . (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) )) ) ) (\a: Unit .\b: Nat .a)))
(succ (((\x: Nat .\y: Rec X. X .y) (( \f: Bool .((f ({a = (((\x: Bool .\y: Unit .x) true ) true) , b = (((\x: Rec X. X .\y: Unit .y) true ) false) }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Nat . true )) )) ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Unit .\y: Unit .y) (unfold [ Bool ] (fold [ Bool ] false )) ) (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = true , c = 0 }.c) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false ))))))
({a = (iszero (pred (if true then 1 else 1))) , b = ({a = (unfold [ Unit ] (fold [ Rec X. X ] (case <r = (unfold [ Unit ] (fold [ Nat ] false )) > as Bool of < l = x > => x | < r = y > => y) )) , b = (((\x: Bool .\y: Bool .x) (let u = ({a = 0 , b = 0 }.b) in u) ) (if ({a = ({a = 0 , b = false }.a) , b = false , c =  1 }.b) then ({a = 1 , b = true }.b) else ({a = (let u = 0 in u) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) , c =  0 }.b))) }.b) }.a)
(let u = (((\x: Bool .\y: Nat .x) ({a = ({a = 0 , b = 1 }.b) , b = false }.a) ) (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = false , c =  0 }.b) ))) in u)
(succ (unfold [ Nat ] (fold [ Unit ] ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = 1 }.b) )))
(( \f: Bool .((f (unfold [ Bool ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (let u = true in 1) )) )) ) (succ (unfold [ Rec X. X ] (fold [ Bool ] ({a = false , b = 1 }.b) ))) ) ) (\a: Unit .\b: Unit .a))
({a = (if (let u = ({a = true , b = 1 }.a) in ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false ))) then (case <l = (fix (\x: Bool . 1 )) > as Unit of < l = x > => x | < r = y > => y) else ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = ({a = 1 , b = false }.a) }.b)) , b = ({a = (let u = ({a = 0 , b = true }.b) in u) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = 0 in (if true then true else true)) )) }.b) , c =  (let u = ({a = ({a = true , b = true }.b) , b = (let u = 0 in 1) }.b) in u) }.b)
(((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Unit .x) (fix (\x: Rec X. X . (( \f: Bool .((f ({a = 1 , b = false }.b) ) (iszero 1) ) ) (\a: Nat .\b: Rec X. X .b)) )) ) ({a = (succ 0) , b = (let u = false in true) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.b)) ) (pred (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (case <l = (unfold [ Nat ] (fold [ Bool ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b) ))))
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Bool . (fix (\x: Unit . (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) )) )) )) , b = (case <r = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) in (iszero 1)) , b = ({a = false , b = 0 }.b) }.a) > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (((\x: Bool .\y: Unit .x) ({a = 0 , b = 1 }.b) ) (((\x: Bool .\y: Bool .y) false ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )))) }.b) }.b)
(( \f: Rec X. X .((f (case <r = (((\x: Unit .\y: Bool .y) (let u = (fix (\x: Unit . false )) in u) ) (unfold [ Nat ] (fold [ Rec X. X ] true ))) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (unfold [ Unit ] (fold [ Bool ] (if (let u = false in false) then true else false) )) in u) ) ) (\a: Bool .\b: Unit .b))
(fix (\x: Bool . (((\x: Unit .\y: Unit .x) (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) then (let u = 0 in u) else (fix (\x: Nat . (if true then 0 else 0) ))) ) (( \f: Rec X. X .((f ({a = ({a = 0 , b = false , c = 0 }.c) , b = (if false then true else true) }.b) ) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Nat .y) true ) false) }.b) ) ) (\a: Rec X. X .\b: Bool .b))) ))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (let u = true in u) in u) , c =  ({a = ({a = 1 , b = true , c = 1 }.c) , b = (fix (\x: Bool . ({a = 1 , b = false }.b) )) , c = ({a = false , b = 0 }.b) }.c) }.b) ))
(case <l = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <l = (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) )) > as Bool of < l = x > => x | < r = y > => y) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Nat ] (fold [ Unit ] (let u = ({a = ({a = true , b = 0 }.a) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.b) in ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) , b = (fix (\x: Bool . 0 )) }.b)) ))
(unfold [ Nat ] (fold [ Unit ] (( \f: Unit .((f (case <r = (iszero (let u = 1 in 1)) > as Nat of < l = x > => x | < r = y > => y) ) (if (let u = 0 in true) then ({a = true , b = ({a = 0 , b = true , c = 1 }.c) }.a) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))) ) ) (\a: Rec X. X .\b: Unit .a)) ))
(let u = (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) ) (((\x: Unit .\y: Nat .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = true , b = false }.b))) ) (if ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) then false else true) ) ) (\a: Rec X. X .\b: Bool .b)) in u)
(( \f: Bool .((f (let u = (unfold [ Unit ] (fold [ Nat ] ({a = true , b = 1 }.a) )) in (if false then ({a = 0 , b = true , c =  0 }.b) else (case <r = false > as Nat of < l = x > => x | < r = y > => y))) ) (((\x: Rec X. X .\y: Unit .x) (iszero ({a = 1 , b = true }.a)) ) (((\x: Bool .\y: Rec X. X .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .y) true ) true) )) ) (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = 1 }.a) ) (((\x: Bool .\y: Nat .y) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = false , b = 0 }.a))))) ) ) (\a: Rec X. X .\b: Unit .b))
(if ({a = (((\x: Unit .\y: Bool .x) ({a = (case <l = ({a = true , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . (iszero 0) )) , c = (let u = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .a)) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b))) }.c) ) (((\x: Nat .\y: Rec X. X .x) true ) false)) , b = (let u = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = (let u = 0 in 1) }.b) in (((\x: Nat .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Unit ] true )) ) (((\x: Unit .\y: Nat .x) false ) true))) , c =  (let u = (unfold [ Bool ] (fold [ Rec X. X ] false )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = 0 }.b) ))) }.b) then (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Nat . (((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) ) true) )) )) else (let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = (let u = 0 in 0) }.a) in (let u = (let u = 1 in false) in u)))
(let u = (let u = (fix (\x: Unit . (fix (\x: Unit . 1 )) )) in u) in (( \f: Bool .((f (let u = (if true then 0 else 1) in ({a = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = 0 }.a)) ) (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Nat .y) false ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .a))) )) ) ) (\a: Bool .\b: Bool .a)))
({a = (let u = (unfold [ Unit ] (fold [ Nat ] (let u = true in u) )) in (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) in (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)))) , b = (let u = (let u = (let u = ({a = 0 , b = true }.a) in false) in u) in u) }.b)
({a = (unfold [ Nat ] (fold [ Bool ] (let u = (let u = 1 in u) in u) )) , b = (let u = ({a = ({a = ({a = 0 , b = true , c = 1 }.c) , b = true , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.c) , b = (let u = false in u) }.b) in (unfold [ Nat ] (fold [ Unit ] (let u = true in true) ))) , c = (let u = (let u = (case <l = (((\x: Bool .\y: Unit .x) 1 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a))) in ({a = (((\x: Nat .\y: Unit .y) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) (unfold [ Nat ] (fold [ Bool ] 1 ))) , b = ({a = (succ 1) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.a) }.b)) }.c)
(let u = (unfold [ Bool ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (let u = (pred (let u = 1 in 1)) in ({a = 0 , b = true }.a)) )) )) in (let u = (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .y) (let u = 0 in true) ) (fix (\x: Rec X. X . true ))) ) (if ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = ({a = false , b = 1 }.a) , c =  1 }.b) then (let u = false in u) else (iszero 0))) in (let u = ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = (let u = false in u) }.b) in u)))
(case <l = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] 0 )) )) )) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = ({a = (let u = ({a = 1 , b = true , c =  0 }.b) in u) , b = ({a = 1 , b = true , c = 1 }.c) }.a) , b = (((\x: Unit .\y: Rec X. X .x) (pred 1) ) (let u = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u)) }.b) , b = ({a = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = false }.a)) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = 0 }.a) ) ({a = 1 , b = false , c =  0 }.b)) , c =  ({a = (succ 1) , b = (fix (\x: Unit . false )) , c = ({a = (let u = false in 1) , b = 1 }.b) }.c) }.b) , c =  ({a = (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Rec X. X . true )) )) , b = (succ (succ 0)) }.b) }.b)
({a = (succ ({a = (fix (\x: Nat . true )) , b = (( \f: Bool .((f ({a = 0 , b = true , c = 0 }.c) ) ({a = true , b = 1 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) }.b)) , b = (((\x: Unit .\y: Rec X. X .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in u) )) ) (if (if ({a = true , b = false }.b) then (if true then false else false) else false) then (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .a)) else (iszero 0))) , c = (succ ({a = ({a = (((\x: Unit .\y: Unit .x) 0 ) true) , b = (iszero 0) , c = (fix (\x: Bool . (fix (\x: Unit . 1 )) )) }.c) , b = (if true then true else false) , c = ({a = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = 1 }.b) }.c)) }.c)
(unfold [ Bool ] (fold [ Bool ] (let u = (((\x: Unit .\y: Nat .x) (let u = true in 1) ) ({a = 0 , b = true }.b)) in u) ))
({a = (if (let u = false in true) then (let u = true in u) else (((\x: Rec X. X .\y: Nat .y) false ) ({a = 1 , b = true , c =  0 }.b))) , b = (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = (if false then 0 else 0) , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) , c = ({a = 0 , b = false }.a) }.c) )) ) (pred (fix (\x: Unit . ({a = 0 , b = true , c = 1 }.c) ))) ) ) (\a: Unit .\b: Rec X. X .a)) }.b)
(fix (\x: Rec X. X . (fix (\x: Rec X. X . ({a = 0 , b = true }.a) )) ))
({a = (pred (succ (pred 1))) , b = (((\x: Nat .\y: Unit .x) (case <l = (let u = 0 in 1) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b)) }.b)
(let u = (( \f: Unit .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) (((\x: Bool .\y: Unit .y) false ) 1) ) ) (\a: Unit .\b: Unit .a)) in ({a = ({a = (( \f: Nat .((f ({a = 1 , b = true , c =  0 }.b) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (succ (unfold [ Rec X. X ] (fold [ Unit ] 0 ))) }.b) , b = ({a = (let u = false in 0) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .a)) , c =  (( \f: Rec X. X .((f ({a = 0 , b = (if true then true else true) }.a) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Bool .\b: Unit .b)) }.b) , c = (let u = (((\x: Bool .\y: Rec X. X .x) 0 ) false) in u) }.c))
(if ({a = (( \f: Unit .((f ({a = 1 , b = ({a = false , b = 0 }.a) , c =  (fix (\x: Nat . 1 )) }.b) ) (fix (\x: Unit . false )) ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = ({a = 1 , b = true , c = 1 }.c) , b = (let u = false in u) }.a) }.a) then ({a = (succ (((\x: Rec X. X .\y: Bool .y) true ) 1)) , b = (let u = ({a = (((\x: Nat .\y: Unit .x) true ) true) , b = 0 }.a) in u) }.b) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .b)) )))
(iszero ({a = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = true in 1) )) in ({a = (iszero (pred 1)) , b = (( \f: Bool .((f 0 ) (((\x: Bool .\y: Rec X. X .y) false ) 0) ) ) (\a: Rec X. X .\b: Nat .b)) }.a)) , b = ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (if false then 1 else 1) )) , b = (iszero 0) , c = (((\x: Rec X. X .\y: Unit .y) true ) (unfold [ Nat ] (fold [ Unit ] 1 ))) }.c) , b = ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = ({a = true , b = 1 }.a) }.b) }.a) }.b))
(fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Nat ] ({a = ({a = (if true then 1 else 1) , b = true }.b) , b = ({a = 0 , b = true }.a) }.b) )) ))
(iszero (let u = (let u = ({a = 0 , b = false }.b) in ({a = false , b = 0 }.a)) in (let u = (fix (\x: Rec X. X . ({a = false , b = 0 }.a) )) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .x) 0 ) true) )))))
(unfold [ Unit ] (fold [ Unit ] (let u = (((\x: Nat .\y: Rec X. X .y) (iszero 1) ) (( \f: Rec X. X .((f true ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))) in (case <r = (let u = 1 in false) > as Nat of < l = x > => x | < r = y > => y)) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = (fix (\x: Rec X. X . (fix (\x: Unit . 1 )) )) in (let u = ({a = ({a = 1 , b = true }.b) , b = (pred 1) }.a) in u)) ))
(fix (\x: Bool . ({a = ({a = ({a = 0 , b = true }.b) , b = (((\x: Bool .\y: Unit .x) 0 ) true) }.b) , b = (((\x: Rec X. X .\y: Nat .y) false ) ({a = 0 , b = false }.b)) }.b) ))
({a = (let u = (((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) (let u = 0 in false) ) ) (\a: Rec X. X .\b: Unit .a)) ) (if (((\x: Bool .\y: Unit .x) true ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false ))) then (if false then false else false) else (let u = 1 in false))) in (( \f: Rec X. X .((f (( \f: Nat .((f (succ 0) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a)) ) (unfold [ Nat ] (fold [ Nat ] (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) 0 ) ) (\a: Nat .\b: Nat .b)) )) ) ) (\a: Rec X. X .\b: Nat .a))) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) (if ({a = true , b = true }.b) then true else (let u = 1 in false)) ) ({a = ({a = 1 , b = 0 }.b) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) }.b)) ) (( \f: Rec X. X .((f ({a = 1 , b = false , c =  1 }.b) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .a)) }.a)
(( \f: Bool .((f (case <l = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) true) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (let u = 0 in u) , b = ({a = 1 , b = (iszero 1) }.a) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (iszero (succ (let u = ({a = 0 , b = 1 }.b) in u))) , b = (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = 1 in u) )) ) (( \f: Bool .((f ({a = 0 , b = false , c = 1 }.c) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .a)) }.b)
(case <r = (let u = (succ (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) else 1)) in (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .x) ({a = 0 , b = true }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) false ) true) ))) ) (let u = ({a = true , b = 1 }.b) in ({a = (fix (\x: Bool . 0 )) , b = true , c =  1 }.b)) ) ) (\a: Unit .\b: Nat .a))) > as Nat of < l = x > => x | < r = y > => y)
(if ({a = (( \f: Unit .((f (((\x: Nat .\y: Bool .y) false ) 0) ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (case <r = (((\x: Nat .\y: Nat .x) false ) true) > as Unit of < l = x > => x | < r = y > => y) , c =  (succ 0) }.b) then (( \f: Unit .((f (if (unfold [ Unit ] (fold [ Nat ] false )) then ({a = true , b = true }.b) else ({a = false , b = 0 }.a)) ) (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Rec X. X .x) (fix (\x: Unit . false )) ) (if true then true else true)) ) ({a = (fix (\x: Nat . (let u = 1 in true) )) , b = ({a = true , b = 1 }.a) }.b)) ) ) (\a: Rec X. X .\b: Nat .a)) else (((\x: Unit .\y: Unit .y) (if (((\x: Nat .\y: Rec X. X .y) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a))) then (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) (iszero 0) ) ) (\a: Nat .\b: Bool .b)) else (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) true ) ) (\a: Unit .\b: Unit .a))) ) (((\x: Nat .\y: Nat .y) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (unfold [ Bool ] (fold [ Bool ] false )))))
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (pred (fix (\x: Unit . (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ))) )) , b = (pred (if (unfold [ Unit ] (fold [ Nat ] false )) then (let u = 0 in u) else (let u = 0 in 1))) }.b)
(case <r = (iszero ({a = (pred 0) , b = ({a = 1 , b = 1 }.b) }.b)) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Bool .y) (case <r = ({a = 0 , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Nat .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Nat .\y: Unit .x) true ) true)) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .a))) ) (unfold [ Unit ] (fold [ Nat ] (fix (\x: Rec X. X . false )) )) ) ) (\a: Nat .\b: Nat .b)))
(let u = (case <l = (let u = ({a = 0 , b = true }.a) in u) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = (let u = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) in ({a = 0 , b = (unfold [ Unit ] (fold [ Bool ] true )) }.b)) in u))
(iszero (pred (( \f: Rec X. X .((f ({a = ({a = 1 , b = false , c = 1 }.c) , b = (((\x: Bool .\y: Nat .y) true ) 1) }.b) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = ({a = 1 , b = true , c =  0 }.b) in u) , c = (if true then 0 else 1) }.c) ) ) (\a: Unit .\b: Nat .a))))
(((\x: Rec X. X .\y: Nat .x) (let u = (let u = (case <r = (let u = true in u) > as Rec X. X of < l = x > => x | < r = y > => y) in u) in u) ) (unfold [ Nat ] (fold [ Bool ] (case <r = ({a = (if false then false else false) , b = ({a = false , b = false }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) )))
({a = (( \f: Nat .((f ({a = (if false then 0 else 1) , b = (let u = true in false) , c =  ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = 1 }.b) }.b) ) (iszero (case <l = (let u = false in 1) > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Bool .a)) , b = (if (( \f: Rec X. X .((f (if true then false else true) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Unit .a)) then (( \f: Nat .((f 1 ) (let u = 1 in 1) ) ) (\a: Unit .\b: Bool .a)) else (pred 1)) }.b)
(unfold [ Nat ] (fold [ Unit ] (fix (\x: Nat . (let u = ({a = 0 , b = false , c = 1 }.c) in ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) , b = 0 }.b)) )) ))
(fix (\x: Bool . (( \f: Bool .((f (case <r = (if true then true else false) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) false ) true)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(fix (\x: Bool . (((\x: Bool .\y: Unit .y) (fix (\x: Unit . (fix (\x: Bool . false )) )) ) (if (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .b)) then ({a = 0 , b = true , c =  0 }.b) else true)) ))
(let u = (pred (( \f: Bool .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Unit .\y: Nat .y) false ) 0) ) ) (\a: Bool .\b: Unit .a))) in ({a = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in (let u = false in u)) , b = (succ (pred (((\x: Bool .\y: Unit .y) true ) 0))) }.a))
(( \f: Unit .((f (let u = (unfold [ Nat ] (fold [ Nat ] (pred 0) )) in (fix (\x: Bool . (let u = (let u = false in true) in (let u = false in u)) ))) ) (if (( \f: Bool .((f (let u = false in true) ) (let u = false in u) ) ) (\a: Unit .\b: Bool .b)) then (let u = (( \f: Bool .((f ({a = 1 , b = false , c =  1 }.b) ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Unit .b)) in (let u = false in u)) else (unfold [ Unit ] (fold [ Unit ] (let u = 0 in true) ))) ) ) (\a: Unit .\b: Bool .a))
(((\x: Bool .\y: Rec X. X .y) (case <r = (unfold [ Nat ] (fold [ Unit ] (( \f: Bool .((f ({a = true , b = 0 }.a) ) false ) ) (\a: Unit .\b: Unit .b)) )) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (((\x: Bool .\y: Nat .x) (if false then 1 else 1) ) (( \f: Rec X. X .((f false ) (let u = false in u) ) ) (\a: Bool .\b: Bool .b))) ) ({a = (if false then 1 else 1) , b = (fix (\x: Rec X. X . false )) , c = (fix (\x: Rec X. X . 0 )) }.c) ) ) (\a: Unit .\b: Bool .b)))
({a = (if (unfold [ Nat ] (fold [ Nat ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) then (unfold [ Unit ] (fold [ Rec X. X ] ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = true , c = (let u = 0 in u) }.c) )) else (pred 0)) , b = (fix (\x: Unit . (iszero (if (fix (\x: Bool . true )) then (let u = true in 1) else ({a = 0 , b = true , c = 1 }.c))) )) , c =  (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Bool .y) (let u = 1 in true) ) (((\x: Nat .\y: Nat .x) 0 ) false)) ) (unfold [ Unit ] (fold [ Bool ] (iszero (if false then 0 else 0)) ))) }.b)
(((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Bool .y) (let u = ({a = 0 , b = false }.b) in false) ) ({a = (let u = false in u) , b = 0 }.a)) ) ({a = (case <l = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (fix (\x: Nat . (unfold [ Bool ] (fold [ Nat ] true )) )) in (let u = false in true)) }.b))
(if (if (case <r = (((\x: Rec X. X .\y: Unit .x) (let u = 1 in false) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y) then ({a = (((\x: Nat .\y: Bool .y) ({a = 1 , b = false }.b) ) (pred 1)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) else (((\x: Rec X. X .\y: Rec X. X .y) ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = false }.b) ) (((\x: Bool .\y: Nat .y) true ) false))) then (if (( \f: Unit .((f ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) , b = (let u = 0 in u) }.a) ) (let u = (( \f: Bool .((f 0 ) (if false then 1 else 1) ) ) (\a: Bool .\b: Nat .a)) in (((\x: Bool .\y: Bool .x) (let u = false in true) ) false)) ) ) (\a: Bool .\b: Nat .a)) then (( \f: Bool .((f (pred (succ 0)) ) (let u = (let u = 0 in u) in (((\x: Bool .\y: Bool .y) false ) 1)) ) ) (\a: Nat .\b: Unit .b)) else (((\x: Bool .\y: Rec X. X .x) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = 1 }.b) ) (if false then true else false))) else (fix (\x: Rec X. X . (( \f: Unit .((f ({a = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , b = 0 }.b) ) (((\x: Bool .\y: Nat .y) true ) 0) ) ) (\a: Rec X. X .\b: Unit .b)) )))
({a = (((\x: Rec X. X .\y: Unit .y) (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in u) ) (fix (\x: Bool . (let u = 1 in 1) ))) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .x) (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true ))) ) ({a = 0 , b = true }.b)) )) , c =  (let u = (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then ({a = 1 , b = false , c = 1 }.c) else ({a = ({a = 1 , b = true , c = 0 }.c) , b = true }.a)) in (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) false ) 0) ))) }.b)
({a = (if ({a = 0 , b = ({a = 0 , b = false }.b) , c =  (((\x: Rec X. X .\y: Unit .y) true ) 1) }.b) then (((\x: Nat .\y: Unit .x) ({a = false , b = 0 }.b) ) (let u = false in u)) else ({a = (((\x: Unit .\y: Nat .x) 0 ) true) , b = (let u = true in true) , c = 0 }.c)) , b = (((\x: Rec X. X .\y: Bool .x) (((\x: Rec X. X .\y: Nat .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b))) ) (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Unit ] true )) ))) }.b)
({a = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Unit ] true )) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .a))) , b = ({a = 0 , b = true }.b) }.b) , b = (pred (((\x: Rec X. X .\y: Bool .y) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (fix (\x: Nat . 1 )))) }.a)
(let u = (((\x: Bool .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) (if (let u = false in u) then false else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) ) (let u = ({a = 0 , b = true , c =  1 }.b) in true)) )) ) ({a = (let u = true in 0) , b = ({a = true , b = true }.b) }.b)) in u)
(( \f: Rec X. X .((f (if ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Unit .x) true ) true) )) then (((\x: Bool .\y: Rec X. X .y) ({a = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .a)) , b = (fix (\x: Nat . 0 )) }.a) ) (iszero (let u = 0 in 1))) else (let u = (if false then true else false) in (if (if true then true else true) then false else (((\x: Unit .\y: Nat .y) false ) false)))) ) (iszero (if (let u = (unfold [ Bool ] (fold [ Bool ] false )) in ({a = 1 , b = false }.b)) then ({a = 0 , b = true }.a) else (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false))) ) ) (\a: Nat .\b: Bool .a))
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Nat ] true )) )) , b = (if (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) then (let u = (if (((\x: Nat .\y: Nat .x) true ) false) then 0 else 1) in (iszero 1)) else (((\x: Nat .\y: Nat .y) true ) (iszero 1))) }.b)
(((\x: Nat .\y: Rec X. X .x) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] 1 )) )) in (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) ) (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = 0 , b = 0 }.b)) ) ) (\a: Nat .\b: Bool .b)) ))) ) (let u = (let u = 0 in true) in u))
(let u = (( \f: Nat .((f ({a = (((\x: Unit .\y: Nat .x) 1 ) true) , b = (if true then 1 else 0) }.b) ) (fix (\x: Unit . 0 )) ) ) (\a: Rec X. X .\b: Unit .a)) in (if (((\x: Bool .\y: Rec X. X .x) true ) false) then ({a = ({a = 1 , b = false }.a) , b = ({a = true , b = 1 }.b) }.b) else (unfold [ Unit ] (fold [ Nat ] 1 ))))
(iszero ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (pred ({a = 0 , b = false }.a)) )))
({a = (let u = (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) in (((\x: Bool .\y: Bool .x) false ) false)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false ))) , b = ({a = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)) , b = (( \f: Unit .((f ({a = 0 , b = false , c =  0 }.b) ) (iszero 1) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) }.b)
({a = (if (((\x: Bool .\y: Bool .y) ({a = 0 , b = true , c =  0 }.b) ) ({a = true , b = 0 }.a)) then ({a = ({a = (pred 0) , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .b)) }.a) , b = ({a = 0 , b = false , c =  1 }.b) }.a) else (if ({a = true , b = ({a = false , b = false }.b) }.b) then (succ 1) else (((\x: Nat .\y: Nat .x) (if true then 0 else 1) ) true))) , b = (if (let u = (pred 1) in (fix (\x: Bool . false ))) then ({a = ({a = 1 , b = 0 }.b) , b = (((\x: Nat .\y: Nat .x) true ) true) , c =  (unfold [ Unit ] (fold [ Bool ] 1 )) }.b) else ({a = (let u = true in (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a))) , b = ({a = 0 , b = 0 }.b) }.a)) }.a)
(unfold [ Nat ] (fold [ Bool ] (((\x: Bool .\y: Bool .y) (case <r = ({a = ({a = false , b = (((\x: Nat .\y: Rec X. X .y) true ) 0) }.b) , b = ({a = 0 , b = false }.b) , c =  ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = ({a = 0 , b = false , c =  1 }.b) }.a) }.b) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . (fix (\x: Rec X. X . 0 )) ))) ))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (( \f: Bool .((f ({a = (let u = ({a = true , b = false }.b) in (unfold [ Bool ] (fold [ Unit ] false ))) , b = (unfold [ Bool ] (fold [ Unit ] (if false then 0 else 0) )) }.a) ) ({a = ({a = ({a = 1 , b = 0 }.b) , b = (((\x: Unit .\y: Rec X. X .x) true ) false) }.b) , b = (let u = true in u) }.b) ) ) (\a: Bool .\b: Nat .a)) )) in (pred (case <l = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y)))
({a = (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f (pred 1) ) 1 ) ) (\a: Unit .\b: Unit .b)) )) , b = (( \f: Unit .((f (( \f: Unit .((f (iszero (pred 0)) ) ({a = ({a = false , b = false }.b) , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) ) (\a: Nat .\b: Unit .b)) ) ({a = (case <l = ({a = 1 , b = true }.a) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , c =  (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) ) ) (\a: Bool .\b: Unit .b)) }.b)
(succ ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.b) , b = (case <l = (((\x: Unit .\y: Nat .y) false ) 0) > as Unit of < l = x > => x | < r = y > => y) }.b))
({a = ({a = (( \f: Unit .((f 1 ) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (((\x: Nat .\y: Nat .y) false ) false) )) , c = (pred (let u = (let u = false in 1) in 1)) }.c) , b = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Nat .x) 1 ) false) )) )) in (let u = (iszero 0) in u)) }.b)
(((\x: Unit .\y: Bool .y) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Rec X. X .x) true ) false) ) false) )) in u) ) ({a = ({a = false , b = (if true then 0 else 1) }.b) , b = (fix (\x: Nat . false )) }.b))
(pred ({a = (( \f: Bool .((f ({a = 0 , b = true }.a) ) (((\x: Rec X. X .\y: Bool .x) (let u = 1 in u) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .b)) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) false ) true) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.a))
(((\x: Bool .\y: Unit .x) ({a = (let u = (((\x: Bool .\y: Unit .x) (fix (\x: Unit . true )) ) (if false then true else true)) in (((\x: Nat .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) false)) , b = (pred ({a = false , b = 0 }.b)) }.b) ) (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Nat . (case <r = (if true then false else true) > as Bool of < l = x > => x | < r = y > => y) )) )))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in u) }.b) )) in ({a = (( \f: Bool .((f (if ({a = true , b = false }.b) then 1 else (let u = 1 in u)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (pred 0) )) ) ) (\a: Bool .\b: Nat .b)) , b = (let u = ({a = 1 , b = true , c =  0 }.b) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) , c = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) true ) 1) ) (( \f: Unit .((f (((\x: Bool .\y: Bool .x) 1 ) true) ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Rec X. X .a)) }.c))
(fix (\x: Nat . (let u = (fix (\x: Nat . (if true then false else (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .a))) )) in (let u = (succ ({a = false , b = 1 }.b)) in ({a = (pred 0) , b = 0 }.b))) ))
(fix (\x: Nat . ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero ({a = 0 , b = 1 }.b)) )) ))
(( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) ({a = (if true then 1 else 1) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.b) ) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .y) false ) 1) )) , b = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false , c =  0 }.b) , c =  (let u = ({a = (((\x: Bool .\y: Unit .x) 0 ) true) , b = true }.b) in (( \f: Bool .((f ({a = 0 , b = false }.a) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a))) }.b)) ) (let u = (iszero 0) in (let u = false in u)) ) ) (\a: Bool .\b: Nat .a))
(let u = (iszero (let u = (if (iszero 0) then (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) else (pred ({a = 1 , b = false , c = 1 }.c))) in u)) in ({a = ({a = (succ 1) , b = (let u = 1 in false) }.b) , b = (iszero (((\x: Unit .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .a)) ) (let u = 0 in u))) }.b))
({a = ({a = (if (fix (\x: Unit . (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .a)) )) then (unfold [ Unit ] (fold [ Nat ] 0 )) else (((\x: Unit .\y: Bool .x) (pred 0) ) true)) , b = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = (let u = 0 in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) , c =  (fix (\x: Bool . 1 )) }.b) }.b) , b = ({a = (((\x: Bool .\y: Bool .x) (if (let u = true in false) then (fix (\x: Nat . (succ 1) )) else ({a = ({a = 1 , b = false , c =  1 }.b) , b = (if true then 1 else 1) }.b)) ) ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , b = (if false then 0 else 1) }.a)) , b = (case <r = (iszero (let u = 1 in 0)) > as Nat of < l = x > => x | < r = y > => y) }.a) }.a)
(let u = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (let u = true in false) ) true) , b = (succ 1) }.a) in u)
(if ({a = (fix (\x: Unit . true )) , b = (if true then false else ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true ))) }.b) then ({a = ({a = (let u = 1 in u) , b = ({a = 1 , b = false , c =  1 }.b) }.b) , b = ({a = (iszero 0) , b = (succ (if true then 1 else 1)) }.b) }.b) else (case <l = ({a = ({a = false , b = 0 }.a) , b = (if true then ({a = 0 , b = 1 }.b) else (let u = 0 in 1)) }.b) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Unit .((f (if (((\x: Unit .\y: Unit .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = false }.b) ))) then (case <l = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) else (fix (\x: Bool . (if true then 0 else 1) ))) ) ({a = (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in (iszero 0)) , b = ({a = false , b = 1 }.b) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (case <l = ({a = (let u = 1 in u) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) > as Bool of < l = x > => x | < r = y > => y) in (( \f: Nat .((f ({a = 1 , b = true }.b) ) (let u = 1 in (((\x: Unit .\y: Unit .x) false ) true)) ) ) (\a: Nat .\b: Bool .b))) ))
({a = (if (((\x: Rec X. X .\y: Unit .y) (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (fix (\x: Bool . false )) else ({a = false , b = (((\x: Nat .\y: Unit .x) false ) true) }.b)) ) (fix (\x: Rec X. X . (let u = true in u) ))) then (let u = (( \f: Unit .((f false ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) ) ) (\a: Nat .\b: Bool .a)) in (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) else (iszero (pred 0))) , b = ({a = (( \f: Unit .((f ({a = 0 , b = false , c = (fix (\x: Nat . 0 )) }.c) ) (( \f: Rec X. X .((f 0 ) (((\x: Unit .\y: Rec X. X .x) 0 ) false) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .a)) , b = (let u = ({a = (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in ({a = false , b = 1 }.b)) , b = ({a = 0 , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) }.b) , c =  (if true then ({a = 1 , b = false }.a) else 0) }.b) in u) , c =  (if ({a = 0 , b = true }.b) then (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . 1 )) )) else ({a = true , b = 1 }.b)) }.b) }.b)
({a = (unfold [ Nat ] (fold [ Nat ] (((\x: Nat .\y: Bool .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 0 in true)) )) , b = ({a = ({a = (((\x: Bool .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) ) ({a = 0 , b = true , c = 1 }.c)) , b = (if false then ({a = 1 , b = true }.a) else ({a = 0 , b = true }.a)) }.b) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (iszero (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) )) }.a) }.b)
(case <r = ({a = (if (fix (\x: Rec X. X . ({a = 1 , b = true , c =  0 }.b) )) then (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) else (((\x: Unit .\y: Unit .x) false ) true)) , b = (if ({a = (( \f: Rec X. X .((f 1 ) (((\x: Rec X. X .\y: Nat .y) false ) 0) ) ) (\a: Bool .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Bool .x) false ) true) , c =  (((\x: Bool .\y: Bool .y) true ) 1) }.b) then ({a = (fix (\x: Unit . 1 )) , b = (let u = false in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.a) else (succ (if false then 0 else 0))) }.a) > as Unit of < l = x > => x | < r = y > => y)
(let u = (let u = (((\x: Unit .\y: Bool .y) ({a = ({a = ({a = 0 , b = true , c =  0 }.b) , b = (((\x: Nat .\y: Unit .y) true ) 1) }.a) , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)))) in (((\x: Unit .\y: Rec X. X .x) ({a = (let u = 1 in 0) , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.b) ) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)))) in ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = (if false then true else false) , b = (((\x: Unit .\y: Unit .y) false ) 1) }.a) )))
(((\x: Unit .\y: Nat .x) ({a = (let u = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = ({a = 1 , b = true }.b) }.a) in u) , b = (let u = (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) in (((\x: Rec X. X .\y: Unit .y) true ) 0)) }.b) ) ({a = (((\x: Unit .\y: Unit .y) ({a = (let u = 1 in u) , b = false , c =  0 }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 ))) , b = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) ({a = true , b = (let u = 0 in false) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) , c =  ({a = (if false then false else false) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) }.b) }.b))
(( \f: Bool .((f (( \f: Nat .((f (( \f: Nat .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) ) ({a = ({a = 1 , b = true , c = 0 }.c) , b = (((\x: Bool .\y: Rec X. X .x) true ) false) , c =  0 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) (case <r = (fix (\x: Unit . false )) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (let u = (let u = ({a = 1 , b = false , c = 0 }.c) in (((\x: Bool .\y: Nat .x) true ) false)) in (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f false ) (((\x: Bool .\y: Bool .y) false ) true) ) ) (\a: Bool .\b: Bool .a)) ) ({a = (if false then 0 else 1) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.b))) , b = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) ({a = ({a = true , b = true }.b) , b = (if true then (let u = true in 1) else (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b))) }.b)) }.a) ) ) (\a: Rec X. X .\b: Unit .b))
(succ (succ (((\x: Bool .\y: Unit .x) (pred (fix (\x: Rec X. X . 1 ))) ) (((\x: Unit .\y: Unit .y) (fix (\x: Nat . false )) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false ))))))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) (pred (succ 1)) ) ({a = ({a = 1 , b = true }.b) , b = (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Nat .y) false ) false) ) (fix (\x: Bool . 1 ))) }.a)) ))
({a = (case <r = ({a = (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = false }.b) )) , b = (let u = 1 in false) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (iszero (succ 1)) }.b)
(let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (fix (\x: Unit . false )) , b = (let u = ({a = 0 , b = true , c = 1 }.c) in (( \f: Bool .((f true ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b))) }.b) )) in u)
(let u = (( \f: Nat .((f ({a = (iszero 0) , b = (((\x: Unit .\y: Nat .x) 1 ) true) }.b) ) ({a = (unfold [ Rec X. X ] (fold [ Bool ] true )) , b = ({a = 0 , b = false , c = 1 }.c) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) in (succ (((\x: Unit .\y: Bool .y) ({a = 1 , b = false }.b) ) (fix (\x: Rec X. X . 0 )))))
(( \f: Rec X. X .((f ({a = (fix (\x: Rec X. X . (let u = 1 in (((\x: Unit .\y: Unit .x) 1 ) true)) )) , b = (let u = ({a = (((\x: Bool .\y: Rec X. X .y) true ) false) , b = (let u = false in u) }.b) in u) , c =  (fix (\x: Rec X. X . ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) )) )) }.b) ) (let u = ({a = (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (succ (((\x: Nat .\y: Nat .y) true ) 0)) }.a) in u) ) ) (\a: Rec X. X .\b: Nat .b))
({a = (let u = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) ) (\a: Rec X. X .\b: Nat .a)) in ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)) ))) , b = (let u = ({a = (((\x: Nat .\y: Bool .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred 1) )) ) (iszero 1)) , b = (iszero (pred 1)) , c =  ({a = (let u = 0 in u) , b = true }.a) }.b) in u) }.b)
(fix (\x: Unit . (( \f: Unit .((f (let u = ({a = 0 , b = false , c = 0 }.c) in (fix (\x: Rec X. X . (fix (\x: Bool . false )) ))) ) (fix (\x: Bool . ({a = 1 , b = false , c =  0 }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(fix (\x: Unit . (( \f: Nat .((f (let u = (case <r = (unfold [ Unit ] (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Bool .x) 1 ) (((\x: Bool .\y: Bool .x) true ) false))) ) (( \f: Bool .((f (((\x: Bool .\y: Nat .y) true ) (let u = true in 1)) ) (unfold [ Unit ] (fold [ Nat ] 1 )) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Unit .\b: Nat .b)) ))
(case <l = ({a = (succ (if true then 0 else 0)) , b = ({a = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (let u = (if true then 0 else 1) in (let u = false in false)) }.a) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Nat .y) ({a = (((\x: Unit .\y: Nat .x) (let u = true in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) ({a = 0 , b = ({a = true , b = 1 }.a) , c =  ({a = 1 , b = false , c = 1 }.c) }.b)) , b = (let u = (((\x: Unit .\y: Bool .y) false ) true) in (let u = false in u)) }.b) ) (if (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f ({a = ({a = 1 , b = 1 }.b) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) (iszero 0) ) ) (\a: Rec X. X .\b: Unit .a)) ) (((\x: Unit .\y: Nat .x) (if true then true else true) ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)))) then ({a = (iszero (fix (\x: Rec X. X . 0 ))) , b = ({a = (unfold [ Unit ] (fold [ Nat ] true )) , b = (((\x: Nat .\y: Bool .y) true ) 1) }.b) }.a) else (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Nat .((f ({a = false , b = false }.b) ) ({a = 1 , b = true }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))))
(let u = (succ (let u = (pred 0) in (((\x: Rec X. X .\y: Bool .y) false ) 1))) in ({a = (let u = (unfold [ Unit ] (fold [ Unit ] 0 )) in u) , b = (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) )) )) }.b))
({a = (if (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .a)) then (((\x: Rec X. X .\y: Unit .y) ({a = true , b = 0 }.a) ) (let u = 0 in true)) else (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .y) true ) false) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (let u = (((\x: Bool .\y: Nat .y) (let u = 0 in false) ) (if false then false else true)) in ({a = 0 , b = ({a = 0 , b = true }.b) }.b)) }.b)
(unfold [ Unit ] (fold [ Nat ] ({a = ({a = (let u = false in 1) , b = ({a = false , b = 0 }.a) , c = 0 }.c) , b = ({a = ({a = 1 , b = 0 }.b) , b = (let u = 0 in ({a = 1 , b = false , c =  1 }.b)) , c =  (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.b) , c = ({a = ({a = false , b = 1 }.a) , b = (fix (\x: Bool . 0 )) }.b) }.c) ))
(let u = (( \f: Nat .((f (let u = ({a = 0 , b = false }.a) in u) ) (( \f: Unit .((f ({a = false , b = 1 }.b) ) ({a = 0 , b = (((\x: Nat .\y: Bool .y) false ) true) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .b)) in u)
(fix (\x: Bool . ({a = (let u = (case <l = (fix (\x: Nat . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Nat .((f (let u = true in true) ) (unfold [ Bool ] (fold [ Unit ] (if true then false else false) )) ) ) (\a: Bool .\b: Rec X. X .b))) , b = (((\x: Rec X. X .\y: Unit .y) ({a = (iszero 1) , b = 0 }.a) ) (succ (let u = 1 in u))) }.b) ))
(let u = ({a = (((\x: Rec X. X .\y: Bool .y) ({a = false , b = 0 }.a) ) ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = true , c = 0 }.c)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = false , c =  1 }.b) )) }.a) in (( \f: Unit .((f (((\x: Unit .\y: Nat .y) (((\x: Nat .\y: Nat .y) (fix (\x: Nat . true )) ) (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) (let u = 1 in 1)) ) (let u = (case <l = (let u = false in 0) > as Nat of < l = x > => x | < r = y > => y) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (if true then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) else 0) ))) ) ) (\a: Nat .\b: Rec X. X .b)))
(iszero ({a = (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Unit .y) true ) 0) ) ({a = false , b = true }.b)) , b = (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) ({a = 1 , b = false }.b)) , c = ({a = (((\x: Nat .\y: Unit .x) 0 ) false) , b = (let u = (let u = 1 in 1) in ({a = 0 , b = true }.a)) }.b) }.c))
({a = (let u = (( \f: Rec X. X .((f ({a = 1 , b = true }.b) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .b)) in ({a = true , b = 1 }.a)) , b = (succ (( \f: Nat .((f (let u = ({a = (((\x: Unit .\y: Unit .y) true ) 1) , b = (let u = false in u) , c = 0 }.c) in u) ) (case <l = (succ (let u = 0 in 0)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a))) }.b)
(((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Nat .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (if (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) then (fix (\x: Unit . true )) else ({a = false , b = ({a = 1 , b = true , c =  0 }.b) }.b)) )) ) (let u = (if (iszero 0) then (((\x: Nat .\y: Unit .y) true ) false) else false) in (fix (\x: Unit . 0 )))) ) (( \f: Rec X. X .((f (if (iszero 0) then ({a = true , b = true }.b) else (unfold [ Unit ] (fold [ Bool ] true ))) ) (let u = (pred 1) in (if false then ({a = 1 , b = true }.b) else ({a = 0 , b = false }.b))) ) ) (\a: Bool .\b: Rec X. X .b)))
({a = (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = true }.b) )) )) ) ({a = (((\x: Bool .\y: Nat .x) true ) (let u = false in u)) , b = ({a = ({a = false , b = true }.b) , b = (let u = (let u = false in 0) in u) }.a) }.b) ) ) (\a: Unit .\b: Unit .b)) , b = (let u = ({a = 0 , b = (if false then false else true) }.a) in (if true then ({a = true , b = 0 }.a) else (let u = true in u))) }.b)
({a = (fix (\x: Rec X. X . (( \f: Bool .((f false ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .a)) )) , b = (let u = ({a = (fix (\x: Nat . (let u = true in u) )) , b = (unfold [ Unit ] (fold [ Nat ] 0 )) }.a) in (let u = (unfold [ Bool ] (fold [ Nat ] true )) in (((\x: Nat .\y: Rec X. X .y) false ) 0))) }.b)
({a = ({a = (unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) )) , b = (let u = ({a = 0 , b = true }.b) in (((\x: Unit .\y: Nat .x) true ) true)) }.b) , b = (let u = (let u = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .a)) in 0) in (( \f: Unit .((f (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .x) 0 ) true) ) ) (\a: Nat .\b: Nat .a))) }.a)
(pred (case <l = (let u = ({a = 1 , b = (((\x: Bool .\y: Unit .y) false ) false) }.a) in u) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Unit .((f (case <r = (iszero ({a = 1 , b = 1 }.b)) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (fix (\x: Nat . (let u = false in false) )) , b = (let u = ({a = (fix (\x: Rec X. X . (pred 0) )) , b = (let u = false in u) }.a) in u) }.a) ) ) (\a: Rec X. X .\b: Bool .b))
(((\x: Bool .\y: Rec X. X .y) (let u = (iszero ({a = ({a = 0 , b = true , c = 1 }.c) , b = (let u = 1 in u) }.b)) in u) ) (if (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = 0 , b = true }.b) )) )) then (((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .a)) ) (let u = (fix (\x: Bool . ({a = 1 , b = false , c =  1 }.b) )) in ({a = 0 , b = false , c =  0 }.b))) else ({a = ({a = 0 , b = false }.b) , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .b)) }.b)))
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Unit . 1 )) )) , b = (( \f: Rec X. X .((f ({a = (unfold [ Nat ] (fold [ Nat ] 1 )) , b = (((\x: Unit .\y: Unit .y) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .a)) ) (let u = 0 in 1)) }.b) ) (case <l = (let u = 0 in 1) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) }.b)
(( \f: Rec X. X .((f (let u = (case <r = ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = 0 , b = false , c = 0 }.c) }.a) > as Nat of < l = x > => x | < r = y > => y) in ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = true in u) }.b)) ) ({a = (if false then false else (((\x: Bool .\y: Nat .y) true ) true)) , b = (( \f: Bool .((f ({a = 0 , b = false }.a) ) (succ 1) ) ) (\a: Nat .\b: Unit .b)) }.a) ) ) (\a: Unit .\b: Nat .b))
(iszero ({a = ({a = ({a = ({a = 0 , b = false }.a) , b = (fix (\x: Rec X. X . true )) }.a) , b = (((\x: Nat .\y: Nat .x) true ) true) }.a) , b = (succ (fix (\x: Nat . (let u = 1 in u) ))) }.b))
(iszero (((\x: Rec X. X .\y: Bool .y) (case <r = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) then ({a = 1 , b = 1 }.b) else 0) ))))
(case <l = (( \f: Nat .((f (let u = ({a = (if true then 1 else 0) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , c =  (succ 1) }.b) in (let u = (fix (\x: Bool . true )) in (pred 1))) ) (( \f: Nat .((f ({a = 0 , b = true }.a) ) (((\x: Nat .\y: Unit .x) 1 ) false) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y)
({a = (unfold [ Rec X. X ] (fold [ Nat ] (let u = (let u = (if true then true else true) in u) in (((\x: Rec X. X .\y: Nat .y) false ) false)) )) , b = (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Unit .y) false ) true) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ({a = 1 , b = (unfold [ Bool ] (fold [ Bool ] true )) , c =  (((\x: Nat .\y: Rec X. X .y) false ) 1) }.b)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] true )) )) )) ) ) (\a: Nat .\b: Bool .b)) }.b)
({a = ({a = (( \f: Nat .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) ) (pred 1) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = ({a = 1 , b = false , c = (((\x: Bool .\y: Unit .y) true ) 1) }.c) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) }.b) , c = (( \f: Rec X. X .((f (let u = 1 in 0) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .a)) }.c) , b = (fix (\x: Nat . ({a = ({a = 0 , b = false }.b) , b = (fix (\x: Bool . 0 )) }.a) )) }.a)
({a = (fix (\x: Nat . ({a = (iszero 1) , b = (unfold [ Bool ] (fold [ Bool ] false )) }.b) )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (((\x: Bool .\y: Rec X. X .x) true ) (unfold [ Nat ] (fold [ Rec X. X ] true ))) in u) )) }.b)
({a = ({a = (( \f: Unit .((f ({a = (let u = 1 in 1) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) ) ({a = (let u = 1 in u) , b = ({a = true , b = false }.b) }.a) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (case <r = (if ({a = (let u = 0 in u) , b = true , c =  1 }.b) then ({a = true , b = 0 }.a) else (let u = true in (if false then false else true))) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = (( \f: Nat .((f (succ 0) ) (if false then (((\x: Rec X. X .\y: Unit .x) 0 ) false) else (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (fix (\x: Nat . (if true then true else (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b))) )) }.a) }.b) , b = ({a = (if true then (((\x: Rec X. X .\y: Unit .x) 1 ) true) else (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) , b = (fix (\x: Nat . (if true then false else true) )) , c = (let u = ({a = true , b = 1 }.b) in u) }.c) }.a)
({a = ({a = (let u = ({a = ({a = 0 , b = false , c =  1 }.b) , b = (let u = (let u = 0 in true) in 1) }.b) in (((\x: Nat .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) ({a = 1 , b = false }.a))) , b = (let u = (unfold [ Unit ] (fold [ Unit ] 0 )) in ({a = (let u = 1 in u) , b = 0 }.b)) }.b) , b = (((\x: Nat .\y: Bool .x) ({a = ({a = false , b = 0 }.b) , b = (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a)) )) }.b) ) (iszero 0)) }.a)
({a = (fix (\x: Nat . (case <r = (let u = true in u) > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (((\x: Bool .\y: Nat .x) (((\x: Rec X. X .\y: Unit .y) (iszero 0) ) (let u = 1 in 0)) ) (if ({a = 1 , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) then ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true , c =  (((\x: Bool .\y: Nat .x) 0 ) false) }.b) else (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)))) }.a)
(if ({a = (if (((\x: Bool .\y: Nat .y) (fix (\x: Unit . true )) ) ({a = true , b = false }.b)) then ({a = 1 , b = (((\x: Nat .\y: Unit .y) true ) true) }.b) else ({a = false , b = 0 }.a)) , b = ({a = (((\x: Bool .\y: Nat .x) (let u = 1 in false) ) (let u = true in false)) , b = (succ 1) }.b) }.a) then ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] ({a = (let u = 1 in false) , b = (fix (\x: Nat . 1 )) }.b) )) )) else (((\x: Unit .\y: Rec X. X .y) ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = (if true then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) else 1) }.a) ) ({a = (((\x: Nat .\y: Bool .y) false ) (((\x: Rec X. X .\y: Nat .x) true ) true)) , b = (((\x: Unit .\y: Rec X. X .y) false ) 1) }.b)))
(( \f: Bool .((f (( \f: Bool .((f (let u = (let u = true in 1) in ({a = 1 , b = true , c = 1 }.c)) ) (let u = (( \f: Rec X. X .((f 1 ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) in u) ) ) (\a: Unit .\b: Nat .b)) ) (succ (pred ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) , b = (let u = false in 1) }.b))) ) ) (\a: Nat .\b: Bool .a))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (pred (let u = (let u = (((\x: Bool .\y: Bool .x) 0 ) true) in ({a = false , b = 0 }.b)) in (fix (\x: Bool . (((\x: Rec X. X .\y: Bool .x) 0 ) true) )))) ))
(fix (\x: Bool . ({a = (( \f: Bool .((f (fix (\x: Rec X. X . 1 )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = (succ 1) , b = true }.b) }.b) ))
(let u = (succ (unfold [ Bool ] (fold [ Rec X. X ] (let u = (let u = (let u = true in 0) in u) in u) ))) in ({a = ({a = ({a = (iszero 0) , b = (if false then 0 else 0) }.b) , b = ({a = ({a = 0 , b = true }.a) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.c) }.b) , b = (if (((\x: Unit .\y: Unit .x) ({a = false , b = 0 }.a) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) then (unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Bool ] 1 )) )) else (succ (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)))) }.b))
(let u = (let u = ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (let u = false in true) , c = ({a = 1 , b = 0 }.b) }.c) in (let u = 0 in (case <r = true > as Nat of < l = x > => x | < r = y > => y))) in (let u = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (((\x: Unit .\y: Bool .x) false ) false) , c = 0 }.c) in (let u = (pred 0) in u)))
(((\x: Unit .\y: Unit .x) (((\x: Unit .\y: Bool .y) ({a = false , b = (((\x: Nat .\y: Unit .y) false ) 0) }.a) ) (let u = ({a = (let u = 0 in 1) , b = 0 }.b) in (fix (\x: Unit . false )))) ) ({a = (((\x: Nat .\y: Rec X. X .x) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (let u = true in u)) , b = (iszero (let u = 0 in u)) , c =  (let u = (let u = ({a = false , b = 1 }.b) in u) in (unfold [ Nat ] (fold [ Unit ] (fix (\x: Bool . 1 )) ))) }.b))
(let u = ({a = (pred (unfold [ Bool ] (fold [ Unit ] (succ 0) ))) , b = (fix (\x: Rec X. X . (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) )) }.a) in (iszero ({a = (if true then 0 else 0) , b = ({a = (((\x: Nat .\y: Rec X. X .y) false ) 0) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = (if false then 1 else 0) }.c) }.b)))
({a = (((\x: Unit .\y: Bool .x) (fix (\x: Unit . (let u = true in u) )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Bool . true )) ))) , b = (( \f: Rec X. X .((f (case <l = (let u = false in 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) (pred (((\x: Nat .\y: Bool .y) false ) 1)) ) ) (\a: Bool .\b: Rec X. X .a)) }.a)
(case <r = (let u = (case <r = (let u = 0 in false) > as Bool of < l = x > => x | < r = y > => y) in ({a = (let u = false in 0) , b = (if true then false else false) , c =  (fix (\x: Unit . 0 )) }.b)) > as Unit of < l = x > => x | < r = y > => y)
(case <r = ({a = (( \f: Nat .((f (if true then 1 else 1) ) (let u = false in 1) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Rec X. X .((f (if (fix (\x: Rec X. X . false )) then (if false then false else true) else (((\x: Unit .\y: Unit .x) true ) false)) ) (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) true ) (let u = true in true)) )) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  (((\x: Unit .\y: Unit .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero 1) )) ) ({a = 0 , b = 0 }.b)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (fix (\x: Nat . (let u = ({a = true , b = 1 }.b) in ({a = true , b = true }.b)) )) , b = (iszero ({a = (if (let u = true in true) then 1 else 1) , b = (case <r = (let u = true in true) > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) }.b)
(unfold [ Unit ] (fold [ Bool ] (fix (\x: Rec X. X . (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) )) ))
({a = (succ ({a = ({a = 0 , b = 0 }.b) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) }.a)) , b = (case <r = (let u = (( \f: Rec X. X .((f (succ 1) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) in (let u = (fix (\x: Rec X. X . false )) in ({a = false , b = 0 }.a))) > as Bool of < l = x > => x | < r = y > => y) }.b)
(let u = (let u = (((\x: Rec X. X .\y: Nat .x) 0 ) true) in ({a = ({a = false , b = 0 }.a) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.a)) in (unfold [ Unit ] (fold [ Unit ] (let u = (case <r = (((\x: Unit .\y: Rec X. X .y) true ) true) > as Unit of < l = x > => x | < r = y > => y) in ({a = (let u = 1 in true) , b = (((\x: Nat .\y: Nat .y) false ) true) }.b)) )))
(let u = (( \f: Nat .((f (let u = (((\x: Unit .\y: Nat .x) false ) true) in u) ) (unfold [ Nat ] (fold [ Bool ] (case <r = (if true then false else false) > as Bool of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Nat .a)) in u)
(let u = (let u = (( \f: Bool .((f ({a = 1 , b = true , c =  1 }.b) ) (((\x: Nat .\y: Unit .y) (let u = false in u) ) (((\x: Bool .\y: Nat .y) false ) false)) ) ) (\a: Bool .\b: Bool .b)) in (iszero (let u = 0 in 0))) in (let u = (pred (( \f: Rec X. X .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b))) in (if ({a = (let u = 0 in false) , b = 1 }.a) then (if ({a = false , b = 1 }.a) then (fix (\x: Unit . false )) else ({a = ({a = 0 , b = 0 }.b) , b = false }.b)) else ({a = (fix (\x: Bool . 1 )) , b = (fix (\x: Unit . false )) }.b))))
(let u = (unfold [ Rec X. X ] (fold [ Bool ] (if (((\x: Unit .\y: Bool .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true) then (if (((\x: Bool .\y: Rec X. X .y) true ) false) then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else (let u = false in u)) else ({a = (let u = 0 in false) , b = 1 }.a)) )) in (case <r = (case <r = (fix (\x: Rec X. X . true )) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y))
(unfold [ Rec X. X ] (fold [ Bool ] (pred (( \f: Rec X. X .((f (succ 0) ) (((\x: Rec X. X .\y: Unit .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false , c =  1 }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ))
(let u = (fix (\x: Bool . ({a = (((\x: Unit .\y: Bool .y) true ) (((\x: Bool .\y: Rec X. X .x) false ) true)) , b = (unfold [ Unit ] (fold [ Unit ] 0 )) }.b) )) in u)
({a = (case <l = (unfold [ Nat ] (fold [ Bool ] ({a = 1 , b = ({a = 1 , b = true }.b) }.a) )) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Rec X. X .y) (let u = true in false) ) ({a = 0 , b = false , c =  0 }.b)) ) (let u = ({a = false , b = 1 }.a) in u)) , c = ({a = (let u = (((\x: Bool .\y: Rec X. X .y) true ) false) in (let u = ({a = 0 , b = false , c = 1 }.c) in (let u = true in u))) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = 0 }.b) )) }.b) }.c)
(((\x: Rec X. X .\y: Unit .y) (let u = (( \f: Nat .((f (((\x: Unit .\y: Unit .x) ({a = 1 , b = false , c =  0 }.b) ) (fix (\x: Bool . false ))) ) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) in u) ) ) (\a: Bool .\b: Rec X. X .a)) in ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (((\x: Rec X. X .\y: Bool .y) ({a = 0 , b = true , c =  0 }.b) ) true) }.b)) ) (fix (\x: Rec X. X . ({a = (((\x: Bool .\y: Unit .y) true ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) , b = ({a = true , b = 0 }.b) }.a) )))
(let u = ({a = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) )) , b = (( \f: Nat .((f (let u = ({a = false , b = 0 }.a) in false) ) (let u = 1 in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Nat .b)) , c =  (((\x: Nat .\y: Nat .x) (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) true) }.b) in ({a = (((\x: Unit .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Bool ] false )) ) (pred (if true then ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) else 1))) , b = ({a = ({a = 0 , b = false }.b) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.a) , c =  (if (let u = (let u = false in ({a = 1 , b = 0 }.b)) in (((\x: Rec X. X .\y: Rec X. X .y) true ) ({a = false , b = true }.b))) then (case <l = (pred 0) > as Unit of < l = x > => x | < r = y > => y) else (( \f: Nat .((f (((\x: Nat .\y: Bool .y) true ) 1) ) (pred 0) ) ) (\a: Nat .\b: Unit .a))) }.b))
({a = (case <l = ({a = 1 , b = false }.a) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (if (if (iszero 1) then ({a = 0 , b = true }.b) else true) then ({a = ({a = 0 , b = true }.a) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.a) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) in ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) , b = true }.b)) , c =  (if ({a = (let u = 0 in false) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.a) then (((\x: Bool .\y: Nat .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ({a = true , b = false }.b)) else (((\x: Rec X. X .\y: Nat .x) ({a = 0 , b = true }.a) ) true)) }.b)
(let u = ({a = (let u = (let u = true in 1) in u) , b = (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Nat .y) false ) false) ) (unfold [ Rec X. X ] (fold [ Bool ] true ))) }.b) in (((\x: Unit .\y: Nat .y) (((\x: Nat .\y: Unit .y) (iszero 1) ) (let u = 0 in false)) ) (fix (\x: Bool . true ))))
({a = (((\x: Rec X. X .\y: Nat .y) (((\x: Unit .\y: Nat .x) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) true) ) ({a = 0 , b = false , c = 1 }.c)) , b = (case <r = (((\x: Bool .\y: Rec X. X .x) (iszero 1) ) true) > as Rec X. X of < l = x > => x | < r = y > => y) , c = ({a = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Rec X. X ] (let u = 0 in false) )) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = true }.b) )) ) ) (\a: Unit .\b: Unit .b)) , b = (((\x: Unit .\y: Unit .x) (succ (((\x: Rec X. X .\y: Nat .x) 0 ) false)) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Bool ] true )) ) (((\x: Unit .\y: Rec X. X .x) false ) true) ) ) (\a: Nat .\b: Rec X. X .b))) }.b) }.c)
(unfold [ Bool ] (fold [ Unit ] ({a = (( \f: Nat .((f (let u = true in 1) ) (if false then 1 else 0) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 0 , b = true , c =  1 }.b) )) , c = (succ 1) }.c) ))
(let u = ({a = (case <l = ({a = 0 , b = true , c = 0 }.c) > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) }.a) in (case <r = (((\x: Bool .\y: Bool .y) (iszero 1) ) (((\x: Nat .\y: Rec X. X .x) false ) false)) > as Nat of < l = x > => x | < r = y > => y))
({a = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = ({a = true , b = true }.b) in ({a = true , b = true }.b)) )) in (if (((\x: Unit .\y: Bool .y) (unfold [ Bool ] (fold [ Bool ] true )) ) false) then ({a = 1 , b = false }.b) else ({a = (pred 1) , b = false }.b))) , b = ({a = (( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] true )) ) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = ({a = 0 , b = true }.b) , b = (let u = 0 in u) }.b) }.a) }.b)
({a = (((\x: Bool .\y: Nat .x) (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Nat .x) false ) false) )) ) (let u = (((\x: Rec X. X .\y: Bool .y) false ) (let u = 1 in u)) in ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = ({a = false , b = 0 }.a) , c =  (pred 0) }.b))) , b = (let u = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Rec X. X ] (let u = 0 in 1) )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (if false then 1 else 1) )) ) ) (\a: Rec X. X .\b: Unit .b)) in u) }.b)
(((\x: Rec X. X .\y: Nat .y) (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) (fix (\x: Bool . false )) ) ) (\a: Nat .\b: Unit .a)) ) (((\x: Nat .\y: Nat .x) ({a = false , b = true }.b) ) (let u = 0 in true))) ) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in u) )) in u))
(let u = (let u = (( \f: Bool .((f (( \f: Nat .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .b)) ) false ) ) (\a: Nat .\b: Bool .a)) ) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) ) (\a: Bool .\b: Nat .b)) in u) in (pred (let u = 1 in ({a = true , b = 0 }.b))))
(let u = (case <r = ({a = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = true in true) }.b) , b = (let u = (let u = true in true) in u) }.b) > as Unit of < l = x > => x | < r = y > => y) in (if (case <r = (case <r = ({a = 0 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Unit .x) (let u = 1 in false) ) (let u = true in u)) else (( \f: Bool .((f (case <r = ({a = false , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . false )) ) ) (\a: Bool .\b: Nat .b))))
({a = (if (unfold [ Unit ] (fold [ Rec X. X ] (iszero 1) )) then (( \f: Bool .((f (fix (\x: Bool . 1 )) ) (let u = 1 in (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Unit .\b: Bool .a)) else (case <l = (fix (\x: Unit . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = (let u = 0 in u) , b = (if ({a = 1 , b = (((\x: Unit .\y: Unit .y) false ) true) }.b) then (iszero 0) else (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a))) , c =  (case <l = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) > as Unit of < l = x > => x | < r = y > => y) }.b) }.a)
(iszero (if (( \f: Unit .((f (((\x: Unit .\y: Bool .x) true ) true) ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .b)) then (unfold [ Unit ] (fold [ Bool ] ({a = true , b = 0 }.b) )) else (unfold [ Bool ] (fold [ Nat ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ))))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = (( \f: Nat .((f (let u = true in u) ) (fix (\x: Rec X. X . (iszero 1) )) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Unit .((f (fix (\x: Bool . 0 )) ) (let u = 0 in 0) ) ) (\a: Bool .\b: Bool .b)) }.a) ))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Nat .y) (let u = ({a = true , b = 1 }.a) in (let u = true in u)) ) (( \f: Rec X. X .((f (( \f: Unit .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .a)) ) ({a = false , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) (unfold [ Nat ] (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Nat .b))) ))
({a = ({a = (((\x: Bool .\y: Bool .y) ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) , b = ({a = 0 , b = true , c =  1 }.b) }.b) ) ({a = 0 , b = true }.a)) , b = (fix (\x: Rec X. X . (iszero (let u = 1 in 1)) )) }.b) , b = (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Bool .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = true , b = 1 }.a)) ) (let u = ({a = (if true then 0 else ({a = 0 , b = 0 }.b)) , b = (if false then false else false) , c =  (fix (\x: Nat . 1 )) }.b) in (( \f: Nat .((f (let u = false in false) ) (iszero 0) ) ) (\a: Nat .\b: Rec X. X .a)))) }.b)
(((\x: Bool .\y: Rec X. X .x) (let u = (let u = 0 in 0) in (case <l = (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then 0 else 1) > as Nat of < l = x > => x | < r = y > => y)) ) (if (let u = (let u = false in (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a))) in u) then ({a = (((\x: Nat .\y: Rec X. X .x) (succ 0) ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a))) , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) , c =  ({a = (if false then 0 else 0) , b = false }.a) }.b) else (if (( \f: Unit .((f (let u = true in u) ) false ) ) (\a: Nat .\b: Nat .a)) then (let u = (iszero 0) in ({a = 1 , b = false }.b)) else (if false then (unfold [ Rec X. X ] (fold [ Unit ] true )) else true))))
({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) )) , b = (let u = ({a = (pred 1) , b = (if true then true else false) }.b) in u) }.b)
(fix (\x: Bool . (if (fix (\x: Bool . ({a = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Unit . true )) )) , b = ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) }.b) }.a) )) then ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . (if false then 1 else 0) )) )) else ({a = (if ({a = false , b = true }.b) then ({a = 1 , b = false , c =  0 }.b) else (let u = 0 in false)) , b = (fix (\x: Nat . 1 )) }.b)) ))
({a = (let u = (let u = (fix (\x: Rec X. X . 1 )) in u) in u) , b = (((\x: Bool .\y: Unit .x) (let u = (unfold [ Rec X. X ] (fold [ Unit ] (succ 1) )) in (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Rec X. X ] (iszero 1) )) ) (((\x: Bool .\y: Bool .y) true ) true))) ) (unfold [ Unit ] (fold [ Unit ] (let u = false in u) ))) }.a)
(( \f: Unit .((f (let u = (if (let u = (( \f: Unit .((f (((\x: Unit .\y: Bool .y) false ) true) ) true ) ) (\a: Rec X. X .\b: Bool .b)) in u) then (((\x: Nat .\y: Nat .x) ({a = 0 , b = 1 }.b) ) (((\x: Rec X. X .\y: Nat .y) (fix (\x: Rec X. X . false )) ) true)) else (((\x: Unit .\y: Unit .x) (case <l = ({a = true , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Bool .x) ({a = 1 , b = false }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a))))) in u) ) (let u = (case <r = (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) true ) false) )) > as Bool of < l = x > => x | < r = y > => y) in ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = ({a = 1 , b = true , c = 1 }.c) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(unfold [ Bool ] (fold [ Nat ] (pred (if (let u = (iszero 0) in false) then (case <l = ({a = true , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) else (let u = 1 in u))) ))
({a = (((\x: Nat .\y: Nat .y) (iszero (((\x: Nat .\y: Nat .x) 1 ) ({a = false , b = 1 }.a))) ) (pred (fix (\x: Nat . (fix (\x: Nat . 1 )) )))) , b = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f true ) (iszero 0) ) ) (\a: Nat .\b: Unit .a)) )) , b = (unfold [ Unit ] (fold [ Unit ] ({a = (fix (\x: Rec X. X . 1 )) , b = (((\x: Bool .\y: Unit .x) true ) false) , c = (let u = 0 in 0) }.c) )) }.a) , c = (case <l = (case <l = ({a = (let u = 1 in u) , b = (unfold [ Bool ] (fold [ Nat ] true )) , c = 1 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) }.c)
(case <r = (fix (\x: Unit . ({a = (pred 0) , b = (((\x: Unit .\y: Unit .y) false ) true) , c =  ({a = true , b = 1 }.b) }.b) )) > as Unit of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = (pred (succ 0)) , b = (((\x: Bool .\y: Bool .x) (((\x: Bool .\y: Nat .x) (succ 0) ) ({a = true , b = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) }.b)) ) (((\x: Unit .\y: Bool .y) true ) ({a = 0 , b = true , c =  0 }.b))) }.b) ))
(iszero (( \f: Bool .((f (if (((\x: Rec X. X .\y: Bool .y) true ) false) then (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) else (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) (unfold [ Bool ] (fold [ Rec X. X ] (case <l = (unfold [ Nat ] (fold [ Unit ] 0 )) > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Unit .a)))
(let u = (let u = (let u = (iszero 1) in (succ 0)) in ({a = ({a = 1 , b = true }.a) , b = false }.b)) in (((\x: Nat .\y: Unit .y) ({a = ({a = false , b = 0 }.b) , b = (if false then (iszero 0) else (if false then false else false)) , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) ) (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = 1 }.a) )) in (((\x: Bool .\y: Bool .x) 0 ) (let u = 1 in true)))))
({a = ({a = ({a = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in 1) , b = (fix (\x: Bool . (( \f: Bool .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) false ) ) (\a: Bool .\b: Unit .a)) )) , c = (fix (\x: Bool . (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) )) }.c) , b = (let u = (( \f: Nat .((f (let u = (((\x: Bool .\y: Nat .x) true ) false) in u) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)) in u) , c = (let u = (((\x: Rec X. X .\y: Unit .x) true ) false) in ({a = (pred 0) , b = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .b)) }.a)) }.c) , b = (unfold [ Nat ] (fold [ Unit ] (if (( \f: Unit .((f (let u = 0 in false) ) true ) ) (\a: Bool .\b: Rec X. X .a)) then (((\x: Rec X. X .\y: Bool .y) true ) ({a = false , b = 0 }.a)) else (fix (\x: Unit . true ))) )) , c = (let u = ({a = (if ({a = 0 , b = true , c =  1 }.b) then ({a = 1 , b = true }.a) else (((\x: Nat .\y: Unit .y) true ) 1)) , b = ({a = false , b = 1 }.a) , c =  (succ 1) }.b) in (((\x: Unit .\y: Bool .x) (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) ) (( \f: Nat .((f true ) (if true then true else false) ) ) (\a: Unit .\b: Unit .a)))) }.c)
(( \f: Bool .((f (pred ({a = ({a = false , b = 0 }.b) , b = false }.a)) ) (let u = ({a = (fix (\x: Nat . (let u = true in u) )) , b = ({a = 0 , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) }.a) }.b) in u) ) ) (\a: Nat .\b: Nat .b))
(((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f (let u = (if (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = true , c =  0 }.b) )) then (iszero 0) else ({a = 0 , b = true }.b)) in u) ) (( \f: Nat .((f (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = true , c =  1 }.b) ) false) ) (((\x: Nat .\y: Bool .y) true ) true) ) ) (\a: Unit .\b: Nat .b)) ) (let u = false in false) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Bool .a)) ) (let u = (pred (fix (\x: Nat . (let u = 1 in u) ))) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = 1 , b = 0 }.b) in u) ))))
(if ({a = (case <r = (((\x: Unit .\y: Rec X. X .x) false ) false) > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = 1 in 0) ) (fix (\x: Unit . true ))) }.a) then (let u = ({a = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ({a = (pred 1) , b = (if true then 1 else 1) }.b) }.b) in (case <r = (( \f: Nat .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) (let u = false in false) ) ) (\a: Unit .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y)) else (fix (\x: Nat . ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f ({a = false , b = 0 }.a) ) (((\x: Rec X. X .\y: Nat .y) true ) true) ) ) (\a: Bool .\b: Bool .b)) )) )))
(iszero (((\x: Rec X. X .\y: Rec X. X .x) (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) ) (if ({a = 0 , b = false }.b) then true else ({a = true , b = 1 }.a))))
(case <l = (fix (\x: Nat . (succ (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) > as Unit of < l = x > => x | < r = y > => y)
(iszero (fix (\x: Nat . (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Rec X. X .x) (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) > as Unit of < l = x > => x | < r = y > => y) ) (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (((\x: Nat .\y: Unit .x) true ) true) else false)) ) (unfold [ Bool ] (fold [ Bool ] ({a = false , b = 1 }.b) ))) )))
(fix (\x: Bool . ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (case <l = (((\x: Nat .\y: Rec X. X .x) 1 ) true) > as Unit of < l = x > => x | < r = y > => y) }.b) ))
({a = (( \f: Nat .((f (pred 1) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (pred 1) )) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (let u = (let u = (fix (\x: Unit . 0 )) in u) in (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) (fix (\x: Unit . 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = ({a = (( \f: Bool .((f (let u = 1 in u) ) (let u = false in (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true)) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Bool .\y: Nat .x) false ) ({a = 1 , b = false }.b)) }.a) }.b) }.b)
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (if ({a = (if true then ({a = 0 , b = false , c = 0 }.c) else 1) , b = ({a = (((\x: Bool .\y: Bool .x) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a))) , b = (((\x: Nat .\y: Rec X. X .y) false ) false) }.b) , c =  (((\x: Nat .\y: Rec X. X .x) (let u = 1 in u) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true ))) }.b) then (let u = (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.a) ) ) (\a: Rec X. X .\b: Unit .b)) in (((\x: Rec X. X .\y: Rec X. X .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.b))) else (((\x: Unit .\y: Unit .y) (iszero 0) ) (let u = false in false))) ))
(let u = (case <l = (if (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Nat .a)) then 0 else 1) > as Unit of < l = x > => x | < r = y > => y) in (let u = (iszero ({a = 0 , b = true }.a)) in u))
({a = (unfold [ Nat ] (fold [ Bool ] (let u = 1 in u) )) , b = ({a = (( \f: Nat .((f ({a = true , b = 0 }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Unit ] (fold [ Bool ] 0 )) )) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = (let u = ({a = 0 , b = false }.b) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) , b = (let u = 0 in false) , c =  (let u = 0 in 1) }.b) , c =  (( \f: Unit .((f ({a = 1 , b = (unfold [ Bool ] (fold [ Nat ] true )) }.a) ) ({a = ({a = 0 , b = true , c =  1 }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) , c =  (if (unfold [ Nat ] (fold [ Nat ] false )) then ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) else (( \f: Unit .((f 0 ) (unfold [ Bool ] (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Unit .b))) }.b)
(let u = (iszero (((\x: Nat .\y: Bool .y) true ) 1)) in u)
({a = (let u = (((\x: Rec X. X .\y: Nat .y) ({a = 1 , b = true , c =  0 }.b) ) (fix (\x: Nat . false ))) in u) , b = ({a = (pred (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) , b = (((\x: Bool .\y: Nat .y) ({a = false , b = 1 }.a) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) }.b) }.b)
(fix (\x: Nat . (fix (\x: Nat . (let u = (((\x: Nat .\y: Rec X. X .x) false ) true) in u) )) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (if ({a = ({a = ({a = 0 , b = 1 }.b) , b = true }.a) , b = ({a = (((\x: Nat .\y: Nat .y) false ) false) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (if false then false else true) )) }.b) }.b) then (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Unit .y) false ) 0) )) )) else (let u = ({a = (((\x: Bool .\y: Nat .y) true ) 1) , b = (((\x: Bool .\y: Unit .x) 1 ) true) }.b) in u)) ))
(if (((\x: Bool .\y: Rec X. X .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) ) (( \f: Nat .((f (if false then false else true) ) false ) ) (\a: Bool .\b: Rec X. X .b))) then ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = (((\x: Nat .\y: Unit .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 0)) in ({a = (((\x: Unit .\y: Unit .y) false ) false) , b = ({a = 0 , b = true }.a) }.a)) )) else ({a = ({a = ({a = true , b = 0 }.b) , b = (((\x: Nat .\y: Rec X. X .y) ({a = true , b = 0 }.a) ) false) , c = (let u = 1 in 0) }.c) , b = (( \f: Rec X. X .((f ({a = ({a = 1 , b = 0 }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in false) )) , c =  (((\x: Nat .\y: Nat .y) false ) 1) }.b) ) (((\x: Rec X. X .\y: Unit .y) true ) ({a = 1 , b = false }.b)) ) ) (\a: Bool .\b: Rec X. X .a)) }.b))
({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a)) )) , b = (succ (( \f: Rec X. X .((f (succ 0) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Bool .\b: Unit .a))) }.a)
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = ({a = 0 , b = true }.a) , b = true , c = 1 }.c) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) ))
({a = ({a = ({a = (fix (\x: Rec X. X . (if false then false else true) )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Bool .x) true ) true) , b = 1 }.b) )) }.b) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Nat .\y: Nat .y) true ) true) , c =  (let u = 1 in 0) }.b) )) , c = (if ({a = false , b = true }.b) then ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) else ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 ))) }.c) , b = (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (if true then (unfold [ Unit ] (fold [ Nat ] false )) else (let u = true in true)) )) then (let u = true in true) else ({a = (let u = false in u) , b = (pred 1) }.a)) , c = (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (if false then false else true) in (let u = false in 0)) )) ) (fix (\x: Bool . (let u = (succ 1) in false) ))) }.c)
(succ (pred (unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = 0 , b = true , c = 1 }.c) , b = (fix (\x: Bool . true )) }.a) ))))
(( \f: Rec X. X .((f ({a = ({a = ({a = false , b = 0 }.b) , b = (((\x: Nat .\y: Unit .y) true ) true) }.a) , b = (((\x: Nat .\y: Bool .x) (let u = false in (((\x: Nat .\y: Unit .y) false ) false)) ) (let u = 1 in ({a = false , b = false }.b))) , c =  (unfold [ Unit ] (fold [ Bool ] (if ({a = true , b = true }.b) then 0 else (unfold [ Bool ] (fold [ Unit ] 1 ))) )) }.b) ) (if (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) )) ) (iszero 1) ) ) (\a: Rec X. X .\b: Nat .b)) then ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Bool .y) true ) false) )) else (( \f: Nat .((f ({a = 0 , b = false , c =  0 }.b) ) (if (((\x: Nat .\y: Unit .y) false ) true) then true else ({a = 1 , b = false , c =  1 }.b)) ) ) (\a: Nat .\b: Nat .a))) ) ) (\a: Rec X. X .\b: Bool .b))
(fix (\x: Bool . (if ({a = true , b = true }.b) then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else (( \f: Bool .((f (let u = false in 1) ) (succ 1) ) ) (\a: Bool .\b: Rec X. X .a))) ))
(case <l = (((\x: Nat .\y: Unit .y) (let u = (( \f: Nat .((f (let u = 1 in 1) ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in (case <r = ({a = 1 , b = true , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (if true then (let u = false in 0) else (succ 1)) , b = (((\x: Bool .\y: Bool .x) 1 ) false) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(iszero (( \f: Nat .((f ({a = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .b)) , b = (( \f: Unit .((f 1 ) (succ 0) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) ) (fix (\x: Bool . (if (fix (\x: Bool . true )) then 0 else 0) )) ) ) (\a: Bool .\b: Unit .a)))
(( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) , b = (if (let u = 1 in true) then false else (unfold [ Unit ] (fold [ Nat ] true ))) , c = (let u = (((\x: Bool .\y: Unit .y) true ) 1) in u) }.c) ) (((\x: Nat .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (let u = 1 in true) , b = (if false then true else false) }.b) )) ) (succ (unfold [ Nat ] (fold [ Bool ] 1 )))) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(( \f: Nat .((f ({a = (( \f: Nat .((f ({a = (fix (\x: Rec X. X . true )) , b = (pred 1) }.b) ) (fix (\x: Bool . 1 )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Rec X. X . true )) )) , c =  ({a = (pred 1) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) }.b) ) ({a = (case <r = (let u = (fix (\x: Unit . true )) in true) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = (fix (\x: Nat . 0 )) , b = (let u = 0 in false) }.b) )) , b = ({a = ({a = (((\x: Nat .\y: Unit .x) false ) false) , b = 1 }.b) , b = (if false then ({a = 0 , b = true , c = 1 }.c) else 0) }.b) }.a) }.b) ) ) (\a: Bool .\b: Unit .a))
(iszero (let u = ({a = (pred 1) , b = ({a = 1 , b = (((\x: Nat .\y: Rec X. X .y) false ) true) }.b) , c = ({a = (fix (\x: Nat . 0 )) , b = true , c = 1 }.c) }.c) in (fix (\x: Nat . (let u = 0 in u) ))))
(if (((\x: Bool .\y: Unit .y) (let u = (((\x: Bool .\y: Nat .x) false ) false) in u) ) (let u = (let u = ({a = false , b = true }.b) in 1) in (fix (\x: Rec X. X . (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) )))) then (( \f: Bool .((f (case <l = (fix (\x: Bool . 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (succ (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) in 0)) ) ) (\a: Rec X. X .\b: Unit .a)) else (fix (\x: Nat . ({a = (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u) , b = (case <l = ({a = 1 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y) }.b) )))
(fix (\x: Unit . (let u = (( \f: Nat .((f (( \f: Rec X. X .((f ({a = true , b = (((\x: Bool .\y: Rec X. X .y) false ) 0) }.a) ) (( \f: Unit .((f true ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .b)) ) (let u = true in false) ) ) (\a: Nat .\b: Rec X. X .a)) in u) ))
(case <r = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in false) )) in u) > as Bool of < l = x > => x | < r = y > => y)
(case <l = (let u = (( \f: Rec X. X .((f (let u = (((\x: Unit .\y: Bool .x) false ) true) in u) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Bool .\b: Rec X. X .b)) in (let u = (let u = true in 0) in (let u = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a)) in ({a = 1 , b = true , c = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) }.c)))) > as Nat of < l = x > => x | < r = y > => y)
(let u = ({a = (fix (\x: Bool . ({a = true , b = 1 }.a) )) , b = (unfold [ Unit ] (fold [ Rec X. X ] ({a = true , b = 1 }.b) )) }.a) in (let u = (fix (\x: Unit . ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) )) in u))
(( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) ({a = (succ 0) , b = false }.b) ) (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in u)) ) (((\x: Rec X. X .\y: Unit .y) (let u = true in true) ) (let u = false in 1)) ) ) (\a: Unit .\b: Unit .a))
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = (fix (\x: Unit . true )) , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) )) , b = (case <r = (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) true ) true) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ) (\a: Rec X. X .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(fix (\x: Bool . ({a = (if ({a = 0 , b = true }.b) then 0 else 1) , b = (( \f: Nat .((f (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .a)) ) (((\x: Rec X. X .\y: Unit .y) false ) false) ) ) (\a: Unit .\b: Unit .a)) , c =  (let u = (unfold [ Nat ] (fold [ Bool ] false )) in ({a = 1 , b = (fix (\x: Unit . 0 )) }.b)) }.b) ))
(let u = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) (pred (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Unit .b)) )) ) (let u = ({a = 0 , b = false }.b) in ({a = 1 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = 0 }.c)) ) ) (\a: Unit .\b: Rec X. X .a)) in u)
(pred (let u = (if (case <r = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) > as Unit of < l = x > => x | < r = y > => y) then ({a = (if true then 0 else 1) , b = ({a = true , b = 0 }.a) }.a) else (unfold [ Bool ] (fold [ Nat ] (let u = 0 in 1) ))) in u))
(let u = (let u = (if true then 0 else (let u = true in 0)) in (((\x: Rec X. X .\y: Bool .y) false ) (if false then false else false))) in ({a = (( \f: Unit .((f (succ 1) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (fix (\x: Unit . ({a = 1 , b = false , c =  (let u = true in 0) }.b) )) , c =  (((\x: Nat .\y: Bool .x) (succ ({a = 0 , b = 1 }.b)) ) ({a = true , b = false }.b)) }.b))
(((\x: Unit .\y: Bool .y) ({a = (let u = (((\x: Rec X. X .\y: Bool .y) true ) true) in (case <l = (succ 1) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Nat .b)) }.b) ) (( \f: Nat .((f ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (if true then true else (let u = true in u)) }.a) ) (((\x: Nat .\y: Bool .x) (if true then 0 else 0) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .a)) ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Nat .b))) ) ) (\a: Bool .\b: Nat .b)))
({a = (unfold [ Rec X. X ] (fold [ Bool ] (if (((\x: Bool .\y: Bool .x) (fix (\x: Rec X. X . false )) ) (fix (\x: Bool . false ))) then ({a = (succ 0) , b = (iszero 0) }.b) else (unfold [ Bool ] (fold [ Rec X. X ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) ))) )) , b = (let u = (((\x: Rec X. X .\y: Unit .x) false ) false) in u) }.b)
(fix (\x: Rec X. X . ({a = ({a = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = (iszero 0) }.b) , b = ({a = ({a = 1 , b = false , c = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.c) , b = ({a = (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .x) true ) false) ) (((\x: Rec X. X .\y: Bool .y) true ) true) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = true , b = true }.b) }.b) , c = (succ (let u = false in (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)))) }.c) }.a) ))
(pred (pred (fix (\x: Rec X. X . 0 ))))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = false , b = 0 }.b) )) )) , b = ({a = (((\x: Nat .\y: Bool .y) (let u = ({a = 0 , b = false , c = 1 }.c) in (let u = false in u)) ) (let u = ({a = 1 , b = false }.a) in u)) , b = (((\x: Rec X. X .\y: Bool .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .y) true ) false) )) ) ({a = (fix (\x: Rec X. X . false )) , b = 0 }.a)) }.b) , c =  (pred ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) 1 ) ) (\a: Unit .\b: Nat .a)) ))) }.b)
(( \f: Rec X. X .((f (let u = (let u = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) in ({a = ({a = 0 , b = false , c = 0 }.c) , b = true }.a)) in u) ) (if (let u = ({a = false , b = (if false then true else false) }.b) in u) then (((\x: Unit .\y: Nat .y) ({a = 1 , b = false }.b) ) (let u = 0 in 1)) else ({a = (let u = 0 in u) , b = ({a = true , b = 0 }.a) }.a)) ) ) (\a: Bool .\b: Bool .b))
(( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Nat ] ({a = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in ({a = 1 , b = true }.a)) , b = (fix (\x: Nat . 1 )) }.b) )) ) (let u = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in (((\x: Rec X. X .\y: Nat .y) true ) true)) in (let u = ({a = (( \f: Unit .((f (iszero 0) ) (let u = false in false) ) ) (\a: Bool .\b: Nat .a)) , b = (if true then 0 else 1) }.a) in (fix (\x: Unit . (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) )))) ) ) (\a: Nat .\b: Bool .b))
(let u = (let u = ({a = ({a = (let u = true in 0) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) in (fix (\x: Bool . (if (let u = true in false) then (let u = true in 1) else (fix (\x: Nat . 0 ))) ))) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (if (let u = true in u) then false else (let u = false in true)) )))
(( \f: Rec X. X .((f (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) in (if ({a = false , b = false }.b) then 1 else (let u = 1 in u))) ) (if (((\x: Nat .\y: Unit .y) (fix (\x: Bool . true )) ) (let u = (let u = false in true) in u)) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 0 in 1) )) else (pred (( \f: Rec X. X .((f (let u = 0 in u) ) (let u = 1 in 0) ) ) (\a: Nat .\b: Unit .b)))) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Bool .\y: Unit .y) (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Unit ] ({a = false , b = true }.b) )) ) (if (((\x: Unit .\y: Nat .y) (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) )) ) (fix (\x: Bool . false ))) then (let u = 0 in (((\x: Bool .\y: Bool .y) true ) false)) else (( \f: Nat .((f (( \f: Bool .((f ({a = false , b = 1 }.a) ) (let u = false in false) ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .b))) ) ) (\a: Nat .\b: Nat .b)) ) (case <l = (((\x: Nat .\y: Bool .y) (let u = false in u) ) (unfold [ Nat ] (fold [ Unit ] 0 ))) > as Bool of < l = x > => x | < r = y > => y))
(succ (let u = (fix (\x: Bool . (if (let u = false in u) then 1 else (let u = 1 in u)) )) in u))
(iszero (pred (((\x: Nat .\y: Rec X. X .x) (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Nat .x) false ) false) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a))) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .x) true ) true) ) false ) ) (\a: Nat .\b: Unit .a)))))
(( \f: Unit .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) in (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) )) ) ({a = (( \f: Nat .((f ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = true , c = 1 }.c) ) (pred 1) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Nat .((f ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) ) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Rec X. X .b)) }.a) ) ) (\a: Nat .\b: Unit .a))
(((\x: Rec X. X .\y: Unit .x) ({a = (( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ({a = 0 , b = 1 }.b) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , c =  (( \f: Bool .((f (let u = true in 0) ) (((\x: Bool .\y: Nat .y) false ) ({a = 1 , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) ) (( \f: Bool .((f ({a = 1 , b = false , c =  (let u = 0 in 0) }.b) ) (( \f: Unit .((f (fix (\x: Nat . true )) ) (((\x: Rec X. X .\y: Unit .x) false ) false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .b)))
(let u = ({a = (case <r = ({a = (((\x: Unit .\y: Nat .y) false ) false) , b = ({a = 0 , b = false , c =  1 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . (let u = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = 1 }.b) in (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a))) )) }.b) in (((\x: Unit .\y: Unit .x) (fix (\x: Bool . (fix (\x: Bool . false )) )) ) (iszero (( \f: Bool .((f (let u = 1 in 1) ) 1 ) ) (\a: Bool .\b: Rec X. X .b)))))
(pred ({a = ({a = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = 1 in false) }.b) , b = ({a = (pred 0) , b = (let u = (let u = true in 1) in 1) }.b) }.b))
(if (( \f: Unit .((f (fix (\x: Unit . (( \f: Nat .((f (let u = 0 in true) ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Bool .b)) )) ) (fix (\x: Nat . (( \f: Bool .((f false ) (if false then true else true) ) ) (\a: Unit .\b: Nat .a)) )) ) ) (\a: Unit .\b: Bool .a)) then (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Rec X. X .y) (let u = true in true) ) 0) ) (((\x: Bool .\y: Nat .x) false ) false)) ) (let u = (( \f: Nat .((f ({a = 1 , b = false }.a) ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Nat .b)) in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) else ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Unit .((f ({a = 0 , b = true }.a) ) (pred ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) ) ) (\a: Nat .\b: Nat .a)) )) , b = ({a = (let u = (let u = ({a = 1 , b = true }.b) in 0) in ({a = true , b = true }.b)) , b = (iszero (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) }.b) }.a))
(let u = (let u = (fix (\x: Nat . (fix (\x: Bool . 0 )) )) in (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)))) in (let u = ({a = (((\x: Rec X. X .\y: Bool .y) false ) 1) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) , c =  ({a = 0 , b = false , c = 1 }.c) }.b) in u))
(if (case <r = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Nat .y) ({a = true , b = 0 }.a) ) (((\x: Bool .\y: Bool .y) true ) false)) ) ({a = 0 , b = ({a = 0 , b = false , c =  1 }.b) }.b)) > as Unit of < l = x > => x | < r = y > => y) then ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) false ) false) )) else (iszero (((\x: Bool .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = false }.b) )) ) (if (iszero 0) then 0 else 1))))
(if (((\x: Rec X. X .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) true ) false) )) )) ) (let u = (case <r = ({a = false , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) in (unfold [ Nat ] (fold [ Bool ] ({a = (((\x: Bool .\y: Unit .y) false ) 1) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) )))) then (if (( \f: Unit .((f (let u = ({a = true , b = 0 }.a) in u) ) (iszero 1) ) ) (\a: Unit .\b: Bool .b)) then ({a = 1 , b = (fix (\x: Rec X. X . 1 )) }.b) else (if ({a = (let u = 1 in 1) , b = (let u = false in true) }.b) then (if (if true then true else true) then 1 else 0) else ({a = 1 , b = 1 }.b))) else (fix (\x: Nat . ({a = ({a = 1 , b = ({a = true , b = false }.b) }.a) , b = (unfold [ Nat ] (fold [ Unit ] (fix (\x: Bool . true )) )) }.a) )))
(((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f ({a = (succ (let u = 1 in 1)) , b = (((\x: Bool .\y: Rec X. X .x) false ) ({a = true , b = 0 }.a)) , c =  (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) ) 0) }.b) ) (if (fix (\x: Nat . false )) then (let u = 0 in false) else (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .b)) ) (let u = (iszero ({a = 0 , b = 0 }.b)) in u))
(iszero (fix (\x: Bool . (( \f: Rec X. X .((f ({a = ({a = 0 , b = 0 }.b) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.a) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Rec X. X .b)) )))
(case <r = (fix (\x: Nat . (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) true ) false) ) ({a = (fix (\x: Nat . 1 )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) }.b) ) ) (\a: Bool .\b: Bool .b)) )) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f (( \f: Unit .((f (let u = true in u) ) (iszero 0) ) ) (\a: Bool .\b: Rec X. X .a)) ) (( \f: Bool .((f ({a = false , b = true }.b) ) true ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .b)) ) (( \f: Bool .((f (fix (\x: Unit . true )) ) ({a = false , b = 0 }.a) ) ) (\a: Unit .\b: Nat .b))) ) (( \f: Nat .((f (case <r = (((\x: Nat .\y: Bool .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = false , b = 0 }.a) )) , b = (let u = (if true then false else false) in (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b))) }.b) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b))
(case <r = (fix (\x: Bool . (case <r = (((\x: Rec X. X .\y: Unit .x) false ) false) > as Bool of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = ({a = (pred (if (let u = 1 in false) then (let u = false in 1) else 1)) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = true in u) )) }.a) in (let u = (((\x: Nat .\y: Nat .y) (fix (\x: Rec X. X . ({a = false , b = true }.b) )) ) (let u = (pred 1) in u)) in u))
(if (( \f: Unit .((f ({a = ({a = 0 , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) , c = 0 }.c) , b = (let u = true in u) , c =  ({a = 1 , b = false , c = 0 }.c) }.b) ) (let u = ({a = ({a = 1 , b = false }.a) , b = (((\x: Nat .\y: Unit .y) ({a = false , b = true }.b) ) true) }.b) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (case <r = (fix (\x: Unit . ({a = 0 , b = false , c =  1 }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y) else (case <r = (((\x: Rec X. X .\y: Nat .x) (if true then false else false) ) true) > as Unit of < l = x > => x | < r = y > => y))
(unfold [ Bool ] (fold [ Bool ] (succ (let u = (((\x: Bool .\y: Bool .x) 0 ) false) in ({a = (if false then 0 else 0) , b = (fix (\x: Rec X. X . true )) , c = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.c))) ))
({a = (unfold [ Rec X. X ] (fold [ Bool ] (let u = true in 1) )) , b = ({a = ({a = (((\x: Unit .\y: Nat .x) false ) true) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] true )) , b = 1 }.b) }.a) , b = ({a = (if (fix (\x: Rec X. X . true )) then (let u = 0 in 0) else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = false , c =  1 }.b) )) , c = (succ ({a = 0 , b = 1 }.b)) }.c) }.a) }.b)
(if (( \f: Rec X. X .((f ({a = ({a = true , b = 0 }.b) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  (((\x: Unit .\y: Bool .y) true ) 1) }.b) ) (fix (\x: Bool . (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .b)) )) ) ) (\a: Rec X. X .\b: Nat .a)) then (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) ) (case <r = (fix (\x: Bool . (unfold [ Unit ] (fold [ Rec X. X ] false )) )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) else (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = 0 , b = false }.b) )) in u))
(case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (if ({a = (let u = true in u) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) }.a) then (let u = 0 in 0) else (unfold [ Bool ] (fold [ Nat ] ({a = false , b = 0 }.b) ))) )) > as Nat of < l = x > => x | < r = y > => y)
(iszero ({a = ({a = 0 , b = 1 }.b) , b = (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) in (if ({a = true , b = 0 }.a) then true else (((\x: Bool .\y: Bool .y) false ) true))) }.a))
({a = (let u = ({a = ({a = ({a = 1 , b = false , c =  1 }.b) , b = ({a = 1 , b = true , c = 0 }.c) }.a) , b = (succ 1) }.b) in u) , b = (iszero (fix (\x: Nat . (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .y) true ) 1) ) (unfold [ Nat ] (fold [ Nat ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) )) ) ) (\a: Bool .\b: Rec X. X .b)) ))) , c = (( \f: Bool .((f (if ({a = 1 , b = false , c =  1 }.b) then (pred (((\x: Rec X. X .\y: Unit .x) 0 ) true)) else (((\x: Bool .\y: Nat .y) true ) 0)) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) }.c)
(if (fix (\x: Rec X. X . (case <r = (((\x: Unit .\y: Unit .x) true ) false) > as Bool of < l = x > => x | < r = y > => y) )) then ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (((\x: Nat .\y: Unit .y) false ) true) ) (let u = false in false) ) ) (\a: Unit .\b: Unit .a)) }.b) else (( \f: Nat .((f (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then ({a = false , b = 1 }.a) else (((\x: Bool .\y: Rec X. X .x) true ) true)) ) (let u = (( \f: Rec X. X .((f ({a = true , b = 1 }.b) ) 1 ) ) (\a: Bool .\b: Unit .b)) in ({a = ({a = true , b = 0 }.a) , b = false }.b)) ) ) (\a: Unit .\b: Rec X. X .b)))
(unfold [ Bool ] (fold [ Rec X. X ] (( \f: Unit .((f (let u = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) in u) ) (iszero (let u = false in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
(if (case <r = (( \f: Rec X. X .((f (let u = (let u = false in 1) in ({a = true , b = 0 }.a)) ) (((\x: Rec X. X .\y: Bool .x) false ) false) ) ) (\a: Bool .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = (((\x: Bool .\y: Nat .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (unfold [ Unit ] (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ))) , b = (((\x: Bool .\y: Bool .y) (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) )) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .b))) }.b) else ({a = (( \f: Nat .((f 0 ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = (let u = false in true) , b = (let u = (let u = 0 in u) in 1) }.a) , c =  (((\x: Unit .\y: Bool .y) true ) ({a = 1 , b = 1 }.b)) }.b))
(( \f: Unit .((f ({a = (( \f: Unit .((f (let u = ({a = (((\x: Unit .\y: Bool .x) 0 ) false) , b = (let u = false in u) }.a) in (let u = 1 in u)) ) ({a = ({a = false , b = true }.b) , b = (let u = 1 in 1) }.b) ) ) (\a: Nat .\b: Unit .a)) , b = (if (((\x: Bool .\y: Bool .y) ({a = (let u = 1 in u) , b = ({a = true , b = true }.b) }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) then ({a = true , b = (((\x: Nat .\y: Bool .x) 0 ) false) }.a) else (( \f: Unit .((f (let u = true in u) ) (unfold [ Nat ] (fold [ Bool ] ({a = true , b = true }.b) )) ) ) (\a: Bool .\b: Unit .b))) }.a) ) (succ (case <l = (let u = (unfold [ Bool ] (fold [ Unit ] 1 )) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) 0 ) true) ))) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Rec X. X .b))
(case <l = (let u = (fix (\x: Rec X. X . ({a = true , b = 0 }.a) )) in ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) in u) , b = (let u = 0 in u) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (case <l = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y) )) , b = (if ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = false , c =  0 }.b) )) then (( \f: Bool .((f 1 ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Bool .b)) else (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Nat . 0 )) ))) }.b) , b = (let u = (let u = (let u = 0 in false) in (iszero 1)) in u) , c =  (if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = false in true) )) then (((\x: Bool .\y: Unit .y) ({a = false , b = 1 }.a) ) (succ 1)) else (( \f: Rec X. X .((f (let u = false in 0) ) (fix (\x: Bool . 1 )) ) ) (\a: Rec X. X .\b: Unit .b))) }.b)
(let u = ({a = (let u = (( \f: Nat .((f (let u = 0 in u) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) ) ) (\a: Bool .\b: Nat .b)) in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in (succ (if ({a = false , b = 1 }.a) then 1 else (if true then 0 else 0)))) }.b) in u)
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred 0) )) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in 1) )) , b = (fix (\x: Unit . (if false then false else true) )) }.a) }.b)
(((\x: Bool .\y: Unit .x) ({a = ({a = 1 , b = (let u = 0 in true) }.b) , b = (let u = (let u = true in 1) in 1) }.b) ) (case <r = (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = true }.b) )) > as Unit of < l = x > => x | < r = y > => y))
({a = ({a = (( \f: Rec X. X .((f ({a = (succ 0) , b = ({a = 1 , b = 0 }.b) }.b) ) (pred ({a = (pred 0) , b = false }.a)) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (((\x: Bool .\y: Rec X. X .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (((\x: Nat .\y: Rec X. X .x) false ) false)) , c =  ({a = (iszero 1) , b = ({a = 1 , b = false }.a) }.b) }.b) , b = (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f ({a = (((\x: Rec X. X .\y: Unit .x) true ) false) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.b) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = 1 }.a) ) false) ))) }.a)
({a = (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) ({a = ({a = 1 , b = true }.a) , b = true , c =  0 }.b) ) (( \f: Nat .((f (((\x: Nat .\y: Nat .x) false ) false) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Nat .a))) ) (let u = ({a = (((\x: Bool .\y: Rec X. X .y) false ) false) , b = (let u = 1 in u) }.b) in (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) false ) ) (\a: Unit .\b: Nat .a))) ) ) (\a: Nat .\b: Nat .a)) , b = (case <r = (let u = ({a = 0 , b = false , c =  1 }.b) in (let u = 0 in false)) > as Nat of < l = x > => x | < r = y > => y) }.b)
({a = (( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] (if true then 1 else ({a = 0 , b = 1 }.b)) )) ) (pred (pred (succ 1))) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Unit ] ({a = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) , b = (let u = (iszero 1) in 0) }.a) )) , c =  (((\x: Bool .\y: Rec X. X .y) (( \f: Unit .((f ({a = true , b = false }.b) ) ({a = ({a = true , b = false }.b) , b = false }.b) ) ) (\a: Unit .\b: Unit .b)) ) ({a = (let u = true in 1) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.b)) }.b)
(let u = ({a = (( \f: Bool .((f (fix (\x: Nat . 1 )) ) (if (if false then true else false) then 1 else 1) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = ({a = ({a = 1 , b = true , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.c) , b = (iszero 1) , c = (fix (\x: Bool . 1 )) }.c) , b = (( \f: Rec X. X .((f (fix (\x: Bool . false )) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) }.b) , c = (pred (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) in u)) }.c) in (let u = (if (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) then ({a = 1 , b = false }.a) else (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) in 1)) in (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (let u = 1 in u) else (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)))))
(((\x: Rec X. X .\y: Rec X. X .y) (let u = (( \f: Unit .((f false ) (let u = 0 in false) ) ) (\a: Rec X. X .\b: Bool .a)) in ({a = ({a = true , b = false }.b) , b = 0 }.a)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) , b = ({a = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) in false) , b = (unfold [ Bool ] (fold [ Nat ] 0 )) }.a) , c =  (let u = 0 in u) }.b) )))
(let u = (let u = (let u = ({a = 1 , b = false }.a) in (let u = ({a = true , b = 1 }.a) in 0)) in u) in (let u = (succ 1) in (let u = true in u)))
(( \f: Unit .((f (( \f: Bool .((f (let u = ({a = false , b = true }.b) in true) ) (case <r = (((\x: Bool .\y: Bool .x) false ) false) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) ) (((\x: Unit .\y: Nat .x) (let u = 0 in (let u = true in false)) ) ({a = (iszero 1) , b = (if true then false else false) }.b)) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Rec X. X .\y: Nat .x) (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) ) (iszero ({a = (((\x: Unit .\y: Bool .x) ({a = true , b = false }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (if true then 0 else 0) , b = ({a = true , b = true }.b) }.a) }.b)))
(( \f: Unit .((f (((\x: Rec X. X .\y: Unit .y) (unfold [ Nat ] (fold [ Bool ] (fix (\x: Nat . true )) )) ) (((\x: Rec X. X .\y: Rec X. X .y) (if true then true else false) ) (let u = 1 in u))) ) (unfold [ Unit ] (fold [ Nat ] (if (let u = 0 in false) then 0 else 0) )) ) ) (\a: Bool .\b: Nat .a))
(((\x: Rec X. X .\y: Nat .y) ({a = (unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = 1 , b = false }.b) , b = (let u = true in 0) }.b) )) , b = (( \f: Unit .((f (case <r = ({a = false , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero (let u = 0 in u)) ) ) (\a: Unit .\b: Unit .b)) }.b) ) (( \f: Bool .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Rec X. X ] (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 ))) )) ) ) (\a: Nat .\b: Unit .a)))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (succ (if (let u = false in u) then (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) else ({a = ({a = false , b = 0 }.b) , b = true }.a))) ))
(unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f (((\x: Unit .\y: Nat .x) ({a = false , b = 1 }.a) ) (let u = 0 in (if true then false else true))) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = false , c =  ({a = 0 , b = true }.a) }.b) ) ) (\a: Unit .\b: Bool .a)) ))
(( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Unit .y) false ) true) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .b))) )) ) ({a = (if true then 0 else 1) , b = (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = ({a = 0 , b = true , c =  1 }.b) , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (pred (let u = 1 in 1)) }.b) ) ) (\a: Unit .\b: Nat .b))
(fix (\x: Rec X. X . (( \f: Nat .((f ({a = (case <l = (((\x: Bool .\y: Unit .y) true ) 1) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = 1 }.b) }.a) , c =  (fix (\x: Nat . 0 )) }.b) ) ({a = (let u = (fix (\x: Rec X. X . (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) )) in (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b))) , b = (let u = 1 in true) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) ))
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) (((\x: Bool .\y: Unit .x) (((\x: Nat .\y: Rec X. X .x) ({a = 1 , b = false }.b) ) true) ) (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y)) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Nat .y) false ) true)) ))) ))
(case <r = (let u = (((\x: Nat .\y: Unit .y) true ) ({a = true , b = 0 }.b)) in (( \f: Nat .((f false ) (fix (\x: Rec X. X . false )) ) ) (\a: Rec X. X .\b: Nat .b))) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (( \f: Nat .((f (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a))) ) ({a = (let u = 0 in 1) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) , c = (((\x: Bool .\y: Rec X. X .x) 1 ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b))) }.c) ) ) (\a: Nat .\b: Bool .a)) , b = ({a = (((\x: Rec X. X .\y: Bool .y) true ) false) , b = (succ (succ 0)) }.b) }.b)
(let u = (let u = (((\x: Nat .\y: Nat .y) ({a = false , b = 1 }.a) ) ({a = 0 , b = true }.a)) in (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in u) ) (let u = (( \f: Rec X. X .((f (let u = false in u) ) ({a = false , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .a)) in u))) in u)
(let u = (( \f: Bool .((f (if true then 1 else 0) ) ({a = (unfold [ Bool ] (fold [ Bool ] 0 )) , b = ({a = false , b = 0 }.a) , c = 1 }.c) ) ) (\a: Rec X. X .\b: Nat .a)) in (unfold [ Bool ] (fold [ Unit ] (pred (unfold [ Nat ] (fold [ Nat ] 1 ))) )))
(case <l = (let u = (( \f: Rec X. X .((f false ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) in (( \f: Nat .((f (succ 1) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a))) > as Bool of < l = x > => x | < r = y > => y)
(unfold [ Bool ] (fold [ Bool ] (((\x: Rec X. X .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) (if (if true then true else false) then true else false)) ))
(unfold [ Unit ] (fold [ Bool ] (( \f: Nat .((f (case <l = ({a = (unfold [ Unit ] (fold [ Unit ] false )) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 1 in 0) )) }.b) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Rec X. X .y) (iszero 0) ) ({a = 1 , b = false , c = 0 }.c)) ) ) (\a: Rec X. X .\b: Unit .b)) ))
({a = (if ({a = (((\x: Nat .\y: Nat .x) false ) false) , b = (if (unfold [ Bool ] (fold [ Nat ] true )) then false else true) }.b) then (let u = true in 0) else (case <l = (pred (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a))) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f (let u = ({a = 0 , b = true }.a) in true) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (if true then true else false) , c =  (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (if (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Nat .x) false ) false) ) ({a = false , b = 0 }.a)) then (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Rec X. X .x) 1 ) false) )) else ({a = 0 , b = true , c = 0 }.c)) else (unfold [ Nat ] (fold [ Nat ] 0 ))) }.b)
(if (unfold [ Nat ] (fold [ Rec X. X ] (case <r = (fix (\x: Unit . (iszero 1) )) > as Nat of < l = x > => x | < r = y > => y) )) then (let u = (let u = ({a = 0 , b = false }.a) in u) in (( \f: Rec X. X .((f (if false then 1 else 1) ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Unit .a))) else (unfold [ Unit ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f 1 ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) ) (\a: Unit .\b: Bool .a)) , b = (iszero 0) , c = ({a = 0 , b = true , c = 0 }.c) }.c) )))
(case <l = (if (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) in (((\x: Bool .\y: Bool .y) ({a = 0 , b = false }.b) ) true)) then (let u = ({a = (if true then true else true) , b = ({a = 1 , b = true , c = 0 }.c) }.b) in u) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b))) > as Unit of < l = x > => x | < r = y > => y)
(pred (if ({a = 1 , b = (fix (\x: Rec X. X . false )) }.b) then (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = true }.a) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) else (case <l = (((\x: Unit .\y: Nat .x) 0 ) false) > as Bool of < l = x > => x | < r = y > => y)))
(( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (if true then (let u = 0 in 1) else 1) )) ) (succ (let u = true in 0)) ) ) (\a: Unit .\b: Bool .a))
(((\x: Unit .\y: Rec X. X .y) (let u = (iszero 0) in ({a = (( \f: Bool .((f 0 ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) }.b)) ) (( \f: Rec X. X .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (iszero ({a = 0 , b = 1 }.b)) )) ) ({a = (((\x: Bool .\y: Bool .y) ({a = false , b = 0 }.a) ) true) , b = (((\x: Nat .\y: Rec X. X .y) false ) 0) }.a) ) ) (\a: Unit .\b: Unit .a)))
(let u = ({a = (succ 1) , b = ({a = false , b = 1 }.a) , c =  (fix (\x: Nat . ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = (((\x: Bool .\y: Rec X. X .x) 0 ) true) }.c) )) }.b) in (unfold [ Unit ] (fold [ Rec X. X ] (succ ({a = 0 , b = (let u = 1 in true) }.a)) )))
(((\x: Bool .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) (fix (\x: Bool . false )) ) false) )) ) (succ ({a = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) }.b)))
(unfold [ Rec X. X ] (fold [ Bool ] (case <l = ({a = 1 , b = true , c = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.c) > as Bool of < l = x > => x | < r = y > => y) ))
(( \f: Unit .((f (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , b = (fix (\x: Unit . 0 )) }.b) )) in u) ) (fix (\x: Unit . (( \f: Nat .((f (( \f: Bool .((f (succ 0) ) (((\x: Bool .\y: Rec X. X .y) false ) 1) ) ) (\a: Nat .\b: Unit .b)) ) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true , c = 0 }.c) ) ) (\a: Nat .\b: Bool .b)) )) ) ) (\a: Nat .\b: Bool .b))
(((\x: Unit .\y: Nat .y) ({a = (let u = ({a = (pred 1) , b = (let u = true in true) , c =  1 }.b) in (iszero (unfold [ Bool ] (fold [ Rec X. X ] 1 )))) , b = (let u = (let u = ({a = 1 , b = false }.b) in ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 ))) in (let u = ({a = false , b = true }.b) in u)) }.b) ) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .y) true ) (unfold [ Nat ] (fold [ Unit ] 1 ))) )) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = false in false) )) }.b))
(( \f: Bool .((f (( \f: Rec X. X .((f (case <r = (let u = false in true) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false ))) ) ) (\a: Nat .\b: Nat .b)) ) (((\x: Bool .\y: Bool .x) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = (((\x: Rec X. X .\y: Unit .x) true ) false) , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) ) ({a = (if false then 0 else ({a = 1 , b = false , c = 1 }.c)) , b = ({a = false , b = true }.b) }.b)) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Nat .\y: Bool .x) (let u = ({a = (let u = 1 in 1) , b = (if true then 1 else 1) }.b) in (let u = ({a = 0 , b = (succ 0) }.b) in (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Nat .y) false ) 1) )))) ) (fix (\x: Bool . (iszero ({a = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = 1 }.b)) )))
(((\x: Rec X. X .\y: Unit .y) (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Rec X. X .y) ({a = false , b = true }.b) ) true) ) (( \f: Nat .((f (let u = true in false) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Nat .b))) ) (let u = (( \f: Unit .((f 1 ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Unit .b)) in (((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Unit .x) true ) false) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y))))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (succ (fix (\x: Nat . 1 ))) )) in u)
(( \f: Rec X. X .((f ({a = (pred (pred 1)) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = true , c =  0 }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false ))) }.b) ) (iszero ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 0 in u) }.b) , b = ({a = false , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) , c = (let u = true in 0) }.c)) ) ) (\a: Bool .\b: Bool .a))
(let u = (succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = (pred 1) in 1) )) ))) in ({a = ({a = ({a = 1 , b = true }.b) , b = (fix (\x: Bool . 0 )) }.b) , b = ({a = (fix (\x: Nat . 0 )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) }.b) , c =  ({a = (((\x: Bool .\y: Rec X. X .y) false ) 0) , b = false }.a) }.b))
(fix (\x: Unit . (( \f: Rec X. X .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = false in (let u = true in 1)) ) ) (\a: Nat .\b: Bool .a)) ))
(case <l = (( \f: Nat .((f (case <l = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Bool .y) false ) (if false then 0 else 1)) ) ) (\a: Unit .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (let u = (fix (\x: Rec X. X . ({a = true , b = 0 }.a) )) in (case <r = (let u = false in true) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .y) false ) ({a = false , b = true }.b)) ) ({a = true , b = 1 }.a)) ) (let u = (((\x: Bool .\y: Rec X. X .y) true ) 1) in (if false then false else true)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b))
(((\x: Rec X. X .\y: Rec X. X .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] (let u = ({a = 0 , b = 0 }.b) in 0) )) )) ) ({a = (case <l = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .a)) , c =  (let u = ({a = 0 , b = 0 }.b) in (succ 1)) }.b))
(let u = (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) in (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b))) in (((\x: Unit .\y: Unit .x) (if (((\x: Unit .\y: Bool .y) false ) false) then (pred 0) else 1) ) ({a = 0 , b = false , c =  1 }.b))) in (if (unfold [ Rec X. X ] (fold [ Unit ] (if true then (if true then true else true) else false) )) then (case <r = (fix (\x: Unit . true )) > as Bool of < l = x > => x | < r = y > => y) else (fix (\x: Nat . ({a = (((\x: Nat .\y: Bool .x) (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) false) , b = ({a = false , b = true }.b) , c =  ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.b) ))))
(pred ({a = (let u = ({a = 0 , b = false }.a) in (let u = 0 in u)) , b = (unfold [ Unit ] (fold [ Unit ] (let u = ({a = (if false then false else false) , b = ({a = 1 , b = false }.b) }.b) in (if false then false else false)) )) }.a))
(fix (\x: Rec X. X . (let u = (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .y) true ) true) )) in (case <l = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) > as Nat of < l = x > => x | < r = y > => y)) ))
(let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) , b = (let u = false in u) }.b) ) ({a = 1 , b = ({a = 0 , b = false }.b) , c =  1 }.b)) ) (((\x: Rec X. X .\y: Bool .y) (unfold [ Bool ] (fold [ Unit ] ({a = false , b = 0 }.a) )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] true )) ))) ) ) (\a: Unit .\b: Nat .a)) in (( \f: Unit .((f (let u = false in (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b))) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Nat .a)))
({a = (( \f: Rec X. X .((f (case <l = (let u = 1 in 0) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . (pred (succ 1)) )) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Nat ] ({a = ({a = 0 , b = true }.b) , b = false }.b) )) ) ({a = (((\x: Rec X. X .\y: Nat .x) false ) true) , b = false }.b)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Rec X. X .b)) }.b)
({a = ({a = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .a)) }.a) , b = ({a = false , b = (((\x: Bool .\y: Unit .y) true ) false) }.b) }.a) , b = (let u = ({a = ({a = 1 , b = true }.b) , b = (fix (\x: Bool . 1 )) }.a) in u) , c =  (( \f: Nat .((f (let u = (((\x: Nat .\y: Nat .x) 0 ) true) in u) ) (((\x: Nat .\y: Bool .y) (unfold [ Unit ] (fold [ Nat ] (iszero 1) )) ) (if false then 1 else 0)) ) ) (\a: Bool .\b: Rec X. X .a)) }.b)
(((\x: Rec X. X .\y: Unit .x) (let u = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Rec X. X .x) false ) true) }.a) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (pred 1) ))) ) ({a = ({a = (iszero 1) , b = ({a = (let u = 1 in 1) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.a) }.b) , b = (let u = true in u) , c =  (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.b))
(if (iszero (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u)) then (let u = (((\x: Bool .\y: Nat .y) (let u = false in true) ) (let u = (((\x: Unit .\y: Rec X. X .y) false ) true) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )))) in (( \f: Rec X. X .((f (succ 0) ) (pred 0) ) ) (\a: Unit .\b: Nat .a))) else ({a = (let u = (((\x: Bool .\y: Bool .x) 0 ) false) in (((\x: Bool .\y: Rec X. X .y) true ) 1)) , b = ({a = (pred 0) , b = (pred ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 1 ))) }.b) }.b))
(if (((\x: Unit .\y: Unit .y) (case <r = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Unit .y) false ) 1) , b = (fix (\x: Unit . false )) }.b) )) ) (((\x: Rec X. X .\y: Unit .y) (fix (\x: Bool . false )) ) ({a = 1 , b = true , c =  1 }.b)) ) ) (\a: Unit .\b: Nat .b))) then (if ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (let u = true in u) in u) , c =  (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) then ({a = (if (((\x: Bool .\y: Unit .x) false ) false) then (let u = 0 in u) else (if false then 1 else 1)) , b = ({a = false , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.b) , c = ({a = 0 , b = 0 }.b) }.c) else (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 0 , b = false , c = 0 }.c) )))) else (let u = (succ 0) in u))
(( \f: Rec X. X .((f (fix (\x: Unit . (iszero 1) )) ) (((\x: Nat .\y: Rec X. X .x) (fix (\x: Bool . (if true then false else true) )) ) (( \f: Unit .((f ({a = false , b = 0 }.a) ) true ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Nat .\b: Nat .a))
(fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (let u = true in false) in ({a = true , b = true }.b)) )) ))
(let u = (let u = (let u = ({a = ({a = true , b = 1 }.b) , b = true , c =  (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b) in u) in (case <r = (if false then false else false) > as Unit of < l = x > => x | < r = y > => y)) in (case <r = (unfold [ Unit ] (fold [ Bool ] (((\x: Unit .\y: Rec X. X .y) (let u = 1 in ({a = 0 , b = true }.b)) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , c =  (fix (\x: Bool . 1 )) }.b)) )) > as Bool of < l = x > => x | < r = y > => y))
(fix (\x: Bool . ({a = (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Bool .x) ({a = true , b = false }.b) ) false) ) (unfold [ Unit ] (fold [ Nat ] false ))) , b = (let u = ({a = 0 , b = false , c = 0 }.c) in (((\x: Rec X. X .\y: Unit .y) (if false then false else true) ) false)) }.b) ))
(fix (\x: Nat . (case <l = (case <l = (fix (\x: Rec X. X . 1 )) > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ))
(case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (let u = (let u = 0 in false) in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) )) > as Bool of < l = x > => x | < r = y > => y)
((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Bool .((f (( \f: Nat .((f (let u = true in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) ) (fix (\x: Rec X. X . false )) ) ) (\a: Nat .\b: Bool .a)) ) ({a = false , b = (let u = 0 in u) }.a) ) ) (\a: Bool .\b: Unit .b)) ))
(succ (pred (( \f: Unit .((f 0 ) (let u = 1 in 1) ) ) (\a: Nat .\b: Unit .b))))
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (if (( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] true )) ) (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) true ) false) )) ) ) (\a: Unit .\b: Rec X. X .b)) then ({a = (let u = false in u) , b = ({a = 0 , b = true , c = 1 }.c) }.b) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (if true then 0 else 0) ))) ))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = (case <l = ({a = 1 , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) in (let u = 1 in false)) )) , b = ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in false) )) , b = ({a = 1 , b = false }.a) }.a) , b = (unfold [ Unit ] (fold [ Nat ] (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) )) }.b) }.b)
(((\x: Nat .\y: Rec X. X .y) (let u = ({a = ({a = false , b = true }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in 0) )) }.a) in (case <r = (case <r = (let u = true in (let u = true in false)) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)) ) (( \f: Bool .((f (let u = (let u = 0 in 0) in u) ) (if (let u = 0 in false) then (((\x: Rec X. X .\y: Unit .y) true ) 0) else 1) ) ) (\a: Bool .\b: Rec X. X .b)))
({a = (fix (\x: Unit . (( \f: Nat .((f (((\x: Unit .\y: Unit .x) 0 ) true) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = (let u = (let u = 0 in true) in u) }.a)
(((\x: Nat .\y: Rec X. X .x) (let u = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = 0 in 0)) in u) ) (fix (\x: Unit . (( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Bool .a)) )))
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = (let u = 0 in u) , b = (if true then true else true) , c =  ({a = 0 , b = 1 }.b) }.b) )) ))
({a = (let u = (( \f: Unit .((f (let u = 1 in 1) ) (fix (\x: Unit . 0 )) ) ) (\a: Bool .\b: Bool .a)) in ({a = (((\x: Nat .\y: Unit .x) (let u = 1 in 0) ) (let u = 0 in true)) , b = (if (( \f: Bool .((f (let u = 1 in true) ) false ) ) (\a: Unit .\b: Nat .b)) then (( \f: Rec X. X .((f (if true then true else true) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Bool .b)) else (case <r = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y)) }.b)) , b = ({a = (let u = (let u = 1 in false) in (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a))) , b = (if ({a = false , b = true }.b) then (pred 0) else (((\x: Nat .\y: Nat .x) ({a = 1 , b = 1 }.b) ) false)) }.b) }.a)
(((\x: Bool .\y: Bool .y) (iszero (((\x: Rec X. X .\y: Nat .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) (((\x: Nat .\y: Rec X. X .y) false ) 0))) ) (case <l = (( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) ) (((\x: Bool .\y: Bool .y) true ) 0) ) ) (\a: Rec X. X .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y))
(unfold [ Nat ] (fold [ Bool ] ({a = ({a = ({a = 1 , b = false }.a) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , c =  (pred 0) }.b) , b = (((\x: Unit .\y: Nat .x) (pred (let u = true in 0)) ) (((\x: Bool .\y: Rec X. X .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) ) ({a = 1 , b = false , c =  0 }.b))) }.b) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] ({a = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .a)) , b = (let u = true in u) }.b) )) ) (let u = (let u = 1 in true) in u) ) ) (\a: Bool .\b: Nat .a)) ))
(case <l = (fix (\x: Unit . (let u = ({a = ({a = 0 , b = 0 }.b) , b = (let u = 0 in false) , c = 0 }.c) in (succ 1)) )) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (succ (( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] 1 )) ) (succ 1) ) ) (\a: Bool .\b: Rec X. X .b))) ))
(case <l = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Bool .((f (if true then 1 else 0) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Unit .a)) )) in (let u = (let u = 1 in 0) in 0)) > as Bool of < l = x > => x | < r = y > => y)
(let u = (if (fix (\x: Bool . false )) then (case <l = ({a = true , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) else (if (case <r = (let u = false in false) > as Nat of < l = x > => x | < r = y > => y) then (fix (\x: Rec X. X . 1 )) else (let u = 0 in u))) in (((\x: Unit .\y: Nat .y) (unfold [ Bool ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) )) ) (fix (\x: Bool . (pred (let u = false in 1)) ))))
({a = (fix (\x: Unit . (case <l = (( \f: Unit .((f 0 ) (((\x: Unit .\y: Rec X. X .y) true ) 1) ) ) (\a: Bool .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y) )) , b = (( \f: Nat .((f (unfold [ Bool ] (fold [ Unit ] (((\x: Bool .\y: Bool .y) (iszero 1) ) false) )) ) (fix (\x: Rec X. X . true )) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (if false then 0 else 1) )) in u) }.b)
(( \f: Nat .((f (iszero (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) ) ({a = (if ({a = (((\x: Bool .\y: Unit .x) true ) true) , b = (iszero 1) }.b) then ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) else ({a = (if (if false then false else true) then (((\x: Unit .\y: Rec X. X .x) false ) false) else true) , b = (unfold [ Unit ] (fold [ Unit ] true )) }.b)) , b = ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = (fix (\x: Unit . (( \f: Rec X. X .((f ({a = false , b = true }.b) ) (((\x: Nat .\y: Bool .y) true ) true) ) ) (\a: Unit .\b: Bool .b)) )) }.b) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
(( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) (case <r = (( \f: Unit .((f ({a = 0 , b = false , c =  1 }.b) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) ) (let u = 1 in (case <r = true > as Unit of < l = x > => x | < r = y > => y))) ) (((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] true )) )) ) (((\x: Nat .\y: Nat .y) (if false then false else true) ) true)) ) ) (\a: Unit .\b: Bool .b))
(iszero (( \f: Nat .((f (pred 0) ) (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ) (if true then 0 else 0) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .b)))
({a = (fix (\x: Unit . (fix (\x: Unit . ({a = (fix (\x: Rec X. X . 0 )) , b = (( \f: Rec X. X .((f true ) (if true then false else false) ) ) (\a: Bool .\b: Unit .a)) }.a) )) )) , b = (let u = ({a = (let u = 1 in 0) , b = (((\x: Bool .\y: Rec X. X .y) (let u = 0 in false) ) (unfold [ Bool ] (fold [ Nat ] false ))) }.a) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.b) ))) }.b)
({a = (pred (((\x: Bool .\y: Rec X. X .y) (fix (\x: Bool . ({a = false , b = true }.b) )) ) (( \f: Unit .((f 0 ) (if false then 1 else 1) ) ) (\a: Nat .\b: Nat .a)))) , b = ({a = (let u = ({a = (pred 0) , b = (let u = true in true) , c = (let u = false in 1) }.c) in (let u = 0 in true)) , b = (let u = (fix (\x: Unit . (let u = 1 in u) )) in (let u = (succ 0) in u)) }.a) }.b)
(case <l = ({a = ({a = (( \f: Nat .((f (( \f: Nat .((f (if true then 1 else 0) ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) , b = (( \f: Bool .((f (let u = false in u) ) true ) ) (\a: Unit .\b: Nat .b)) }.a) , b = ({a = (if (iszero 1) then ({a = false , b = 1 }.b) else 1) , b = (pred 1) }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (((\x: Unit .\y: Unit .y) (iszero (pred (succ 1))) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) }.a)) , b = (if (unfold [ Nat ] (fold [ Bool ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) then (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] false )) )) else (fix (\x: Rec X. X . (((\x: Unit .\y: Unit .y) true ) true) ))) }.a)
(((\x: Rec X. X .\y: Rec X. X .x) (if (( \f: Bool .((f true ) (fix (\x: Rec X. X . false )) ) ) (\a: Unit .\b: Bool .a)) then (case <r = ({a = false , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = ({a = 0 , b = true }.a) in false)) ) (iszero (pred 0)))
(iszero (unfold [ Nat ] (fold [ Nat ] (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) in (if false then 0 else 1)) )))
(case <l = (( \f: Bool .((f ({a = (pred (let u = 0 in u)) , b = ({a = 0 , b = ({a = false , b = 1 }.a) , c =  (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) , c = (let u = ({a = 1 , b = false }.b) in 0) }.c) ) (succ (succ 0)) ) ) (\a: Bool .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (( \f: Nat .((f ({a = ({a = (pred 1) , b = ({a = 1 , b = true , c =  0 }.b) , c =  (let u = (let u = 1 in u) in (let u = 0 in 1)) }.b) , b = (let u = (((\x: Unit .\y: Bool .y) false ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b))) in ({a = (((\x: Rec X. X .\y: Nat .y) false ) 0) , b = (let u = true in false) }.b)) }.b) ) (let u = (( \f: Bool .((f ({a = 1 , b = false }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)) in ({a = (fix (\x: Rec X. X . true )) , b = 0 }.a)) ) ) (\a: Bool .\b: Rec X. X .b)) ))
(case <r = (unfold [ Bool ] (fold [ Unit ] ({a = (let u = false in u) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in u) }.a) }.a) )) > as Nat of < l = x > => x | < r = y > => y)
(unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = 1 , b = false }.a) , b = (unfold [ Unit ] (fold [ Bool ] (if false then false else true) )) }.a) ))
(((\x: Nat .\y: Rec X. X .x) ({a = (case <r = (((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Unit .x) false ) false) ) (((\x: Nat .\y: Bool .x) false ) true)) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = 0 , b = false , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.c) in u) }.a) ) (fix (\x: Bool . (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in u) )))
(( \f: Bool .((f (((\x: Unit .\y: Rec X. X .x) (fix (\x: Nat . (let u = true in u) )) ) (let u = (let u = false in u) in u)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (if false then (fix (\x: Nat . true )) else false) )) ) ) (\a: Unit .\b: Rec X. X .b))
(( \f: Rec X. X .((f (iszero (pred (( \f: Bool .((f (fix (\x: Bool . 0 )) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)))) ) (let u = (((\x: Nat .\y: Rec X. X .y) ({a = 1 , b = true }.b) ) (( \f: Unit .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b))) in u) ) ) (\a: Unit .\b: Bool .b))
(case <l = (( \f: Bool .((f (( \f: Unit .((f (((\x: Nat .\y: Bool .y) (if true then true else true) ) 1) ) (((\x: Unit .\y: Unit .x) 0 ) true) ) ) (\a: Bool .\b: Bool .a)) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Unit .((f ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (((\x: Unit .\y: Rec X. X .y) true ) false) , c = (unfold [ Rec X. X ] (fold [ Nat ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) }.c) ) ({a = (let u = true in 0) , b = (((\x: Rec X. X .\y: Unit .x) (iszero 1) ) (((\x: Nat .\y: Nat .y) true ) true)) , c = ({a = (if false then true else false) , b = (let u = 0 in u) }.b) }.c) ) ) (\a: Rec X. X .\b: Nat .b))
(( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) ({a = false , b = true }.b) ) (((\x: Nat .\y: Unit .y) true ) ({a = 1 , b = true }.b))) )) ) ({a = ({a = (((\x: Bool .\y: Bool .x) true ) true) , b = (case <l = ({a = true , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ({a = 0 , b = true , c =  (pred 0) }.b) , c =  (((\x: Nat .\y: Nat .x) (unfold [ Bool ] (fold [ Nat ] 1 )) ) ({a = 1 , b = false , c =  0 }.b)) }.b) ) ) (\a: Unit .\b: Rec X. X .a))
({a = (if ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .a)) }.b) then ({a = ({a = 1 , b = 0 }.b) , b = (((\x: Unit .\y: Nat .y) true ) true) , c = (( \f: Rec X. X .((f 0 ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Bool .\b: Nat .b)) }.c) else (unfold [ Bool ] (fold [ Nat ] 0 ))) , b = (case <r = (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) true ) false) )) > as Unit of < l = x > => x | < r = y > => y) }.b)
(let u = (((\x: Bool .\y: Bool .y) (( \f: Unit .((f (((\x: Nat .\y: Nat .y) false ) false) ) false ) ) (\a: Unit .\b: Unit .a)) ) ({a = (((\x: Nat .\y: Bool .x) 1 ) false) , b = (if false then true else false) }.b)) in u)
(let u = (unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = (if false then 1 else 1) , b = (if (fix (\x: Nat . false )) then (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) else (let u = 0 in u)) }.b) in (let u = (((\x: Bool .\y: Rec X. X .y) ({a = false , b = 0 }.a) ) (unfold [ Unit ] (fold [ Nat ] 1 ))) in u)) )) in u)
({a = ({a = ({a = ({a = 1 , b = true , c = 1 }.c) , b = (((\x: Nat .\y: Nat .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) false) }.a) , b = (fix (\x: Nat . (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Rec X. X .b)) )) , c =  (((\x: Unit .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) ) (fix (\x: Unit . true ))) }.b) , b = (if ({a = (let u = true in u) , b = ({a = true , b = 0 }.b) }.a) then (let u = (if true then 0 else 1) in 0) else (((\x: Bool .\y: Unit .x) 1 ) true)) }.b)
({a = ({a = ({a = (if true then (pred 1) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) , b = (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false )) )) , c =  (let u = true in ({a = 0 , b = true }.a)) }.b) , b = ({a = ({a = true , b = ({a = 1 , b = true }.b) }.b) , b = (let u = 1 in u) }.b) }.b) , b = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) ({a = (let u = 1 in true) , b = (iszero 1) }.b) ) ({a = (if (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) then ({a = 0 , b = false , c =  1 }.b) else ({a = false , b = 1 }.a)) , b = (((\x: Unit .\y: Nat .y) true ) false) }.b)) )) , c = (pred (let u = (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) true ) 1) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) in u)) }.c)
({a = (succ (((\x: Nat .\y: Rec X. X .x) 0 ) true)) , b = (fix (\x: Rec X. X . (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) )) }.b)
(let u = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred (fix (\x: Rec X. X . 1 ))) )) in u) in (case <l = (((\x: Unit .\y: Nat .x) (( \f: Rec X. X .((f (pred 0) ) (if false then 1 else 0) ) ) (\a: Bool .\b: Unit .a)) ) (let u = (if true then false else true) in u)) > as Nat of < l = x > => x | < r = y > => y))
(if (iszero ({a = (let u = 0 in u) , b = (fix (\x: Unit . false )) }.a)) then (( \f: Unit .((f ({a = true , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) ) ({a = false , b = (let u = false in u) }.b) ) ) (\a: Bool .\b: Nat .b)) else ({a = (let u = (((\x: Rec X. X .\y: Unit .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) ) (((\x: Unit .\y: Rec X. X .x) true ) false)) in u) , b = (let u = (succ 1) in ({a = true , b = (succ 1) }.a)) }.b))
(if (iszero (pred ({a = true , b = 0 }.b))) then ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Unit .((f (( \f: Nat .((f ({a = true , b = 1 }.b) ) (fix (\x: Bool . 1 )) ) ) (\a: Bool .\b: Unit .b)) ) (((\x: Nat .\y: Rec X. X .x) 1 ) false) ) ) (\a: Rec X. X .\b: Unit .b)) )) else (pred (fix (\x: Bool . (let u = 0 in 0) ))))
(((\x: Bool .\y: Rec X. X .x) (fix (\x: Rec X. X . (( \f: Nat .((f (((\x: Nat .\y: Nat .x) false ) ({a = false , b = true }.b)) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ({a = ({a = ({a = 0 , b = 0 }.b) , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .a)) ) (let u = false in true) ) ) (\a: Bool .\b: Unit .a)) )) }.b))
(let u = (((\x: Rec X. X .\y: Nat .x) ({a = 0 , b = true , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = true in u) ))) in u)
(let u = ({a = ({a = (let u = false in ({a = true , b = true }.b)) , b = ({a = true , b = 0 }.a) }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (fix (\x: Unit . false )) in (pred 1)) )) }.b) in ({a = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] true )) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (iszero (if true then 0 else 0)) }.b))
(let u = ({a = ({a = (((\x: Nat .\y: Rec X. X .y) true ) false) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.a) , b = (let u = ({a = 1 , b = 0 }.b) in (let u = 1 in u)) }.b) in u)
(succ (let u = (( \f: Unit .((f ({a = 1 , b = true }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)))
({a = (let u = ({a = (let u = true in false) , b = ({a = 0 , b = true }.a) }.a) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = (fix (\x: Rec X. X . 0 )) , b = false , c = 0 }.c) in ({a = 1 , b = true , c =  (let u = true in 1) }.b)) ))) , b = ({a = (fix (\x: Unit . (((\x: Unit .\y: Bool .y) false ) ({a = false , b = 0 }.a)) )) , b = ({a = (if true then 1 else 0) , b = false }.b) }.b) }.b)
(( \f: Bool .((f (( \f: Rec X. X .((f ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = (((\x: Nat .\y: Bool .x) 0 ) false) }.a) ) (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f false ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) )) ) ) (\a: Unit .\b: Bool .b)) ) (( \f: Bool .((f ({a = false , b = (if true then 1 else 0) }.a) ) (if (unfold [ Rec X. X ] (fold [ Unit ] false )) then ({a = true , b = 0 }.a) else (let u = true in false)) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Unit .b))
(let u = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (succ (fix (\x: Nat . 0 ))) )) , b = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .a)) }.a) in (case <l = (pred 0) > as Rec X. X of < l = x > => x | < r = y > => y))
(((\x: Rec X. X .\y: Unit .y) ({a = (unfold [ Unit ] (fold [ Bool ] ({a = (( \f: Unit .((f ({a = true , b = 0 }.a) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.a) )) , b = (let u = (if true then false else true) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 ))) }.a) ) (let u = (( \f: Unit .((f (( \f: Unit .((f (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) (((\x: Bool .\y: Unit .y) false ) 0) ) ) (\a: Bool .\b: Bool .b)) ) ({a = 0 , b = 1 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) in (( \f: Rec X. X .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in true) ) true) ) ) (\a: Bool .\b: Bool .a))))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (let u = (((\x: Unit .\y: Unit .x) (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Unit . true )) )) ) (iszero 1)) in u) in u) ))
(let u = (fix (\x: Unit . (let u = (((\x: Bool .\y: Rec X. X .y) true ) true) in ({a = false , b = false }.b)) )) in u)
(if (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = (unfold [ Bool ] (fold [ Bool ] (let u = 1 in u) )) }.b) )) in ({a = ({a = (((\x: Rec X. X .\y: Unit .x) 1 ) false) , b = false }.a) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = 1 in false) )) }.b)) then ({a = (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .x) (let u = true in u) ) (iszero 0)) ) (if false then true else false) ) ) (\a: Bool .\b: Unit .a)) , b = (( \f: Rec X. X .((f (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (fix (\x: Bool . true )) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) else (if (( \f: Nat .((f (let u = ({a = true , b = false }.b) in true) ) (let u = 0 in false) ) ) (\a: Unit .\b: Bool .b)) then (((\x: Unit .\y: Nat .y) true ) false) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = (succ 0) , b = false }.b) ))))
(((\x: Unit .\y: Unit .y) (case <r = (let u = (fix (\x: Rec X. X . (if false then ({a = 0 , b = true , c = 1 }.c) else 0) )) in ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = 1 }.b) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (let u = false in u) in u))
(((\x: Rec X. X .\y: Nat .y) (iszero ({a = (fix (\x: Nat . 0 )) , b = ({a = 1 , b = false , c =  1 }.b) , c = (pred 1) }.c)) ) (let u = (pred (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a))) in u))
(case <r = (if (case <r = ({a = false , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) then ({a = (((\x: Nat .\y: Nat .y) false ) false) , b = true }.b) else (((\x: Nat .\y: Rec X. X .x) ({a = 1 , b = true , c =  (((\x: Rec X. X .\y: Nat .x) 1 ) true) }.b) ) (let u = true in u))) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Nat .((f ({a = (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) (((\x: Bool .\y: Unit .y) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) 0)) , b = (fix (\x: Rec X. X . true )) }.b) ) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) )) , b = ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Nat .\y: Unit .x) ({a = 1 , b = false }.b) ) false) }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (((\x: Unit .\y: Unit .y) ({a = ({a = ({a = 1 , b = 0 }.b) , b = 1 }.b) , b = (((\x: Nat .\y: Rec X. X .x) true ) true) , c =  ({a = 0 , b = true }.a) }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ))) , b = (( \f: Bool .((f ({a = ({a = true , b = 1 }.a) , b = (let u = false in false) }.b) ) (( \f: Bool .((f (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .a)) , c = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = (iszero (if (iszero 1) then 1 else ({a = 0 , b = 1 }.b))) , b = (( \f: Rec X. X .((f (succ 1) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) )) }.c)
(let u = (( \f: Unit .((f (if ({a = (let u = ({a = true , b = 1 }.b) in 0) , b = ({a = 0 , b = true , c =  0 }.b) , c =  ({a = 1 , b = 0 }.b) }.b) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) )) else ({a = 1 , b = (if false then true else true) }.b)) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = 0 , b = ({a = 0 , b = false , c =  1 }.b) }.b) , b = ({a = 1 , b = true , c =  1 }.b) }.b) )) ) ) (\a: Bool .\b: Rec X. X .b)) in u)
(((\x: Rec X. X .\y: Bool .x) ({a = ({a = ({a = 0 , b = false }.b) , b = (pred 0) }.b) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = true , b = false }.b) )) }.a) ) (( \f: Rec X. X .((f (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = 1 , b = 1 }.b) , b = false , c =  (((\x: Rec X. X .\y: Nat .y) false ) 0) }.b) )) ) ) (\a: Nat .\b: Nat .b)))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if true then 0 else 0) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) ) (let u = true in u)) , b = (let u = (unfold [ Nat ] (fold [ Bool ] 0 )) in (pred 0)) }.b) ) ) (\a: Rec X. X .\b: Nat .a)) ))
(( \f: Unit .((f (let u = (( \f: Bool .((f (( \f: Nat .((f (iszero 1) ) ({a = 1 , b = true }.b) ) ) (\a: Rec X. X .\b: Unit .a)) ) (((\x: Bool .\y: Nat .y) ({a = true , b = 0 }.a) ) true) ) ) (\a: Nat .\b: Bool .a)) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = (fix (\x: Unit . ({a = 1 , b = 1 }.b) )) in (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)))) )) ) ) (\a: Bool .\b: Unit .b))
(pred (let u = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (if false then true else false) , c = (succ 0) }.c) in (let u = 1 in 0)))
(iszero ({a = (( \f: Unit .((f (fix (\x: Unit . 0 )) ) (succ 0) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Bool .((f (((\x: Nat .\y: Unit .y) (unfold [ Unit ] (fold [ Bool ] true )) ) (if false then true else false)) ) ({a = false , b = true }.b) ) ) (\a: Nat .\b: Bool .b)) }.a))
({a = ({a = (succ (unfold [ Bool ] (fold [ Unit ] 0 ))) , b = (let u = ({a = 1 , b = true , c =  0 }.b) in (fix (\x: Bool . false ))) , c =  (succ ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) }.a)) }.b) , b = (( \f: Rec X. X .((f ({a = (( \f: Bool .((f ({a = false , b = 0 }.b) ) (((\x: Bool .\y: Nat .x) 1 ) false) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (case <r = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (if (((\x: Nat .\y: Bool .x) true ) true) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) else (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b))) }.c) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 1 in 0) )) ) ) (\a: Nat .\b: Rec X. X .a)) }.b)
(( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = true }.b) ) 0) )) )) ) (let u = (pred (((\x: Bool .\y: Rec X. X .x) (if true then 0 else 1) ) (unfold [ Unit ] (fold [ Rec X. X ] true )))) in ({a = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) , b = (((\x: Nat .\y: Unit .y) false ) true) }.b) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b)) ) ) (\a: Bool .\b: Bool .b))
(((\x: Nat .\y: Nat .y) (let u = (fix (\x: Unit . (((\x: Bool .\y: Bool .y) ({a = false , b = true }.b) ) false) )) in ({a = (iszero ({a = 1 , b = false , c = 1 }.c)) , b = (pred 0) }.a)) ) (case <r = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) > as Unit of < l = x > => x | < r = y > => y))
(let u = ({a = (let u = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then 0 else (((\x: Nat .\y: Unit .y) true ) 0)) in u) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) )) ) (( \f: Unit .((f (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ) (( \f: Rec X. X .((f ({a = 1 , b = false , c = 0 }.c) ) (let u = 1 in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .b)) }.b) in (let u = (if (let u = 1 in false) then (let u = 0 in u) else (succ 0)) in ({a = (pred 0) , b = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) }.b)))
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Bool . (if ({a = 1 , b = true }.b) then (pred 1) else ({a = (let u = true in 1) , b = true }.a)) )) ))
(( \f: Bool .((f ({a = ({a = (( \f: Nat .((f 1 ) (let u = 1 in 1) ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) false ) false) ) 1) }.b) , b = ({a = (if true then true else true) , b = (if (((\x: Nat .\y: Unit .x) true ) true) then false else ({a = 1 , b = true }.b)) }.b) }.b) ) (( \f: Unit .((f (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) ) (iszero 1)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Nat .a)) ) (((\x: Rec X. X .\y: Nat .y) (unfold [ Unit ] (fold [ Bool ] true )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false ))) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Bool .a))
({a = (( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Rec X. X .x) false ) true) ) ({a = 0 , b = true }.b)) )) ) (let u = ({a = ({a = false , b = 0 }.a) , b = (iszero 1) }.b) in u) ) ) (\a: Bool .\b: Unit .b)) , b = (((\x: Nat .\y: Bool .x) (fix (\x: Unit . (if false then ({a = 0 , b = false }.b) else true) )) ) ({a = (let u = 1 in u) , b = ({a = 1 , b = true }.b) }.b)) }.b)
(iszero (pred (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false )) in (let u = 0 in u))))
(((\x: Bool .\y: Unit .y) (let u = ({a = 1 , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) in ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = (case <l = (let u = 1 in u) > as Nat of < l = x > => x | < r = y > => y) }.a)) ) (let u = (let u = (fix (\x: Unit . 0 )) in (( \f: Nat .((f (fix (\x: Nat . true )) ) true ) ) (\a: Nat .\b: Rec X. X .a))) in u))
(( \f: Unit .((f (((\x: Nat .\y: Bool .y) (case <r = (fix (\x: Rec X. X . true )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Rec X. X ] (iszero 1) ))) ) (if (((\x: Bool .\y: Unit .y) false ) false) then (case <r = (((\x: Bool .\y: Rec X. X .x) true ) false) > as Unit of < l = x > => x | < r = y > => y) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .b)) ))) ) ) (\a: Bool .\b: Bool .b))
(((\x: Unit .\y: Bool .x) (let u = (if (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .a)) then ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = ({a = 1 , b = true , c =  1 }.b) , c =  1 }.b) else (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .a))) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = false , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) }.b) ))) ) (( \f: Bool .((f ({a = (if false then 1 else 1) , b = ({a = 1 , b = false }.b) , c =  (((\x: Bool .\y: Bool .y) true ) 1) }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = false in true) )) ) ) (\a: Rec X. X .\b: Bool .b)))
(if (unfold [ Unit ] (fold [ Unit ] ({a = (fix (\x: Bool . 0 )) , b = ({a = 1 , b = true , c =  1 }.b) , c =  1 }.b) )) then (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) (if true then 0 else 1)) ) ({a = (let u = (pred 0) in u) , b = (let u = 0 in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false ))) , c = (let u = 1 in u) }.c) ) ) (\a: Rec X. X .\b: Unit .a)) else (let u = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) (if ({a = 1 , b = false }.b) then ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) else (succ 1)) ) ) (\a: Nat .\b: Unit .a)) in (pred ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = 0 }.b))))
(( \f: Rec X. X .((f (((\x: Unit .\y: Bool .y) (case <r = (unfold [ Rec X. X ] (fold [ Unit ] false )) > as Unit of < l = x > => x | < r = y > => y) ) (pred ({a = 0 , b = true , c = 1 }.c))) ) ({a = ({a = (let u = ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (if false then true else true) , c =  (pred 0) }.b) in (fix (\x: Bool . (case <r = false > as Unit of < l = x > => x | < r = y > => y) ))) , b = (((\x: Unit .\y: Nat .y) ({a = 0 , b = ({a = false , b = true }.b) , c =  0 }.b) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a))) }.b) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Unit .x) false ) true) }.b) , c = (let u = (fix (\x: Nat . (succ 0) )) in (pred 1)) }.c) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = ({a = ({a = ({a = true , b = 0 }.b) , b = (iszero 1) }.b) , b = (pred (pred 1)) }.a) in u)
(( \f: Nat .((f (((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Bool .x) ({a = false , b = true }.b) ) (case <r = ({a = 0 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y)) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) (let u = 0 in false)) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b))) ) (if (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = (fix (\x: Unit . true )) , c =  (if false then 0 else 0) }.b) )) then (unfold [ Unit ] (fold [ Nat ] (let u = true in false) )) else (( \f: Bool .((f (fix (\x: Bool . true )) ) (let u = ({a = (let u = true in false) , b = (fix (\x: Rec X. X . 0 )) }.a) in ({a = 1 , b = true , c =  0 }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Nat .b))
(if (((\x: Nat .\y: Bool .y) (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] false )) ) (let u = (let u = false in 0) in true) ) ) (\a: Nat .\b: Rec X. X .a)) ) (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .b)) )) > as Unit of < l = x > => x | < r = y > => y)) then (((\x: Bool .\y: Unit .x) (let u = (pred 0) in (fix (\x: Unit . 0 ))) ) (((\x: Bool .\y: Nat .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) (if true then true else false))) else (((\x: Bool .\y: Nat .x) ({a = (fix (\x: Unit . ({a = 1 , b = 0 }.b) )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) , c = ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = (let u = false in 1) }.b) }.c) ) (fix (\x: Nat . (if ({a = ({a = 0 , b = 1 }.b) , b = false }.b) then (let u = 1 in (fix (\x: Bool . false ))) else (let u = 0 in false)) ))))
(if (let u = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) (if true then 1 else 0) ) ) (\a: Unit .\b: Unit .b)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ))) then ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) in (iszero 1)) )) else (( \f: Rec X. X .((f ({a = ({a = true , b = 0 }.a) , b = ({a = 1 , b = 0 }.b) }.a) ) ({a = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (iszero 1) )) }.b) ) ) (\a: Rec X. X .\b: Nat .b)))
(case <l = (pred (let u = (if true then (if false then 1 else 0) else 0) in (if false then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else 1))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = (iszero (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f ({a = 0 , b = false , c = 1 }.c) ) (let u = 0 in u) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) in u)
(unfold [ Nat ] (fold [ Nat ] ({a = (succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 ))) , b = ({a = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) in u) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.b) }.b) ))
(unfold [ Bool ] (fold [ Rec X. X ] ({a = (((\x: Bool .\y: Nat .x) (if false then false else true) ) ({a = 1 , b = true }.b)) , b = (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) }.a) ) (let u = false in u)) }.a) ))
(case <l = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (if (if true then true else false) then (succ 0) else ({a = (unfold [ Unit ] (fold [ Unit ] false )) , b = 0 }.b)) )) > as Nat of < l = x > => x | < r = y > => y)
(let u = (((\x: Nat .\y: Bool .y) ({a = (let u = false in 1) , b = (let u = true in u) }.b) ) ({a = true , b = 1 }.a)) in (( \f: Nat .((f ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Unit .((f true ) (unfold [ Nat ] (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Unit .a)) }.a) ) (succ 0) ) ) (\a: Bool .\b: Rec X. X .a)))
(fix (\x: Unit . (succ (fix (\x: Nat . (pred 1) ))) ))
({a = ({a = (pred (fix (\x: Bool . 1 ))) , b = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Rec X. X .((f ({a = 0 , b = true , c =  1 }.b) ) (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Unit .\b: Nat .a)) ) ({a = (let u = ({a = 0 , b = 0 }.b) in (let u = true in u)) , b = (let u = false in u) }.b)) }.a) , b = ({a = (let u = (case <r = (fix (\x: Rec X. X . (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) > as Nat of < l = x > => x | < r = y > => y) in (unfold [ Nat ] (fold [ Nat ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ))) , b = (let u = ({a = true , b = true }.b) in u) , c =  (succ (( \f: Nat .((f (let u = 1 in u) ) 1 ) ) (\a: Unit .\b: Bool .b))) }.b) }.b)
(case <l = (unfold [ Unit ] (fold [ Rec X. X ] (if (unfold [ Nat ] (fold [ Unit ] false )) then (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) else (if ({a = false , b = 0 }.a) then (((\x: Unit .\y: Unit .x) 1 ) true) else 1)) )) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (let u = (((\x: Bool .\y: Nat .x) (let u = (if true then 0 else 1) in ({a = 0 , b = true , c = 0 }.c)) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) in (( \f: Rec X. X .((f (let u = 1 in ({a = false , b = 0 }.a)) ) ({a = 0 , b = true }.b) ) ) (\a: Bool .\b: Bool .a))) ) (( \f: Nat .((f (fix (\x: Nat . (if false then true else false) )) ) (let u = 1 in (((\x: Bool .\y: Unit .y) false ) false)) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Bool .\b: Bool .b))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (let u = true in u) , c =  ({a = 0 , b = (((\x: Nat .\y: Rec X. X .x) false ) true) , c = 0 }.c) }.b) ) (((\x: Nat .\y: Unit .x) ({a = true , b = 0 }.b) ) true)) ) ({a = ({a = ({a = ({a = 1 , b = (if false then false else false) }.a) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a)) }.a) , b = (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) false ) 1) ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) , b = ({a = (if false then true else true) , b = (fix (\x: Nat . (let u = false in 1) )) }.b) }.b) ) ) (\a: Nat .\b: Unit .b))
(let u = ({a = ({a = (fix (\x: Unit . false )) , b = ({a = false , b = 0 }.b) }.a) , b = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Unit . 1 )) )) }.b) in ({a = (let u = ({a = 1 , b = true }.a) in (fix (\x: Nat . false ))) , b = (let u = (iszero 0) in (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y))) }.b))
(fix (\x: Nat . (iszero (let u = false in ({a = true , b = 1 }.b))) ))
(unfold [ Bool ] (fold [ Unit ] (fix (\x: Bool . (((\x: Unit .\y: Nat .y) ({a = 1 , b = false , c =  1 }.b) ) (unfold [ Unit ] (fold [ Bool ] (let u = 0 in 0) ))) )) ))
(let u = ({a = (succ 1) , b = (((\x: Nat .\y: Rec X. X .x) (let u = true in false) ) (((\x: Unit .\y: Bool .x) (let u = false in u) ) false)) }.a) in (if (((\x: Bool .\y: Rec X. X .x) (let u = false in u) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .b))) then ({a = (iszero (let u = 0 in 0)) , b = (let u = 1 in u) }.a) else (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = true }.b) ) true) in (if false then (((\x: Unit .\y: Rec X. X .x) true ) false) else false))))
(fix (\x: Rec X. X . (( \f: Rec X. X .((f ({a = true , b = 0 }.b) ) (succ (let u = 0 in 0)) ) ) (\a: Nat .\b: Rec X. X .a)) ))
(fix (\x: Unit . (if ({a = (succ 0) , b = (( \f: Unit .((f false ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Unit .b)) }.b) then (unfold [ Rec X. X ] (fold [ Bool ] 1 )) else (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = 1 in 0) )) in (let u = 0 in 1))) ))
(let u = (if (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Nat ] true )) )) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = (succ 0) , b = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) }.b) )) else (fix (\x: Unit . (let u = (let u = false in 1) in 0) ))) in (case <r = (case <r = (case <r = false > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (fix (\x: Bool . (case <l = (( \f: Unit .((f 1 ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) )) in (unfold [ Nat ] (fold [ Rec X. X ] ({a = (iszero 1) , b = ({a = 1 , b = true }.b) }.b) )))
(( \f: Nat .((f (((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Bool .x) ({a = (let u = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .a)) in ({a = 0 , b = false , c =  0 }.b)) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in u) ))) ) (((\x: Nat .\y: Nat .y) (iszero 0) ) (((\x: Nat .\y: Rec X. X .y) false ) (let u = false in u)))) ) (( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] (let u = 0 in u) )) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 1 in (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a))) )) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Nat .\b: Unit .b))
(let u = (let u = (if (((\x: Bool .\y: Rec X. X .x) false ) (iszero 1)) then (succ (if true then 1 else 1)) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 ))) in (( \f: Unit .((f (((\x: Bool .\y: Bool .x) (let u = false in false) ) (let u = 0 in true)) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (iszero 1) )) ) ) (\a: Unit .\b: Rec X. X .b))) in u)
({a = ({a = (( \f: Bool .((f (iszero 0) ) (( \f: Bool .((f false ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (let u = ({a = 1 , b = true }.b) in (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a))) }.a) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = (((\x: Nat .\y: Unit .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ) ({a = true , b = 0 }.a)) , b = (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .y) false ) 1) )) }.b) )) }.a)
(case <r = (let u = (iszero (let u = 0 in 0)) in ({a = (if true then (let u = 0 in 1) else (pred 1)) , b = (if false then true else true) }.b)) > as Nat of < l = x > => x | < r = y > => y)
({a = (((\x: Nat .\y: Bool .x) (let u = (( \f: Rec X. X .((f false ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Bool .b)) in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) ({a = ({a = (if true then 0 else 1) , b = (fix (\x: Rec X. X . false )) , c = (((\x: Bool .\y: Bool .x) 1 ) true) }.c) , b = ({a = false , b = 0 }.a) , c =  ({a = (((\x: Nat .\y: Nat .x) (fix (\x: Nat . 0 )) ) (fix (\x: Nat . false ))) , b = (((\x: Bool .\y: Bool .y) false ) true) , c = (succ ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) }.c) }.b)) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (fix (\x: Bool . 0 )) , b = ({a = false , b = 0 }.a) , c = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.c) )) }.a)
(( \f: Bool .((f (let u = (( \f: Rec X. X .((f (pred 0) ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) in (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) ) (let u = (case <l = ({a = (unfold [ Unit ] (fold [ Unit ] 1 )) , b = false , c = 1 }.c) > as Nat of < l = x > => x | < r = y > => y) in u) ) ) (\a: Rec X. X .\b: Unit .a))
({a = ({a = (pred 1) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .b)) , c = (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) }.c) , b = (let u = ({a = (let u = 0 in 0) , b = true }.a) in u) }.b)
(let u = (let u = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = false in u) )) in u) in (succ ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )))) in (let u = (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) 0 ) false) ) (if true then 0 else 0) ) ) (\a: Nat .\b: Rec X. X .b)) in u))
(( \f: Bool .((f (fix (\x: Rec X. X . (let u = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a)) in u) )) ) ({a = (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) ) false ) ) (\a: Bool .\b: Nat .a)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Nat .((f 0 ) (succ 1) ) ) (\a: Unit .\b: Rec X. X .a)) )) }.a) ) ) (\a: Unit .\b: Bool .b))
(let u = (iszero (if (let u = (let u = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) in false) in (iszero (if true then 1 else 1))) then ({a = ({a = 1 , b = true }.b) , b = (let u = 0 in u) }.b) else (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if ({a = 1 , b = true }.b) then (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) else ({a = false , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b)) )))
(let u = ({a = ({a = (let u = true in 1) , b = (case <r = (((\x: Nat .\y: Bool .x) true ) false) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ({a = ({a = true , b = 0 }.b) , b = ({a = 1 , b = false }.b) }.b) }.b) in (fix (\x: Rec X. X . (( \f: Rec X. X .((f false ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) ) (\a: Unit .\b: Rec X. X .b)) )))
(( \f: Nat .((f (( \f: Bool .((f (fix (\x: Unit . (let u = false in false) )) ) ({a = (let u = 1 in false) , b = (let u = 1 in u) }.a) ) ) (\a: Unit .\b: Unit .a)) ) ({a = (unfold [ Bool ] (fold [ Nat ] (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 ))) )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Nat .\y: Bool .y) true ) false) )) , c =  (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) )) }.b) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Bool .y) true ) ({a = 0 , b = false }.a)) ) ({a = (if false then 0 else 1) , b = ({a = (let u = true in 1) , b = ({a = false , b = true }.b) , c =  (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) , c =  (pred 0) }.b)) , b = (let u = (fix (\x: Rec X. X . (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .a)) )) in ({a = (( \f: Rec X. X .((f ({a = true , b = ({a = 0 , b = true }.a) }.b) ) ({a = (succ 1) , b = ({a = 1 , b = true }.b) }.a) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Nat .((f (( \f: Rec X. X .((f ({a = 0 , b = false , c =  0 }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) ) ({a = 1 , b = (if true then false else true) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) }.a)) }.b)
(let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (let u = 1 in (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .a))) ) ) (\a: Bool .\b: Bool .a)) , b = (((\x: Nat .\y: Unit .x) (unfold [ Unit ] (fold [ Nat ] (let u = 0 in 0) )) ) ({a = 0 , b = false }.b)) }.b) )) in ({a = (( \f: Bool .((f (if true then (let u = 1 in u) else 1) ) (let u = true in 1) ) ) (\a: Bool .\b: Bool .a)) , b = (if ({a = false , b = false }.b) then 1 else (((\x: Unit .\y: Nat .y) false ) 0)) }.b))
(((\x: Unit .\y: Unit .y) (iszero (let u = (((\x: Nat .\y: Nat .y) false ) 0) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)))) ) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Rec X. X . (iszero 1) )) )) , b = (iszero (succ (((\x: Nat .\y: Nat .x) 1 ) false))) }.b))
(((\x: Rec X. X .\y: Nat .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (iszero (((\x: Bool .\y: Unit .x) 0 ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)))) )) ) (iszero (((\x: Rec X. X .\y: Bool .y) (let u = (let u = false in u) in u) ) ({a = 1 , b = (fix (\x: Bool . true )) , c = ({a = true , b = 0 }.b) }.c))))
(pred (( \f: Unit .((f (let u = (let u = false in 0) in (((\x: Rec X. X .\y: Nat .x) 0 ) false)) ) (let u = (if false then 0 else 0) in (let u = true in 1)) ) ) (\a: Nat .\b: Rec X. X .b)))
(((\x: Nat .\y: Rec X. X .y) (let u = ({a = ({a = 0 , b = false }.b) , b = ({a = (unfold [ Bool ] (fold [ Unit ] 1 )) , b = true , c = (let u = false in 1) }.c) }.a) in (iszero (((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) ) true))) ) (let u = (case <l = (((\x: Bool .\y: Unit .y) true ) 0) > as Bool of < l = x > => x | < r = y > => y) in u))
(let u = (( \f: Unit .((f ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Rec X. X . false )) , b = (( \f: Unit .((f (if false then 1 else 1) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .a)) }.a) }.a) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Nat . true )) )) , b = ({a = false , b = 1 }.b) }.b) ) ) (\a: Nat .\b: Bool .a)) in u)
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f ({a = 1 , b = false , c =  1 }.b) ) true ) ) (\a: Bool .\b: Bool .a)) ) ({a = (let u = false in true) , b = (if false then 0 else 1) }.b)) ))
(let u = (case <l = (( \f: Rec X. X .((f (let u = (case <l = ({a = 0 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Nat .x) (let u = 1 in 0) ) false)) ) (let u = (unfold [ Bool ] (fold [ Nat ] 0 )) in u) ) ) (\a: Nat .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(let u = ({a = (let u = (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] 0 )) )) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in u) ))) , b = ({a = ({a = true , b = ({a = 0 , b = true , c =  1 }.b) }.b) , b = ({a = true , b = (let u = false in 1) }.b) }.b) }.b) in (((\x: Unit .\y: Unit .x) (((\x: Bool .\y: Nat .x) 1 ) ({a = 0 , b = true }.b)) ) ({a = 0 , b = (fix (\x: Rec X. X . false )) , c =  ({a = 0 , b = true , c = 1 }.c) }.b)))
(((\x: Unit .\y: Rec X. X .x) ({a = (case <l = (let u = 1 in 0) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (iszero 1) ) (if (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a)) then ({a = true , b = 1 }.a) else (fix (\x: Nat . false ))) ) ) (\a: Bool .\b: Rec X. X .a)) }.a) ) (fix (\x: Unit . (case <r = ({a = 0 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) )))
(succ (let u = (((\x: Nat .\y: Rec X. X .y) ({a = ({a = 1 , b = (succ 0) }.b) , b = (unfold [ Bool ] (fold [ Unit ] false )) }.b) ) (pred 1)) in u))
(( \f: Unit .((f (unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = 0 , b = true }.b) in (iszero 1)) )) ) ({a = (((\x: Unit .\y: Nat .x) 1 ) false) , b = (let u = true in false) }.b) ) ) (\a: Bool .\b: Nat .a))
({a = ({a = (( \f: Unit .((f (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.a) )) in u) ) (iszero (((\x: Bool .\y: Rec X. X .y) true ) 0)) ) ) (\a: Bool .\b: Nat .b)) , b = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) }.b) }.b) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in (((\x: Unit .\y: Nat .y) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = true , b = 1 }.a))) }.a)
(let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f (let u = 1 in true) ) ({a = (if true then false else false) , b = true }.b) ) ) (\a: Unit .\b: Bool .b)) )) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if ({a = (unfold [ Unit ] (fold [ Bool ] (let u = false in u) )) , b = (let u = false in u) }.b) then ({a = true , b = (let u = 0 in 1) }.a) else (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) )))
(let u = (let u = (((\x: Nat .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Bool ] (pred 0) )) ) (fix (\x: Bool . (let u = 0 in true) ))) in (let u = (((\x: Unit .\y: Unit .x) (pred 0) ) ({a = 0 , b = false , c =  1 }.b)) in (let u = (iszero (succ 1)) in (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) ) (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) ) (\a: Nat .\b: Bool .b))))) in (((\x: Unit .\y: Unit .y) (let u = false in (fix (\x: Bool . true ))) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true ))))
(fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) (let u = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .a)) in u) ) (unfold [ Unit ] (fold [ Bool ] (let u = false in (pred 1)) ))) ))
(let u = (((\x: Unit .\y: Bool .x) (iszero (fix (\x: Bool . 1 ))) ) (let u = ({a = (((\x: Unit .\y: Rec X. X .y) true ) true) , b = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then ({a = true , b = 0 }.a) else false) }.b) in u)) in u)
(if (fix (\x: Bool . (if ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = false in u) }.b) )) then (iszero ({a = 0 , b = false , c = 0 }.c)) else ({a = 1 , b = true }.b)) )) then ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (((\x: Bool .\y: Rec X. X .y) false ) 0) , b = ({a = true , b = 1 }.a) , c =  (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) }.b) )) else (( \f: Rec X. X .((f (( \f: Nat .((f (((\x: Nat .\y: Nat .x) false ) false) ) (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) in (fix (\x: Rec X. X . true ))) ) ) (\a: Bool .\b: Nat .a)) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = true , b = 0 }.a) )) ) ) (\a: Unit .\b: Bool .a)))
(((\x: Rec X. X .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Unit ] (succ 0) )) ) (( \f: Bool .((f (case <r = ({a = true , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) )) , b = ({a = (fix (\x: Nat . true )) , b = (if (((\x: Rec X. X .\y: Rec X. X .y) false ) false) then (let u = 1 in true) else ({a = true , b = 1 }.a)) }.b) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(pred ({a = (let u = (fix (\x: Nat . ({a = 0 , b = false , c =  1 }.b) )) in (fix (\x: Nat . 0 ))) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false ))) }.a))
({a = (((\x: Nat .\y: Rec X. X .x) ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (let u = (succ 0) in 0) }.a) ) ({a = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .b)) , b = true }.b)) , b = (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) ) (((\x: Unit .\y: Nat .x) ({a = 0 , b = true }.b) ) (let u = 1 in true))) }.a)
(pred (pred (((\x: Unit .\y: Nat .x) 0 ) (let u = false in u))))
(unfold [ Unit ] (fold [ Rec X. X ] (succ ({a = (( \f: Nat .((f ({a = false , b = 1 }.a) ) true ) ) (\a: Unit .\b: Nat .b)) , b = (( \f: Bool .((f 1 ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)) ))
(case <r = ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = 0 }.b) }.b) , b = (((\x: Nat .\y: Bool .y) (if true then true else false) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false ))) , c =  (succ ({a = false , b = 0 }.b)) }.b) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (((\x: Unit .\y: Bool .y) ({a = false , b = true }.b) ) ({a = 0 , b = false }.a)) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) }.a) , b = ({a = (unfold [ Bool ] (fold [ Nat ] (case <l = (( \f: Rec X. X .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . 0 )) ) ) (\a: Bool .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) )) , b = (( \f: Unit .((f ({a = 1 , b = true , c =  (if true then 0 else 0) }.b) ) (iszero ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) }.a)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (( \f: Bool .((f (if true then false else (iszero 1)) ) (if (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) then false else ({a = true , b = true }.b)) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = ({a = (((\x: Nat .\y: Nat .y) false ) true) , b = 1 }.b) , b = (fix (\x: Rec X. X . ({a = 0 , b = false , c =  1 }.b) )) }.a) }.a) ))
(if (((\x: Bool .\y: Bool .x) (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) ) (let u = ({a = 1 , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b)) , c = 0 }.c) in (fix (\x: Bool . true )))) then (case <l = (let u = (((\x: Unit .\y: Rec X. X .x) 0 ) false) in u) > as Bool of < l = x > => x | < r = y > => y) else (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Rec X. X .((f (( \f: Nat .((f ({a = 0 , b = false , c = 0 }.c) ) (unfold [ Nat ] (fold [ Nat ] 0 )) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = ({a = 1 , b = 0 }.b) , b = false }.a) ) ) (\a: Nat .\b: Nat .b)) )))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Nat .y) ({a = true , b = 0 }.a) ) (unfold [ Nat ] (fold [ Rec X. X ] true ))) )) , b = ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = ({a = 0 , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true )) , c = (fix (\x: Nat . 0 )) }.c) }.b) , b = ({a = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) , b = ({a = true , b = 0 }.b) }.b) , b = (( \f: Bool .((f ({a = true , b = true }.b) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) , c = ({a = (fix (\x: Bool . true )) , b = (let u = (((\x: Rec X. X .\y: Nat .y) false ) false) in 0) }.b) }.c) }.b)
(let u = (if (case <r = (let u = (let u = false in u) in u) > as Nat of < l = x > => x | < r = y > => y) then ({a = (let u = (unfold [ Nat ] (fold [ Nat ] true )) in u) , b = ({a = (fix (\x: Bool . 0 )) , b = false }.a) }.a) else (unfold [ Rec X. X ] (fold [ Nat ] (let u = ({a = true , b = 1 }.a) in ({a = true , b = false }.b)) ))) in ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)) )) , b = (let u = ({a = (iszero 0) , b = (let u = 1 in u) }.b) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 ))) }.b))
(succ (( \f: Unit .((f (case <l = (((\x: Rec X. X .\y: Unit .x) 1 ) true) > as Rec X. X of < l = x > => x | < r = y > => y) ) (pred ({a = true , b = 1 }.b)) ) ) (\a: Nat .\b: Rec X. X .a)))
({a = (case <l = (let u = (let u = 1 in u) in u) > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = (succ 0) , b = ({a = 1 , b = false , c =  1 }.b) }.b) )) }.a)
(((\x: Nat .\y: Nat .y) (( \f: Nat .((f ({a = (( \f: Rec X. X .((f ({a = 0 , b = false , c = 1 }.c) ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = 1 in false) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) in u) ) ) (\a: Nat .\b: Unit .a)) ) (succ (succ 1)))
(case <r = (fix (\x: Rec X. X . (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) false ) true) ) ({a = (let u = false in true) , b = (let u = 1 in false) }.b) ) ) (\a: Bool .\b: Nat .a)) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (pred (let u = (fix (\x: Bool . ({a = 0 , b = true }.b) )) in (((\x: Rec X. X .\y: Bool .x) 1 ) true))) , b = (iszero (succ ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (succ 1) )))) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) in u) ))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .x) ({a = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = 1 }.b) , b = (((\x: Rec X. X .\y: Unit .y) false ) false) }.b) ) ({a = (let u = 0 in u) , b = (iszero ({a = false , b = 1 }.b)) }.b)) ))
(( \f: Rec X. X .((f (let u = (if true then 0 else ({a = 1 , b = false }.a)) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) ) (fix (\x: Unit . (case <l = ({a = 0 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Rec X. X .\b: Bool .b))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Nat .((f (let u = (let u = false in true) in u) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) )) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f (let u = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) in u) ) (case <r = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (iszero (let u = true in 0)) )))
(fix (\x: Unit . (((\x: Unit .\y: Bool .x) ({a = (succ (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = 1 , b = false }.a) }.b) ) (let u = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .a)) in (iszero 0))) ))
(( \f: Bool .((f (if ({a = (fix (\x: Rec X. X . 1 )) , b = ({a = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .b)) , b = (let u = 0 in u) }.a) , c =  ({a = 1 , b = true , c = 0 }.c) }.b) then (let u = (let u = 0 in 1) in (let u = false in false)) else (((\x: Bool .\y: Nat .y) (let u = true in false) ) false)) ) (if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .b)) )) then (let u = true in (((\x: Nat .\y: Nat .y) false ) false)) else (let u = false in u)) ) ) (\a: Nat .\b: Nat .a))
(( \f: Nat .((f (let u = ({a = ({a = 0 , b = (let u = 0 in 1) }.b) , b = ({a = ({a = 0 , b = false , c =  0 }.b) , b = false }.b) , c =  (fix (\x: Nat . 0 )) }.b) in (let u = (unfold [ Nat ] (fold [ Bool ] 1 )) in (unfold [ Rec X. X ] (fold [ Unit ] false )))) ) (case <r = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (iszero (let u = 0 in u)) }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b))
(let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (case <l = ({a = true , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (let u = true in 0) ) (( \f: Rec X. X .((f (let u = false in 1) ) 0 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .b)) }.b) )) in (case <r = (((\x: Bool .\y: Rec X. X .x) (if true then true else false) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y))
(case <l = (if (case <r = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) then ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = true , c = 1 }.c) )) else ({a = 0 , b = false , c = (let u = false in 0) }.c)) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Unit .x) (( \f: Rec X. X .((f (let u = (((\x: Unit .\y: Rec X. X .x) true ) false) in 0) ) (let u = (let u = true in (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .b))) in (let u = 0 in 0)) ) ) (\a: Unit .\b: Unit .a)) ) (let u = (let u = (( \f: Nat .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .b)) in (( \f: Unit .((f ({a = true , b = 1 }.a) ) (let u = true in u) ) ) (\a: Unit .\b: Unit .a))) in (( \f: Nat .((f (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (((\x: Unit .\y: Rec X. X .x) true ) true) ) ) (\a: Bool .\b: Nat .a))))
(fix (\x: Bool . (succ (case <l = (pred ({a = false , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y)) ))
({a = ({a = (succ 0) , b = ({a = (if false then false else true) , b = (fix (\x: Bool . (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) }.a) }.a) , b = (fix (\x: Nat . (fix (\x: Nat . (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Unit .y) true ) false) ) true) )) )) }.b)
(let u = (fix (\x: Nat . (( \f: Nat .((f (fix (\x: Rec X. X . (pred 1) )) ) (fix (\x: Nat . (let u = 0 in 0) )) ) ) (\a: Bool .\b: Bool .b)) )) in u)
(if ({a = (( \f: Unit .((f (let u = 0 in u) ) (((\x: Unit .\y: Nat .x) (pred 0) ) false) ) ) (\a: Bool .\b: Bool .b)) , b = (iszero ({a = (let u = 1 in u) , b = ({a = 1 , b = true , c =  1 }.b) }.a)) }.b) then (let u = ({a = (((\x: Nat .\y: Nat .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) (iszero 1)) , b = (( \f: Bool .((f ({a = 1 , b = 0 }.b) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) in u) else (( \f: Bool .((f (case <r = (((\x: Bool .\y: Unit .y) (iszero 0) ) true) > as Nat of < l = x > => x | < r = y > => y) ) (case <r = (if (let u = true in u) then ({a = false , b = 1 }.a) else true) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)))
(let u = (let u = ({a = (let u = 1 in 1) , b = (iszero 0) , c =  (succ 1) }.b) in (let u = (let u = 1 in 1) in (let u = false in true))) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) , b = (let u = 0 in false) }.b) )))
({a = (let u = (fix (\x: Bool . ({a = ({a = (let u = 0 in 1) , b = (pred 1) }.b) , b = (((\x: Nat .\y: Rec X. X .y) false ) false) , c =  (unfold [ Unit ] (fold [ Unit ] 1 )) }.b) )) in (let u = (( \f: Unit .((f (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Rec X. X .\y: Bool .y) false ) (iszero 0)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ({a = (( \f: Unit .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = 1 in true) , c =  (if (fix (\x: Unit . true )) then ({a = true , b = 0 }.b) else 1) }.b))) , b = (case <l = (let u = ({a = true , b = 1 }.a) in ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) true ) true) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(((\x: Bool .\y: Bool .x) ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Bool .\y: Rec X. X .x) ({a = 0 , b = false }.b) ) ({a = 1 , b = false , c =  1 }.b)) }.b) ) (iszero (( \f: Unit .((f ({a = 0 , b = true }.a) ) 1 ) ) (\a: Rec X. X .\b: Bool .a))))
(succ ({a = (unfold [ Unit ] (fold [ Bool ] (let u = 0 in u) )) , b = (case <r = (((\x: Rec X. X .\y: Nat .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) ) (let u = true in true)) > as Nat of < l = x > => x | < r = y > => y) }.a))
({a = (( \f: Unit .((f ({a = ({a = 0 , b = false , c =  (if false then 0 else 1) }.b) , b = (( \f: Nat .((f (let u = 1 in true) ) ({a = (succ 1) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Bool .a)) }.b) ) ({a = (( \f: Bool .((f (iszero 0) ) (let u = 0 in false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (succ 0) }.a) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (pred ({a = (fix (\x: Rec X. X . 1 )) , b = (let u = true in u) , c = (succ 0) }.c)) }.a)
({a = (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) ) (if (let u = ({a = 1 , b = true , c =  0 }.b) in (let u = false in u)) then (let u = 1 in u) else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .a)) , b = (iszero (pred (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in u))) }.b)
({a = (((\x: Rec X. X .\y: Bool .x) ({a = (( \f: Rec X. X .((f false ) (((\x: Rec X. X .\y: Nat .y) true ) true) ) ) (\a: Nat .\b: Nat .a)) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) }.a) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) , b = (pred ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = (((\x: Bool .\y: Bool .x) 1 ) false) }.b)) }.b)
({a = ({a = (pred (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) , b = (((\x: Rec X. X .\y: Nat .y) false ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a))) , c = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) in u) }.c) , b = (if (( \f: Rec X. X .((f false ) (((\x: Unit .\y: Unit .y) true ) true) ) ) (\a: Nat .\b: Rec X. X .a)) then (unfold [ Bool ] (fold [ Bool ] (((\x: Rec X. X .\y: Nat .x) ({a = true , b = 1 }.a) ) false) )) else (case <r = (( \f: Nat .((f true ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y)) , c =  ({a = (if false then 0 else ({a = 0 , b = true }.a)) , b = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) }.b)
(if (case <r = (((\x: Unit .\y: Rec X. X .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (iszero ({a = 1 , b = 0 }.b))) > as Nat of < l = x > => x | < r = y > => y) then (let u = (fix (\x: Bool . (iszero 1) )) in (( \f: Bool .((f (( \f: Bool .((f (fix (\x: Bool . 1 )) ) (let u = true in 1) ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Unit .\y: Rec X. X .y) (if false then false else false) ) (succ 0)) ) ) (\a: Unit .\b: Rec X. X .b))) else (pred ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) , b = ({a = 0 , b = 1 }.b) }.b)))
(case <l = (pred (fix (\x: Rec X. X . (fix (\x: Unit . ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) )) ))) > as Unit of < l = x > => x | < r = y > => y)
({a = (unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] (let u = (((\x: Rec X. X .\y: Nat .y) false ) 1) in (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) )) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (case <r = (((\x: Unit .\y: Unit .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) )) ) (case <r = (((\x: Bool .\y: Rec X. X .y) true ) ({a = 0 , b = false , c =  1 }.b)) > as Bool of < l = x > => x | < r = y > => y)) )) , c = (let u = (((\x: Bool .\y: Rec X. X .y) ({a = false , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) }.b) ) (case <l = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y)) in (succ (((\x: Bool .\y: Bool .y) ({a = 0 , b = true , c =  1 }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] 0 ))))) }.c)
(let u = (( \f: Bool .((f (case <l = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (( \f: Unit .((f (fix (\x: Unit . true )) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Unit .a)) , b = (((\x: Nat .\y: Unit .y) true ) 0) }.b) ) ) (\a: Nat .\b: Unit .a)) in u)
(let u = ({a = (let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (succ 0) }.b) in u) , b = ({a = (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.b) ))) , b = (( \f: Unit .((f ({a = true , b = 1 }.b) ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.b) }.b) in (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in (if (((\x: Unit .\y: Unit .x) false ) true) then ({a = 0 , b = false , c =  0 }.b) else true)))
(case <r = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = true in true) )) )) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . ({a = (case <l = (((\x: Nat .\y: Rec X. X .x) 0 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in u) }.b) ))
(let u = ({a = (((\x: Unit .\y: Rec X. X .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ({a = true , b = 0 }.a)) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .b)) in u) }.b) in (unfold [ Nat ] (fold [ Rec X. X ] ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = (fix (\x: Rec X. X . true )) , c = 1 }.c) )))
(if (let u = (( \f: Rec X. X .((f (fix (\x: Rec X. X . ({a = false , b = true }.b) )) ) (((\x: Nat .\y: Bool .y) false ) true) ) ) (\a: Bool .\b: Nat .a)) in (fix (\x: Rec X. X . ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) , b = (iszero 0) }.b) ))) then (( \f: Nat .((f (pred ({a = 1 , b = true , c = 1 }.c)) ) (pred 1) ) ) (\a: Rec X. X .\b: Nat .b)) else (( \f: Unit .((f ({a = (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) (succ 0) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (fix (\x: Rec X. X . true )) , c = (if (((\x: Rec X. X .\y: Bool .y) false ) false) then ({a = true , b = 0 }.b) else 1) }.c) ) ({a = ({a = (((\x: Nat .\y: Nat .y) true ) 1) , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .b)) }.b) , b = (fix (\x: Rec X. X . 0 )) }.b) ) ) (\a: Nat .\b: Rec X. X .a)))
(iszero ({a = (fix (\x: Nat . (unfold [ Bool ] (fold [ Nat ] 1 )) )) , b = (( \f: Unit .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Bool ] true )) ) ) (\a: Nat .\b: Nat .b)) , c = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = false , b = (((\x: Bool .\y: Unit .y) false ) 1) }.b) )) }.c))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) (let u = ({a = 1 , b = true }.b) in u) ) (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = false , c =  1 }.b) ))) ))
({a = (if ({a = ({a = 1 , b = true }.a) , b = ({a = true , b = 0 }.a) , c =  (pred 0) }.b) then (( \f: Bool .((f (succ 0) ) 0 ) ) (\a: Bool .\b: Bool .b)) else ({a = 0 , b = false , c = 1 }.c)) , b = (unfold [ Bool ] (fold [ Bool ] (let u = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .a)) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false ))) )) , c =  (unfold [ Nat ] (fold [ Bool ] (pred ({a = ({a = true , b = 1 }.b) , b = 1 }.b)) )) }.b)
(((\x: Bool .\y: Nat .y) (fix (\x: Unit . (((\x: Nat .\y: Bool .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = false , b = false }.b)) )) ) ({a = (iszero (succ (unfold [ Bool ] (fold [ Unit ] 0 )))) , b = (( \f: Unit .((f (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) ) (( \f: Rec X. X .((f 1 ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .b)) }.b))
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = (pred ({a = true , b = (let u = true in 0) }.b)) in u) ))
(let u = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Unit .\y: Bool .y) ({a = 0 , b = true }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = 1 , b = (let u = true in u) , c = (let u = 0 in u) }.c)) in ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = (if (((\x: Unit .\y: Unit .y) true ) false) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) else (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a))) in (if false then 0 else 0)) )))
({a = (let u = (let u = (let u = ({a = 1 , b = true , c = 0 }.c) in (if false then true else false)) in (succ 1)) in ({a = (((\x: Unit .\y: Nat .y) ({a = ({a = 1 , b = false , c =  0 }.b) , b = (let u = false in true) }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = (((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f false ) ({a = true , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ) (((\x: Rec X. X .\y: Unit .y) true ) false)) }.b)) , b = (let u = (let u = (unfold [ Rec X. X ] (fold [ Nat ] true )) in u) in ({a = 1 , b = 0 }.b)) }.a)
(( \f: Rec X. X .((f (((\x: Unit .\y: Unit .x) (fix (\x: Bool . (( \f: Nat .((f (let u = 1 in u) ) (pred 1) ) ) (\a: Nat .\b: Bool .b)) )) ) (let u = (let u = (((\x: Rec X. X .\y: Unit .y) true ) false) in u) in u)) ) (case <l = ({a = (( \f: Bool .((f (let u = 0 in false) ) false ) ) (\a: Nat .\b: Nat .a)) , b = (let u = 0 in 0) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = 0 }.a) , b = (( \f: Bool .((f (iszero 1) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) ) (\a: Nat .\b: Bool .b)) }.b) ))
({a = (succ (pred (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)))) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = (let u = false in u) , b = ({a = 0 , b = (((\x: Rec X. X .\y: Nat .y) true ) true) , c =  1 }.b) }.b) )) , c = (let u = (pred (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .y) false ) 0) ) (if true then 0 else 1) ) ) (\a: Bool .\b: Bool .a))) in u) }.c)
(if (( \f: Nat .((f ({a = (if ({a = true , b = 1 }.a) then ({a = true , b = false }.b) else (if true then false else true)) , b = (pred 0) }.a) ) (( \f: Bool .((f false ) ({a = true , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .a)) then (case <r = (((\x: Unit .\y: Nat .y) true ) true) > as Rec X. X of < l = x > => x | < r = y > => y) else (if ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) , b = (fix (\x: Unit . 0 )) }.a) then (if false then true else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true ))) else (if (fix (\x: Bool . true )) then ({a = ({a = 1 , b = true }.b) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.a) else ({a = 1 , b = false }.b))))
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .x) (( \f: Nat .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ))) ))
({a = (( \f: Nat .((f ({a = (succ 1) , b = true }.b) ) (let u = true in true) ) ) (\a: Bool .\b: Unit .a)) , b = (let u = ({a = (if (iszero 0) then (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) else 0) , b = ({a = true , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) }.b) , c = (let u = (fix (\x: Rec X. X . 1 )) in (fix (\x: Rec X. X . 0 ))) }.c) in u) }.b)
(let u = (if (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Bool .x) false ) false) )) then (iszero ({a = 0 , b = false }.a)) else (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ({a = true , b = false }.b))) in u)
(case <l = (let u = (let u = ({a = false , b = true }.b) in u) in (fix (\x: Unit . (let u = (succ 0) in u) ))) > as Nat of < l = x > => x | < r = y > => y)
({a = (pred (case <l = (((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f ({a = 1 , b = false }.b) ) true ) ) (\a: Bool .\b: Nat .b)) ) (pred 0)) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (((\x: Bool .\y: Bool .y) (( \f: Nat .((f (( \f: Unit .((f true ) ({a = false , b = 0 }.a) ) ) (\a: Unit .\b: Unit .b)) ) (let u = (let u = 0 in false) in ({a = false , b = 0 }.a)) ) ) (\a: Nat .\b: Unit .a)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) ))) , c =  (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Unit .x) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a)) ) ({a = false , b = false }.b)) ) ({a = (let u = 0 in u) , b = (fix (\x: Rec X. X . false )) , c = (fix (\x: Unit . 0 )) }.c)) }.b)
(case <l = (case <l = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) in u) > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(let u = (fix (\x: Rec X. X . (let u = ({a = true , b = 0 }.b) in u) )) in (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a)) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) (((\x: Unit .\y: Nat .y) (((\x: Nat .\y: Unit .x) true ) true) ) (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .b)))
(if (fix (\x: Bool . (((\x: Bool .\y: Bool .y) (let u = (let u = (iszero 1) in u) in (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) ) (case <r = (fix (\x: Unit . true )) > as Nat of < l = x > => x | < r = y > => y)) )) then ({a = (((\x: Nat .\y: Rec X. X .y) ({a = false , b = 0 }.a) ) (let u = 1 in 0)) , b = (((\x: Bool .\y: Bool .x) (let u = 1 in true) ) ({a = false , b = 1 }.a)) , c =  (( \f: Nat .((f (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .y) true ) 1) )) ) (((\x: Unit .\y: Nat .y) false ) 0) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) else (case <r = (fix (\x: Unit . (unfold [ Nat ] (fold [ Unit ] false )) )) > as Nat of < l = x > => x | < r = y > => y))
({a = (iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ({a = 0 , b = true , c = 0 }.c) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) }.b) ))) , b = (fix (\x: Unit . ({a = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in 0) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) , b = ({a = false , b = 0 }.a) , c =  (let u = 0 in 0) }.b) , c = (fix (\x: Unit . (fix (\x: Bool . 0 )) )) }.c) )) }.a)
(((\x: Rec X. X .\y: Bool .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (if (unfold [ Rec X. X ] (fold [ Nat ] true )) then (let u = true in true) else (( \f: Rec X. X .((f (if true then false else true) ) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ) (\a: Nat .\b: Rec X. X .a))) )) ) (( \f: Bool .((f ({a = (((\x: Nat .\y: Unit .x) 0 ) true) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (iszero 1) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(fix (\x: Nat . (((\x: Bool .\y: Rec X. X .y) ({a = (pred 1) , b = ({a = 1 , b = true , c =  1 }.b) }.b) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) ))
(( \f: Bool .((f ({a = (unfold [ Nat ] (fold [ Unit ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) , b = (if (iszero 0) then (unfold [ Nat ] (fold [ Nat ] true )) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) }.b) ) (((\x: Rec X. X .\y: Nat .x) (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false ))) in u)) ) ) (\a: Bool .\b: Rec X. X .a))
({a = ({a = (case <l = (unfold [ Nat ] (fold [ Bool ] (if true then 1 else 0) )) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (let u = 0 in true) , b = (let u = false in u) }.b) }.a) , b = (if (( \f: Nat .((f ({a = (succ 1) , b = (let u = true in true) , c =  1 }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) then ({a = (( \f: Nat .((f (if (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) then true else true) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) 1 ) ) (\a: Nat .\b: Unit .a)) }.b) else (case <l = (((\x: Unit .\y: Rec X. X .y) (let u = true in u) ) (((\x: Nat .\y: Rec X. X .x) 1 ) true)) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b)
(let u = (case <l = (((\x: Nat .\y: Bool .x) ({a = 1 , b = true , c = 0 }.c) ) (let u = (if false then false else true) in u)) > as Bool of < l = x > => x | < r = y > => y) in u)
(( \f: Bool .((f (if (unfold [ Unit ] (fold [ Nat ] (let u = true in true) )) then (( \f: Rec X. X .((f (let u = false in u) ) true ) ) (\a: Rec X. X .\b: Unit .b)) else (if false then false else false)) ) (let u = (((\x: Rec X. X .\y: Bool .x) ({a = false , b = 1 }.a) ) (((\x: Nat .\y: Rec X. X .x) (let u = 0 in false) ) false)) in u) ) ) (\a: Unit .\b: Nat .a))
(( \f: Rec X. X .((f (succ (((\x: Unit .\y: Rec X. X .x) (if (unfold [ Unit ] (fold [ Nat ] false )) then 0 else 0) ) (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y))) ) ({a = ({a = (let u = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Unit ] true )) ) true ) ) (\a: Nat .\b: Bool .b)) in u) , b = (let u = (((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Nat .x) true ) true) ) 0) in u) }.b) , b = (if ({a = true , b = 1 }.a) then ({a = true , b = 0 }.a) else (fix (\x: Unit . false ))) }.a) ) ) (\a: Bool .\b: Unit .a))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .b)) ) (( \f: Nat .((f (iszero 1) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Nat .\b: Bool .b)) )) , b = (case <l = (succ ({a = (fix (\x: Bool . false )) , b = 0 }.b)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f (succ (if false then 0 else (let u = false in 1))) ) ({a = ({a = true , b = 0 }.b) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) ) (\a: Bool .\b: Bool .a)) ) ({a = (fix (\x: Bool . ({a = (fix (\x: Rec X. X . 1 )) , b = (((\x: Bool .\y: Bool .x) true ) false) }.a) )) , b = (( \f: Rec X. X .((f ({a = 0 , b = (let u = false in u) }.b) ) ({a = ({a = 1 , b = false , c =  0 }.b) , b = 0 }.a) ) ) (\a: Nat .\b: Rec X. X .b)) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] (pred (let u = false in 1)) )) }.b))
({a = (case <l = ({a = (pred 0) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) ({a = 1 , b = false , c =  1 }.b)) , c = (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Bool .x) 1 ) true) ) (iszero 1)) }.c) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (if (iszero 1) then true else (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b))) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in u) )) ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (((\x: Rec X. X .\y: Unit .x) (succ 1) ) (unfold [ Nat ] (fold [ Unit ] (if true then false else false) ))) }.b)
({a = (succ ({a = (( \f: Unit .((f (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) 0 ) ) (\a: Unit .\b: Nat .b)) ) (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )) in 0) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .a)) }.a)) , b = (fix (\x: Rec X. X . (if ({a = true , b = false }.b) then (if true then ({a = 0 , b = true }.b) else false) else (unfold [ Rec X. X ] (fold [ Bool ] false ))) )) , c = (if (iszero (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in 0)) then ({a = (if false then (((\x: Nat .\y: Unit .x) 0 ) true) else 1) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) else (if (((\x: Unit .\y: Bool .y) ({a = 0 , b = false }.b) ) (let u = false in u)) then ({a = ({a = 1 , b = 0 }.b) , b = true , c = (let u = false in 0) }.c) else ({a = true , b = 0 }.b))) }.c)
(((\x: Rec X. X .\y: Nat .x) (pred (((\x: Unit .\y: Unit .x) 0 ) false)) ) ({a = ({a = (((\x: Bool .\y: Nat .x) 0 ) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b))) , b = (fix (\x: Bool . (fix (\x: Nat . (((\x: Bool .\y: Unit .y) true ) false) )) )) , c =  ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = true in 0) )) }.b) , b = (let u = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in u) in u) }.b))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Nat .y) true ) false) ) (iszero (let u = (succ 1) in 1))) ))
({a = ({a = (unfold [ Bool ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) )) , b = (((\x: Rec X. X .\y: Bool .y) (iszero (if ({a = false , b = true }.b) then 1 else ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )))) ) (((\x: Rec X. X .\y: Unit .y) false ) (pred 0))) }.b) , b = (pred ({a = ({a = true , b = 1 }.b) , b = ({a = 1 , b = false }.b) , c = ({a = true , b = 0 }.b) }.c)) }.b)
(( \f: Unit .((f ({a = (((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) ({a = 1 , b = false , c =  1 }.b)) , b = (let u = (((\x: Rec X. X .\y: Nat .y) false ) 1) in (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .a))) }.b) ) (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f (fix (\x: Bool . (let u = false in true) )) ) (let u = true in false) ) ) (\a: Nat .\b: Bool .a)) ) (let u = (case <l = (succ (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b))) > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Unit . ({a = 0 , b = true , c =  0 }.b) )))) ) ) (\a: Nat .\b: Bool .b))
(let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero 1) )) , b = (let u = ({a = true , b = (let u = 1 in 0) }.b) in (( \f: Bool .((f (if true then 0 else 0) ) (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in u) ) ) (\a: Bool .\b: Bool .a))) }.a) in u)
(unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Rec X. X .x) (( \f: Unit .((f (iszero (((\x: Bool .\y: Rec X. X .x) 1 ) true)) ) (let u = ({a = 1 , b = false , c =  0 }.b) in (let u = 1 in false)) ) ) (\a: Nat .\b: Nat .a)) ) (if (if false then (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) else true) then (let u = false in u) else (iszero 0))) ))
({a = (let u = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) in (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) in (if ({a = true , b = 0 }.a) then (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) else (pred 1)))) , b = ({a = ({a = (let u = false in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false ))) , b = (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) false) in (if false then 0 else 1)) }.b) , b = (if false then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , c =  (let u = (pred 0) in u) }.b) }.b)
(case <r = ({a = ({a = (((\x: Unit .\y: Unit .x) false ) (let u = false in true)) , b = ({a = false , b = 0 }.a) }.b) , b = (fix (\x: Unit . (((\x: Bool .\y: Bool .x) true ) true) )) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Bool .y) ({a = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) }.a) , b = (case <r = (let u = 0 in false) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (let u = 1 in true) , c = (if true then 0 else 0) }.c) }.b) ) (fix (\x: Bool . ({a = (let u = true in u) , b = ({a = 1 , b = true , c = 0 }.c) }.b) )))
(( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) ({a = ({a = (pred 1) , b = false }.a) , b = ({a = 0 , b = true }.b) }.a) ) (((\x: Unit .\y: Nat .y) (((\x: Nat .\y: Nat .x) false ) true) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = false }.b))) ) (let u = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = 0 in 0) )) ) (if false then (let u = 1 in 1) else (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) ) ) (\a: Unit .\b: Bool .b)) in u) ) ) (\a: Bool .\b: Nat .b))
({a = (if (((\x: Unit .\y: Unit .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = false in u)) then (if (iszero 0) then 1 else ({a = false , b = 0 }.b)) else (((\x: Nat .\y: Bool .x) ({a = 0 , b = true , c = 1 }.c) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )))) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.a) )) , b = (( \f: Bool .((f (case <r = (let u = (((\x: Nat .\y: Unit .x) false ) false) in true) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Rec X. X ] true )) ) ) (\a: Bool .\b: Nat .a)) , c = ({a = ({a = 0 , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.a) , b = ({a = 1 , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) , c =  (let u = false in 0) }.b) , c = ({a = (fix (\x: Bool . 1 )) , b = (let u = false in u) , c = ({a = false , b = 1 }.b) }.c) }.c) }.c) }.b)
({a = (let u = (( \f: Nat .((f (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in ({a = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) , b = 0 }.b)) ) (pred ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) ) ) (\a: Nat .\b: Nat .b)) in u) , b = ({a = ({a = (iszero 1) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (unfold [ Bool ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = 0 , b = true , c = 1 }.c) , b = (if false then false else false) }.a) )) )) }.a) }.a)
(((\x: Rec X. X .\y: Rec X. X .y) (let u = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = false }.a) )) , b = (if ({a = 0 , b = true }.b) then true else true) , c =  (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) in u) ) (if (if (let u = 0 in false) then ({a = 1 , b = false }.b) else (if true then false else false)) then (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a)) else ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (unfold [ Nat ] (fold [ Bool ] true )) }.a)))
(((\x: Bool .\y: Nat .x) (iszero (((\x: Rec X. X .\y: Bool .y) ({a = false , b = false }.b) ) ({a = 1 , b = 0 }.b))) ) (((\x: Nat .\y: Unit .x) (fix (\x: Unit . ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = true , b = true }.b) )) )) ) (iszero ({a = 0 , b = 0 }.b))))
(case <l = (((\x: Nat .\y: Nat .y) (iszero (((\x: Rec X. X .\y: Nat .y) true ) 0)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y)
({a = (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) , b = (pred (let u = (( \f: Nat .((f 1 ) (let u = 1 in 0) ) ) (\a: Rec X. X .\b: Nat .b)) in u)) }.b)
(if ({a = (if ({a = ({a = true , b = 0 }.a) , b = false }.b) then ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = 1 in u) }.b) else (if ({a = false , b = 0 }.a) then 0 else 1)) , b = (if (((\x: Rec X. X .\y: Bool .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Unit .x) true ) true)) then (fix (\x: Unit . true )) else (if ({a = (((\x: Rec X. X .\y: Nat .y) false ) true) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) then (unfold [ Rec X. X ] (fold [ Nat ] true )) else (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)))) , c =  (let u = (pred (unfold [ Nat ] (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) ))) in (succ (pred (fix (\x: Rec X. X . 1 ))))) }.b) then (unfold [ Nat ] (fold [ Nat ] (let u = (((\x: Unit .\y: Bool .y) true ) true) in 0) )) else (let u = (let u = (if false then true else true) in u) in (succ ({a = 0 , b = true }.a))))
(let u = (let u = ({a = (pred (let u = false in 1)) , b = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) in (let u = false in u)) , c =  (((\x: Bool .\y: Nat .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) (let u = 1 in false)) }.b) in (((\x: Nat .\y: Nat .y) ({a = (succ 0) , b = (iszero 1) , c =  (((\x: Bool .\y: Unit .y) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) 1) }.b) ) (fix (\x: Bool . (if false then true else false) )))) in (succ (let u = (let u = (((\x: Nat .\y: Nat .y) false ) true) in (((\x: Unit .\y: Bool .y) false ) false)) in (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) (fix (\x: Bool . (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) )) ) ) (\a: Bool .\b: Nat .b)))))
(let u = (((\x: Rec X. X .\y: Bool .x) ({a = ({a = 1 , b = false , c =  0 }.b) , b = (let u = false in 1) }.a) ) (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) (fix (\x: Rec X. X . true )))) in (fix (\x: Nat . (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) (case <l = (let u = 0 in 0) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) )))
({a = (let u = (fix (\x: Nat . 0 )) in (( \f: Bool .((f (((\x: Nat .\y: Unit .x) ({a = 1 , b = false }.b) ) (fix (\x: Bool . true ))) ) (iszero (succ 1)) ) ) (\a: Nat .\b: Bool .b))) , b = (( \f: Nat .((f (let u = (fix (\x: Rec X. X . (if false then false else true) )) in (let u = 0 in false)) ) ({a = ({a = (case <l = (let u = 1 in 1) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false , c =  0 }.b) , c =  ({a = 1 , b = true , c = 1 }.c) }.b) , b = (( \f: Nat .((f (let u = true in false) ) (let u = (((\x: Nat .\y: Unit .x) false ) false) in true) ) ) (\a: Nat .\b: Nat .b)) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(case <r = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Bool .((f ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = 1 in 1) }.a) ) (let u = ({a = false , b = false }.b) in (if false then true else true)) ) ) (\a: Nat .\b: Rec X. X .a)) )) > as Nat of < l = x > => x | < r = y > => y)
({a = (let u = (if (unfold [ Nat ] (fold [ Bool ] false )) then (case <r = true > as Nat of < l = x > => x | < r = y > => y) else ({a = false , b = true }.b)) in u) , b = ({a = ({a = 1 , b = ({a = 0 , b = false }.b) , c = (if false then 1 else 0) }.c) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.a) }.b)
(fix (\x: Rec X. X . ({a = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 0 in u) }.a) , b = (((\x: Nat .\y: Nat .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (if (iszero 1) then (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) else (((\x: Rec X. X .\y: Unit .x) 0 ) true))) }.a) ))
(let u = (((\x: Unit .\y: Nat .x) ({a = (((\x: Nat .\y: Nat .x) true ) true) , b = 1 }.a) ) (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) in (case <r = true > as Nat of < l = x > => x | < r = y > => y))) in ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) , b = ({a = (if ({a = 0 , b = false }.b) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) else 0) , b = (let u = false in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) , c = ({a = 1 , b = true , c = 0 }.c) }.c) }.b))
(let u = (fix (\x: Bool . (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) )) ) ) (\a: Nat .\b: Unit .b)) )) in u)
({a = (if (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) in u) then (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (pred 0)) else (let u = (iszero 0) in (let u = ({a = 0 , b = true , c =  1 }.b) in 0))) , b = (if (let u = (((\x: Bool .\y: Unit .x) ({a = (let u = true in u) , b = 1 }.b) ) (let u = true in false)) in (( \f: Nat .((f (let u = 0 in false) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a))) then (( \f: Bool .((f (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Bool .x) (unfold [ Unit ] (fold [ Nat ] 0 )) ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b))) ) ) (\a: Bool .\b: Rec X. X .b)) else ({a = (let u = (fix (\x: Nat . 1 )) in u) , b = ({a = (let u = 0 in u) , b = true , c = 1 }.c) }.b)) }.b)
(( \f: Rec X. X .((f (fix (\x: Rec X. X . ({a = (let u = false in 1) , b = ({a = 1 , b = false }.a) }.b) )) ) (let u = (( \f: Unit .((f 1 ) ({a = true , b = 1 }.b) ) ) (\a: Nat .\b: Nat .b)) in u) ) ) (\a: Nat .\b: Unit .a))
({a = ({a = (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) ))) , b = ({a = (((\x: Unit .\y: Unit .x) 1 ) false) , b = (let u = 1 in u) }.b) }.a) , b = (fix (\x: Nat . (case <r = (if false then false else false) > as Bool of < l = x > => x | < r = y > => y) )) }.b)
(unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = (if false then (((\x: Unit .\y: Rec X. X .x) true ) false) else false) , b = ({a = 1 , b = 0 }.b) }.b) ) (pred (case <l = ({a = 0 , b = true , c = 1 }.c) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
({a = (( \f: Bool .((f (( \f: Bool .((f (fix (\x: Bool . 1 )) ) (fix (\x: Unit . 1 )) ) ) (\a: Bool .\b: Unit .a)) ) (fix (\x: Nat . (let u = 1 in u) )) ) ) (\a: Nat .\b: Nat .b)) , b = (case <r = ({a = (pred 0) , b = true , c =  ({a = false , b = 0 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (succ (let u = ({a = false , b = (fix (\x: Bool . 0 )) }.a) in (( \f: Unit .((f 0 ) (if true then 1 else 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)))) }.b)
(let u = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = false in (let u = true in u)) )) )) in u)
(let u = (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) ) (( \f: Nat .((f true ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .b))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = ({a = true , b = 1 }.a) in u) )) ) ) (\a: Unit .\b: Bool .b)) in (( \f: Unit .((f (let u = ({a = false , b = false }.b) in (iszero 1)) ) (((\x: Bool .\y: Nat .x) (unfold [ Bool ] (fold [ Unit ] true )) ) false) ) ) (\a: Unit .\b: Bool .a)))
(let u = (( \f: Unit .((f (iszero (fix (\x: Nat . ({a = 1 , b = false }.a) ))) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Nat .b)) in (unfold [ Unit ] (fold [ Nat ] (let u = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) in u) )))
(( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )) ) ) (\a: Unit .\b: Unit .b)) )) ) (( \f: Unit .((f ({a = (((\x: Rec X. X .\y: Unit .y) true ) false) , b = ({a = 0 , b = true }.a) }.b) ) (((\x: Bool .\y: Rec X. X .y) ({a = ({a = (let u = 0 in true) , b = 0 }.b) , b = (((\x: Unit .\y: Rec X. X .x) false ) false) , c =  (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b) ) (if (((\x: Nat .\y: Unit .y) (let u = true in u) ) false) then ({a = 1 , b = false , c = 1 }.c) else (let u = true in 0))) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Bool .\b: Unit .b))
({a = (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) )) )) , b = (let u = (iszero (((\x: Unit .\y: Rec X. X .x) 1 ) false)) in (((\x: Bool .\y: Bool .x) ({a = (iszero 1) , b = 0 }.a) ) (fix (\x: Unit . ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) )))) }.b)
(fix (\x: Rec X. X . ({a = (( \f: Unit .((f ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = false , c = 0 }.c) )) }.b) ) ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) , c = (let u = 1 in 0) }.c) ) ) (\a: Nat .\b: Unit .a)) , b = (unfold [ Nat ] (fold [ Unit ] (let u = true in u) )) }.b) ))
((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] (if false then 1 else 1) )) )) ))
(iszero (if (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in (iszero 0)) then ({a = 0 , b = 1 }.b) else (let u = (succ 1) in ({a = 1 , b = true }.a))))
((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (if (unfold [ Bool ] (fold [ Rec X. X ] (iszero 0) )) then ({a = ({a = (( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (let u = 1 in (if true then true else true)) , c =  (let u = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) }.b) , b = (case <r = (unfold [ Rec X. X ] (fold [ Unit ] false )) > as Nat of < l = x > => x | < r = y > => y) }.b) else (((\x: Nat .\y: Unit .x) (let u = ({a = 1 , b = true }.b) in (let u = true in true)) ) (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) in u))) ))
(case <r = ({a = (((\x: Bool .\y: Rec X. X .y) (let u = true in u) ) (((\x: Unit .\y: Bool .x) 0 ) false)) , b = ({a = (succ (pred 0)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) , c =  (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in u) }.b) > as Unit of < l = x > => x | < r = y > => y)
(iszero (pred ({a = ({a = 0 , b = true }.a) , b = (let u = 0 in 1) }.b)))
(fix (\x: Bool . (((\x: Nat .\y: Bool .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (fix (\x: Nat . false )) )) ) ({a = (succ 0) , b = (((\x: Rec X. X .\y: Nat .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) , c = ({a = true , b = 0 }.b) }.c)) ))
(if (if (let u = (let u = 0 in false) in u) then (let u = ({a = 0 , b = false }.b) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) else ({a = (if true then 0 else (let u = true in 1)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) }.b)) then ({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (pred 1)) , b = (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f ({a = 1 , b = true }.a) ) (((\x: Nat .\y: Rec X. X .y) true ) 1) ) ) (\a: Rec X. X .\b: Bool .b)) )) }.b) else (let u = (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . (( \f: Rec X. X .((f 0 ) (let u = 0 in 0) ) ) (\a: Nat .\b: Unit .b)) )) )) in (if ({a = ({a = true , b = 0 }.a) , b = (let u = true in true) }.b) then (pred 0) else (pred 1))))
({a = ({a = (unfold [ Bool ] (fold [ Unit ] (let u = false in 0) )) , b = ({a = (let u = 0 in false) , b = (let u = 0 in 1) }.a) , c =  (pred (((\x: Rec X. X .\y: Bool .y) true ) 0)) }.b) , b = (let u = (let u = (let u = 1 in u) in ({a = 1 , b = false , c =  0 }.b)) in (let u = (((\x: Bool .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) false) in u)) }.b)
(fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f (((\x: Nat .\y: Unit .y) false ) (let u = true in false)) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Bool .\b: Unit .b)) )) ))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Bool ] false )) ) (unfold [ Nat ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
({a = (unfold [ Bool ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = true }.b) )) )) , b = (let u = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) in (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .y) true ) true) ) 1)) }.a)
({a = (((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Bool .x) ({a = (((\x: Unit .\y: Rec X. X .y) false ) false) , b = ({a = false , b = 1 }.b) }.b) ) ({a = 0 , b = true }.b)) ) ({a = (if false then false else false) , b = (if (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) then (((\x: Nat .\y: Nat .x) true ) true) else false) }.b)) , b = (case <r = (let u = (let u = true in false) in (unfold [ Bool ] (fold [ Rec X. X ] false ))) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (fix (\x: Rec X. X . ({a = (fix (\x: Unit . (let u = 1 in 1) )) , b = ({a = 0 , b = false }.b) }.a) )) }.b)
(succ (let u = (case <r = ({a = 1 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) in ({a = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Unit .((f (succ 0) ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)))
({a = (( \f: Unit .((f ({a = (pred (succ 1)) , b = (let u = (((\x: Unit .\y: Bool .y) ({a = 0 , b = false , c =  1 }.b) ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b))) in (succ 0)) }.b) ) (((\x: Nat .\y: Bool .x) (fix (\x: Unit . (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true ))) ) ) (\a: Bool .\b: Nat .a)) , b = (if (let u = (let u = (((\x: Rec X. X .\y: Nat .x) false ) false) in ({a = 1 , b = false , c =  0 }.b)) in u) then (iszero ({a = 0 , b = 0 }.b)) else (iszero ({a = 0 , b = false , c = 0 }.c))) }.a)
({a = (((\x: Rec X. X .\y: Nat .y) (( \f: Unit .((f (((\x: Unit .\y: Bool .x) true ) true) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Bool .\b: Nat .b)) ) (let u = ({a = false , b = true }.b) in true)) , b = (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Bool .y) (case <r = (let u = false in false) > as Nat of < l = x > => x | < r = y > => y) ) (let u = true in u)) ) (let u = (if true then 1 else 1) in u)) }.a)
(if (((\x: Rec X. X .\y: Rec X. X .x) (let u = (if true then (let u = true in false) else false) in ({a = 0 , b = ({a = 0 , b = false }.b) }.b)) ) (( \f: Rec X. X .((f (let u = true in u) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Unit .b))) then (iszero (let u = (((\x: Nat .\y: Bool .y) false ) ({a = 1 , b = true }.a)) in u)) else (((\x: Unit .\y: Rec X. X .y) (fix (\x: Bool . ({a = 0 , b = true }.b) )) ) (((\x: Bool .\y: Bool .y) (((\x: Unit .\y: Rec X. X .y) true ) true) ) false)))
(iszero (let u = (((\x: Unit .\y: Nat .x) ({a = false , b = (((\x: Nat .\y: Nat .x) false ) true) }.b) ) (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) ) (unfold [ Rec X. X ] (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Nat .a))) in (fix (\x: Nat . (case <l = ({a = (let u = 1 in 1) , b = (if false then false else false) }.a) > as Nat of < l = x > => x | < r = y > => y) ))))
({a = (let u = ({a = (fix (\x: Bool . false )) , b = ({a = false , b = 0 }.a) }.b) in (pred (unfold [ Bool ] (fold [ Unit ] 1 )))) , b = (let u = (((\x: Bool .\y: Rec X. X .y) (if (iszero 0) then (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) else ({a = 1 , b = false , c =  1 }.b)) ) (if (let u = 0 in false) then (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) )) else (if (if false then false else false) then 1 else 1))) in (((\x: Nat .\y: Unit .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . true )) )) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y))) }.b)
(( \f: Unit .((f (pred (succ (( \f: Nat .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (pred 1) ) ) (\a: Rec X. X .\b: Bool .b)))) ) (pred (succ (let u = false in 0))) ) ) (\a: Unit .\b: Nat .a))
(if (unfold [ Rec X. X ] (fold [ Nat ] ({a = ({a = false , b = 0 }.a) , b = ({a = false , b = false }.b) }.b) )) then (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = true in true) )) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = false , b = ({a = 1 , b = true , c = 0 }.c) }.a) )) ) ) (\a: Unit .\b: Bool .b)) else ({a = (((\x: Rec X. X .\y: Unit .x) (fix (\x: Unit . (if false then true else false) )) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) false ) 1) ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (succ (((\x: Unit .\y: Nat .x) 0 ) true)) }.b) }.a))
({a = (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f (( \f: Rec X. X .((f false ) (let u = false in u) ) ) (\a: Nat .\b: Bool .b)) ) (let u = (let u = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) in (if true then false else true)) in u) ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (succ (if (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in u) )) then (((\x: Unit .\y: Unit .x) 0 ) (let u = false in u)) else (( \f: Rec X. X .((f (let u = 0 in u) ) 0 ) ) (\a: Bool .\b: Unit .a)))) }.b)
({a = ({a = (((\x: Nat .\y: Unit .x) ({a = ({a = 0 , b = false , c = 1 }.c) , b = 0 }.b) ) (((\x: Unit .\y: Unit .x) (iszero 1) ) (let u = false in u))) , b = ({a = (( \f: Bool .((f (let u = false in true) ) false ) ) (\a: Unit .\b: Unit .a)) , b = ({a = 1 , b = false }.b) }.b) , c =  ({a = (fix (\x: Unit . (let u = true in (((\x: Nat .\y: Nat .x) 1 ) true)) )) , b = (if (((\x: Unit .\y: Nat .x) true ) true) then (let u = true in false) else (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .a))) , c = ({a = 0 , b = 1 }.b) }.c) }.b) , b = ({a = ({a = ({a = (succ 0) , b = ({a = 0 , b = true }.b) , c = (if false then 1 else 1) }.c) , b = (let u = (((\x: Rec X. X .\y: Bool .y) false ) 1) in u) }.b) , b = (fix (\x: Rec X. X . (let u = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) in u) )) , c =  (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) in u) }.b) }.b)
(iszero (let u = ({a = (((\x: Rec X. X .\y: Unit .y) false ) 1) , b = (fix (\x: Unit . 1 )) }.b) in (let u = (pred 1) in u)))
(let u = (case <r = (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Nat .x) true ) false) ) (let u = ({a = 0 , b = true , c = 0 }.c) in ({a = true , b = false }.b))) > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (if false then 1 else (succ 0)) )))
(if (( \f: Unit .((f (( \f: Nat .((f (if ({a = true , b = true }.b) then ({a = 0 , b = false , c =  1 }.b) else false) ) (let u = true in false) ) ) (\a: Unit .\b: Bool .b)) ) ({a = (if true then true else false) , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) ) (\a: Nat .\b: Nat .a)) then ({a = (case <r = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f (if false then false else true) ) ({a = (unfold [ Unit ] (fold [ Bool ] true )) , b = (fix (\x: Unit . false )) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) else (let u = ({a = ({a = (fix (\x: Nat . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) )) , b = ({a = (((\x: Bool .\y: Bool .y) false ) true) , b = 1 }.a) , c =  ({a = 1 , b = false }.a) }.b) , b = (let u = (fix (\x: Nat . (unfold [ Bool ] (fold [ Bool ] true )) )) in ({a = true , b = 1 }.b)) }.b) in (((\x: Nat .\y: Nat .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (let u = true in false) in u))))
(((\x: Unit .\y: Bool .x) ({a = (fix (\x: Bool . (fix (\x: Bool . true )) )) , b = (let u = (((\x: Rec X. X .\y: Bool .y) false ) 1) in (( \f: Rec X. X .((f (if false then 1 else 0) ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) }.b) ) (case <r = (unfold [ Unit ] (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) false) , b = true }.b) )) > as Unit of < l = x > => x | < r = y > => y))
({a = (( \f: Nat .((f (case <l = (if false then 1 else 1) > as Nat of < l = x > => x | < r = y > => y) ) (succ (fix (\x: Unit . (if true then 1 else 1) ))) ) ) (\a: Unit .\b: Nat .b)) , b = (let u = ({a = ({a = 0 , b = 1 }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) }.b) in (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Nat .x) 1 ) true) ))) }.b)
(case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (succ (succ 1)) )) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (let u = ({a = ({a = 1 , b = true , c =  1 }.b) , b = ({a = 1 , b = false }.a) }.a) in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b))) ) (((\x: Nat .\y: Bool .y) (let u = ({a = 0 , b = ({a = false , b = 1 }.b) }.b) in (((\x: Rec X. X .\y: Nat .y) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) (iszero 0))) ) (case <r = (let u = (fix (\x: Nat . 0 )) in (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b))) > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Unit .b))
(unfold [ Bool ] (fold [ Bool ] (if (fix (\x: Bool . false )) then (((\x: Unit .\y: Unit .x) (let u = 1 in true) ) false) else ({a = 1 , b = false }.b)) ))
(unfold [ Bool ] (fold [ Unit ] ({a = (fix (\x: Unit . 1 )) , b = (if (((\x: Nat .\y: Unit .x) true ) false) then (unfold [ Unit ] (fold [ Rec X. X ] ({a = 1 , b = false }.b) )) else (iszero (fix (\x: Nat . 1 )))) }.b) ))
(((\x: Unit .\y: Unit .x) (let u = (succ (let u = true in (succ 0))) in (((\x: Bool .\y: Nat .y) (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b))) ) (pred (((\x: Bool .\y: Unit .x) 1 ) false)))) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) (let u = true in u) ) (let u = false in u)) )))
(case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Bool . (unfold [ Unit ] (fold [ Unit ] 1 )) )) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Nat .x) (iszero (pred (((\x: Unit .\y: Nat .y) true ) (((\x: Unit .\y: Bool .y) false ) 0)))) ) (( \f: Rec X. X .((f (case <r = ({a = false , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) ) ({a = ({a = false , b = false }.b) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Bool .\b: Nat .b)))
(( \f: Rec X. X .((f ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) )) , b = (((\x: Nat .\y: Bool .y) (let u = true in u) ) false) }.b) , b = (let u = (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) false) in u) }.b) ) (let u = (case <l = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) (((\x: Rec X. X .\y: Nat .y) true ) 1) ) ) (\a: Unit .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) in (let u = (let u = false in u) in u)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(iszero (( \f: Nat .((f (pred 1) ) (((\x: Unit .\y: Nat .y) (let u = false in u) ) 1) ) ) (\a: Unit .\b: Nat .a)))
(pred ({a = (((\x: Unit .\y: Nat .x) (if true then 0 else 0) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (let u = 0 in u) , b = ({a = 0 , b = false , c =  0 }.b) , c = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) }.c) }.b))
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] ({a = (unfold [ Bool ] (fold [ Unit ] ({a = true , b = 0 }.a) )) , b = (if true then 0 else 0) }.a) )) ))
(((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Nat .x) ({a = (if false then 1 else 0) , b = (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) )) }.b) ) (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y)) ) ({a = ({a = (let u = (if false then 1 else 1) in 0) , b = (case <r = (fix (\x: Rec X. X . false )) > as Unit of < l = x > => x | < r = y > => y) , c =  ({a = (succ 1) , b = ({a = 0 , b = false }.a) }.b) }.b) , b = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (pred 1) )) in ({a = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u) , b = ({a = false , b = 0 }.a) , c =  (pred 1) }.b)) }.b))
(let u = ({a = ({a = (fix (\x: Unit . 1 )) , b = ({a = 0 , b = false , c =  0 }.b) }.a) , b = ({a = (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) }.a) }.b) in (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (let u = false in ({a = 0 , b = false }.a)) )) in (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ))))
(((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Unit .x) (( \f: Nat .((f ({a = 1 , b = (((\x: Bool .\y: Nat .x) true ) false) }.b) ) (( \f: Nat .((f ({a = 0 , b = false , c =  1 }.b) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .b)) ) ({a = (case <l = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] false )) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .b)) , c =  (( \f: Bool .((f (((\x: Nat .\y: Unit .y) true ) 0) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Unit .a)) }.b)) ) (iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ))))
(iszero (unfold [ Rec X. X ] (fold [ Bool ] (pred (fix (\x: Bool . ({a = 1 , b = false }.a) ))) )))
({a = ({a = ({a = (( \f: Unit .((f ({a = 1 , b = 1 }.b) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Bool .b)) , b = (case <l = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (let u = (((\x: Nat .\y: Unit .y) true ) (iszero 1)) in ({a = ({a = 1 , b = 1 }.b) , b = true , c =  1 }.b)) }.b) , b = (fix (\x: Unit . (case <l = (( \f: Bool .((f ({a = 0 , b = true , c = 0 }.c) ) (((\x: Nat .\y: Rec X. X .y) true ) 1) ) ) (\a: Bool .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a)
(((\x: Unit .\y: Bool .y) ({a = (let u = (if true then 0 else 1) in u) , b = ({a = (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .x) 0 ) (let u = 0 in false)) )) , b = ({a = ({a = ({a = 0 , b = 1 }.b) , b = true , c =  0 }.b) , b = (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .b)) in false) }.b) , c =  (if ({a = false , b = false }.b) then 1 else 1) }.b) , c =  (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) )) ) ({a = 0 , b = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) , c = (((\x: Bool .\y: Bool .y) false ) 1) }.c) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) (let u = (let u = (unfold [ Unit ] (fold [ Nat ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) in u) in (( \f: Rec X. X .((f (let u = (pred 0) in true) ) ({a = true , b = 1 }.a) ) ) (\a: Unit .\b: Nat .a))))
({a = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f (let u = false in false) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (fix (\x: Nat . (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .b)) )) , b = (( \f: Nat .((f ({a = (succ 1) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) , c = ({a = 0 , b = false , c = 0 }.c) }.c) ) (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) ) (\a: Unit .\b: Unit .b)) }.a)) , b = (if (((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .a)) ) (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Nat .x) true ) false) ) false)) then (fix (\x: Nat . (if true then false else ({a = 0 , b = true , c =  1 }.b)) )) else ({a = (((\x: Nat .\y: Nat .y) ({a = 1 , b = false , c =  1 }.b) ) 1) , b = (( \f: Unit .((f (iszero ({a = false , b = 1 }.b)) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) , c =  (fix (\x: Nat . (let u = true in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) )) }.b)) }.b)
(( \f: Unit .((f (case <r = ({a = (unfold [ Nat ] (fold [ Bool ] ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) )) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ({a = ({a = false , b = 1 }.b) , b = (iszero (if false then 1 else 0)) , c =  (let u = (let u = 1 in 1) in u) }.b) ) ) (\a: Bool .\b: Bool .a))
(case <l = (( \f: Rec X. X .((f (if (if false then true else false) then ({a = 0 , b = true }.a) else ({a = (((\x: Unit .\y: Rec X. X .x) 0 ) false) , b = (let u = false in true) , c = (((\x: Rec X. X .\y: Bool .x) 1 ) false) }.c)) ) (succ (if (iszero 0) then (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) else (fix (\x: Unit . ({a = 0 , b = false , c = 1 }.c) )))) ) ) (\a: Bool .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Unit ] ({a = (fix (\x: Bool . (fix (\x: Bool . (((\x: Nat .\y: Unit .y) false ) true) )) )) , b = (case <l = ({a = (pred ({a = 0 , b = true , c = 0 }.c)) , b = (( \f: Unit .((f true ) (let u = true in false) ) ) (\a: Bool .\b: Rec X. X .a)) , c = (succ 1) }.c) > as Nat of < l = x > => x | < r = y > => y) }.a) ))
({a = (let u = ({a = (((\x: Unit .\y: Bool .y) (((\x: Nat .\y: Nat .x) true ) false) ) (unfold [ Bool ] (fold [ Rec X. X ] false ))) , b = ({a = 1 , b = (((\x: Rec X. X .\y: Nat .x) true ) true) , c = 1 }.c) }.b) in (let u = (let u = (( \f: Unit .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) false ) ) (\a: Unit .\b: Rec X. X .a)) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) in (succ (((\x: Nat .\y: Bool .x) 0 ) true)))) , b = (let u = (((\x: Unit .\y: Nat .y) (iszero 1) ) ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = ({a = true , b = 1 }.a) , c =  1 }.b)) in u) , c = (((\x: Rec X. X .\y: Bool .x) (let u = (let u = ({a = true , b = 0 }.b) in false) in (succ ({a = 1 , b = 1 }.b))) ) (((\x: Rec X. X .\y: Rec X. X .x) (let u = true in u) ) (let u = false in u))) }.c)
(((\x: Unit .\y: Bool .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = ({a = 1 , b = (iszero 1) , c = ({a = 0 , b = 0 }.b) }.c) , b = (((\x: Rec X. X .\y: Nat .y) true ) 0) }.b) )) ) (let u = (((\x: Nat .\y: Nat .y) (if true then false else true) ) false) in (case <r = ({a = 0 , b = false , c =  1 }.b) > as Nat of < l = x > => x | < r = y > => y)))
(let u = (iszero (((\x: Rec X. X .\y: Bool .x) (pred 0) ) (let u = (((\x: Rec X. X .\y: Bool .x) false ) true) in u))) in u)
({a = (fix (\x: Unit . (let u = 0 in u) )) , b = (let u = (unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .a)) )) in u) , c = (unfold [ Bool ] (fold [ Unit ] (succ 0) )) }.c)
({a = (fix (\x: Bool . (if (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true ))) then (let u = 1 in u) else (unfold [ Bool ] (fold [ Nat ] 0 ))) )) , b = (if (if (((\x: Nat .\y: Nat .x) true ) true) then (iszero (unfold [ Unit ] (fold [ Rec X. X ] 0 ))) else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) then (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = true , c =  0 }.b) )) else ({a = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.a)) , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (if ({a = 1 , b = true }.b) then (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) else (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = false }.a) ) (unfold [ Rec X. X ] (fold [ Bool ] true )))) )) }.c)
({a = (let u = (( \f: Nat .((f (let u = (pred 0) in u) ) (if (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in false) then (let u = 1 in u) else ({a = 0 , b = true }.a)) ) ) (\a: Unit .\b: Bool .b)) in u) , b = (let u = ({a = 0 , b = true }.b) in u) }.b)
(let u = (fix (\x: Rec X. X . (case <r = (let u = 0 in false) > as Rec X. X of < l = x > => x | < r = y > => y) )) in u)
(case <r = (((\x: Rec X. X .\y: Nat .y) (case <r = (fix (\x: Bool . ({a = 0 , b = true }.b) )) > as Unit of < l = x > => x | < r = y > => y) ) (if (let u = false in (let u = true in u)) then ({a = true , b = false }.b) else (if false then true else false))) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Unit .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = (((\x: Bool .\y: Bool .y) true ) false) in (let u = false in true)) )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (succ (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false)) )))
(fix (\x: Rec X. X . (fix (\x: Bool . (let u = (((\x: Rec X. X .\y: Bool .x) 0 ) true) in u) )) ))
(let u = (((\x: Rec X. X .\y: Nat .y) ({a = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (iszero 1) )) ) ({a = 0 , b = true }.b) ) ) (\a: Bool .\b: Unit .a)) , b = (let u = (unfold [ Bool ] (fold [ Nat ] 0 )) in u) }.a) ) (let u = (if false then true else (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a))) in (iszero ({a = (fix (\x: Unit . true )) , b = (((\x: Bool .\y: Nat .x) 1 ) true) }.b)))) in u)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (case <l = ({a = true , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (pred 1) ) ({a = true , b = 1 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) ))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (((\x: Nat .\y: Bool .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = true , b = 1 }.a) )) ) (( \f: Nat .((f ({a = 1 , b = false , c =  1 }.b) ) true ) ) (\a: Unit .\b: Rec X. X .a))) in (pred ({a = true , b = 0 }.b))) ))
(unfold [ Nat ] (fold [ Nat ] ({a = (if (((\x: Nat .\y: Bool .y) (if false then true else true) ) false) then (case <l = ({a = 1 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) else (case <l = ({a = 0 , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = ({a = 1 , b = false , c =  (let u = false in 0) }.b) }.a) , b = (let u = true in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false ))) }.b) , c =  (( \f: Rec X. X .((f (let u = ({a = ({a = 0 , b = 0 }.b) , b = true , c = 1 }.c) in ({a = 1 , b = false }.a)) ) (case <l = (let u = false in 1) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) }.b) ))
(let u = (( \f: Rec X. X .((f (succ 0) ) (( \f: Bool .((f (let u = 0 in u) ) (if false then 0 else (let u = true in 1)) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a)) in u)
({a = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = false , b = 0 }.a) )) , b = (let u = (( \f: Rec X. X .((f 1 ) ({a = 1 , b = 1 }.b) ) ) (\a: Nat .\b: Rec X. X .b)) in u) }.b) , b = (if (iszero 1) then ({a = (pred 0) , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.a) else (( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) ) (succ ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 ))) ) ) (\a: Nat .\b: Rec X. X .a))) }.b)
(pred (pred (succ ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = ({a = 1 , b = true , c =  0 }.b) , c = ({a = 1 , b = 1 }.b) }.c))))
({a = (let u = (let u = (let u = 0 in true) in ({a = 0 , b = ({a = 0 , b = false }.b) , c =  ({a = 1 , b = 1 }.b) }.b)) in (if (let u = (fix (\x: Bool . 1 )) in true) then ({a = 0 , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) }.a) else (((\x: Rec X. X .\y: Bool .x) 1 ) (fix (\x: Bool . false ))))) , b = ({a = (let u = (((\x: Bool .\y: Rec X. X .y) false ) true) in u) , b = (((\x: Nat .\y: Unit .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true , c =  1 }.b)) }.a) , c = (((\x: Nat .\y: Rec X. X .y) ({a = (iszero (((\x: Unit .\y: Bool .y) true ) 1)) , b = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (iszero 1) }.b) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = false in 0) ))) }.c)
({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = ({a = (((\x: Nat .\y: Bool .y) false ) 1) , b = ({a = true , b = 0 }.a) }.a) in (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Rec X. X .\y: Unit .y) true ) 0) ))) )) , b = (((\x: Unit .\y: Nat .y) ({a = (((\x: Bool .\y: Nat .y) false ) 0) , b = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in false) }.b) ) (let u = (let u = 1 in false) in (let u = false in false))) , c =  ({a = (( \f: Unit .((f 0 ) (((\x: Nat .\y: Bool .y) true ) 0) ) ) (\a: Unit .\b: Bool .b)) , b = ({a = ({a = false , b = false }.b) , b = (( \f: Nat .((f (fix (\x: Unit . 1 )) ) 0 ) ) (\a: Unit .\b: Unit .a)) }.b) }.b) }.b)
({a = ({a = (let u = true in u) , b = ({a = (let u = false in false) , b = (succ 0) }.b) }.b) , b = ({a = (((\x: Nat .\y: Bool .x) true ) true) , b = (case <r = (((\x: Rec X. X .\y: Unit .x) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , c = (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Bool .y) true ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) ) (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) in ({a = 0 , b = false , c =  1 }.b))) }.c)
({a = (((\x: Rec X. X .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) )) ) (fix (\x: Rec X. X . (let u = ({a = false , b = 0 }.a) in u) ))) , b = (let u = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 )) in (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .b))) in (( \f: Unit .((f (fix (\x: Unit . false )) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b))) }.b)
({a = ({a = ({a = (iszero 0) , b = (let u = false in 0) }.b) , b = (case <l = (((\x: Nat .\y: Unit .y) ({a = false , b = true }.b) ) 0) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = true in 0) )) , b = (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 ))) }.b) }.b)
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (fix (\x: Unit . ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = ({a = 1 , b = false }.a) }.b) )) , b = (( \f: Nat .((f (( \f: Bool .((f (if true then false else false) ) ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) }.b) ))
(((\x: Unit .\y: Bool .y) ({a = (case <l = ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Rec X. X .y) true ) true) , c = 1 }.c) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Bool ] ({a = true , b = true }.b) )) }.b) ) (let u = (unfold [ Bool ] (fold [ Nat ] (let u = true in u) )) in u))
(unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . (iszero (fix (\x: Rec X. X . (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) ))) )) ))
(( \f: Nat .((f ({a = (let u = (let u = 0 in 0) in u) , b = (let u = (succ ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) in (iszero 1)) , c = (let u = (((\x: Nat .\y: Bool .x) 1 ) (((\x: Bool .\y: Rec X. X .x) true ) false)) in ({a = false , b = (let u = 1 in u) }.b)) }.c) ) ({a = (if (let u = 1 in false) then (unfold [ Unit ] (fold [ Unit ] 1 )) else 1) , b = (((\x: Unit .\y: Bool .y) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) (((\x: Unit .\y: Nat .x) true ) ({a = false , b = false }.b))) }.a) ) ) (\a: Nat .\b: Bool .b))
(iszero (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f (let u = 0 in 0) ) (unfold [ Nat ] (fold [ Unit ] 1 )) ) ) (\a: Bool .\b: Unit .b)) )))
(((\x: Bool .\y: Bool .y) ({a = (unfold [ Nat ] (fold [ Bool ] ({a = (let u = 1 in 1) , b = (((\x: Rec X. X .\y: Unit .x) false ) false) }.a) )) , b = (unfold [ Unit ] (fold [ Bool ] (fix (\x: Bool . false )) )) , c =  ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) , b = (((\x: Bool .\y: Unit .x) false ) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b))) , c = (let u = (let u = (((\x: Bool .\y: Bool .x) true ) false) in (((\x: Bool .\y: Bool .x) true ) true)) in (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))) }.c) }.b) ) (( \f: Rec X. X .((f (let u = (if true then true else true) in u) ) (let u = 1 in (fix (\x: Rec X. X . false ))) ) ) (\a: Nat .\b: Rec X. X .b)))
({a = (pred ({a = (((\x: Unit .\y: Unit .y) (if false then true else false) ) (let u = (((\x: Unit .\y: Rec X. X .x) 0 ) false) in u)) , b = (((\x: Unit .\y: Nat .x) false ) true) }.a)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) (( \f: Unit .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = false in u)) )) , c = (( \f: Nat .((f (( \f: Unit .((f (succ 1) ) (pred 1) ) ) (\a: Unit .\b: Bool .b)) ) (fix (\x: Bool . (let u = false in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) )) ) ) (\a: Bool .\b: Nat .b)) }.c)
(( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Unit .x) ({a = true , b = 0 }.b) ) (case <r = (if false then true else false) > as Unit of < l = x > => x | < r = y > => y)) ) (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in (iszero 0))) ) (if ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 0 in u) }.a) then (( \f: Bool .((f (succ 1) ) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = true , c = (if false then 1 else 1) }.c) ) ) (\a: Unit .\b: Rec X. X .b)) else ({a = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = true }.a) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.a)) ) ) (\a: Nat .\b: Nat .a))
(( \f: Bool .((f (case <l = (fix (\x: Unit . (pred 1) )) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (if (((\x: Unit .\y: Unit .y) ({a = true , b = 0 }.a) ) true) then (let u = true in (fix (\x: Unit . true ))) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) , b = (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Unit . 1 )) )) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(( \f: Bool .((f (if (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .a)) in u) then (((\x: Unit .\y: Bool .y) ({a = true , b = 0 }.a) ) ({a = (((\x: Bool .\y: Rec X. X .y) false ) true) , b = (unfold [ Bool ] (fold [ Nat ] 0 )) }.b)) else (( \f: Nat .((f ({a = 0 , b = (if true then true else true) }.a) ) (if false then (if true then 1 else 1) else 0) ) ) (\a: Bool .\b: Unit .a))) ) (((\x: Nat .\y: Rec X. X .x) (case <l = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) ) (if (iszero 1) then (((\x: Unit .\y: Unit .y) true ) true) else (iszero (let u = false in 1)))) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = (case <l = (case <l = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) in u) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in (( \f: Unit .((f (fix (\x: Nat . (fix (\x: Bool . true )) )) ) ({a = true , b = (((\x: Rec X. X .\y: Bool .y) false ) 0) }.a) ) ) (\a: Rec X. X .\b: Nat .a)))
(let u = (succ (( \f: Unit .((f ({a = 0 , b = true }.a) ) (((\x: Unit .\y: Bool .x) 1 ) true) ) ) (\a: Rec X. X .\b: Bool .a))) in (((\x: Bool .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . true ))) ) (let u = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) in u)))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (if (iszero ({a = 1 , b = false }.a)) then (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) in (iszero 0)) else (((\x: Bool .\y: Unit .x) (unfold [ Unit ] (fold [ Nat ] false )) ) false)) )) , b = (((\x: Rec X. X .\y: Bool .y) (let u = true in false) ) (( \f: Bool .((f (let u = 1 in u) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .b))) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (let u = ({a = (let u = 0 in true) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) }.a) in (((\x: Unit .\y: Bool .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) ) 0)) , b = (case <r = (case <r = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , c = (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) ({a = ({a = true , b = false }.b) , b = 0 }.b)) }.c) ))
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (if (unfold [ Bool ] (fold [ Bool ] (let u = 0 in true) )) then ({a = (if false then 1 else 1) , b = (if false then 0 else 1) }.b) else (let u = false in 0)) )) , b = (fix (\x: Bool . (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = false , b = 1 }.a)) )) }.b)
(( \f: Rec X. X .((f ({a = (succ 0) , b = (let u = (let u = 0 in 0) in false) , c = (if (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b)) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) else (fix (\x: Nat . 1 ))) }.c) ) (pred (( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) (succ 1) ) ) (\a: Unit .\b: Bool .a))) ) ) (\a: Bool .\b: Unit .a))
(let u = (( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = (let u = true in 1) , b = 1 }.b) ) (( \f: Rec X. X .((f (fix (\x: Rec X. X . 0 )) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Bool .\b: Nat .b)) ) (((\x: Nat .\y: Unit .x) (pred (pred ({a = 1 , b = true }.a))) ) (iszero 0)) ) ) (\a: Bool .\b: Bool .b)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = true , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) )))
({a = (((\x: Nat .\y: Nat .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero 1) )) ) ({a = (if true then false else true) , b = true }.b)) , b = (succ (( \f: Bool .((f ({a = false , b = (((\x: Unit .\y: Rec X. X .x) 0 ) true) }.b) ) (((\x: Bool .\y: Nat .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . true ))) ) ) (\a: Nat .\b: Nat .b))) }.a)
(( \f: Bool .((f (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Unit . false )) )) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .x) (((\x: Unit .\y: Bool .x) (unfold [ Nat ] (fold [ Bool ] ({a = false , b = false }.b) )) ) (let u = false in u)) ) (let u = (if true then 0 else 1) in ({a = ({a = 0 , b = false }.b) , b = 0 }.a))) ) ) (\a: Bool .\b: Unit .a))
(unfold [ Bool ] (fold [ Nat ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = false , b = 0 }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , c = (((\x: Nat .\y: Bool .y) ({a = 1 , b = true , c =  1 }.b) ) 1) }.c) )) ))
({a = ({a = (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) , b = ({a = (( \f: Unit .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Bool .a)) , b = (((\x: Unit .\y: Unit .y) true ) 1) }.b) }.b) , b = (( \f: Nat .((f (if (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) then ({a = (((\x: Unit .\y: Bool .y) false ) 1) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) else ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) true) , b = ({a = ({a = true , b = 0 }.b) , b = false , c =  0 }.b) }.b)) ) ({a = ({a = 1 , b = true }.b) , b = ({a = ({a = (iszero 1) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) }.a) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) }.b) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) , c =  (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Unit . (let u = true in 1) )) )) in u) }.b)
(((\x: Bool .\y: Unit .x) (let u = (( \f: Rec X. X .((f (let u = true in false) ) false ) ) (\a: Rec X. X .\b: Bool .a)) in u) ) (iszero ({a = (succ (unfold [ Bool ] (fold [ Nat ] 0 ))) , b = (iszero (((\x: Nat .\y: Bool .x) 0 ) true)) , c = (case <l = ({a = (((\x: Bool .\y: Bool .x) 1 ) true) , b = ({a = 0 , b = true , c =  0 }.b) , c = (fix (\x: Nat . 1 )) }.c) > as Nat of < l = x > => x | < r = y > => y) }.c)))
(if (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) > as Unit of < l = x > => x | < r = y > => y) then ({a = (let u = (let u = 1 in u) in u) , b = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Rec X. X .\y: Unit .y) true ) 0) , b = true , c =  0 }.b) }.b) }.a) else ({a = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = true , c = 0 }.c) }.b) , b = ({a = ({a = 1 , b = false }.a) , b = (((\x: Bool .\y: Bool .y) true ) false) }.b) , c = (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) (pred 1) ) ) (\a: Nat .\b: Bool .b)) }.c))
(((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b)) ) ({a = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) in (pred 1)) , b = (if (if false then false else true) then (let u = (if false then 1 else 0) in (unfold [ Bool ] (fold [ Unit ] 0 ))) else (let u = ({a = 0 , b = 1 }.b) in u)) }.b))
(let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (succ (fix (\x: Bool . 0 ))) )) in (case <r = (iszero ({a = (let u = true in 1) , b = ({a = true , b = 0 }.b) }.b)) > as Unit of < l = x > => x | < r = y > => y))
(fix (\x: Nat . (( \f: Bool .((f (let u = (unfold [ Bool ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) )) in (fix (\x: Nat . false ))) ) (((\x: Bool .\y: Nat .y) ({a = ({a = true , b = true }.b) , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) ) ({a = ({a = 1 , b = 1 }.b) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b)) ) ) (\a: Unit .\b: Rec X. X .b)) ))
(( \f: Nat .((f (((\x: Nat .\y: Nat .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Unit .y) false ) false) )) ) (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u)) ) (let u = (iszero (((\x: Nat .\y: Bool .x) 0 ) true)) in (unfold [ Bool ] (fold [ Rec X. X ] (case <r = (let u = false in u) > as Nat of < l = x > => x | < r = y > => y) ))) ) ) (\a: Bool .\b: Bool .b))
(((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Unit .y) ({a = (if true then 0 else 0) , b = true }.b) ) (let u = ({a = 1 , b = false , c =  0 }.b) in 0)) ) (( \f: Rec X. X .((f (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = 0 in u) )) in (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a))) ) (((\x: Rec X. X .\y: Nat .x) true ) false) ) ) (\a: Rec X. X .\b: Bool .a)))
({a = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (if true then 0 else 1) )) ) (unfold [ Unit ] (fold [ Unit ] ({a = ({a = 0 , b = true }.b) , b = 0 }.b) )) ) ) (\a: Unit .\b: Unit .a)) , b = (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then true else false) )) > as Bool of < l = x > => x | < r = y > => y) , c =  (let u = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = ({a = 0 , b = true }.b) }.b) in ({a = true , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.b)) }.b)
(let u = ({a = (unfold [ Bool ] (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) )) , b = (let u = ({a = 1 , b = 1 }.b) in u) }.b) in (((\x: Bool .\y: Nat .y) (if (unfold [ Unit ] (fold [ Rec X. X ] true )) then ({a = false , b = 1 }.a) else (iszero ({a = 0 , b = 0 }.b))) ) ({a = (succ 0) , b = ({a = 1 , b = true }.b) }.a)))
({a = (let u = ({a = (((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Unit .x) false ) true) ) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b))) , b = (pred (((\x: Nat .\y: Nat .y) false ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)))) }.b) in (pred (unfold [ Unit ] (fold [ Rec X. X ] (succ 0) )))) , b = ({a = (pred (if ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) then 0 else (((\x: Nat .\y: Unit .y) false ) 0))) , b = (iszero (succ (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = true }.a) )))) , c =  ({a = (pred (let u = 0 in u)) , b = (let u = ({a = (let u = false in u) , b = (let u = 1 in 0) }.a) in (((\x: Unit .\y: Nat .x) true ) false)) , c = ({a = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , b = 1 }.b) }.c) }.b) }.b)
(if (((\x: Unit .\y: Bool .x) (( \f: Unit .((f (let u = true in u) ) (fix (\x: Unit . true )) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) (let u = 1 in false)) , b = (if ({a = 1 , b = true }.b) then (succ 0) else 1) }.a)) then (let u = ({a = (iszero (let u = 0 in u)) , b = (fix (\x: Unit . (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Nat ] 0 )) )) )) }.b) in ({a = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) )) }.b) , b = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 0 , b = false }.a) )) in ({a = true , b = true }.b)) }.a)) else ({a = ({a = ({a = true , b = 1 }.a) , b = ({a = true , b = 1 }.b) }.b) , b = (fix (\x: Unit . 1 )) }.b))
(((\x: Rec X. X .\y: Unit .x) (iszero (let u = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 0 in true) , c = (let u = (let u = 0 in 1) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.c) in (pred (pred 1)))) ) (case <r = ({a = (((\x: Unit .\y: Rec X. X .x) 0 ) ({a = true , b = 1 }.a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (iszero 1) ) (unfold [ Unit ] (fold [ Bool ] false ))) , c =  ({a = false , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
({a = (if (((\x: Rec X. X .\y: Unit .y) (fix (\x: Bool . false )) ) (let u = 0 in false)) then (succ (pred 0)) else ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = (((\x: Bool .\y: Nat .y) true ) true) }.a)) , b = (( \f: Unit .((f (let u = ({a = false , b = 0 }.a) in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b))) ) (let u = (fix (\x: Nat . true )) in (fix (\x: Unit . 1 ))) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)
(let u = ({a = (( \f: Bool .((f (((\x: Nat .\y: Bool .x) (if false then false else true) ) true) ) (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) , b = (succ (fix (\x: Nat . 1 ))) }.a) in (let u = (( \f: Bool .((f 0 ) (pred 0) ) ) (\a: Unit .\b: Bool .b)) in (succ ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) )))))
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = ({a = true , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) )) , b = (let u = ({a = (((\x: Unit .\y: Rec X. X .x) (let u = 0 in true) ) (let u = false in u)) , b = ({a = true , b = (((\x: Unit .\y: Bool .y) false ) 0) }.b) }.b) in u) }.b)
(let u = (case <l = (let u = ({a = 1 , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)) }.a) in u) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(pred (((\x: Bool .\y: Rec X. X .x) ({a = (pred 0) , b = ({a = ({a = 0 , b = true }.a) , b = true , c =  (((\x: Rec X. X .\y: Bool .y) false ) 1) }.b) }.a) ) (fix (\x: Unit . ({a = false , b = 0 }.a) ))))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f ({a = (fix (\x: Rec X. X . 1 )) , b = 1 }.b) ) (pred (if false then 1 else (fix (\x: Unit . 1 )))) ) ) (\a: Rec X. X .\b: Bool .b)) ))
(if (if (unfold [ Bool ] (fold [ Nat ] (( \f: Nat .((f false ) (((\x: Nat .\y: Rec X. X .x) false ) false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) then (fix (\x: Bool . ({a = (let u = true in 1) , b = (let u = true in false) }.b) )) else (( \f: Unit .((f (if true then false else true) ) (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) false ) true) )) ) ) (\a: Nat .\b: Bool .b))) then ({a = (((\x: Unit .\y: Bool .y) (let u = true in u) ) (((\x: Bool .\y: Nat .x) 0 ) false)) , b = (succ (fix (\x: Bool . (let u = (succ 0) in u) ))) }.b) else (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) (if true then 0 else 0)) ) (fix (\x: Rec X. X . (succ 0) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) in u) )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (if (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Bool .y) false ) false) ) (((\x: Nat .\y: Unit .y) true ) false)) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) else ({a = 0 , b = (let u = false in false) , c = 1 }.c)) , b = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (let u = true in u) }.b) }.a) )) ) ) (\a: Unit .\b: Nat .a))
(fix (\x: Bool . (fix (\x: Rec X. X . (( \f: Nat .((f ({a = (let u = true in u) , b = (let u = (((\x: Unit .\y: Bool .x) true ) false) in 1) }.a) ) (( \f: Rec X. X .((f (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) (let u = (unfold [ Unit ] (fold [ Bool ] false )) in u) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .a)) )) ))
(case <l = (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) true ) (if true then 0 else 1)) ) ({a = 0 , b = ({a = 0 , b = false , c = 0 }.c) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y)
(if ({a = (let u = (if false then 0 else 0) in (unfold [ Nat ] (fold [ Nat ] false ))) , b = (let u = (succ 1) in (let u = 0 in true)) }.b) then ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .y) (( \f: Unit .((f true ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = ({a = 0 , b = true }.a) , b = (((\x: Bool .\y: Unit .y) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ) ({a = 0 , b = 1 }.b)) }.b)) )) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (let u = ({a = 1 , b = true }.b) in u) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )))
(((\x: Unit .\y: Rec X. X .y) ({a = (let u = ({a = 1 , b = ({a = true , b = false }.b) , c = ({a = 0 , b = false }.a) }.c) in (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b))) , b = ({a = (if false then false else false) , b = ({a = ({a = 0 , b = true }.a) , b = false , c =  (let u = 0 in u) }.b) }.b) , c =  (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) in u) }.b) ) (( \f: Bool .((f ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = true }.b) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .b)))
(((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Bool .x) (succ ({a = false , b = ({a = 1 , b = true , c = 0 }.c) }.b)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (if false then 1 else 1) , b = (fix (\x: Unit . false )) , c =  1 }.b) ))) ) ({a = (( \f: Nat .((f (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) ) ({a = (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = (let u = false in u) }.a) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) true ) true) )) ) (if (iszero 0) then (fix (\x: Unit . false )) else (let u = false in u)) ) ) (\a: Rec X. X .\b: Nat .a)) , c =  (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) (((\x: Nat .\y: Bool .y) true ) 1) ) ) (\a: Bool .\b: Nat .a)) }.b))
(fix (\x: Bool . ({a = (let u = (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = 1 }.b) )) in u) , b = ({a = 0 , b = (iszero 0) }.b) }.a) ))
({a = ({a = ({a = (let u = (succ 1) in u) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = (if true then 1 else 1) }.b) }.b) , b = (( \f: Bool .((f ({a = true , b = (((\x: Unit .\y: Unit .y) true ) false) }.b) ) (((\x: Rec X. X .\y: Nat .x) (let u = false in true) ) (let u = true in false)) ) ) (\a: Bool .\b: Nat .a)) , c = ({a = (let u = 0 in (if false then 1 else 1)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.b) }.c) , b = ({a = ({a = (unfold [ Unit ] (fold [ Bool ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f true ) (let u = 0 in true) ) ) (\a: Unit .\b: Unit .b)) }.a) , b = (( \f: Nat .((f (((\x: Unit .\y: Nat .x) ({a = 1 , b = false }.b) ) (let u = 0 in (unfold [ Bool ] (fold [ Unit ] true )))) ) ({a = ({a = true , b = (let u = true in 0) }.a) , b = ({a = 0 , b = 1 }.b) }.a) ) ) (\a: Bool .\b: Rec X. X .b)) , c = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) (if true then false else true)) ) (((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Bool .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) 1) ) (if (unfold [ Unit ] (fold [ Unit ] false )) then true else (let u = true in u))) ) ) (\a: Bool .\b: Unit .a)) }.c) }.b)
({a = (( \f: Nat .((f (fix (\x: Bool . ({a = 1 , b = false }.a) )) ) ({a = (if true then false else false) , b = ({a = 1 , b = true , c = 1 }.c) }.b) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Nat .((f ({a = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) true ) ) (\a: Bool .\b: Nat .a)) , b = (succ 1) }.a) ) ({a = (let u = (((\x: Rec X. X .\y: Bool .x) true ) true) in u) , b = (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Nat .\b: Bool .b)) }.a) ) ) (\a: Rec X. X .\b: Nat .a)) , c = (unfold [ Nat ] (fold [ Bool ] (pred ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = 1 }.b)) )) }.c)
({a = (fix (\x: Nat . ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (pred (((\x: Bool .\y: Rec X. X .y) true ) 0)) )) )) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in u) )) }.a)
(fix (\x: Unit . ({a = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = (case <r = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) in (( \f: Bool .((f (if false then true else false) ) (iszero 0) ) ) (\a: Unit .\b: Unit .a))) , c =  (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = false , c =  (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.b) ) (fix (\x: Unit . (succ 0) ))) }.b) ))
(( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] ({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) , b = (if false then 1 else 0) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = (unfold [ Bool ] (fold [ Bool ] 1 )) in true) , c = (succ 0) }.c) )) ) (((\x: Nat .\y: Rec X. X .x) (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Nat .((f false ) (let u = 0 in true) ) ) (\a: Unit .\b: Nat .a))) ) ) (\a: Bool .\b: Nat .b))
(case <r = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) true ) ) (\a: Nat .\b: Bool .a)) , c =  ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) ({a = 0 , b = true , c =  1 }.b) ) 1) )) }.b) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Nat .y) (let u = ({a = 1 , b = true , c = 0 }.c) in (let u = (let u = true in 0) in ({a = 1 , b = false }.b))) ) (case <r = ({a = 1 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y)) ) ({a = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (pred 1) }.b) , b = ({a = (succ 1) , b = true , c =  ({a = 1 , b = true , c = 1 }.c) }.b) , c =  (let u = 0 in 0) }.b))
(((\x: Unit .\y: Nat .x) (( \f: Rec X. X .((f (let u = (pred 1) in u) ) ({a = (( \f: Nat .((f (pred 1) ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (if (let u = true in u) then 1 else ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 ))) }.b) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Bool .\y: Nat .y) ({a = (if (((\x: Unit .\y: Rec X. X .y) false ) false) then false else false) , b = (if true then (let u = 0 in u) else 1) }.a) ) (unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f (let u = true in true) ) true ) ) (\a: Nat .\b: Nat .a)) ))))
(iszero (let u = (fix (\x: Unit . (succ 0) )) in ({a = (let u = ({a = 1 , b = false }.b) in u) , b = (let u = (let u = (pred 0) in (succ 0)) in (if true then 0 else 0)) }.b)))
(( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) ) (((\x: Rec X. X .\y: Bool .x) ({a = true , b = false }.b) ) (unfold [ Unit ] (fold [ Rec X. X ] true ))) ) ) (\a: Unit .\b: Rec X. X .b)) )) ) (fix (\x: Nat . (((\x: Unit .\y: Rec X. X .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) ) (((\x: Unit .\y: Unit .x) (if false then false else (let u = 1 in true)) ) (let u = 0 in false))) )) ) ) (\a: Bool .\b: Bool .b))
({a = (if (if (unfold [ Unit ] (fold [ Bool ] false )) then (((\x: Nat .\y: Nat .y) (let u = true in true) ) false) else (if true then false else true)) then (( \f: Nat .((f ({a = (let u = 1 in false) , b = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.a) ) ({a = (case <r = (fix (\x: Nat . true )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = true , b = true }.b) ) true ) ) (\a: Nat .\b: Rec X. X .a)) }.b) ) ) (\a: Nat .\b: Nat .a)) else (((\x: Unit .\y: Rec X. X .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = true , b = false }.b) )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (iszero 1) )))) , b = (( \f: Bool .((f (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) in u) in u) ) ({a = ({a = false , b = 0 }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.b) ) ) (\a: Nat .\b: Unit .b)) }.b)
({a = (((\x: Unit .\y: Nat .x) ({a = (unfold [ Nat ] (fold [ Unit ] false )) , b = ({a = ({a = 1 , b = 0 }.b) , b = false , c =  (unfold [ Nat ] (fold [ Nat ] 0 )) }.b) }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) , b = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) ({a = 1 , b = false }.a)) , b = ({a = 0 , b = true }.b) }.a) )) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = (((\x: Rec X. X .\y: Bool .y) false ) false) , c =  (succ 0) }.b) }.a) }.b)
({a = (((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f true ) (((\x: Nat .\y: Unit .x) false ) true) ) ) (\a: Bool .\b: Nat .a)) ) (let u = true in u)) ) (((\x: Rec X. X .\y: Nat .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) ({a = 1 , b = (fix (\x: Rec X. X . false )) }.b))) , b = (unfold [ Bool ] (fold [ Nat ] (let u = false in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) )) }.b)
({a = (iszero ({a = (fix (\x: Rec X. X . 1 )) , b = false , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c)) , b = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) 0 ) (((\x: Rec X. X .\y: Bool .x) true ) true)) ) (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) true ) 0) ) ({a = 0 , b = false }.a) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .a)) }.b)
(((\x: Unit .\y: Nat .x) (( \f: Bool .((f ({a = (case <l = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) , c =  (( \f: Rec X. X .((f (let u = 0 in 0) ) 1 ) ) (\a: Bool .\b: Unit .a)) }.b) ) (case <r = (( \f: Unit .((f ({a = false , b = 0 }.a) ) (((\x: Unit .\y: Rec X. X .x) (((\x: Nat .\y: Unit .x) true ) true) ) false) ) ) (\a: Nat .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) ) (let u = (( \f: Rec X. X .((f ({a = 1 , b = false }.a) ) (succ 0) ) ) (\a: Rec X. X .\b: Nat .b)) in (fix (\x: Unit . ({a = true , b = true }.b) ))))
(fix (\x: Unit . (if ({a = (succ ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = false }.a)) , b = (unfold [ Bool ] (fold [ Unit ] (let u = 1 in true) )) , c =  (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .x) 1 ) false) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) then (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f true ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (let u = 0 in true) , b = ({a = 0 , b = false , c =  0 }.b) }.b)) else (let u = ({a = 1 , b = 1 }.b) in (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then (((\x: Nat .\y: Unit .y) false ) true) else false))) ))
({a = ({a = (((\x: Nat .\y: Nat .y) false ) true) , b = (( \f: Nat .((f ({a = 1 , b = true }.b) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) , b = (( \f: Rec X. X .((f ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , c = (((\x: Bool .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) (succ 0)) }.c) ) ({a = ({a = (succ (let u = 0 in u)) , b = ({a = true , b = ({a = 0 , b = 0 }.b) }.a) , c = (succ 1) }.c) , b = (if (iszero 1) then (let u = ({a = 0 , b = true }.a) in ({a = 1 , b = true , c =  1 }.b)) else (unfold [ Unit ] (fold [ Unit ] true ))) , c = (( \f: Bool .((f (pred 1) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a)
(succ (unfold [ Nat ] (fold [ Rec X. X ] ({a = ({a = 0 , b = ({a = 1 , b = true , c =  0 }.b) }.b) , b = (( \f: Unit .((f 0 ) ({a = 0 , b = false }.a) ) ) (\a: Nat .\b: Unit .b)) }.b) )))
(pred ({a = (case <l = (let u = (let u = 1 in 1) in u) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) , b = (let u = true in 1) }.b) }.b))
(unfold [ Rec X. X ] (fold [ Nat ] ({a = ({a = 1 , b = true }.a) , b = (let u = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)) in (iszero 1)) }.a) ))
(( \f: Unit .((f ({a = ({a = 0 , b = (if true then 0 else 0) }.b) , b = (( \f: Nat .((f (( \f: Bool .((f ({a = false , b = true }.b) ) (if false then false else true) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = 0 , b = (let u = 1 in false) , c =  0 }.b) ) ) (\a: Unit .\b: Nat .a)) , c = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (let u = 1 in 1) }.b) }.c) ) (case <l = (let u = (succ 0) in u) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a))
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (succ 1) )) in ({a = ({a = (let u = true in u) , b = (let u = 0 in 1) }.b) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) }.b))
(unfold [ Unit ] (fold [ Unit ] (let u = ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , c =  ({a = 0 , b = false }.a) }.b) in (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) , b = ({a = true , b = (let u = true in 0) }.a) , c =  ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = true , c = 0 }.c) }.b) in (((\x: Bool .\y: Bool .y) ({a = ({a = 1 , b = true }.a) , b = true }.b) ) (((\x: Nat .\y: Nat .y) true ) false)))) ))
(((\x: Unit .\y: Unit .y) (let u = (case <r = (iszero ({a = (fix (\x: Bool . false )) , b = 0 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) ({a = (if (((\x: Bool .\y: Nat .x) false ) ({a = true , b = 0 }.a)) then (unfold [ Bool ] (fold [ Nat ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) )) else (let u = ({a = 0 , b = false , c = 0 }.c) in false)) , b = (pred ({a = ({a = true , b = 0 }.b) , b = ({a = true , b = 1 }.a) }.a)) }.b))
({a = (( \f: Rec X. X .((f (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = 0 , b = false , c =  0 }.b) , b = ({a = 1 , b = true }.a) }.a) )) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f (case <r = (if true then true else true) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = false in ({a = 1 , b = false , c =  1 }.b)) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .b)) , b = (let u = ({a = ({a = true , b = 0 }.b) , b = (fix (\x: Rec X. X . false )) }.b) in u) }.b)
({a = (let u = ({a = 1 , b = 0 }.b) in u) , b = (if (case <r = ({a = (fix (\x: Unit . 0 )) , b = (iszero 1) , c =  ({a = 1 , b = true }.a) }.b) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Bool .x) (succ (let u = 1 in 0)) ) ({a = 1 , b = true , c =  0 }.b)) else (fix (\x: Rec X. X . (succ (let u = 0 in u)) ))) }.b)
(unfold [ Bool ] (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] (if false then ({a = 1 , b = false }.a) else ({a = 0 , b = 1 }.b)) )) ))
({a = (let u = (let u = (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .a)) , c = (let u = 0 in u) }.c) )) in (fix (\x: Nat . ({a = (((\x: Nat .\y: Unit .x) 0 ) true) , b = true }.b) ))) in u) , b = ({a = (if (iszero 0) then ({a = (let u = false in 0) , b = false }.a) else (((\x: Unit .\y: Unit .x) 0 ) true)) , b = (fix (\x: Rec X. X . true )) , c = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (pred 0) }.b) }.c) }.b)
(pred (( \f: Bool .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = false }.a) ) ) (\a: Rec X. X .\b: Bool .b)))
(let u = (( \f: Rec X. X .((f (( \f: Unit .((f (let u = ({a = false , b = false }.b) in (let u = 0 in false)) ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Rec X. X .x) true ) false) ) false) )) ) ) (\a: Bool .\b: Bool .a)) in (( \f: Bool .((f (succ (((\x: Bool .\y: Unit .x) 1 ) false)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Unit .\b: Unit .a)))
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = (let u = 0 in false) in ({a = (let u = true in u) , b = 1 }.b)) }.b) ) ({a = ({a = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .a)) , b = true }.b) , b = ({a = (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = false , c = 1 }.c) ) true) , b = ({a = false , b = 0 }.b) }.b) }.a))
(case <r = (fix (\x: Nat . (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y)
(unfold [ Bool ] (fold [ Unit ] ({a = (if (let u = true in u) then (let u = false in 0) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) , b = (let u = true in (fix (\x: Bool . false ))) }.a) ))
(case <l = (let u = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . (let u = false in u) )) }.b) in (((\x: Nat .\y: Rec X. X .x) (if false then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) else (((\x: Unit .\y: Rec X. X .y) false ) 1)) ) (iszero 1))) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (( \f: Rec X. X .((f (pred (let u = 1 in u)) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) ))
(case <l = (( \f: Unit .((f ({a = ({a = (succ (let u = 1 in 0)) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) , c =  (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Unit .x) 0 ) false) )) }.b) , b = (let u = ({a = 1 , b = false }.b) in 1) }.b) ) (let u = (let u = ({a = (if true then 1 else 1) , b = ({a = true , b = true }.b) }.b) in (let u = false in 0)) in u) ) ) (\a: Bool .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (case <r = ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = false , c =  (((\x: Bool .\y: Unit .x) 0 ) true) }.b) > as Bool of < l = x > => x | < r = y > => y) in (if ({a = (((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Rec X. X .x) true ) false) ) (let u = false in u)) , b = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = 1 , b = true , c =  1 }.b) in u) }.b) }.b) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] (fix (\x: Rec X. X . 0 )) )) )) else (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) ))))
({a = (( \f: Nat .((f (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Bool .y) (iszero (unfold [ Bool ] (fold [ Nat ] 0 ))) ) (let u = 0 in true)) ) (fix (\x: Unit . (pred 0) ))) ) (let u = (fix (\x: Nat . 1 )) in ({a = (((\x: Bool .\y: Unit .x) 0 ) true) , b = 0 }.b)) ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Nat .\y: Nat .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (if true then 0 else 0) )) ) (let u = (unfold [ Nat ] (fold [ Nat ] true )) in (((\x: Bool .\y: Rec X. X .x) true ) false))) }.b)
({a = (((\x: Nat .\y: Nat .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) false ) false) )) ) (iszero 0)) , b = (unfold [ Bool ] (fold [ Rec X. X ] (let u = (pred 1) in true) )) }.b)
(let u = (let u = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = (if ({a = true , b = true }.b) then true else (let u = 1 in true)) }.b) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) in 1) ))) in (( \f: Nat .((f (((\x: Nat .\y: Bool .x) (if true then ({a = false , b = 0 }.a) else false) ) (let u = true in u)) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)))
(((\x: Bool .\y: Rec X. X .y) (let u = (((\x: Rec X. X .\y: Nat .y) (let u = (fix (\x: Rec X. X . false )) in u) ) ({a = ({a = 1 , b = true }.a) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) }.b)) in (let u = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = false , b = false }.b) , c =  ({a = 1 , b = 0 }.b) }.b) in u)) ) (succ (case <l = (( \f: Rec X. X .((f ({a = 0 , b = 1 }.b) ) (if ({a = 0 , b = true }.b) then ({a = 0 , b = false , c = 0 }.c) else ({a = 0 , b = false , c = 0 }.c)) ) ) (\a: Bool .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y)))
({a = (if ({a = 1 , b = (let u = false in false) , c =  0 }.b) then ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Nat .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (let u = false in u)) }.a) else ({a = ({a = 1 , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ({a = 1 , b = true , c =  0 }.b) }.a)) , b = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) , b = (let u = (let u = 1 in true) in (unfold [ Unit ] (fold [ Nat ] true ))) }.b) }.a)
({a = (let u = (fix (\x: Unit . (let u = true in 1) )) in (( \f: Unit .((f ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = true }.b) ) (if (unfold [ Bool ] (fold [ Bool ] false )) then false else (((\x: Bool .\y: Bool .y) false ) true)) ) ) (\a: Nat .\b: Rec X. X .a))) , b = ({a = (( \f: Nat .((f (fix (\x: Unit . (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) ) (let u = (if false then true else false) in false) ) ) (\a: Bool .\b: Nat .a)) , b = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) in u) }.a) }.b)
({a = (( \f: Bool .((f (let u = ({a = false , b = (succ 0) }.a) in u) ) (( \f: Unit .((f (( \f: Bool .((f ({a = false , b = 0 }.a) ) (( \f: Nat .((f (let u = true in false) ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .x) false ) false) )) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (iszero (((\x: Bool .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) )) ) (let u = ({a = 1 , b = false }.b) in 0))) }.b)
({a = (case <l = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] 0 )) )) ) (if (((\x: Nat .\y: Rec X. X .x) true ) true) then (pred 1) else 1) ) ) (\a: Bool .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . (let u = (((\x: Unit .\y: Rec X. X .x) (let u = 0 in u) ) true) in (( \f: Unit .((f false ) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ) (\a: Unit .\b: Rec X. X .a))) )) }.b)
({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) (let u = true in ({a = 0 , b = false }.b)) ) (let u = 1 in u)) )) , b = (let u = (case <r = ({a = (((\x: Nat .\y: Rec X. X .y) false ) false) , b = (let u = false in 0) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.b)
(((\x: Unit .\y: Bool .y) (fix (\x: Unit . (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = (if true then 1 else 0) }.a) )) )) ) (if (((\x: Nat .\y: Nat .y) ({a = 0 , b = ({a = false , b = 1 }.a) }.b) ) (case <r = ({a = 0 , b = true , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y)) then (let u = ({a = 0 , b = true , c =  ({a = true , b = 0 }.b) }.b) in (let u = true in true)) else (case <r = ({a = true , b = ({a = true , b = 1 }.a) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)))
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = (if (let u = false in u) then ({a = 0 , b = false }.b) else ({a = true , b = 1 }.a)) , b = (let u = (((\x: Nat .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .x) true ) false) ) (fix (\x: Bool . true ))) in (((\x: Rec X. X .\y: Nat .y) false ) false)) }.b) ))
(succ (pred (fix (\x: Bool . 1 ))))
(((\x: Unit .\y: Rec X. X .y) ({a = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)) )) , b = ({a = (succ ({a = 0 , b = false }.a)) , b = ({a = true , b = 0 }.a) }.a) }.a) ) (((\x: Unit .\y: Bool .y) (let u = (iszero 1) in (let u = false in u)) ) (let u = (fix (\x: Rec X. X . 1 )) in u)))
(pred (let u = (unfold [ Unit ] (fold [ Rec X. X ] (let u = 1 in (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b))) )) in (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )))))
(( \f: Rec X. X .((f (fix (\x: Unit . ({a = (((\x: Rec X. X .\y: Bool .x) false ) false) , b = (if true then 0 else 1) }.a) )) ) ({a = (((\x: Unit .\y: Unit .y) ({a = (if false then 1 else 0) , b = true , c =  (let u = true in 0) }.b) ) ({a = (pred 0) , b = 0 }.b)) , b = (if (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .b)) then ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) else (iszero (((\x: Bool .\y: Bool .x) 0 ) true))) , c =  (let u = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) }.b) ) ) (\a: Bool .\b: Bool .a))
(let u = (case <r = (case <r = (let u = 0 in true) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in ({a = (succ 1) , b = (succ 0) }.b))
(succ (( \f: Bool .((f (((\x: Unit .\y: Bool .x) ({a = 0 , b = true , c = 1 }.c) ) (if false then false else true)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = false , b = (succ 1) }.b) )) ) ) (\a: Unit .\b: Nat .b)))
(let u = (case <r = ({a = ({a = true , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) , b = ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) , b = true }.b) }.b) > as Unit of < l = x > => x | < r = y > => y) in u)
({a = (((\x: Nat .\y: Bool .x) (succ ({a = (fix (\x: Bool . 0 )) , b = false , c = 0 }.c)) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a))) , b = ({a = ({a = (((\x: Nat .\y: Bool .y) true ) 1) , b = ({a = true , b = 0 }.a) }.b) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) )) ) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) }.b)
(let u = (( \f: Rec X. X .((f ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , b = ({a = (succ 0) , b = 0 }.b) }.b) ) (case <l = (case <l = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) in ({a = (let u = (succ 0) in u) , b = (fix (\x: Unit . (((\x: Unit .\y: Unit .y) (if false then false else false) ) false) )) }.b))
(fix (\x: Nat . ({a = (pred (case <l = ({a = 1 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (((\x: Nat .\y: Rec X. X .y) ({a = true , b = true }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = (( \f: Nat .((f (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) false ) false) ) false ) ) (\a: Nat .\b: Bool .b)) ) (let u = ({a = 1 , b = 0 }.b) in (fix (\x: Nat . true ))) ) ) (\a: Bool .\b: Nat .b)) }.b) , c = ({a = (( \f: Nat .((f true ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = false , b = 1 }.b) }.b) }.c) ))
({a = (case <l = (let u = ({a = 1 , b = false , c =  0 }.b) in (if true then 0 else 0)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . (((\x: Unit .\y: Nat .y) (case <r = ({a = true , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Nat .b))) )) }.b)
(((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Bool .x) (unfold [ Nat ] (fold [ Rec X. X ] (if true then true else true) )) ) (let u = 0 in ({a = true , b = 0 }.a))) ) (if (let u = false in (let u = false in u)) then (fix (\x: Bool . (let u = 0 in 1) )) else (if (iszero 0) then ({a = 1 , b = true }.a) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )))))
({a = (unfold [ Unit ] (fold [ Rec X. X ] (let u = (( \f: Rec X. X .((f (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) false ) ) (\a: Rec X. X .\b: Bool .a)) in ({a = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , b = (fix (\x: Rec X. X . 1 )) }.b) , b = (let u = false in u) }.b)) )) , b = (unfold [ Unit ] (fold [ Bool ] ({a = ({a = true , b = 1 }.a) , b = (let u = true in 0) }.a) )) }.b)
({a = (pred (((\x: Unit .\y: Bool .x) (succ 0) ) false)) , b = (fix (\x: Nat . (case <r = ({a = true , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) )) }.a)
(let u = (((\x: Nat .\y: Unit .y) (let u = ({a = 0 , b = false }.b) in (let u = true in u)) ) (case <r = ({a = 0 , b = true , c =  1 }.b) > as Bool of < l = x > => x | < r = y > => y)) in (( \f: Bool .((f (let u = (let u = 1 in false) in (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a))) ) ({a = (let u = false in u) , b = 1 }.b) ) ) (\a: Bool .\b: Bool .a)))
(let u = (iszero (fix (\x: Unit . 1 ))) in u)
(pred (fix (\x: Unit . (let u = (((\x: Unit .\y: Unit .x) 1 ) true) in u) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f (fix (\x: Bool . ({a = false , b = false }.b) )) ) (( \f: Unit .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .b)) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Rec X. X .b)) ))
(let u = ({a = (( \f: Bool .((f (let u = 1 in false) ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Nat .((f (let u = 0 in u) ) (let u = true in 0) ) ) (\a: Unit .\b: Nat .b)) }.b) in (case <r = (let u = ({a = 1 , b = true , c = 1 }.c) in (iszero ({a = true , b = 1 }.b))) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = ({a = (let u = (if ({a = 0 , b = false }.b) then (if false then 0 else 0) else 1) in (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) ))) , b = (let u = (let u = false in u) in ({a = true , b = false }.b)) , c = (let u = (iszero (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) in (pred 1)) }.c) in (unfold [ Nat ] (fold [ Nat ] ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = ({a = false , b = 0 }.a) , c =  ({a = 0 , b = true , c = 0 }.c) }.b) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero (succ ({a = false , b = 0 }.b))) ))
(( \f: Nat .((f (fix (\x: Nat . (( \f: Nat .((f (((\x: Unit .\y: Bool .y) (let u = false in u) ) ({a = true , b = false }.b)) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) ) (\a: Bool .\b: Unit .a)) )) ) (iszero (( \f: Nat .((f ({a = false , b = 1 }.b) ) (case <l = (fix (\x: Unit . 0 )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a))) ) ) (\a: Rec X. X .\b: Unit .a))
(( \f: Nat .((f ({a = ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = 1 }.b) , b = (( \f: Nat .((f (let u = true in 0) ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b) ) (if ({a = 0 , b = (let u = 1 in true) }.b) then ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) )) else (let u = (((\x: Unit .\y: Unit .x) 1 ) false) in u)) ) ) (\a: Nat .\b: Nat .a))
({a = ({a = ({a = ({a = (iszero 1) , b = (((\x: Rec X. X .\y: Nat .x) false ) false) }.b) , b = (let u = false in 0) }.a) , b = ({a = (pred 1) , b = ({a = true , b = 1 }.a) }.a) }.b) , b = (fix (\x: Rec X. X . (( \f: Unit .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .a)) )) }.b)
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = (let u = ({a = 1 , b = true }.b) in u) in (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) false ) 1) ) (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 1) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b))) ))
(unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true , c =  1 }.b) )) )) ))
(( \f: Nat .((f (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = false , b = true }.b) )) ) (( \f: Nat .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false }.b) )) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (( \f: Nat .((f ({a = (if false then 1 else 1) , b = (((\x: Unit .\y: Nat .y) ({a = 0 , b = false }.b) ) (let u = false in u)) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) false ) 1) )) }.b) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = ({a = true , b = (if true then 0 else 0) }.a) in (unfold [ Rec X. X ] (fold [ Unit ] true ))) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (pred (fix (\x: Unit . (succ (let u = 0 in 0)) ))) in (((\x: Bool .\y: Nat .x) (let u = (((\x: Bool .\y: Unit .y) true ) 1) in (iszero 1)) ) (let u = true in false)))
({a = (let u = (unfold [ Nat ] (fold [ Nat ] (unfold [ Unit ] (fold [ Bool ] true )) )) in (pred ({a = ({a = 0 , b = 0 }.b) , b = (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = true , c =  0 }.b) ) 0) }.b))) , b = (fix (\x: Bool . (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) in u) )) , c = (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Nat ] 1 )) )) }.c)
(fix (\x: Rec X. X . (( \f: Unit .((f (( \f: Rec X. X .((f (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) (unfold [ Unit ] (fold [ Unit ] false )) ) ) (\a: Bool .\b: Nat .a)) ) (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) in true) ) ) (\a: Bool .\b: Bool .a)) ))
({a = (((\x: Rec X. X .\y: Bool .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) ({a = (((\x: Nat .\y: Rec X. X .x) false ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .a))) , b = (let u = false in u) }.b)) , b = (((\x: Nat .\y: Unit .y) ({a = (((\x: Bool .\y: Unit .y) true ) (unfold [ Bool ] (fold [ Nat ] false ))) , b = (( \f: Rec X. X .((f (fix (\x: Unit . 1 )) ) 1 ) ) (\a: Unit .\b: Nat .b)) }.a) ) ({a = 1 , b = (unfold [ Unit ] (fold [ Bool ] false )) }.b)) }.b)
(let u = (succ ({a = (fix (\x: Unit . (if (if false then false else false) then (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) else (iszero 1)) )) , b = ({a = (if true then 0 else 1) , b = (unfold [ Rec X. X ] (fold [ Unit ] false )) , c = (let u = 0 in u) }.c) }.b)) in (case <r = (unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) false ) (if false then true else false)) )) > as Nat of < l = x > => x | < r = y > => y))
(if (unfold [ Nat ] (fold [ Rec X. X ] (if (let u = true in true) then (fix (\x: Nat . false )) else ({a = 0 , b = true , c =  0 }.b)) )) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] (case <l = (let u = true in 1) > as Bool of < l = x > => x | < r = y > => y) )) )) else (fix (\x: Bool . (( \f: Rec X. X .((f (fix (\x: Rec X. X . 1 )) ) 1 ) ) (\a: Unit .\b: Nat .a)) )))
({a = (succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (succ (succ 1)) ))) , b = (let u = (((\x: Bool .\y: Rec X. X .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false ))) in u) }.a)
({a = (pred (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Unit .((f ({a = false , b = 1 }.b) ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = false , b = (fix (\x: Nat . false )) }.b) )) }.a)
(let u = ({a = ({a = ({a = false , b = 0 }.b) , b = (fix (\x: Bool . (( \f: Rec X. X .((f true ) (let u = false in false) ) ) (\a: Unit .\b: Nat .a)) )) }.b) , b = ({a = (( \f: Bool .((f 0 ) ({a = 0 , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = (succ 0) in ({a = 0 , b = true }.a)) }.b) }.a) in (( \f: Bool .((f (let u = (((\x: Unit .\y: Nat .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .x) false ) true)) in ({a = 1 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = 0 , b = true }.a) }.b)) ) ({a = ({a = 1 , b = false }.b) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.a) ) ) (\a: Unit .\b: Bool .b)))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = (succ (pred 1)) , b = (((\x: Unit .\y: Unit .y) true ) 1) }.b) )) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = ({a = 0 , b = (fix (\x: Unit . false )) }.a) in (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .b)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )))) )) }.a)
(( \f: Bool .((f (fix (\x: Bool . (let u = (((\x: Bool .\y: Nat .x) 0 ) false) in u) )) ) (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Rec X. X .y) (iszero 1) ) ({a = ({a = 0 , b = 0 }.b) , b = (((\x: Unit .\y: Unit .x) 0 ) false) }.b)) ) (((\x: Rec X. X .\y: Nat .x) false ) (let u = false in false))) ) ) (\a: Nat .\b: Bool .b))
(((\x: Unit .\y: Rec X. X .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = ({a = true , b = 0 }.b) in ({a = true , b = false }.b)) )) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = 0 , b = false }.b) , b = ({a = 0 , b = true }.b) }.b) )))
(iszero (let u = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Unit .y) false ) true) in ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false ))) )) in u) in (let u = (if true then 0 else 1) in (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in u))))
(fix (\x: Rec X. X . ({a = (if (((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) false) then (if ({a = false , b = false }.b) then ({a = true , b = 0 }.a) else (((\x: Unit .\y: Unit .x) true ) false)) else (let u = (let u = 0 in true) in (if (((\x: Rec X. X .\y: Nat .x) true ) false) then true else true))) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (pred 0) )) }.a) ))
(let u = (iszero (let u = (fix (\x: Unit . false )) in (((\x: Unit .\y: Unit .x) 1 ) false))) in ({a = (succ (if false then 1 else 1)) , b = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.b) , c =  (let u = (if ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) then 1 else ({a = true , b = 0 }.b)) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a))) }.b))
(succ (let u = (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = false , c =  0 }.b) )) in (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Bool .a))))
(succ (let u = (fix (\x: Bool . (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) in (unfold [ Rec X. X ] (fold [ Nat ] true ))) )) in ({a = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Unit ] true )) ) 0) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = 1 in true) )) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) }.c)))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Nat .\y: Rec X. X .x) (( \f: Bool .((f ({a = 0 , b = false , c = 0 }.c) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Unit .b))) ))
({a = (case <l = ({a = (case <l = (let u = false in 1) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = true , b = 0 }.b) }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (iszero ({a = (( \f: Unit .((f (( \f: Bool .((f 0 ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Nat .((f ({a = true , b = 0 }.b) ) (((\x: Nat .\y: Rec X. X .x) 1 ) true) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Unit .\b: Nat .a)) , b = (if (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) then (let u = (((\x: Rec X. X .\y: Unit .x) false ) false) in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true ))) else (fix (\x: Rec X. X . false ))) }.a)) }.b)
(((\x: Nat .\y: Nat .y) ({a = (pred ({a = 1 , b = 0 }.b)) , b = (((\x: Bool .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , c =  (if (if false then false else false) then ({a = 1 , b = true }.a) else (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b))) }.b) ) ({a = (( \f: Unit .((f (fix (\x: Bool . 1 )) ) (((\x: Rec X. X .\y: Bool .y) (((\x: Rec X. X .\y: Bool .y) true ) true) ) (pred 1)) ) ) (\a: Nat .\b: Nat .a)) , b = (pred ({a = 0 , b = true }.a)) }.b))
({a = (case <l = ({a = ({a = (let u = true in 0) , b = (fix (\x: Rec X. X . 1 )) }.b) , b = (fix (\x: Nat . true )) , c = (let u = 0 in 1) }.c) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = (unfold [ Unit ] (fold [ Bool ] (succ 1) )) , b = ({a = (((\x: Bool .\y: Nat .y) true ) true) , b = 0 }.a) , c =  (let u = ({a = 0 , b = false , c = 1 }.c) in 0) }.b) )) }.a)
({a = (case <l = (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = (let u = 1 in 0) }.b) ) (((\x: Bool .\y: Bool .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (if (((\x: Rec X. X .\y: Unit .x) false ) false) then true else ({a = true , b = 1 }.a)))) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <r = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) else (let u = 0 in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )))) > as Unit of < l = x > => x | < r = y > => y) , c =  (( \f: Bool .((f (((\x: Bool .\y: Unit .y) ({a = ({a = true , b = 0 }.b) , b = true , c =  0 }.b) ) (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = (( \f: Unit .((f 0 ) (if true then 0 else 1) ) ) (\a: Nat .\b: Unit .a)) , b = ({a = true , b = 0 }.b) }.b) ) ) (\a: Unit .\b: Nat .b)) }.b)
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (succ (((\x: Nat .\y: Bool .x) (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)))) ))
(case <l = ({a = ({a = (unfold [ Nat ] (fold [ Bool ] true )) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .x) 1 ) true) )) }.b) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Bool .x) (pred (let u = (pred (fix (\x: Unit . 0 ))) in u)) ) (((\x: Nat .\y: Bool .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (let u = ({a = 1 , b = true }.a) in true) , b = ({a = true , b = 1 }.b) }.a)))
(let u = (( \f: Unit .((f (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) )) in ({a = (succ 1) , b = (iszero 1) , c =  1 }.b)) ) (unfold [ Rec X. X ] (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Bool .b)) in (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )))
({a = (((\x: Unit .\y: Unit .y) ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (((\x: Nat .\y: Rec X. X .x) true ) false) }.b) ) (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) true ) true) ) false ) ) (\a: Bool .\b: Bool .b))) , b = (let u = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (let u = 0 in 0) ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) }.a) in u) }.b)
({a = ({a = ({a = ({a = (let u = 0 in 0) , b = (let u = 1 in true) , c =  1 }.b) , b = (let u = (let u = false in false) in u) }.b) , b = (succ (let u = 0 in u)) }.b) , b = ({a = (let u = ({a = 0 , b = false , c = 1 }.c) in u) , b = (( \f: Unit .((f (let u = true in false) ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Bool .\b: Nat .a)) , c =  (( \f: Rec X. X .((f (pred 1) ) ({a = 1 , b = 1 }.b) ) ) (\a: Unit .\b: Bool .b)) }.b) , c =  (let u = (if (((\x: Nat .\y: Bool .x) true ) false) then ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) , b = 0 }.b) else (((\x: Unit .\y: Nat .x) 1 ) true)) in u) }.b)
(((\x: Unit .\y: Rec X. X .x) (let u = (unfold [ Nat ] (fold [ Unit ] (case <l = (fix (\x: Bool . 1 )) > as Unit of < l = x > => x | < r = y > => y) )) in (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) in ({a = 1 , b = false , c =  1 }.b))) ) (( \f: Unit .((f ({a = true , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) }.b) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] true )) ) (if false then (((\x: Unit .\y: Unit .y) true ) true) else false) ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Unit .\b: Bool .b)))
(unfold [ Unit ] (fold [ Nat ] (pred (case <l = (( \f: Unit .((f ({a = 0 , b = true , c = 0 }.c) ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y)) ))
({a = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = ({a = (pred 1) , b = ({a = 1 , b = true , c =  0 }.b) }.b) }.a) , b = (unfold [ Unit ] (fold [ Nat ] (fix (\x: Bool . ({a = (((\x: Bool .\y: Unit .x) 1 ) false) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) )) )) }.a)
(let u = ({a = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = (if ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) then (unfold [ Nat ] (fold [ Bool ] false )) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) }.b) in (let u = (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Unit .x) (fix (\x: Bool . false )) ) (((\x: Rec X. X .\y: Nat .x) true ) false)) ) (fix (\x: Unit . 0 ))) in ({a = true , b = (let u = true in u) }.b)))
(((\x: Nat .\y: Rec X. X .x) ({a = (unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) false ) 0) )) , b = (let u = (let u = false in true) in ({a = 0 , b = true , c =  (((\x: Rec X. X .\y: Bool .y) false ) 0) }.b)) }.b) ) ({a = (pred ({a = 1 , b = false }.a)) , b = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in ({a = 1 , b = false }.b)) }.b))
(let u = (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) ) (\a: Bool .\b: Bool .a)) , b = (let u = 1 in u) }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 0 in ({a = 0 , b = true }.a)) )) ) ) (\a: Unit .\b: Nat .b)) in u)
({a = (case <r = ({a = ({a = (succ 1) , b = true }.b) , b = (let u = 0 in 0) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (let u = ({a = ({a = 1 , b = 0 }.b) , b = ({a = 0 , b = false , c =  0 }.b) }.a) in u) ) ({a = (unfold [ Bool ] (fold [ Unit ] true )) , b = (pred 1) }.b) ) ) (\a: Nat .\b: Bool .a)) }.a)
({a = (let u = (let u = ({a = 1 , b = (let u = true in 1) }.b) in (let u = (let u = 1 in true) in 0)) in (if (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a)) then (( \f: Unit .((f 0 ) (if true then 1 else 0) ) ) (\a: Rec X. X .\b: Unit .b)) else (((\x: Bool .\y: Nat .x) ({a = 1 , b = 0 }.b) ) true))) , b = (((\x: Bool .\y: Rec X. X .x) (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Bool .x) 1 ) true) ) ({a = 1 , b = false }.b)) )) ) ({a = (((\x: Nat .\y: Unit .x) 0 ) false) , b = (((\x: Nat .\y: Unit .y) true ) false) , c =  (let u = false in 1) }.b)) }.b)
(case <r = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) )) ) (fix (\x: Unit . (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .a)) )) ) ) (\a: Bool .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (((\x: Unit .\y: Bool .y) (let u = (( \f: Nat .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) ) (pred (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true)) ) ) (\a: Bool .\b: Unit .a)) in ({a = 0 , b = false , c =  1 }.b)) ) ({a = (pred 1) , b = (((\x: Bool .\y: Unit .y) true ) true) , c =  (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)) ) ({a = ({a = (iszero 1) , b = (let u = 1 in false) }.b) , b = (unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) )) }.a) ) ) (\a: Unit .\b: Bool .a))
(iszero (((\x: Nat .\y: Nat .y) (((\x: Rec X. X .\y: Bool .x) (if false then false else true) ) ({a = 1 , b = true }.b)) ) ({a = ({a = (((\x: Bool .\y: Rec X. X .y) true ) true) , b = 1 }.a) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) }.b)))
(if (case <r = (((\x: Unit .\y: Nat .y) (fix (\x: Nat . true )) ) ({a = false , b = true }.b)) > as Bool of < l = x > => x | < r = y > => y) then (case <l = (pred (((\x: Rec X. X .\y: Bool .x) 0 ) true)) > as Bool of < l = x > => x | < r = y > => y) else (let u = (iszero 0) in (pred (if false then (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) else 1))))
(fix (\x: Nat . (fix (\x: Unit . (unfold [ Unit ] (fold [ Unit ] (let u = 0 in 0) )) )) ))
({a = (((\x: Bool .\y: Nat .x) (let u = (succ (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) in (let u = ({a = true , b = false }.b) in ({a = 0 , b = false }.a))) ) ({a = ({a = ({a = (let u = true in 0) , b = ({a = 1 , b = 0 }.b) }.b) , b = (((\x: Nat .\y: Nat .y) false ) (fix (\x: Bool . 1 ))) }.b) , b = (if false then (fix (\x: Rec X. X . false )) else ({a = true , b = 0 }.a)) }.b)) , b = (case <r = (fix (\x: Rec X. X . (( \f: Unit .((f (( \f: Rec X. X .((f ({a = false , b = 1 }.a) ) false ) ) (\a: Nat .\b: Nat .b)) ) (unfold [ Nat ] (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Nat .b)) )) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (let u = (fix (\x: Unit . (if true then 1 else 1) )) in u) }.c)
({a = (if (((\x: Unit .\y: Unit .x) (case <r = (if false then ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) else (iszero 1)) > as Nat of < l = x > => x | < r = y > => y) ) ({a = true , b = (let u = 1 in 0) }.a)) then (((\x: Rec X. X .\y: Rec X. X .x) (let u = true in u) ) (unfold [ Nat ] (fold [ Nat ] false ))) else ({a = (let u = ({a = 1 , b = 1 }.b) in true) , b = (iszero 0) }.b)) , b = ({a = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) (fix (\x: Unit . false )) ) true) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = (case <r = (unfold [ Unit ] (fold [ Unit ] true )) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (pred 1) ) ({a = 0 , b = true }.a) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) }.b) }.a)
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Bool .y) (let u = ({a = 1 , b = true , c = 1 }.c) in (((\x: Unit .\y: Bool .x) (let u = 0 in false) ) (let u = false in true))) ) (((\x: Bool .\y: Nat .x) (fix (\x: Nat . true )) ) (fix (\x: Bool . (let u = 0 in true) )))) ))
(let u = ({a = (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . (fix (\x: Nat . 1 )) )) )) , b = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) ) (((\x: Bool .\y: Bool .x) false ) false) ) ) (\a: Bool .\b: Unit .a)) }.b) in (let u = (fix (\x: Nat . (((\x: Unit .\y: Nat .y) true ) false) )) in (case <r = ({a = 0 , b = false , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)))
(case <l = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Nat . ({a = (if false then 0 else 0) , b = true }.a) )) ) (iszero (pred (let u = true in 0)))) > as Rec X. X of < l = x > => x | < r = y > => y)
(pred ({a = ({a = (let u = 1 in false) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) , b = ({a = ({a = 0 , b = 0 }.b) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.a) }.b))
(succ ({a = (fix (\x: Rec X. X . (let u = 1 in 0) )) , b = ({a = (( \f: Nat .((f ({a = 1 , b = true , c = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.c) ) ({a = (let u = 1 in u) , b = true }.a) ) ) (\a: Bool .\b: Nat .b)) , b = (( \f: Nat .((f ({a = 1 , b = false }.b) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) , c =  ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Nat .\y: Unit .y) (fix (\x: Unit . false )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) }.b) }.b) }.a))
({a = (( \f: Rec X. X .((f (succ (case <l = (pred 1) > as Unit of < l = x > => x | < r = y > => y)) ) (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) (fix (\x: Nat . 0 )) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Bool .x) (if (case <r = (let u = (iszero 0) in true) > as Rec X. X of < l = x > => x | < r = y > => y) then (fix (\x: Rec X. X . (if (if true then false else true) then false else (fix (\x: Bool . true ))) )) else (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .x) false ) false) ) false ) ) (\a: Bool .\b: Bool .a))) ) ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .b)) , b = (fix (\x: Unit . 0 )) }.a)) }.b)
({a = (if (let u = (if (fix (\x: Bool . true )) then 0 else ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 ))) in ({a = ({a = false , b = true }.b) , b = false }.b)) then ({a = (fix (\x: Bool . 1 )) , b = (if (( \f: Rec X. X .((f (let u = true in u) ) false ) ) (\a: Nat .\b: Bool .b)) then (case <r = (fix (\x: Bool . true )) > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = true , b = 1 }.a)) , c = (((\x: Bool .\y: Rec X. X .x) ({a = (succ 1) , b = 1 }.b) ) (((\x: Unit .\y: Rec X. X .y) true ) (((\x: Bool .\y: Rec X. X .y) false ) true))) }.c) else (let u = ({a = 1 , b = (let u = false in 1) }.b) in (case <l = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = false , b = 0 }.b) )) > as Bool of < l = x > => x | < r = y > => y))) , b = (fix (\x: Unit . (if (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false }.b) )) then ({a = (succ 1) , b = (fix (\x: Bool . false )) }.a) else ({a = (succ ({a = 1 , b = 1 }.b)) , b = (unfold [ Unit ] (fold [ Unit ] (succ 0) )) }.b)) )) }.b)
({a = (pred ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (succ (let u = true in 1)) ))) , b = ({a = (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in u) )) }.b) , c = (( \f: Rec X. X .((f (pred (( \f: Nat .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Nat .\b: Nat .a))) ) (let u = (succ 0) in (succ (((\x: Unit .\y: Rec X. X .y) true ) (fix (\x: Bool . 0 ))))) ) ) (\a: Unit .\b: Nat .b)) }.c)
(((\x: Unit .\y: Rec X. X .y) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (fix (\x: Rec X. X . false )) in false) )) in (case <r = ({a = 1 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = (((\x: Unit .\y: Nat .x) ({a = ({a = 1 , b = false }.a) , b = (iszero 1) , c =  0 }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 1 , b = false }.b) ))) in ({a = (if false then false else false) , b = ({a = false , b = 1 }.b) }.b)))
(let u = ({a = (( \f: Unit .((f ({a = 0 , b = false }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (if (if true then ({a = 0 , b = false , c =  0 }.b) else true) then (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = 1 }.b) ) (iszero 1)) else (fix (\x: Rec X. X . (let u = 0 in 1) ))) }.a) in (unfold [ Rec X. X ] (fold [ Bool ] (succ (let u = 1 in 1)) )))
(((\x: Unit .\y: Unit .y) (if ({a = (iszero 1) , b = (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) }.a) then (unfold [ Bool ] (fold [ Rec X. X ] (let u = (fix (\x: Unit . 1 )) in false) )) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = true in false) ))) ) (let u = ({a = (iszero 0) , b = (((\x: Unit .\y: Unit .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ({a = false , b = true }.b)) }.b) in u))
(let u = (unfold [ Unit ] (fold [ Bool ] ({a = (let u = ({a = (((\x: Nat .\y: Bool .y) true ) 1) , b = ({a = false , b = 0 }.b) }.b) in u) , b = (((\x: Bool .\y: Rec X. X .y) false ) 0) }.b) )) in ({a = (let u = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .a)) in u) , b = (((\x: Nat .\y: Nat .x) (fix (\x: Nat . 0 )) ) (iszero 1)) }.a))
({a = ({a = ({a = (( \f: Bool .((f (((\x: Unit .\y: Nat .x) false ) false) ) (fix (\x: Nat . true )) ) ) (\a: Nat .\b: Unit .a)) , b = (((\x: Nat .\y: Bool .x) 0 ) true) }.b) , b = (fix (\x: Rec X. X . (case <r = ({a = 1 , b = false , c =  1 }.b) > as Bool of < l = x > => x | < r = y > => y) )) }.a) , b = ({a = ({a = true , b = 1 }.a) , b = ({a = (if true then false else true) , b = false }.b) }.b) , c = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f (let u = ({a = 0 , b = true , c =  0 }.b) in u) ) (let u = 0 in true) ) ) (\a: Nat .\b: Nat .a)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (succ 1) ))) }.c)
(((\x: Unit .\y: Unit .x) (let u = (let u = ({a = (if ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )) then (pred 0) else 1) , b = (((\x: Nat .\y: Rec X. X .x) false ) false) , c =  ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) }.b) in u) in u) ) (iszero (fix (\x: Bool . (pred 0) ))))
(((\x: Nat .\y: Nat .x) ({a = (case <l = (unfold [ Unit ] (fold [ Unit ] (fix (\x: Nat . 1 )) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ({a = 0 , b = false }.b) , b = (if false then 1 else 1) }.a) }.b) ) (iszero (let u = (succ ({a = false , b = 1 }.b)) in ({a = ({a = 1 , b = false }.a) , b = true , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.c))))
(fix (\x: Rec X. X . (pred ({a = ({a = (if true then 0 else 1) , b = (if false then false else true) }.a) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.b)) ))
(unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 1 , b = 1 }.b) )) , b = ({a = ({a = false , b = false }.b) , b = (fix (\x: Nat . (succ 0) )) }.b) }.b) )) ))
(let u = ({a = ({a = ({a = (( \f: Bool .((f true ) (let u = true in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if false then 0 else 0) }.b) , b = (((\x: Nat .\y: Nat .x) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (((\x: Nat .\y: Unit .y) true ) false) , c = ({a = true , b = 1 }.b) }.c) ) (iszero 1)) }.b) , b = (((\x: Nat .\y: Rec X. X .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Nat ] false ))) }.a) in u)
({a = (pred (if (if false then true else true) then 0 else (let u = false in 1))) , b = ({a = (( \f: Nat .((f (((\x: Nat .\y: Bool .y) true ) true) ) (let u = ({a = true , b = 0 }.a) in true) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = (let u = (iszero 0) in (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) in (pred ({a = true , b = 0 }.b))) }.a) , c =  (pred (let u = 1 in 0)) }.b)
(unfold [ Bool ] (fold [ Bool ] (fix (\x: Bool . (( \f: Bool .((f (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) (let u = false in false) ) ) (\a: Bool .\b: Nat .b)) ) ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) 0 ) ) (\a: Bool .\b: Nat .a)) }.a) ) ) (\a: Rec X. X .\b: Nat .b)) )) ))
({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] (let u = 0 in false) )) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.a) , b = (((\x: Nat .\y: Unit .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) )) ) ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = true , c =  (((\x: Bool .\y: Nat .y) false ) 0) }.b)) }.a)
(( \f: Nat .((f (( \f: Unit .((f (let u = true in false) ) (unfold [ Unit ] (fold [ Nat ] true )) ) ) (\a: Nat .\b: Nat .b)) ) ({a = (( \f: Rec X. X .((f (succ 1) ) (( \f: Nat .((f (((\x: Unit .\y: Nat .y) true ) 1) ) 0 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .a)) , b = (let u = (iszero 0) in u) }.b) ) ) (\a: Unit .\b: Unit .a))
({a = ({a = (let u = (( \f: Unit .((f (let u = 0 in 0) ) (((\x: Bool .\y: Nat .y) true ) 0) ) ) (\a: Bool .\b: Bool .a)) in (if false then 1 else 0)) , b = (let u = (((\x: Nat .\y: Nat .x) false ) true) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false ))) , c =  ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Nat .y) false ) false) }.a) }.b) , b = (((\x: Unit .\y: Bool .x) (let u = (let u = ({a = 1 , b = ({a = 0 , b = 1 }.b) }.b) in (fix (\x: Bool . true ))) in (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) false ) true) ))) ) (let u = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = false , c =  1 }.b) in (let u = false in false))) }.b)
({a = (case <l = (unfold [ Rec X. X ] (fold [ Bool ] (let u = false in 1) )) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Nat .y) (((\x: Rec X. X .\y: Bool .y) false ) false) ) (let u = false in u)) , b = ({a = false , b = 1 }.a) }.b) ) ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Nat .x) false ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b))) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
({a = (let u = (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = 0 , b = (if true then false else true) , c =  1 }.b) ) ) (\a: Unit .\b: Rec X. X .b)) in ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.b)) , b = (case <l = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (let u = 0 in u) , b = ({a = 0 , b = true }.b) , c = 1 }.c) }.b) > as Nat of < l = x > => x | < r = y > => y) }.b)
(((\x: Bool .\y: Rec X. X .x) (pred (pred ({a = (succ 0) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b))) ) (((\x: Nat .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Unit .\y: Bool .x) ({a = 0 , b = false }.b) ) ({a = (((\x: Unit .\y: Bool .x) 0 ) true) , b = ({a = 0 , b = true , c =  0 }.b) , c =  1 }.b)) )) ) ({a = ({a = 1 , b = false }.a) , b = (((\x: Rec X. X .\y: Bool .x) true ) true) , c =  (let u = 0 in (fix (\x: Nat . 1 ))) }.b)))
(succ (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Unit . (( \f: Unit .((f 0 ) (((\x: Nat .\y: Rec X. X .y) false ) 0) ) ) (\a: Unit .\b: Nat .a)) )) )))
(if (( \f: Bool .((f (( \f: Rec X. X .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . true )) ) ) (\a: Nat .\b: Nat .b)) ) (( \f: Unit .((f ({a = 1 , b = (((\x: Rec X. X .\y: Bool .x) false ) true) , c =  1 }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) false ) true) )) )) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Bool .a)) then (case <r = (((\x: Rec X. X .\y: Unit .y) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = true , c =  0 }.b) ) (let u = true in u)) > as Unit of < l = x > => x | < r = y > => y) else (fix (\x: Nat . (unfold [ Nat ] (fold [ Unit ] (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in u) )) )))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) (iszero (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Bool .y) false ) 0) ))) ) ({a = (let u = 0 in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (let u = true in 0) )) }.a)) ) (iszero (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = true }.b) )) in (( \f: Rec X. X .((f ({a = 1 , b = false , c = 0 }.c) ) (fix (\x: Unit . 1 )) ) ) (\a: Unit .\b: Nat .a)))) ) ) (\a: Nat .\b: Rec X. X .b))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] ({a = (let u = false in false) , b = 1 }.b) )) )) in (let u = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) in false) in u))
(( \f: Nat .((f (let u = ({a = ({a = 0 , b = 0 }.b) , b = ({a = (fix (\x: Nat . false )) , b = false }.b) }.b) in u) ) (case <r = (( \f: Bool .((f ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 1 in 0) }.a) ) (let u = true in u) ) ) (\a: Unit .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a))
(case <r = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = true }.b) )) ) (let u = (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) in u) ) ) (\a: Nat .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y)
({a = (case <r = (((\x: Bool .\y: Unit .x) (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] false )) ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = true }.b) ))) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Rec X. X .y) (iszero (let u = true in 0)) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.b)
({a = (fix (\x: Unit . (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) in (case <r = (iszero 1) > as Bool of < l = x > => x | < r = y > => y)) )) , b = (((\x: Bool .\y: Rec X. X .y) (case <r = (((\x: Bool .\y: Rec X. X .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (let u = (iszero 0) in (unfold [ Nat ] (fold [ Unit ] true ))) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (pred 1) )) }.a)) }.b)
({a = (let u = (iszero (let u = ({a = 0 , b = false }.b) in 0)) in ({a = (let u = (let u = true in u) in (let u = false in 0)) , b = (let u = ({a = true , b = true }.b) in (let u = false in true)) , c =  (fix (\x: Unit . (pred 1) )) }.b)) , b = ({a = (succ (fix (\x: Nat . (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) ))) , b = ({a = (pred 1) , b = (iszero 1) , c =  (if true then 0 else 0) }.b) }.b) }.b)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = ({a = 0 , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) }.b) in u) ))
(let u = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .a)) ) ({a = 1 , b = true , c =  1 }.b)) , b = (((\x: Unit .\y: Bool .y) (if false then true else false) ) ({a = (if false then 1 else 1) , b = ({a = 0 , b = true , c =  1 }.b) , c = 0 }.c)) }.b) in u)
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (case <l = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (if false then 1 else 0) , b = ({a = 0 , b = true }.b) }.a) )) > as Rec X. X of < l = x > => x | < r = y > => y) ))
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) (iszero 0) ) (succ 1)) )) , b = (pred (pred ({a = false , b = 0 }.b))) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = (iszero 1) , b = (let u = false in u) }.b) in (( \f: Bool .((f (let u = 0 in u) ) ({a = 0 , b = 0 }.b) ) ) (\a: Unit .\b: Bool .a))) )) ))
({a = (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Unit .y) ({a = false , b = ({a = 0 , b = 1 }.b) }.a) ) (((\x: Unit .\y: Nat .x) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .a)) ) false)) )) , b = (case <r = (( \f: Bool .((f (((\x: Nat .\y: Unit .x) false ) false) ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) }.b)
({a = (( \f: Rec X. X .((f (succ (succ 0)) ) (pred (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = (iszero (if true then 1 else 1)) in ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a)) }.a)
(( \f: Rec X. X .((f (( \f: Bool .((f (( \f: Rec X. X .((f (succ 1) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Nat .a)) ) (pred (let u = true in 1)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (succ (case <l = ({a = 0 , b = true }.a) > as Bool of < l = x > => x | < r = y > => y)) )) ) ) (\a: Unit .\b: Bool .b))
(let u = (let u = ({a = (fix (\x: Nat . 1 )) , b = (if true then false else false) , c = (fix (\x: Nat . 1 )) }.c) in (((\x: Bool .\y: Nat .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) false)) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (succ ({a = (let u = true in 0) , b = (((\x: Bool .\y: Rec X. X .y) (fix (\x: Bool . true )) ) true) , c = ({a = true , b = 1 }.b) }.c)) )))
(( \f: Bool .((f ({a = (if ({a = 1 , b = false , c =  1 }.b) then (((\x: Rec X. X .\y: Bool .y) false ) 0) else 1) , b = (let u = true in u) , c =  (pred ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = 1 }.b)) }.b) ) (( \f: Nat .((f ({a = 1 , b = true }.b) ) (iszero ({a = 0 , b = false , c = 0 }.c)) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .a))
(fix (\x: Rec X. X . (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) (let u = true in true) ) ) (\a: Bool .\b: Rec X. X .b))) ))
({a = (((\x: Rec X. X .\y: Bool .x) (unfold [ Unit ] (fold [ Unit ] (let u = (let u = 0 in 0) in false) )) ) (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = false , c =  1 }.b) ))) , b = (( \f: Nat .((f ({a = (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in (let u = false in u)) , b = (let u = 0 in true) }.b) ) (if ({a = (let u = true in u) , b = false }.b) then (case <r = (( \f: Nat .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) true ) ) (\a: Nat .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) else ({a = (case <l = ({a = 1 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = 0 }.a) , c =  (let u = 1 in 1) }.b)) ) ) (\a: Bool .\b: Bool .a)) }.b)
({a = (let u = ({a = ({a = (if false then true else true) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.a) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.b) in u) , b = (let u = ({a = 0 , b = ({a = true , b = 1 }.a) }.a) in ({a = ({a = (if true then 1 else 0) , b = (iszero 0) , c =  (let u = 0 in 1) }.b) , b = (let u = (let u = false in false) in u) }.b)) , c =  (((\x: Bool .\y: Nat .y) (let u = ({a = 0 , b = false , c =  1 }.b) in u) ) (let u = (if true then 0 else 1) in (let u = 1 in 0))) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = (let u = 0 in 1) in (let u = 0 in 0)) , b = (let u = (fix (\x: Unit . 1 )) in (let u = ({a = 1 , b = 1 }.b) in false)) }.b) ))
(pred ({a = (((\x: Bool .\y: Bool .y) (let u = true in u) ) (let u = 0 in 0)) , b = (let u = (succ (fix (\x: Nat . 0 ))) in u) }.b))
(((\x: Bool .\y: Nat .y) ({a = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ({a = false , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) }.b) ) (let u = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = (iszero 0) , c =  (fix (\x: Unit . 0 )) }.b) in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a))))
(unfold [ Unit ] (fold [ Rec X. X ] ({a = ({a = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (((\x: Bool .\y: Unit .y) true ) false) }.a) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = 1 }.a) )) in (((\x: Bool .\y: Nat .x) true ) true)) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) , b = (if (((\x: Bool .\y: Unit .y) true ) (let u = false in false)) then (let u = (unfold [ Nat ] (fold [ Nat ] ({a = false , b = 0 }.b) )) in ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false ))) else (( \f: Rec X. X .((f (fix (\x: Nat . false )) ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .a))) , c =  (let u = ({a = 1 , b = true }.a) in (((\x: Bool .\y: Bool .x) 0 ) true)) }.b) ))
(succ (let u = (fix (\x: Nat . ({a = true , b = (((\x: Bool .\y: Unit .x) false ) false) }.b) )) in (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) ))))
({a = (( \f: Unit .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f (iszero 0) ) (( \f: Rec X. X .((f true ) (((\x: Bool .\y: Nat .x) false ) false) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .b)) )) ) (case <r = (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .x) false ) false) )) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (iszero (case <l = (let u = ({a = 0 , b = false , c =  0 }.b) in (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b))) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b)
(unfold [ Bool ] (fold [ Nat ] ({a = (iszero (((\x: Nat .\y: Unit .x) 1 ) false)) , b = (let u = (((\x: Rec X. X .\y: Nat .x) false ) ({a = 1 , b = true , c =  1 }.b)) in ({a = (let u = true in false) , b = 1 }.b)) }.b) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Rec X. X ] 0 )) )) )) ))
(case <r = (((\x: Bool .\y: Rec X. X .y) ({a = ({a = false , b = 1 }.a) , b = (let u = false in true) }.b) ) ({a = ({a = 0 , b = true }.b) , b = (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = false }.b) ) false) }.b)) > as Nat of < l = x > => x | < r = y > => y)
(let u = (( \f: Rec X. X .((f (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Rec X. X .\b: Unit .b)) ) (if (let u = false in true) then (((\x: Unit .\y: Unit .y) ({a = 1 , b = false , c =  0 }.b) ) 1) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = 1 }.b) ))) ) ) (\a: Nat .\b: Unit .a)) in u)
(iszero (let u = (((\x: Rec X. X .\y: Bool .x) ({a = (unfold [ Unit ] (fold [ Bool ] 1 )) , b = (let u = false in u) }.b) ) (let u = (unfold [ Bool ] (fold [ Unit ] false )) in (iszero 0))) in (let u = (let u = false in (let u = false in true)) in (( \f: Nat .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (pred 0) )) ) (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) ) ) (\a: Unit .\b: Unit .a)))))
(fix (\x: Nat . (let u = ({a = ({a = 0 , b = ({a = true , b = true }.b) }.a) , b = ({a = true , b = true }.b) }.a) in ({a = ({a = false , b = true }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) }.a)) ))
(fix (\x: Nat . (((\x: Bool .\y: Bool .y) (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .y) false ) false) )) ) ({a = (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in false) ) 1) , b = (case <r = ({a = false , b = (((\x: Unit .\y: Rec X. X .y) false ) true) }.b) > as Unit of < l = x > => x | < r = y > => y) }.a)) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] (if ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) then ({a = 0 , b = (let u = 0 in false) , c =  0 }.b) else ({a = 0 , b = false , c =  (succ 1) }.b)) )) ))
(((\x: Nat .\y: Unit .y) (case <r = (iszero (case <l = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) > as Bool of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y) ) (pred (fix (\x: Rec X. X . (let u = 0 in 1) ))))
(case <l = (((\x: Unit .\y: Unit .y) (iszero 1) ) (fix (\x: Nat . (((\x: Nat .\y: Nat .x) 0 ) false) ))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Rec X. X .y) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) , b = (if (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Rec X. X .y) true ) true) ) false) then (fix (\x: Bool . (let u = false in u) )) else (let u = ({a = 1 , b = true }.a) in (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)))) , c =  (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) ) (unfold [ Nat ] (fold [ Bool ] (fix (\x: Rec X. X . (iszero 1) )) )))
(( \f: Nat .((f (pred (pred (let u = (let u = false in u) in 1))) ) (let u = ({a = (pred 0) , b = false , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 )) }.c) in (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = 0 }.b) ))) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(case <l = (( \f: Unit .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) (( \f: Bool .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) ({a = (let u = false in 0) , b = (let u = false in 1) }.b) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y)
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) )) )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] true )) )) )) }.a)
({a = (if (let u = 0 in (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b))) then (( \f: Nat .((f (pred 1) ) (((\x: Nat .\y: Nat .x) 1 ) false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = 1 }.b) ))) , b = ({a = (succ (((\x: Unit .\y: Unit .y) (iszero 0) ) 1)) , b = (((\x: Rec X. X .\y: Unit .x) (let u = 1 in true) ) false) }.b) }.a)
(((\x: Unit .\y: Bool .x) ({a = ({a = ({a = ({a = true , b = false }.b) , b = (let u = false in 1) }.b) , b = (let u = 0 in (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b))) , c = (let u = ({a = 0 , b = 0 }.b) in u) }.c) , b = (if ({a = (succ (succ 0)) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) then (let u = ({a = false , b = (((\x: Rec X. X .\y: Bool .y) false ) 1) }.a) in (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y)) else (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y)) , c =  ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Bool ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) )) }.b) ) ({a = (pred 1) , b = (( \f: Bool .((f false ) (let u = false in false) ) ) (\a: Unit .\b: Nat .b)) }.b))
({a = (let u = (let u = (((\x: Nat .\y: Nat .x) 1 ) true) in (let u = 0 in (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)))) in u) , b = (( \f: Nat .((f ({a = (let u = (fix (\x: Rec X. X . 0 )) in u) , b = (case <l = (((\x: Unit .\y: Rec X. X .x) 1 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f (if false then 0 else 1) ) ({a = 0 , b = 1 }.b) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)) }.a)
(unfold [ Rec X. X ] (fold [ Unit ] (let u = (pred ({a = 0 , b = true , c = 1 }.c)) in ({a = (( \f: Bool .((f (if true then 1 else 1) ) (pred 1) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] true )) )) , c =  (fix (\x: Unit . ({a = true , b = 0 }.b) )) }.b)) ))
(let u = (case <l = (succ (succ ({a = 1 , b = true , c = 0 }.c))) > as Bool of < l = x > => x | < r = y > => y) in (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) in (let u = (unfold [ Unit ] (fold [ Bool ] 0 )) in (let u = true in 1))))
((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (pred (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .y) false ) 1) ) (let u = 0 in 0) ) ) (\a: Nat .\b: Unit .b))) ))
(fix (\x: Rec X. X . (((\x: Nat .\y: Unit .y) (let u = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) in u) ) (let u = (((\x: Nat .\y: Nat .x) false ) false) in u)) ))
(fix (\x: Rec X. X . (((\x: Unit .\y: Unit .y) ({a = (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Bool .b)) , b = ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) in true) }.b) }.b) ) (( \f: Nat .((f ({a = 0 , b = false }.a) ) (fix (\x: Bool . 0 )) ) ) (\a: Rec X. X .\b: Nat .b))) ))
({a = (if (((\x: Unit .\y: Unit .y) (if true then true else true) ) (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) true ) false) ))) then (if ({a = 0 , b = false , c =  0 }.b) then (( \f: Nat .((f 1 ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) else (if (iszero 0) then ({a = 0 , b = 0 }.b) else (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )))) , b = (succ (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = true , c = 0 }.c) )))) }.b)
({a = (((\x: Bool .\y: Unit .y) (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] true )) ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = 1 , b = false }.b)) , b = (( \f: Bool .((f (if true then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else false) ) (let u = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = true }.b) in (fix (\x: Rec X. X . false ))) ) ) (\a: Bool .\b: Rec X. X .a)) }.b)
(if (let u = (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) )) in u) then (unfold [ Rec X. X ] (fold [ Bool ] (let u = (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = false , c = 1 }.c) )) in u) )) else (( \f: Bool .((f (( \f: Nat .((f (succ 1) ) (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = 0 }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b))) , b = (unfold [ Nat ] (fold [ Bool ] false )) }.a) )) ) ) (\a: Bool .\b: Nat .a)))
(fix (\x: Bool . (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Bool .y) (unfold [ Nat ] (fold [ Rec X. X ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) ) (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ))) ) (let u = (((\x: Unit .\y: Unit .y) false ) true) in (fix (\x: Nat . (unfold [ Nat ] (fold [ Bool ] true )) )))) ))
(if (let u = (pred 0) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) then (unfold [ Rec X. X ] (fold [ Bool ] (if (((\x: Rec X. X .\y: Unit .y) true ) ({a = 1 , b = false }.b)) then (if (fix (\x: Rec X. X . false )) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else true) else (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)))) )) else ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .x) ({a = (((\x: Rec X. X .\y: Bool .y) true ) 1) , b = (((\x: Rec X. X .\y: Bool .y) true ) false) , c =  (if false then 1 else 0) }.b) ) (((\x: Bool .\y: Rec X. X .x) true ) ({a = 0 , b = false , c =  1 }.b))) )))
(let u = (fix (\x: Unit . (case <r = (unfold [ Bool ] (fold [ Rec X. X ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) )) in u)
(case <r = (let u = (fix (\x: Bool . ({a = ({a = 1 , b = true , c = 0 }.c) , b = ({a = false , b = 0 }.a) , c =  (if false then 0 else (succ 1)) }.b) )) in u) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Nat .((f ({a = (( \f: Unit .((f 1 ) (((\x: Nat .\y: Unit .y) true ) 0) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) }.a) ) ({a = (( \f: Unit .((f 1 ) (((\x: Unit .\y: Rec X. X .x) 0 ) false) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (case <l = (pred ({a = 1 , b = true , c = 0 }.c)) > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Unit .b))
(unfold [ Nat ] (fold [ Unit ] ({a = (((\x: Unit .\y: Rec X. X .y) ({a = ({a = false , b = 0 }.b) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  (((\x: Unit .\y: Rec X. X .x) 1 ) false) }.b) ) (let u = ({a = false , b = 0 }.b) in 1)) , b = (fix (\x: Unit . (((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Rec X. X .y) true ) false) ) false) )) }.a) ))
(let u = ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = (let u = 0 in true) }.a) , b = ({a = ({a = 1 , b = true , c = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.c) , b = (let u = (fix (\x: Bool . 0 )) in (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .b))) }.b) }.b) in u)
({a = ({a = (let u = false in false) , b = (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = true , c = 0 }.c) )) }.a) , b = (pred ({a = ({a = ({a = false , b = 1 }.a) , b = (((\x: Rec X. X .\y: Bool .x) ({a = false , b = 1 }.a) ) true) }.b) , b = (let u = 1 in 0) }.b)) }.a)
(let u = (let u = ({a = (((\x: Rec X. X .\y: Unit .y) true ) (let u = 0 in 1)) , b = (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) )) ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .b)) , c = ({a = false , b = 0 }.b) }.c) in u) in (( \f: Nat .((f ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = ({a = ({a = 1 , b = false , c = 1 }.c) , b = true , c =  ({a = 0 , b = true }.a) }.b) }.a) ) ({a = (((\x: Unit .\y: Unit .x) 1 ) false) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .b)) , c = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) }.c) ) ) (\a: Nat .\b: Nat .a)))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (succ (if (fix (\x: Bool . false )) then (case <l = (if true then 0 else 0) > as Rec X. X of < l = x > => x | < r = y > => y) else (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)))) ))
(fix (\x: Bool . (unfold [ Nat ] (fold [ Rec X. X ] ({a = (pred 1) , b = (((\x: Bool .\y: Rec X. X .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) ) ({a = 0 , b = (((\x: Nat .\y: Bool .x) false ) false) }.b)) }.b) )) ))
(((\x: Rec X. X .\y: Bool .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = ({a = (pred 1) , b = false , c =  0 }.b) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)) }.b) )) ) (((\x: Unit .\y: Unit .x) ({a = (iszero 1) , b = 1 }.a) ) (((\x: Bool .\y: Bool .x) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) (iszero 0))))
(iszero (let u = (let u = ({a = (let u = 0 in u) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c = 0 }.c) in u) in u))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = (( \f: Bool .((f ({a = 1 , b = false , c = (((\x: Bool .\y: Unit .y) false ) 0) }.c) ) (if true then 1 else (if false then 0 else 1)) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Nat .((f (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) true ) ) (\a: Nat .\b: Unit .b)) , c = ({a = 1 , b = true , c = 1 }.c) }.c) ))
(case <l = ({a = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = 1 }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .y) true ) true) )) , c = (succ (pred 1)) }.c) > as Bool of < l = x > => x | < r = y > => y)
({a = (fix (\x: Nat . (((\x: Unit .\y: Bool .x) (if (if false then false else true) then 1 else ({a = 1 , b = true }.a)) ) (let u = true in true)) )) , b = (let u = (iszero ({a = (succ 0) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) , c = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.c)) in u) }.b)
(((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) ({a = (let u = 1 in false) , b = (let u = (fix (\x: Unit . 0 )) in ({a = true , b = 0 }.b)) }.a) ) (let u = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) in u)) ) (((\x: Bool .\y: Unit .x) (let u = (let u = true in true) in u) ) (fix (\x: Unit . (((\x: Bool .\y: Bool .y) false ) true) ))) ) ) (\a: Bool .\b: Bool .a)) ) (((\x: Bool .\y: Nat .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = true , b = 0 }.a) )) ) (case <r = ({a = 0 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y)))
(succ ({a = ({a = ({a = false , b = false }.b) , b = 1 }.b) , b = (let u = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) in u) , c = (let u = (let u = true in u) in ({a = 0 , b = false }.a)) }.c))
(((\x: Rec X. X .\y: Rec X. X .x) (let u = (( \f: Unit .((f (if false then 0 else 0) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) in (fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .y) true ) 0) ))) ) (((\x: Rec X. X .\y: Unit .x) ({a = (let u = 1 in true) , b = false }.b) ) ({a = 1 , b = false }.b)))
({a = (let u = ({a = (let u = 1 in u) , b = ({a = (let u = ({a = 1 , b = false , c =  1 }.b) in u) , b = (case <l = ({a = 0 , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) }.a) , c = (fix (\x: Rec X. X . 1 )) }.c) in (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) 0 ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false ))) ))) , b = (unfold [ Unit ] (fold [ Bool ] ({a = (case <l = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (let u = true in false) in false) }.b) )) }.a)
({a = ({a = (((\x: Unit .\y: Unit .y) false ) 1) , b = ({a = (((\x: Bool .\y: Bool .y) ({a = true , b = 0 }.a) ) false) , b = (let u = 1 in 1) }.a) , c =  (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Unit .x) false ) false) ) ({a = (iszero 1) , b = (pred 1) }.b)) }.b) , b = (let u = ({a = ({a = 1 , b = ({a = false , b = true }.b) , c =  (((\x: Bool .\y: Nat .y) true ) 1) }.b) , b = ({a = false , b = 0 }.b) }.b) in ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = false in (((\x: Bool .\y: Bool .x) false ) false)) , c = ({a = 1 , b = false , c = 0 }.c) }.c)) }.a)
(let u = ({a = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.a) , b = (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = true , c = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) }.c) )) }.b) in ({a = (fix (\x: Bool . (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) , b = (pred (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . 0 )) ))) }.b))
(unfold [ Bool ] (fold [ Bool ] (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) }.b) )) in (fix (\x: Nat . ({a = 1 , b = true , c = 1 }.c) ))) ))
(if (((\x: Unit .\y: Unit .y) ({a = (if ({a = false , b = false }.b) then 1 else (let u = true in 1)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) }.b) ) (iszero (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 0 , b = 0 }.b) )) )))) then ({a = (((\x: Bool .\y: Nat .y) (( \f: Bool .((f true ) (if false then false else true) ) ) (\a: Nat .\b: Unit .a)) ) (((\x: Rec X. X .\y: Rec X. X .x) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ({a = 0 , b = true }.b))) , b = (if (((\x: Unit .\y: Unit .y) true ) true) then (let u = (pred 0) in (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .a))) else (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b))) }.b) else (((\x: Nat .\y: Bool .x) (let u = (pred (pred 1)) in (fix (\x: Nat . (let u = false in true) ))) ) (let u = (let u = false in u) in ({a = 0 , b = false , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b))))
(let u = ({a = (pred (((\x: Rec X. X .\y: Bool .y) false ) 0)) , b = (unfold [ Unit ] (fold [ Nat ] (iszero 1) )) , c = (((\x: Bool .\y: Bool .y) true ) (succ 0)) }.c) in u)
(let u = (fix (\x: Rec X. X . ({a = ({a = 0 , b = false , c =  1 }.b) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .a)) }.b) )) in u)
(succ (((\x: Nat .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .a)) , c =  (fix (\x: Rec X. X . 0 )) }.b) )) ) (succ (((\x: Bool .\y: Rec X. X .y) true ) 0))))
(succ (let u = ({a = ({a = false , b = 0 }.a) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.a) in (((\x: Rec X. X .\y: Bool .y) (let u = false in u) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)))))
(if ({a = (let u = true in u) , b = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) , b = (let u = true in false) }.b) }.b) then (let u = (((\x: Unit .\y: Unit .x) false ) false) in (if true then (unfold [ Unit ] (fold [ Unit ] 1 )) else ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )))) else ({a = (if (iszero 1) then 1 else 0) , b = ({a = true , b = (let u = true in true) }.b) , c = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (if true then false else false) }.a) }.c))
(iszero (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in u) )) in (pred (let u = 0 in u))))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = ({a = true , b = 0 }.b) , b = (unfold [ Nat ] (fold [ Nat ] false )) , c = ({a = 1 , b = false }.a) }.c) , b = (let u = (let u = false in u) in u) , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.c) ))
(( \f: Rec X. X .((f (( \f: Nat .((f ({a = (let u = 0 in 0) , b = (let u = (if false then false else true) in u) }.a) ) ({a = false , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b) ) ) (\a: Bool .\b: Nat .a)) ) (pred ({a = (fix (\x: Nat . true )) , b = 0 }.b)) ) ) (\a: Bool .\b: Nat .a))
(succ (succ (let u = 0 in ({a = false , b = 1 }.b))))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Bool . (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Bool .y) false ) false) ) ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .b)) , b = (fix (\x: Rec X. X . 1 )) }.a)) ) (((\x: Unit .\y: Rec X. X .y) true ) 0)) )) ))
(( \f: Bool .((f (( \f: Bool .((f ({a = ({a = false , b = 0 }.a) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.a) ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Bool .a)) ) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )) , b = (let u = 1 in ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) , c =  (pred 0) }.b) ) ) (\a: Bool .\b: Rec X. X .a))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) true) in (fix (\x: Bool . (case <r = true > as Nat of < l = x > => x | < r = y > => y) ))) ))
(case <r = ({a = (succ (((\x: Unit .\y: Unit .x) 1 ) true)) , b = ({a = (( \f: Bool .((f (((\x: Nat .\y: Nat .x) 0 ) (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .b))) ) (let u = ({a = 1 , b = false }.a) in (let u = false in 0)) ) ) (\a: Unit .\b: Unit .b)) , b = (let u = false in false) }.b) , c =  (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) in ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = (if false then false else false) }.a)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(succ (let u = (fix (\x: Nat . (unfold [ Nat ] (fold [ Unit ] false )) )) in (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) true))))
({a = (if (((\x: Unit .\y: Nat .y) (let u = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .b)) in u) ) (fix (\x: Unit . (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) ))) then ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = ({a = 1 , b = (let u = false in true) }.a) }.b) else (unfold [ Rec X. X ] (fold [ Bool ] (let u = (pred 1) in 1) ))) , b = (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Bool . true )) )) > as Nat of < l = x > => x | < r = y > => y) }.b)
({a = ({a = (( \f: Nat .((f (( \f: Nat .((f (let u = true in u) ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Nat .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in false) )) ) ) (\a: Bool .\b: Bool .a)) , b = (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.b) , b = (let u = (( \f: Unit .((f (if ({a = 0 , b = true }.b) then (let u = 0 in false) else ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , c =  (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) }.b)) ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Bool .\y: Rec X. X .y) (let u = 1 in false) ) (let u = false in u))) , c = (((\x: Bool .\y: Bool .x) ({a = (let u = 0 in 0) , b = false }.a) ) ({a = (((\x: Bool .\y: Rec X. X .y) true ) 1) , b = true , c =  0 }.b)) }.c)
(((\x: Nat .\y: Nat .y) (fix (\x: Nat . ({a = (let u = 1 in true) , b = 0 }.a) )) ) ({a = ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = (fix (\x: Bool . true )) , c = (( \f: Unit .((f (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Nat .y) false ) 1) )) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Unit .a)) }.c) , b = (if ({a = ({a = true , b = 1 }.a) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.a) then ({a = 1 , b = true }.b) else ({a = true , b = 1 }.a)) , c = (((\x: Nat .\y: Nat .x) (let u = 0 in 1) ) (fix (\x: Bool . false ))) }.c))
(let u = ({a = (iszero ({a = 0 , b = true , c = 1 }.c)) , b = (( \f: Bool .((f ({a = true , b = false }.b) ) (let u = false in false) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) in ({a = (((\x: Unit .\y: Bool .x) true ) true) , b = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) in (let u = 1 in u)) }.a))
(let u = (let u = ({a = (succ 1) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .a)) , c = (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 0) > as Unit of < l = x > => x | < r = y > => y) }.c) in u) in (let u = ({a = ({a = 0 , b = false , c = 0 }.c) , b = ({a = true , b = 0 }.a) , c =  0 }.b) in (((\x: Rec X. X .\y: Rec X. X .x) (if true then 0 else 0) ) (let u = 1 in (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a))))))
(((\x: Unit .\y: Rec X. X .x) (if (let u = (((\x: Nat .\y: Rec X. X .y) (((\x: Nat .\y: Unit .x) false ) true) ) (let u = false in 1)) in (let u = ({a = 0 , b = true }.a) in (let u = 0 in false))) then ({a = (((\x: Bool .\y: Bool .x) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) false) , b = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true )) in false) }.b) else (( \f: Bool .((f (((\x: Nat .\y: Unit .x) ({a = 0 , b = false , c =  1 }.b) ) (let u = 0 in true)) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (case <r = (fix (\x: Bool . false )) > as Nat of < l = x > => x | < r = y > => y) }.b) )))
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (case <r = ({a = false , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) ))
(case <l = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) (iszero 1) ) (if (if true then false else false) then ({a = 1 , b = false , c = 0 }.c) else 0)) ) ({a = (((\x: Rec X. X .\y: Unit .y) true ) (if false then 1 else 1)) , b = (if true then 1 else 1) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y)
({a = (unfold [ Unit ] (fold [ Bool ] ({a = (( \f: Bool .((f (if false then 0 else (if false then 1 else 0)) ) (if (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) then 1 else (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Bool .\b: Nat .b)) , b = (iszero (succ 0)) }.b) )) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) ) (((\x: Unit .\y: Rec X. X .y) ({a = false , b = true }.b) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b)))) )) }.b)
({a = (((\x: Bool .\y: Rec X. X .y) (if true then true else true) ) ({a = 1 , b = true , c =  (let u = 1 in u) }.b)) , b = (if (( \f: Bool .((f false ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) then (let u = ({a = true , b = ({a = 0 , b = true }.a) }.a) in u) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true ))) }.b)
(fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] ({a = (((\x: Nat .\y: Nat .x) false ) false) , b = (let u = false in u) }.b) )) ))
(( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] (case <l = ({a = 0 , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) )) ) (fix (\x: Nat . (succ ({a = 1 , b = false , c = 1 }.c)) )) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Rec X. X . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f ({a = true , b = ({a = 0 , b = true , c = 1 }.c) }.a) ) (let u = 1 in true) ) ) (\a: Bool .\b: Nat .a)) )) ))
(if (( \f: Bool .((f (let u = true in (fix (\x: Rec X. X . true ))) ) ({a = (pred (((\x: Rec X. X .\y: Bool .y) true ) 0)) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .b)) }.b) ) ) (\a: Nat .\b: Unit .a)) then (((\x: Bool .\y: Bool .y) ({a = (succ (fix (\x: Nat . 1 ))) , b = (unfold [ Nat ] (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .a)) )) }.b) ) (unfold [ Bool ] (fold [ Unit ] (let u = false in true) ))) else ({a = (let u = ({a = true , b = ({a = 1 , b = 0 }.b) }.b) in (((\x: Rec X. X .\y: Bool .y) true ) (fix (\x: Unit . true )))) , b = (case <l = (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) ) ({a = false , b = (if true then 0 else 1) }.b) ) ) (\a: Unit .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) }.a))
(let u = (let u = (let u = ({a = true , b = ({a = 0 , b = true }.a) }.b) in (((\x: Unit .\y: Bool .y) ({a = 0 , b = false }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )))) in (iszero ({a = 0 , b = false , c = (fix (\x: Rec X. X . 1 )) }.c))) in (((\x: Nat .\y: Rec X. X .x) ({a = ({a = true , b = (unfold [ Unit ] (fold [ Nat ] false )) }.b) , b = (((\x: Bool .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) ({a = ({a = false , b = 0 }.b) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) }.a)) }.a) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = (((\x: Unit .\y: Bool .x) true ) (let u = true in u)) > as Unit of < l = x > => x | < r = y > => y) ))))
(( \f: Nat .((f (( \f: Unit .((f (pred 0) ) (pred 1) ) ) (\a: Bool .\b: Rec X. X .b)) ) (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Unit .y) (iszero 0) ) false) ) ({a = 1 , b = true , c = 0 }.c)) ) ({a = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) in 1) , b = (((\x: Unit .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = false in u)) , c = (if (fix (\x: Nat . true )) then 1 else 0) }.c) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .b))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = ({a = ({a = ({a = true , b = 1 }.b) , b = (if true then 0 else (let u = true in 1)) }.b) , b = ({a = (succ 1) , b = (iszero 0) , c = ({a = 1 , b = false }.a) }.c) }.b) , b = ({a = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Bool .b)) , b = ({a = 1 , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , c = 0 }.c) }.a) }.a) ))
(let u = ({a = (((\x: Rec X. X .\y: Nat .y) (fix (\x: Bool . (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) )) ) ({a = (pred (((\x: Rec X. X .\y: Unit .y) true ) 1)) , b = ({a = false , b = false }.b) , c = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.c)) , b = ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) , c = (succ 0) }.c) }.b) in ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = (fix (\x: Rec X. X . (fix (\x: Nat . true )) )) , c =  (((\x: Bool .\y: Bool .x) ({a = ({a = false , b = false }.b) , b = (let u = true in 0) }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.b))
(unfold [ Bool ] (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] ({a = (( \f: Unit .((f 0 ) (if true then 0 else 0) ) ) (\a: Bool .\b: Unit .a)) , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) }.c) )) ))
({a = (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .x) ({a = true , b = 1 }.b) ) (let u = true in false)) )) , b = ({a = (let u = (iszero 1) in u) , b = (fix (\x: Bool . 1 )) }.a) }.a)
({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = (succ 1) in 0) )) in (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (let u = true in u) else (fix (\x: Rec X. X . ({a = true , b = false }.b) )))) , b = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f ({a = 0 , b = true }.b) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Unit .\b: Unit .a)) )) in ({a = (((\x: Nat .\y: Nat .y) true ) 1) , b = ({a = 0 , b = false , c =  0 }.b) , c =  ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b)) }.b)
({a = (let u = (unfold [ Nat ] (fold [ Unit ] (let u = 1 in u) )) in (let u = (if true then 0 else 0) in u)) , b = ({a = (fix (\x: Nat . (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (let u = ({a = true , b = 1 }.a) in 1) }.a) }.a)
(unfold [ Nat ] (fold [ Unit ] (let u = (unfold [ Unit ] (fold [ Bool ] false )) in ({a = ({a = 0 , b = true , c = 0 }.c) , b = true }.a)) ))
(((\x: Rec X. X .\y: Unit .x) (let u = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) in (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) false ) true) )) > as Bool of < l = x > => x | < r = y > => y)) ) ({a = ({a = (fix (\x: Bool . false )) , b = (((\x: Unit .\y: Unit .x) 0 ) false) }.b) , b = (((\x: Nat .\y: Nat .y) (iszero (( \f: Nat .((f (pred 0) ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 0 , b = false }.b) ))) }.b))
(((\x: Nat .\y: Bool .y) (let u = ({a = (let u = 1 in u) , b = (iszero 0) }.a) in (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) ))) ) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Unit .\y: Unit .y) (if (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) then ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) else (( \f: Bool .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) true ) ) (\a: Bool .\b: Bool .a))) ) (((\x: Bool .\y: Rec X. X .y) false ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)))) ) (let u = (( \f: Bool .((f false ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Nat .b)) in (pred (if false then 0 else 0)))))
({a = ({a = (( \f: Rec X. X .((f (succ 1) ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (iszero 0) }.b) , b = (let u = (case <l = (let u = 1 in 1) > as Unit of < l = x > => x | < r = y > => y) in (if false then (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) else 1)) }.b)
({a = (((\x: Nat .\y: Nat .x) ({a = (let u = (if ({a = 1 , b = false }.b) then false else (fix (\x: Bool . true ))) in (if false then 1 else (pred 1))) , b = (fix (\x: Nat . ({a = 1 , b = true }.b) )) , c = (if ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = ({a = false , b = false }.b) }.b) then (let u = 1 in 1) else (((\x: Rec X. X .\y: Nat .x) 0 ) false)) }.c) ) (( \f: Rec X. X .((f (( \f: Nat .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a))) , b = (case <l = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u) > as Unit of < l = x > => x | < r = y > => y) }.b)
(( \f: Bool .((f (let u = ({a = true , b = 0 }.a) in u) ) (fix (\x: Nat . (case <r = ({a = 0 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) )) ) ) (\a: Nat .\b: Rec X. X .a))
(( \f: Nat .((f (((\x: Nat .\y: Nat .x) ({a = (succ 0) , b = (let u = (((\x: Rec X. X .\y: Bool .x) (let u = 1 in u) ) (iszero 1)) in (((\x: Rec X. X .\y: Bool .x) 0 ) true)) }.b) ) (let u = ({a = (let u = false in 1) , b = (((\x: Unit .\y: Bool .x) false ) true) }.a) in (let u = (let u = false in true) in u))) ) (let u = (((\x: Bool .\y: Bool .y) (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (((\x: Nat .\y: Nat .x) false ) true) , b = true }.b)) in ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = ({a = (if false then true else false) , b = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) }.b)) ) ) (\a: Rec X. X .\b: Nat .b))
(if ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = true , c =  0 }.b) )) )) then (((\x: Nat .\y: Nat .y) (iszero (( \f: Bool .((f (let u = 1 in u) ) (fix (\x: Nat . (pred 0) )) ) ) (\a: Nat .\b: Nat .b))) ) (case <l = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y)) else (unfold [ Rec X. X ] (fold [ Nat ] (pred (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) in u)) )))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (if (if ({a = ({a = 1 , b = 1 }.b) , b = ({a = true , b = 0 }.a) }.b) then (unfold [ Bool ] (fold [ Bool ] (let u = true in u) )) else (let u = (((\x: Unit .\y: Unit .y) true ) true) in ({a = 1 , b = true }.b))) then (fix (\x: Rec X. X . ({a = ({a = false , b = true }.b) , b = (unfold [ Unit ] (fold [ Unit ] (let u = 1 in u) )) }.a) )) else (((\x: Unit .\y: Unit .y) (fix (\x: Nat . true )) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)))) ))
({a = (((\x: Nat .\y: Rec X. X .y) (if ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) then (iszero (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) else (iszero (((\x: Nat .\y: Bool .y) false ) 0))) ) (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)))) , b = (((\x: Rec X. X .\y: Nat .x) (case <r = (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then false else (let u = true in u)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <r = (case <r = (if false then true else true) > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)) }.a)
(let u = (let u = (let u = ({a = 0 , b = false , c =  0 }.b) in (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .a))) in (let u = (unfold [ Nat ] (fold [ Unit ] 0 )) in true)) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero 0) )))
(( \f: Unit .((f ({a = (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) (let u = 1 in 1) ) ) (\a: Nat .\b: Nat .a)) )) , b = (let u = ({a = (if true then 1 else 1) , b = false , c = 1 }.c) in (case <r = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (unfold [ Nat ] (fold [ Nat ] false )) , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y)) , c = (((\x: Bool .\y: Rec X. X .y) (( \f: Nat .((f ({a = 1 , b = false }.b) ) ({a = true , b = true }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (((\x: Nat .\y: Unit .y) false ) (if false then 1 else 0))) }.c) ) ({a = ({a = (succ 1) , b = ({a = 0 , b = false }.a) }.b) , b = (let u = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) in u) in u) }.b) ) ) (\a: Unit .\b: Nat .b))
(fix (\x: Bool . (((\x: Bool .\y: Nat .x) ({a = 0 , b = (let u = true in false) }.b) ) (let u = ({a = false , b = true }.b) in false)) ))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] ({a = false , b = ({a = true , b = 1 }.a) }.b) )) ))
(succ (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) )) ) ({a = (let u = true in 0) , b = (if false then 1 else 1) }.b) ) ) (\a: Bool .\b: Bool .a)))
(let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false )) in (let u = false in (if false then 1 else 1))) )) in (fix (\x: Unit . (let u = false in (if false then false else false)) )))
(iszero (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = 0 in 0) )) ) (fix (\x: Nat . (if false then 1 else 0) )) ) ) (\a: Nat .\b: Bool .a)))
({a = (let u = (unfold [ Unit ] (fold [ Unit ] 0 )) in u) , b = ({a = (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) in ({a = true , b = false }.b)) }.b) , c =  ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (pred 1) ) ) (\a: Bool .\b: Unit .b)) )) }.b)
(( \f: Nat .((f (if (((\x: Bool .\y: Bool .x) (fix (\x: Bool . true )) ) true) then (fix (\x: Nat . true )) else ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.b)) ) ({a = ({a = (pred (succ 0)) , b = (let u = ({a = 0 , b = ({a = 1 , b = false , c =  1 }.b) , c = 1 }.c) in (let u = 1 in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)))) }.b) , b = (((\x: Nat .\y: Nat .x) ({a = (((\x: Nat .\y: Nat .x) false ) true) , b = (let u = true in u) }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) , c =  (let u = ({a = 0 , b = true , c = 0 }.c) in (unfold [ Unit ] (fold [ Nat ] 0 ))) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = 0 , b = false , c = 1 }.c) , b = true }.a) )) )) , b = ({a = (if ({a = false , b = 1 }.a) then (let u = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) in (let u = false in 0)) else (let u = (let u = true in u) in ({a = 1 , b = 0 }.b))) , b = (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) , c = (let u = (case <l = (if true then (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) else ({a = true , b = 0 }.b)) > as Bool of < l = x > => x | < r = y > => y) in u) }.c) }.b)
(( \f: Nat .((f (let u = (( \f: Nat .((f (((\x: Unit .\y: Nat .y) false ) ({a = 0 , b = 0 }.b)) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Unit .\b: Unit .a)) in (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = 0 }.b) ))) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = 1 , b = true , c = 0 }.c) , b = true }.b) ) ({a = 0 , b = (succ 0) }.b)) ) ) (\a: Unit .\b: Unit .a))
(((\x: Nat .\y: Unit .y) (fix (\x: Bool . ({a = ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = 0 }.a) , b = (((\x: Nat .\y: Bool .x) 1 ) true) }.a) )) ) (succ (let u = (let u = 0 in 1) in u)))
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) (((\x: Bool .\y: Unit .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) ) ({a = ({a = 0 , b = false , c =  0 }.b) , b = 1 }.a)) ) (( \f: Bool .((f (case <r = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = ({a = 1 , b = true , c = 0 }.c) in false) ) ) (\a: Bool .\b: Unit .b))) ) (fix (\x: Nat . (let u = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) in ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = (let u = 0 in false) , c =  0 }.b)) )) ) ) (\a: Nat .\b: Bool .a))
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = 0 , b = false , c =  ({a = 1 , b = 0 }.b) }.b) in (let u = (( \f: Rec X. X .((f true ) (fix (\x: Unit . true )) ) ) (\a: Rec X. X .\b: Unit .b)) in (((\x: Unit .\y: Rec X. X .y) true ) false))) )) ))
({a = (((\x: Bool .\y: Nat .x) (let u = (( \f: Unit .((f ({a = 1 , b = true , c = 0 }.c) ) 0 ) ) (\a: Nat .\b: Bool .a)) in u) ) ({a = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) , b = (let u = false in u) }.b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f (let u = 1 in (if false then false else false)) ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Rec X. X .y) (let u = (let u = false in (fix (\x: Rec X. X . true ))) in u) ) ({a = false , b = true }.b))) , c = (fix (\x: Rec X. X . ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) 0 ) ) (\a: Bool .\b: Nat .b)) )) )) }.c)
(let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = 0 in u) )) ) (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 0 , b = true , c = 0 }.c) )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) )) in (( \f: Unit .((f (( \f: Bool .((f ({a = (pred 1) , b = (let u = ({a = true , b = true }.b) in false) }.b) ) (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) in false) ) ) (\a: Rec X. X .\b: Bool .b)) ) (let u = ({a = true , b = 0 }.a) in u) ) ) (\a: Unit .\b: Bool .a)))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (let u = (pred ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 ))) in ({a = 1 , b = (let u = true in false) }.b)) in (fix (\x: Rec X. X . (let u = (iszero 0) in u) ))) ))
(if (case <r = (let u = true in false) > as Bool of < l = x > => x | < r = y > => y) then (( \f: Unit .((f (let u = (( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] 1 )) ) (let u = 1 in u) ) ) (\a: Bool .\b: Rec X. X .b)) in u) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Rec X. X .\b: Nat .a)) else (let u = (let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = true , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) in (fix (\x: Rec X. X . false ))) in (let u = (pred 1) in u)))
(fix (\x: Bool . (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then (((\x: Unit .\y: Unit .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Bool .\y: Nat .x) 0 ) false)) else (let u = 1 in u)) ))
({a = (let u = ({a = (( \f: Bool .((f (pred 1) ) (succ 0) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (( \f: Unit .((f 0 ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) in ({a = ({a = ({a = 1 , b = false , c =  0 }.b) , b = 0 }.b) , b = (fix (\x: Nat . (let u = (if true then 1 else 0) in true) )) , c = (let u = (((\x: Nat .\y: Bool .y) true ) 1) in (succ 1)) }.c)) , b = ({a = (unfold [ Nat ] (fold [ Unit ] (( \f: Unit .((f ({a = 1 , b = true }.b) ) false ) ) (\a: Nat .\b: Unit .a)) )) , b = (((\x: Nat .\y: Rec X. X .x) ({a = false , b = true }.b) ) (let u = true in u)) }.b) , c =  (((\x: Bool .\y: Nat .x) (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ) (case <l = (fix (\x: Rec X. X . 0 )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) ) (( \f: Bool .((f (((\x: Nat .\y: Bool .x) true ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) ) ) (\a: Nat .\b: Unit .b))) }.b)
(iszero (if ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (fix (\x: Rec X. X . true )) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.a) )) then (( \f: Bool .((f 1 ) ({a = 1 , b = false , c = 1 }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b)) else (succ (pred 0))))
(if ({a = ({a = ({a = 1 , b = false }.a) , b = (iszero 0) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = ({a = (((\x: Nat .\y: Rec X. X .y) true ) (let u = false in 1)) , b = (((\x: Unit .\y: Rec X. X .y) true ) false) , c = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) }.c) }.a) then (let u = (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .b)) in u) in (fix (\x: Bool . 1 ))) else (((\x: Rec X. X .\y: Rec X. X .x) ({a = (( \f: Nat .((f ({a = false , b = 0 }.a) ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (case <l = (((\x: Rec X. X .\y: Nat .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) false) > as Bool of < l = x > => x | < r = y > => y) }.b) ) (if (let u = ({a = true , b = true }.b) in false) then (fix (\x: Rec X. X . false )) else ({a = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . true )) , c = (let u = false in 1) }.c) , b = (if true then true else (((\x: Rec X. X .\y: Unit .y) false ) true)) }.b))))
(iszero (let u = (fix (\x: Nat . (succ 0) )) in (((\x: Nat .\y: Rec X. X .x) 1 ) ({a = false , b = 1 }.a))))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) ({a = (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = (let u = 0 in false) }.b) ) (fix (\x: Rec X. X . ({a = true , b = true }.b) ))) ))
(case <l = (case <l = (if true then (if false then 0 else 0) else 0) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (((\x: Rec X. X .\y: Bool .y) (if ({a = (let u = 0 in false) , b = 0 }.a) then (iszero (let u = 1 in 1)) else ({a = ({a = false , b = true }.b) , b = ({a = true , b = false }.b) }.b)) ) (((\x: Unit .\y: Bool .y) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = 0 , b = false }.b))) , b = (let u = (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .x) 0 ) true) ) (let u = true in 1) ) ) (\a: Bool .\b: Nat .a)) in u) }.a)
((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = (((\x: Bool .\y: Nat .x) (let u = true in u) ) (let u = true in u)) in (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ))) ))
({a = ({a = (fix (\x: Nat . (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) )) , b = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) }.b) , b = ({a = (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Nat .x) 0 ) false) ) false) , b = ({a = (let u = 1 in (unfold [ Nat ] (fold [ Nat ] 0 ))) , b = (fix (\x: Rec X. X . (let u = 1 in false) )) , c =  ({a = 0 , b = true }.a) }.b) }.b) , c = (if ({a = (iszero 0) , b = ({a = (let u = 1 in 1) , b = false , c =  0 }.b) }.b) then (case <l = (pred (((\x: Bool .\y: Nat .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.b))) > as Nat of < l = x > => x | < r = y > => y) else ({a = ({a = (let u = 1 in 1) , b = (fix (\x: Nat . true )) }.b) , b = (let u = (unfold [ Rec X. X ] (fold [ Unit ] true )) in ({a = 0 , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = 1 }.c)) }.b)) }.c)
({a = ({a = ({a = (let u = 1 in 0) , b = (fix (\x: Unit . false )) }.a) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . false )) )) , c =  (let u = (iszero (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a))) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) }.b) , b = (((\x: Bool .\y: Unit .y) (let u = (( \f: Rec X. X .((f false ) (iszero 0) ) ) (\a: Unit .\b: Nat .a)) in (if true then true else false)) ) (let u = false in true)) }.b)
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .y) true ) false) )) , b = (let u = ({a = (fix (\x: Bool . 1 )) , b = ({a = 1 , b = 0 }.b) }.b) in u) }.a)
(case <r = (let u = (((\x: Unit .\y: Rec X. X .x) (iszero 1) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) in (((\x: Unit .\y: Nat .x) (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) )) ) (( \f: Nat .((f (((\x: Nat .\y: Bool .x) false ) false) ) (fix (\x: Unit . true )) ) ) (\a: Unit .\b: Unit .b)))) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Unit .y) (let u = (iszero ({a = ({a = false , b = 0 }.b) , b = 0 }.b)) in (let u = (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) in u)) ) (((\x: Nat .\y: Nat .x) (let u = ({a = (let u = 0 in 0) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) }.b) in u) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Unit . ({a = 0 , b = false , c =  1 }.b) )) )) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a)))
(if (( \f: Nat .((f (let u = (iszero 1) in u) ) ({a = (if true then true else true) , b = (fix (\x: Unit . (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .a)) )) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) then (( \f: Nat .((f (let u = (fix (\x: Rec X. X . false )) in true) ) (if ({a = false , b = 0 }.a) then (fix (\x: Unit . (let u = true in u) )) else (((\x: Unit .\y: Unit .y) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) false)) ) ) (\a: Unit .\b: Rec X. X .b)) else ({a = (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ({a = false , b = false }.b) , b = (let u = false in u) }.b) , c =  (let u = (pred 1) in ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b)) }.b))
({a = (fix (\x: Nat . (pred ({a = 0 , b = false , c = 1 }.c)) )) , b = ({a = ({a = ({a = ({a = 0 , b = 1 }.b) , b = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.b) , c = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.c) , b = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (if false then 1 else 0) in u) }.b) }.b) , b = (let u = (succ 1) in (if true then ({a = 1 , b = true , c =  0 }.b) else false)) }.b) , c = (succ (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) in ({a = false , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b))) }.c)
(let u = (fix (\x: Bool . ({a = ({a = (let u = 1 in u) , b = true }.b) , b = (fix (\x: Rec X. X . (let u = 0 in u) )) }.a) )) in (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Nat .y) (( \f: Unit .((f (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Nat .a)) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a))) ) ({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) (iszero 1) ) (((\x: Bool .\y: Bool .y) true ) false)) ) (((\x: Nat .\y: Rec X. X .x) true ) ({a = 0 , b = false , c =  0 }.b)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . true )) )) }.b)))
(case <l = (fix (\x: Unit . (((\x: Unit .\y: Nat .x) (fix (\x: Bool . ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) )) ) (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c =  1 }.b) )) ) ({a = false , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .b))) )) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (pred ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) , b = (unfold [ Bool ] (fold [ Nat ] 1 )) }.b)) , b = (iszero (case <l = (let u = false in 1) > as Unit of < l = x > => x | < r = y > => y)) , c = (let u = (fix (\x: Nat . ({a = (unfold [ Nat ] (fold [ Nat ] 1 )) , b = (if true then true else false) }.a) )) in u) }.c)
(unfold [ Rec X. X ] (fold [ Bool ] (let u = ({a = (( \f: Rec X. X .((f ({a = 0 , b = true , c =  1 }.b) ) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ) (\a: Nat .\b: Bool .b)) , b = (succ 0) }.a) in ({a = ({a = (let u = false in false) , b = true }.b) , b = ({a = 1 , b = 1 }.b) }.b)) ))
({a = (((\x: Bool .\y: Nat .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true ))) , b = ({a = (((\x: Unit .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Unit ] false )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false ))) , b = (((\x: Nat .\y: Bool .y) (( \f: Unit .((f true ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = 1 , b = 1 }.b)) }.b) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f ({a = 1 , b = true }.a) ) (let u = 1 in u) ) ) (\a: Bool .\b: Nat .b)) )) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if (((\x: Bool .\y: Unit .x) (iszero (((\x: Bool .\y: Nat .y) true ) 0)) ) (if true then true else true)) then (pred (((\x: Rec X. X .\y: Unit .y) true ) 1)) else (((\x: Unit .\y: Unit .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) (((\x: Bool .\y: Bool .x) ({a = 1 , b = false , c =  0 }.b) ) true))) ))
(((\x: Bool .\y: Bool .x) (fix (\x: Bool . (fix (\x: Nat . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) )) ) ({a = (let u = false in true) , b = (( \f: Unit .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = false , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .b)) }.b))
({a = (pred ({a = (unfold [ Bool ] (fold [ Nat ] (fix (\x: Unit . 1 )) )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) , c = (if (let u = true in u) then 0 else 0) }.c)) , b = (fix (\x: Nat . ({a = ({a = 0 , b = false , c =  0 }.b) , b = ({a = 0 , b = 1 }.b) }.b) )) }.b)
(case <r = ({a = ({a = (let u = 1 in false) , b = ({a = false , b = 0 }.a) }.b) , b = (let u = ({a = true , b = 1 }.a) in ({a = true , b = false }.b)) }.b) > as Nat of < l = x > => x | < r = y > => y)
(if ({a = (( \f: Bool .((f ({a = 0 , b = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) }.a) ) (let u = (fix (\x: Unit . 1 )) in (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ))) ) ) (\a: Bool .\b: Nat .a)) , b = (fix (\x: Unit . ({a = 1 , b = false , c =  0 }.b) )) }.b) then (( \f: Nat .((f (case <r = (if true then false else false) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Unit .y) ({a = true , b = 0 }.a) ) ({a = false , b = 0 }.a)) ) ) (\a: Bool .\b: Rec X. X .b)) else (((\x: Unit .\y: Nat .x) ({a = (let u = (let u = 1 in 1) in u) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) , c =  (((\x: Rec X. X .\y: Nat .x) (if false then 0 else 0) ) true) }.b) ) ({a = ({a = 0 , b = true , c =  0 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.b)))
(succ (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Unit .y) (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) ) (let u = 0 in u)) ) (let u = (unfold [ Nat ] (fold [ Rec X. X ] true )) in u)))
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Bool ] (let u = true in u) )) )) , b = (case <r = (iszero (((\x: Unit .\y: Bool .x) 1 ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(iszero ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (pred 1) )))
({a = ({a = ({a = (if true then (succ 0) else 0) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) in u) , c = ({a = false , b = 0 }.b) }.c) , b = ({a = true , b = true }.b) , c = (((\x: Bool .\y: Bool .y) (let u = 0 in false) ) 0) }.c) , b = (((\x: Bool .\y: Bool .y) ({a = 0 , b = (unfold [ Nat ] (fold [ Bool ] true )) , c =  1 }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (if true then false else false) ))) , c =  ({a = (let u = (succ 1) in (((\x: Bool .\y: Unit .y) false ) false)) , b = (((\x: Unit .\y: Rec X. X .x) (succ (( \f: Nat .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Bool .a))) ) (( \f: Nat .((f (((\x: Unit .\y: Nat .y) false ) true) ) (let u = false in true) ) ) (\a: Nat .\b: Bool .b))) }.b) }.b)
({a = ({a = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = false }.b) )) ) (let u = true in u) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (((\x: Unit .\y: Unit .y) (unfold [ Bool ] (fold [ Rec X. X ] true )) ) (if true then 1 else 1)) }.a) , b = (unfold [ Nat ] (fold [ Bool ] ({a = (iszero (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) , b = (let u = (iszero 0) in u) }.b) )) }.b)
(let u = ({a = (((\x: Bool .\y: Bool .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) ) (((\x: Nat .\y: Nat .x) 0 ) true)) , b = (( \f: Nat .((f (iszero (if false then 0 else 1)) ) (iszero 1) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  ({a = (iszero ({a = false , b = 0 }.b)) , b = (let u = (let u = 0 in u) in (let u = 1 in u)) }.b) }.b) in (iszero (if true then 1 else ({a = 0 , b = true , c = 0 }.c))))
(let u = ({a = (let u = (let u = false in 1) in (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b))) , b = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] false )) )) in u) , c =  (((\x: Nat .\y: Unit .y) (if (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)) then (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a)) else (let u = true in u)) ) (case <l = ({a = 1 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y)) }.b) in (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Unit .x) ({a = (( \f: Rec X. X .((f 1 ) (let u = 0 in u) ) ) (\a: Unit .\b: Rec X. X .b)) , b = ({a = 1 , b = false }.b) , c = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.c) ) (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .a)) in (((\x: Nat .\y: Unit .y) false ) true))) ) (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .a))))
(unfold [ Nat ] (fold [ Bool ] (let u = (if ({a = true , b = 0 }.a) then ({a = false , b = 1 }.b) else ({a = 0 , b = 0 }.b)) in u) ))
(fix (\x: Nat . ({a = (( \f: Nat .((f ({a = 1 , b = true , c =  (pred 0) }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Bool .a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = 1 }.b) ) (if false then true else false)) }.a) ))
(if ({a = (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f true ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Unit .b)) ) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = ({a = (succ 0) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.b) }.b) then ({a = (( \f: Bool .((f ({a = (if true then false else true) , b = (let u = false in 0) }.b) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .b)) , b = (unfold [ Bool ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) ({a = false , b = 0 }.a) ) (unfold [ Unit ] (fold [ Bool ] false ))) )) , c =  (pred (((\x: Rec X. X .\y: Bool .y) false ) 0)) }.b) else (unfold [ Unit ] (fold [ Rec X. X ] ({a = (iszero 1) , b = (fix (\x: Bool . 1 )) }.a) )))
(let u = (succ ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .a)) }.a)) in (unfold [ Rec X. X ] (fold [ Bool ] (let u = (let u = 0 in false) in (let u = 0 in 1)) )))
({a = (pred (( \f: Rec X. X .((f (case <l = (succ (let u = 1 in 0)) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (pred 1) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a))) , b = ({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = ({a = 1 , b = false }.b) }.a) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = false in u) )) }.b) }.a)
({a = (if (( \f: Bool .((f (let u = false in false) ) (fix (\x: Unit . ({a = 0 , b = false }.b) )) ) ) (\a: Rec X. X .\b: Unit .b)) then (if (if false then false else true) then ({a = 1 , b = false }.b) else (let u = true in u)) else ({a = (((\x: Unit .\y: Unit .y) true ) 0) , b = ({a = 0 , b = true }.b) , c =  0 }.b)) , b = ({a = (case <l = (( \f: Bool .((f 0 ) (succ 0) ) ) (\a: Nat .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = false , b = (let u = 0 in u) }.a) }.b) }.b)
({a = (iszero (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) true)) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) , b = ({a = ({a = true , b = 1 }.b) , b = (let u = 0 in true) }.a) }.b) }.a)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Bool . (iszero 1) )) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (if (let u = ({a = true , b = false }.b) in u) then ({a = false , b = (let u = 1 in 1) }.a) else (iszero (pred 0))) ))
(( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Bool . (let u = (((\x: Nat .\y: Nat .x) true ) true) in false) )) )) ) ({a = (((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Bool .y) false ) true) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false ))) , b = (( \f: Unit .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) false ) ) (\a: Bool .\b: Unit .b)) }.b) ) ) (\a: Nat .\b: Unit .b))
(succ (if (case <r = (case <r = ({a = 0 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) then (succ (fix (\x: Nat . 1 ))) else (let u = 1 in u)))
(if (( \f: Unit .((f (( \f: Bool .((f ({a = false , b = 1 }.a) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Bool .\y: Nat .x) ({a = ({a = 0 , b = false }.a) , b = true , c =  (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.b) ) (( \f: Rec X. X .((f ({a = 1 , b = false }.b) ) (((\x: Bool .\y: Nat .x) true ) (if true then false else false)) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Nat .a)) then ({a = (let u = (((\x: Rec X. X .\y: Bool .x) ({a = false , b = true }.b) ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a))) in ({a = 0 , b = (((\x: Bool .\y: Nat .y) true ) 1) }.b)) , b = ({a = (fix (\x: Bool . false )) , b = ({a = (let u = (fix (\x: Unit . 1 )) in false) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) )) }.b) }.b) }.b) else ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (pred (let u = (let u = 1 in u) in u)) )))
(pred (succ ({a = (let u = (let u = 0 in u) in ({a = 0 , b = true , c = 0 }.c)) , b = (let u = false in (succ 1)) }.b)))
(let u = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) in ({a = (let u = 0 in 1) , b = (succ 1) }.b)) in (let u = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) )) in u))
({a = (( \f: Unit .((f (((\x: Unit .\y: Nat .y) (iszero 1) ) (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )))) ) (( \f: Nat .((f (pred ({a = 1 , b = 0 }.b)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .a)) , b = (case <r = (case <r = ({a = 0 , b = true , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.a)
(((\x: Nat .\y: Nat .x) ({a = (( \f: Rec X. X .((f ({a = (pred 0) , b = ({a = 0 , b = true }.b) }.a) ) (fix (\x: Nat . 1 )) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = (let u = true in u) in u) }.b) ) ({a = (( \f: Unit .((f ({a = 0 , b = true , c = 1 }.c) ) (((\x: Nat .\y: Unit .x) 0 ) true) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (let u = 0 in 1) , b = false }.b) , c =  (let u = (pred 0) in u) }.b))
(( \f: Nat .((f (pred (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = true , c = 0 }.c) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )))) ) (((\x: Bool .\y: Unit .x) ({a = ({a = ({a = true , b = 1 }.b) , b = true , c = 0 }.c) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) ) (((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) false ) ) (\a: Bool .\b: Unit .b)) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y))) ) ) (\a: Nat .\b: Rec X. X .b))
({a = (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Nat .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Unit .x) true ) false)) )) , b = (((\x: Unit .\y: Nat .y) ({a = (( \f: Rec X. X .((f 1 ) (let u = 0 in 1) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Bool .((f ({a = false , b = 1 }.a) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .b)) , c =  ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) false ) true) , c = (if false then 0 else 1) }.c) }.b) ) (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .b)) in 1) else (if false then ({a = 0 , b = false }.a) else 0))) }.b)
({a = (let u = (succ ({a = 1 , b = false }.a)) in (iszero ({a = (let u = false in 0) , b = (((\x: Unit .\y: Bool .x) false ) true) }.a))) , b = (fix (\x: Bool . (succ 1) )) }.b)
(let u = ({a = (let u = ({a = false , b = true }.b) in u) , b = (let u = (if true then 1 else 0) in ({a = true , b = 1 }.b)) }.a) in u)
(( \f: Bool .((f ({a = (let u = (((\x: Unit .\y: Bool .y) false ) false) in ({a = 0 , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b)) , b = (succ ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 ))) }.b) ) ({a = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = ({a = 1 , b = true }.b) , c =  (( \f: Nat .((f (pred 0) ) 0 ) ) (\a: Nat .\b: Nat .b)) }.b) , b = (case <l = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (unfold [ Nat ] (fold [ Nat ] (case <l = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y) )) in u)
(let u = ({a = (((\x: Bool .\y: Rec X. X .y) false ) (let u = 1 in true)) , b = (fix (\x: Bool . (if true then 1 else 0) )) }.a) in u)
(( \f: Nat .((f ({a = ({a = (pred 1) , b = (fix (\x: Bool . false )) }.b) , b = (( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ) 0 ) ) (\a: Bool .\b: Unit .a)) }.a) ) (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) )) ) (let u = false in true)) ) (( \f: Unit .((f (iszero 0) ) (((\x: Bool .\y: Nat .x) true ) false) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .b))
({a = (pred (( \f: Rec X. X .((f ({a = 0 , b = false , c = 0 }.c) ) (let u = true in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Bool .a))) , b = (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f (( \f: Bool .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = true , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Nat .\y: Bool .y) false ) ({a = 0 , b = 1 }.b)) ) ) (\a: Bool .\b: Rec X. X .b)) )) }.b)
(( \f: Bool .((f (pred (let u = (let u = false in 0) in u)) ) (let u = (if (let u = true in u) then ({a = 0 , b = false , c = 0 }.c) else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) in (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Unit . 1 )) ))) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (( \f: Bool .((f ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = false , c = 0 }.c) )) }.b) ) (((\x: Bool .\y: Unit .y) (let u = (( \f: Bool .((f (if true then false else false) ) true ) ) (\a: Bool .\b: Nat .b)) in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) ) ({a = (if true then 0 else 0) , b = ({a = false , b = 1 }.b) }.b)) ) ) (\a: Unit .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = ({a = 0 , b = true }.b) , b = 1 }.a) in u) ) (((\x: Unit .\y: Rec X. X .y) (if false then ({a = true , b = true }.b) else ({a = true , b = 1 }.a)) ) ({a = (pred 0) , b = (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) , c =  (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.b))) }.b)
(unfold [ Rec X. X ] (fold [ Unit ] (if ({a = ({a = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) , b = false }.b) , b = (let u = 1 in u) }.a) then (unfold [ Bool ] (fold [ Rec X. X ] (pred (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) )) else (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = 0 }.b) )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ))
({a = (fix (\x: Bool . (iszero ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 ))) )) , b = ({a = (iszero ({a = (fix (\x: Nat . 1 )) , b = (let u = false in true) }.a)) , b = (unfold [ Unit ] (fold [ Bool ] (succ (((\x: Nat .\y: Unit .y) false ) 0)) )) }.b) }.b)
(pred ({a = (succ (pred (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)))) , b = ({a = (if false then true else false) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) }.b))
(if (let u = (let u = (((\x: Rec X. X .\y: Bool .y) true ) (fix (\x: Bool . false ))) in (let u = 0 in true)) in (((\x: Rec X. X .\y: Unit .x) (if ({a = false , b = 1 }.a) then ({a = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = false }.b) else ({a = (let u = true in u) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) ) (iszero (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)))))) then (( \f: Unit .((f (let u = (fix (\x: Nat . (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) in (case <r = (case <r = (unfold [ Nat ] (fold [ Bool ] true )) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) ) (let u = (if true then 0 else 1) in (let u = (let u = false in u) in ({a = true , b = 1 }.a))) ) ) (\a: Rec X. X .\b: Bool .b)) else ({a = (let u = 1 in (((\x: Bool .\y: Unit .x) 0 ) false)) , b = ({a = 1 , b = ({a = false , b = false }.b) }.b) }.b))
({a = (case <r = (( \f: Unit .((f (let u = (fix (\x: Bool . 0 )) in ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , b = ({a = 1 , b = false , c = 1 }.c) }.a)) ) (fix (\x: Bool . (let u = false in true) )) ) ) (\a: Bool .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Bool .\y: Bool .y) (let u = ({a = 0 , b = false }.b) in u) ) (let u = false in 1)) in u) }.b)
(succ (let u = (((\x: Unit .\y: Unit .x) (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = false , c = 0 }.c) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (fix (\x: Bool . true )) else (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)))) in u))
(iszero (if (let u = (unfold [ Unit ] (fold [ Unit ] (pred 0) )) in ({a = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Bool .x) 0 ) false)) , b = (( \f: Unit .((f (fix (\x: Rec X. X . false )) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)) then ({a = (((\x: Nat .\y: Unit .y) true ) 0) , b = (unfold [ Bool ] (fold [ Rec X. X ] (pred 0) )) }.b) else (if (case <r = (fix (\x: Nat . ({a = 1 , b = false , c =  0 }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Bool .((f ({a = 1 , b = false }.a) ) (let u = 0 in 0) ) ) (\a: Bool .\b: Nat .a)) else (((\x: Unit .\y: Nat .y) ({a = 0 , b = true }.b) ) ({a = (succ 0) , b = ({a = 0 , b = true }.b) }.a)))))
(((\x: Nat .\y: Nat .y) (case <r = (( \f: Unit .((f (fix (\x: Nat . false )) ) ({a = 0 , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) (let u = (iszero (if true then 1 else 0)) in (( \f: Bool .((f true ) (fix (\x: Rec X. X . false )) ) ) (\a: Bool .\b: Bool .a))) ) (iszero 1)) in u))
({a = (iszero ({a = (if false then (fix (\x: Unit . 0 )) else 1) , b = (let u = ({a = 1 , b = 1 }.b) in (if false then 1 else 0)) }.b)) , b = (((\x: Unit .\y: Bool .x) (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) (succ (fix (\x: Bool . 1 ))) ) ) (\a: Unit .\b: Bool .b)) ) (( \f: Bool .((f (( \f: Rec X. X .((f (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) (if false then true else false) ) ) (\a: Nat .\b: Rec X. X .b))) }.b)
(pred ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Rec X. X . (( \f: Nat .((f 0 ) (if false then 0 else 1) ) ) (\a: Nat .\b: Bool .a)) )) )))
({a = (fix (\x: Rec X. X . (let u = (let u = false in u) in u) )) , b = (((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Bool .x) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = false in true)) ) (let u = ({a = false , b = ({a = 0 , b = false }.b) }.b) in ({a = 1 , b = 0 }.b))) }.a)
(((\x: Unit .\y: Rec X. X .y) (let u = (let u = ({a = true , b = 0 }.a) in (let u = 1 in false)) in (((\x: Bool .\y: Bool .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) ) ({a = (let u = 1 in 1) , b = (if true then true else false) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.b))) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) )))
(fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) )) ))
({a = (iszero (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b))) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Nat .((f (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) ) ({a = false , b = 0 }.a) ) ) (\a: Bool .\b: Bool .b)) )) }.b)
(fix (\x: Nat . (( \f: Nat .((f ({a = (fix (\x: Nat . (let u = false in 0) )) , b = (if true then (fix (\x: Bool . false )) else true) }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) in u) )) ) ) (\a: Unit .\b: Unit .a)) ))
(fix (\x: Unit . (((\x: Nat .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Nat . (iszero 1) )) )) ) (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Bool .((f (iszero 1) ) (fix (\x: Rec X. X . false )) ) ) (\a: Nat .\b: Unit .a)) ))) ))
(if (iszero (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) true ) false) ) (((\x: Rec X. X .\y: Nat .x) 0 ) true))) then (((\x: Rec X. X .\y: Nat .y) (unfold [ Nat ] (fold [ Rec X. X ] true )) ) ({a = (fix (\x: Rec X. X . true )) , b = 0 }.b)) else (case <l = (let u = ({a = (if false then 1 else 0) , b = true }.b) in (pred 1)) > as Bool of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Unit .y) (let u = ({a = 1 , b = false , c = ({a = 1 , b = 1 }.b) }.c) in (let u = 0 in (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)))) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ) (let u = (let u = true in u) in false)) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) true ) true) )) , b = (let u = (let u = false in u) in true) }.b) ) ) (\a: Bool .\b: Bool .b)))
(( \f: Unit .((f (pred (( \f: Nat .((f ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = ({a = 1 , b = 1 }.b) }.b) ) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in u) ) ) (\a: Nat .\b: Unit .a))) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] (let u = 0 in (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b))) )) in u) ) ) (\a: Bool .\b: Nat .b))
(fix (\x: Unit . (let u = ({a = 0 , b = true }.a) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (pred 1) ))) ))
(succ (((\x: Unit .\y: Nat .y) (( \f: Bool .((f (( \f: Unit .((f (if false then false else false) ) (let u = true in false) ) ) (\a: Bool .\b: Rec X. X .a)) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) ) (unfold [ Unit ] (fold [ Unit ] (let u = 1 in u) ))))
(let u = ({a = (succ (succ 0)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = false }.b) )) }.a) in u)
(pred (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] 1 )) ) (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) ) (\a: Bool .\b: Rec X. X .b)))
({a = (unfold [ Unit ] (fold [ Bool ] (case <l = (((\x: Rec X. X .\y: Nat .x) 0 ) true) > as Unit of < l = x > => x | < r = y > => y) )) , b = (unfold [ Nat ] (fold [ Nat ] (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) )) }.b)
({a = (if ({a = (((\x: Bool .\y: Rec X. X .y) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = true , c =  1 }.b) ) ({a = 1 , b = (((\x: Rec X. X .\y: Nat .x) false ) false) , c =  1 }.b)) , b = (fix (\x: Unit . ({a = 0 , b = (let u = 1 in true) }.b) )) }.b) then (let u = ({a = (case <l = (let u = false in 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = true , c =  0 }.b) , c = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) in (let u = true in 1)) }.c) in ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) , b = true }.b)) else (((\x: Nat .\y: Rec X. X .x) (let u = false in u) ) (let u = (fix (\x: Bool . false )) in u))) , b = ({a = ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) in u) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) }.b) }.b) , b = (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = false }.a) )) }.b) }.b)
(let u = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) (fix (\x: Bool . 1 )) ) ) (\a: Bool .\b: Nat .b)) )) , b = (fix (\x: Bool . (( \f: Rec X. X .((f (let u = true in u) ) (unfold [ Nat ] (fold [ Bool ] ({a = false , b = 1 }.a) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , c = (( \f: Rec X. X .((f ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = ({a = 1 , b = 1 }.b) }.b) ) ({a = (succ 1) , b = (((\x: Bool .\y: Nat .x) false ) false) , c = (let u = 1 in 0) }.c) ) ) (\a: Rec X. X .\b: Bool .a)) }.c) in ({a = (((\x: Nat .\y: Rec X. X .y) (let u = true in false) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (iszero (unfold [ Bool ] (fold [ Bool ] 1 ))) , c =  (succ ({a = false , b = 0 }.b)) }.b))
(( \f: Rec X. X .((f ({a = ({a = ({a = true , b = false }.b) , b = (fix (\x: Bool . 0 )) }.b) , b = (((\x: Unit .\y: Rec X. X .x) (if (let u = true in u) then (let u = false in u) else ({a = 1 , b = (let u = 0 in true) , c =  1 }.b)) ) (case <r = ({a = ({a = 0 , b = false }.a) , b = false }.b) > as Nat of < l = x > => x | < r = y > => y)) , c = (( \f: Unit .((f ({a = (( \f: Bool .((f (iszero 1) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) ) (\a: Nat .\b: Nat .b)) , b = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.b) ) (if ({a = false , b = false }.b) then ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.c) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (pred 0) )) in u) ) ) (\a: Rec X. X .\b: Bool .b))
(let u = (let u = ({a = ({a = 0 , b = 1 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) (iszero 1)) , c =  (if (let u = false in false) then (pred 0) else (if true then 0 else 1)) }.b) in u) in ({a = (fix (\x: Unit . (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (let u = (iszero 1) in ({a = false , b = 1 }.a)) }.b))
(if (let u = (let u = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in 1) in ({a = false , b = false }.b)) in (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f true ) (fix (\x: Bool . false )) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = (fix (\x: Unit . 0 )) , b = (let u = 1 in true) }.b))) then (let u = (( \f: Bool .((f (case <l = (let u = 1 in u) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Rec X. X ] true )) )) ) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = (succ 1) }.b)) ) ) (\a: Bool .\b: Rec X. X .b)) in u) else (unfold [ Bool ] (fold [ Nat ] ({a = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) , b = (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) }.b) )))
(if (((\x: Rec X. X .\y: Nat .y) (case <r = (unfold [ Nat ] (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) ) (if (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) in u) then (fix (\x: Nat . (if true then false else true) )) else (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)))) then (if (((\x: Rec X. X .\y: Nat .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) then (let u = (if (((\x: Bool .\y: Bool .y) true ) true) then true else false) in (unfold [ Nat ] (fold [ Unit ] false ))) else (((\x: Unit .\y: Unit .y) ({a = false , b = true }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )))) else (( \f: Bool .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (let u = false in u) )) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)))
({a = (iszero (unfold [ Rec X. X ] (fold [ Bool ] ({a = 0 , b = (((\x: Rec X. X .\y: Nat .x) false ) true) }.a) ))) , b = (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) true ) 0) )) }.b)
(pred (case <l = (succ (succ 1)) > as Unit of < l = x > => x | < r = y > => y))
(fix (\x: Unit . (( \f: Rec X. X .((f (iszero (((\x: Bool .\y: Rec X. X .x) 1 ) false)) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = ({a = 1 , b = true , c = 0 }.c) in (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a))) )) ) ) (\a: Unit .\b: Nat .a)) ))
({a = (if (if (iszero 1) then ({a = 1 , b = false }.b) else (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) then (((\x: Rec X. X .\y: Nat .x) (fix (\x: Nat . 0 )) ) true) else (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) 0 ) false) ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) , b = ({a = (fix (\x: Unit . ({a = false , b = 0 }.a) )) , b = (let u = (pred 0) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = false }.b) ))) }.b) , c = (if ({a = (if ({a = 0 , b = false , c =  0 }.b) then true else (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a))) , b = (let u = 1 in 1) }.a) then (((\x: Nat .\y: Unit .y) (let u = true in u) ) (pred 0)) else (((\x: Bool .\y: Bool .y) (let u = false in false) ) (let u = false in 0))) }.c)
(unfold [ Bool ] (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] (iszero (((\x: Unit .\y: Nat .y) false ) 1)) )) ))
(unfold [ Unit ] (fold [ Nat ] (let u = (( \f: Nat .((f 1 ) (let u = 1 in 1) ) ) (\a: Unit .\b: Bool .a)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ))) ))
(let u = (iszero (let u = 0 in 0)) in u)
({a = ({a = (succ 0) , b = (let u = (if true then 0 else 0) in u) }.b) , b = (let u = (((\x: Unit .\y: Bool .x) ({a = false , b = ({a = 1 , b = false }.a) }.a) ) ({a = 1 , b = false , c =  1 }.b)) in u) }.a)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (iszero (pred (( \f: Bool .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) (fix (\x: Unit . 1 )) ) ) (\a: Rec X. X .\b: Bool .a)))) ))
(if (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f ({a = true , b = false }.b) ) (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in u) )) ) ) (\a: Bool .\b: Unit .a)) )) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Bool .y) false ) (if false then false else false)) ) ({a = (let u = true in u) , b = (let u = 1 in (iszero 0)) }.b)) )) else (( \f: Unit .((f (iszero ({a = (let u = 0 in 0) , b = false , c = (let u = 0 in u) }.c)) ) ({a = (let u = ({a = 0 , b = 1 }.b) in u) , b = (((\x: Nat .\y: Unit .x) true ) false) }.b) ) ) (\a: Nat .\b: Rec X. X .b)))
(let u = ({a = ({a = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = ({a = 1 , b = true }.a) }.b) , b = (fix (\x: Bool . ({a = 1 , b = 0 }.b) )) }.b) in u)
(fix (\x: Nat . (fix (\x: Bool . (pred 0) )) ))
(((\x: Rec X. X .\y: Nat .y) (unfold [ Bool ] (fold [ Unit ] (case <r = (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Bool .x) true ) true) ) true) ) (iszero 0)) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (if ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = (if true then true else true) }.b) then (iszero (let u = (((\x: Unit .\y: Nat .x) true ) false) in 1)) else (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = false , c =  1 }.b) )) ))))
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (( \f: Rec X. X .((f (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a))) ) (if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .b)) )) then (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = (let u = false in 1) , b = ({a = false , b = true }.b) , c =  (let u = (let u = 1 in u) in u) }.b) }.b) ) (iszero (if ({a = false , b = false }.b) then (succ 0) else ({a = true , b = (let u = 0 in u) }.b))))
({a = (let u = (let u = false in ({a = 0 , b = true }.a)) in u) , b = ({a = (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then (let u = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) in u) else (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = 0 }.a) ) ) (\a: Unit .\b: Unit .a))) , b = (( \f: Unit .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) (if true then 1 else 1) ) ) (\a: Nat .\b: Nat .b)) }.a) , c =  (if ({a = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , b = (fix (\x: Bool . false )) }.b) then (let u = ({a = 0 , b = ({a = 1 , b = true , c =  1 }.b) }.a) in (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) else ({a = (((\x: Rec X. X .\y: Nat .y) false ) 0) , b = (if true then true else true) , c = 0 }.c)) }.b)
(let u = (unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Bool .x) (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) in ({a = 1 , b = false , c = 1 }.c)) ) (case <r = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y)) )) in (unfold [ Bool ] (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) true ) true) )) )))
({a = (((\x: Unit .\y: Unit .y) (iszero (let u = false in 1)) ) (((\x: Rec X. X .\y: Unit .x) 1 ) (unfold [ Nat ] (fold [ Rec X. X ] false )))) , b = (unfold [ Nat ] (fold [ Nat ] (let u = ({a = 0 , b = false }.b) in u) )) , c = (succ (( \f: Nat .((f (let u = (unfold [ Bool ] (fold [ Bool ] 0 )) in u) ) ({a = 1 , b = 1 }.b) ) ) (\a: Unit .\b: Bool .a))) }.c)
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .x) 1 ) true) )) , b = ({a = (case <l = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.b) }.a)
(fix (\x: Bool . ({a = (let u = (let u = 1 in u) in u) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Bool . 1 )) )) }.b) ))
({a = ({a = (((\x: Nat .\y: Unit .x) ({a = 0 , b = true }.b) ) (let u = (((\x: Nat .\y: Bool .y) true ) true) in u)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f (let u = true in u) ) (fix (\x: Unit . true )) ) ) (\a: Rec X. X .\b: Unit .a)) )) }.b) , b = (((\x: Unit .\y: Rec X. X .x) ({a = ({a = (if true then 0 else 1) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) }.a) , b = (if true then false else false) , c = ({a = (let u = 1 in 1) , b = (fix (\x: Bool . true )) }.a) }.c) ) (case <r = (((\x: Rec X. X .\y: Bool .x) true ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y)) }.a)
({a = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = (if false then 1 else 0) , b = true , c = 1 }.c) )) , b = (((\x: Nat .\y: Bool .y) (let u = (((\x: Bool .\y: Bool .y) false ) false) in u) ) (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) true ) ) (\a: Unit .\b: Rec X. X .b))) , c = (( \f: Unit .((f ({a = 0 , b = false }.a) ) (let u = ({a = 1 , b = true , c = (((\x: Nat .\y: Unit .y) true ) 1) }.c) in u) ) ) (\a: Bool .\b: Bool .a)) }.c) , b = ({a = ({a = (((\x: Rec X. X .\y: Unit .y) ({a = true , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) }.b) ) ({a = 0 , b = (((\x: Unit .\y: Nat .x) false ) true) }.b)) , b = (( \f: Nat .((f (fix (\x: Bool . true )) ) true ) ) (\a: Nat .\b: Nat .b)) }.b) , b = (case <r = (let u = (((\x: Bool .\y: Rec X. X .x) 0 ) false) in false) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b)
(((\x: Unit .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Unit ] (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b)) )) ) (( \f: Unit .((f ({a = ({a = 0 , b = (fix (\x: Rec X. X . false )) , c =  1 }.b) , b = (let u = 1 in 1) }.b) ) (pred (((\x: Nat .\y: Nat .y) false ) 0)) ) ) (\a: Nat .\b: Bool .a)))
(iszero (unfold [ Unit ] (fold [ Bool ] (case <l = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) )))
(((\x: Unit .\y: Bool .y) (fix (\x: Unit . (((\x: Unit .\y: Bool .x) ({a = true , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) }.a) ) (( \f: Nat .((f false ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .a))) )) ) (case <l = (let u = (let u = true in true) in (let u = 0 in 0)) > as Bool of < l = x > => x | < r = y > => y))
({a = ({a = (pred (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) , b = ({a = (((\x: Bool .\y: Bool .x) 1 ) true) , b = (( \f: Bool .((f (if false then 0 else 1) ) 1 ) ) (\a: Nat .\b: Bool .b)) }.b) }.b) , b = (( \f: Nat .((f (let u = (unfold [ Unit ] (fold [ Bool ] false )) in u) ) (case <r = (if false then false else true) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) }.a)
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Unit ] 0 )) ) ({a = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = 1 }.a)) ))
(((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Unit .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) (unfold [ Unit ] (fold [ Bool ] true )) ) (let u = 1 in false)) )) ) (unfold [ Bool ] (fold [ Nat ] (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ))) ) (let u = (( \f: Nat .((f (let u = (let u = 0 in (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b))) in (iszero 0)) ) (iszero ({a = 0 , b = (let u = true in true) , c = ({a = true , b = 0 }.b) }.c)) ) ) (\a: Bool .\b: Rec X. X .a)) in (fix (\x: Bool . (pred 0) ))))
(let u = ({a = (unfold [ Unit ] (fold [ Bool ] (pred (fix (\x: Bool . 0 ))) )) , b = (let u = ({a = true , b = 0 }.a) in 1) }.b) in (( \f: Bool .((f (case <l = (( \f: Rec X. X .((f (succ 0) ) 1 ) ) (\a: Bool .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) ) ({a = ({a = 0 , b = 0 }.b) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(let u = (iszero (( \f: Nat .((f (let u = 0 in 1) ) 0 ) ) (\a: Nat .\b: Unit .b))) in u)
(( \f: Bool .((f (( \f: Bool .((f (pred (fix (\x: Nat . 1 ))) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ) (\a: Rec X. X .\b: Unit .a)) ) (case <l = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a))
((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (if (( \f: Unit .((f (let u = (let u = true in u) in ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true ))) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) in false) )) else ({a = ({a = true , b = (fix (\x: Bool . 1 )) }.a) , b = (((\x: Rec X. X .\y: Bool .x) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = false in u)) }.b)) ))
({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) )) , b = (if false then false else false) }.a) , b = ({a = ({a = (if true then (((\x: Rec X. X .\y: Bool .x) 0 ) false) else (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) , b = (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .b)) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) }.a) , b = (fix (\x: Rec X. X . ({a = (pred 1) , b = (fix (\x: Bool . true )) }.b) )) , c =  (case <l = (if (let u = (let u = false in true) in false) then ({a = 1 , b = 0 }.b) else (let u = 1 in 0)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , c =  (unfold [ Unit ] (fold [ Unit ] ({a = (((\x: Nat .\y: Nat .y) true ) 0) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) , c = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.c) )) }.b)
({a = (let u = (unfold [ Nat ] (fold [ Nat ] (( \f: Unit .((f 1 ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Rec X. X .\b: Nat .b)) )) in u) , b = (case <r = (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) false ) true) ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) }.a)
({a = ({a = (let u = (let u = true in false) in true) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Nat .b))) }.a) , b = (case <l = (fix (\x: Bool . (unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) )) )) > as Nat of < l = x > => x | < r = y > => y) }.a)
(fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Unit .\y: Nat .x) (let u = (let u = 0 in 1) in (let u = true in u)) ) (let u = (((\x: Bool .\y: Unit .x) true ) true) in u)) ) ({a = (( \f: Rec X. X .((f false ) (((\x: Bool .\y: Bool .x) true ) false) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Bool .((f (pred 1) ) 1 ) ) (\a: Bool .\b: Unit .a)) }.b)) ))
(fix (\x: Nat . (case <r = (let u = (( \f: Bool .((f (succ 0) ) 0 ) ) (\a: Bool .\b: Nat .a)) in (((\x: Unit .\y: Nat .y) ({a = ({a = 0 , b = 0 }.b) , b = ({a = 0 , b = true }.b) }.b) ) ({a = 1 , b = true , c =  1 }.b))) > as Nat of < l = x > => x | < r = y > => y) ))
(pred (( \f: Rec X. X .((f (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b))) ) (fix (\x: Nat . (succ 0) )) ) ) (\a: Nat .\b: Nat .b)))
({a = (case <l = (if ({a = false , b = 1 }.a) then (unfold [ Unit ] (fold [ Bool ] 0 )) else (pred ({a = 1 , b = 1 }.b))) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f ({a = ({a = true , b = true }.b) , b = (((\x: Unit .\y: Bool .y) true ) true) }.b) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .a)) , c =  (((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Unit .x) (pred 1) ) ({a = ({a = 0 , b = false }.a) , b = true }.b)) ) (((\x: Unit .\y: Unit .y) ({a = 0 , b = (let u = true in u) }.b) ) (case <r = ({a = (let u = 1 in 0) , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y))) }.b)
(( \f: Rec X. X .((f (if (((\x: Bool .\y: Bool .x) (( \f: Bool .((f (unfold [ Bool ] (fold [ Bool ] true )) ) ({a = ({a = true , b = 0 }.a) , b = (let u = true in true) }.b) ) ) (\a: Nat .\b: Unit .a)) ) (let u = true in false)) then (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) in (pred 1)) else (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = ({a = 1 , b = false }.b) in 1) )) in u)) ) ({a = (if (let u = false in u) then ({a = ({a = true , b = false }.b) , b = (pred 0) }.b) else (if (iszero 1) then 0 else 0)) , b = (( \f: Bool .((f (((\x: Bool .\y: Bool .y) ({a = false , b = 1 }.a) ) false) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) ) ) (\a: Unit .\b: Nat .b)) }.a) ) ) (\a: Rec X. X .\b: Unit .a))
(((\x: Bool .\y: Unit .y) ({a = (pred 1) , b = (((\x: Unit .\y: Rec X. X .y) ({a = 0 , b = false , c =  0 }.b) ) (((\x: Nat .\y: Bool .y) false ) false)) , c =  ({a = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , b = (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) ) 1 ) ) (\a: Nat .\b: Unit .a)) }.b) }.b) ) (fix (\x: Unit . ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = true }.b) )))
(( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) true ) ) (\a: Unit .\b: Bool .b)) )) ) (( \f: Unit .((f (fix (\x: Rec X. X . false )) ) ({a = (let u = false in u) , b = (((\x: Unit .\y: Unit .y) true ) 1) }.a) ) ) (\a: Bool .\b: Unit .b))) ) ({a = (case <l = ({a = true , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in u) , c =  (if (unfold [ Rec X. X ] (fold [ Nat ] true )) then (let u = 1 in u) else (let u = (succ 0) in 1)) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
({a = (let u = ({a = (let u = 0 in false) , b = (unfold [ Unit ] (fold [ Nat ] true )) }.b) in u) , b = (let u = (((\x: Rec X. X .\y: Nat .y) ({a = (((\x: Unit .\y: Bool .y) true ) 1) , b = true }.b) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = ({a = true , b = 0 }.a) , b = false }.b) ))) }.b)
(case <r = (if ({a = ({a = 0 , b = false }.a) , b = (iszero 0) }.b) then (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) in (unfold [ Rec X. X ] (fold [ Nat ] true ))) else (if ({a = (( \f: Rec X. X .((f true ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Unit .b)) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) }.a) then (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) else ({a = ({a = true , b = 1 }.a) , b = 1 }.a))) > as Bool of < l = x > => x | < r = y > => y)
(let u = (succ (succ ({a = 0 , b = true , c = 1 }.c))) in (( \f: Nat .((f (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) true ) false) )) ) (let u = ({a = 1 , b = false }.a) in (let u = true in false)) ) ) (\a: Nat .\b: Bool .a)))
(case <l = (let u = ({a = ({a = (( \f: Bool .((f 1 ) ({a = 1 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (let u = 0 in true) }.a) , b = (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) , c =  (unfold [ Unit ] (fold [ Bool ] 1 )) }.b) in (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Unit .y) false ) 1) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Nat ] ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) , b = (succ 0) }.b) )) ))
({a = (( \f: Unit .((f (((\x: Unit .\y: Unit .y) false ) (((\x: Bool .\y: Bool .x) true ) false)) ) ({a = (fix (\x: Unit . 0 )) , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Unit . ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = ({a = false , b = false }.b) , c = (((\x: Unit .\y: Unit .x) 1 ) false) }.c) )) )) }.a)
(( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] false )) )) ) ({a = (((\x: Unit .\y: Bool .y) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b)) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = ({a = 0 , b = (let u = true in 1) }.b) in (((\x: Nat .\y: Unit .x) (unfold [ Bool ] (fold [ Unit ] 1 )) ) false)) }.a) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (((\x: Bool .\y: Unit .y) (iszero ({a = true , b = 1 }.b)) ) ({a = (((\x: Bool .\y: Bool .x) 0 ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = (case <r = (((\x: Unit .\y: Unit .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) }.b)) in ({a = (let u = (case <l = (((\x: Bool .\y: Rec X. X .x) 1 ) false) > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Unit ] (case <r = (let u = false in true) > as Bool of < l = x > => x | < r = y > => y) ))) , b = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (succ 1) )) , b = (iszero (let u = ({a = 0 , b = true }.a) in (pred 0))) , c = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f 1 ) (let u = 1 in 0) ) ) (\a: Nat .\b: Rec X. X .b)) )) }.c) }.a))
(succ (if ({a = ({a = (let u = false in false) , b = 0 }.a) , b = (((\x: Unit .\y: Rec X. X .y) true ) 1) }.a) then (let u = (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Bool .y) false ) 0) )) in (( \f: Bool .((f (pred 0) ) (pred (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) ) ) (\a: Bool .\b: Nat .a))) else (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y)))
(( \f: Unit .((f (if (let u = (let u = 1 in u) in ({a = 0 , b = false , c =  0 }.b)) then ({a = ({a = false , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b) , b = (let u = false in u) }.a) else (((\x: Nat .\y: Nat .y) ({a = 1 , b = false , c =  0 }.b) ) 0)) ) ({a = (let u = 0 in (let u = true in 0)) , b = ({a = (case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = false , c =  0 }.b) , c =  ({a = true , b = 1 }.b) }.b) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(((\x: Unit .\y: Nat .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Nat . (((\x: Bool .\y: Bool .y) (((\x: Nat .\y: Bool .y) true ) false) ) false) )) )) ) (( \f: Rec X. X .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (pred 1) ) ) (\a: Rec X. X .\b: Nat .a)))
(succ (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) (fix (\x: Bool . true )) ) (((\x: Unit .\y: Nat .y) (iszero 1) ) 0)) ) (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) in (fix (\x: Nat . 0 ))) ) ) (\a: Unit .\b: Unit .a)))
(fix (\x: Nat . ({a = (if (unfold [ Bool ] (fold [ Bool ] (let u = true in true) )) then (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) else ({a = 1 , b = ({a = false , b = false }.b) , c = (let u = 0 in 0) }.c)) , b = (case <l = ({a = 0 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ))
({a = (((\x: Nat .\y: Bool .x) ({a = (((\x: Unit .\y: Nat .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 )) ) (let u = 0 in true)) , b = ({a = 0 , b = true , c =  1 }.b) , c =  (pred 1) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ))) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) , b = (unfold [ Unit ] (fold [ Bool ] 1 )) }.b) )) , b = (case <r = (unfold [ Unit ] (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) , c = (( \f: Rec X. X .((f ({a = 1 , b = true , c = 0 }.c) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Bool .\b: Nat .a)) }.c) }.a)
({a = (fix (\x: Nat . (let u = (let u = false in 0) in (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))) )) , b = (fix (\x: Nat . ({a = ({a = 0 , b = true }.b) , b = 0 }.a) )) }.a)
(succ (( \f: Rec X. X .((f (succ ({a = false , b = 0 }.b)) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = (let u = false in false) , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.c) ) ) (\a: Rec X. X .\b: Nat .b)))
(( \f: Nat .((f ({a = (((\x: Unit .\y: Nat .y) (if true then true else false) ) ({a = 0 , b = false }.a)) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.a) ) ({a = (iszero (let u = true in 0)) , b = (pred (let u = false in 1)) }.b) ) ) (\a: Bool .\b: Rec X. X .a))
(let u = (pred ({a = (let u = 0 in u) , b = (fix (\x: Unit . (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) }.b)) in (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) false ) 0) ))))
(let u = (case <l = (fix (\x: Unit . (((\x: Nat .\y: Rec X. X .x) 1 ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(succ (unfold [ Unit ] (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Bool . 0 )) )) )))
(((\x: Nat .\y: Rec X. X .y) ({a = (iszero (let u = 1 in 0)) , b = ({a = (let u = 0 in (let u = true in u)) , b = (let u = false in 0) }.a) }.b) ) ({a = (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Unit .x) true ) true) ) (let u = (let u = false in 1) in ({a = 0 , b = true , c =  1 }.b))) , b = (let u = ({a = 1 , b = 0 }.b) in false) }.b))
(( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Rec X. X .\y: Bool .x) (unfold [ Bool ] (fold [ Unit ] true )) ) (unfold [ Nat ] (fold [ Unit ] false ))) )) ) (((\x: Unit .\y: Rec X. X .y) (let u = (unfold [ Nat ] (fold [ Nat ] (((\x: Rec X. X .\y: Unit .y) true ) true) )) in u) ) (let u = (unfold [ Bool ] (fold [ Nat ] true )) in (let u = ({a = true , b = 1 }.a) in true))) ) ) (\a: Rec X. X .\b: Unit .a))
(iszero (((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Rec X. X .x) (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Nat .x) true ) false) ) ({a = false , b = false }.b)) ) ({a = false , b = 0 }.a)) ) (let u = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) , b = (( \f: Rec X. X .((f 0 ) ({a = 1 , b = true }.a) ) ) (\a: Rec X. X .\b: Nat .a)) }.a) in (let u = (let u = (if false then 0 else 0) in u) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ))))))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if (( \f: Nat .((f (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) ) (((\x: Nat .\y: Unit .x) false ) false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (( \f: Unit .((f ({a = 1 , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .a)) , c = (((\x: Unit .\y: Bool .y) false ) 0) }.c) ) (succ 1) ) ) (\a: Nat .\b: Bool .a)) else (case <l = ({a = 1 , b = true , c = 1 }.c) > as Bool of < l = x > => x | < r = y > => y)) ))
({a = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (if (let u = true in true) then (unfold [ Unit ] (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) else (fix (\x: Rec X. X . 1 ))) )) , b = ({a = ({a = true , b = 0 }.b) , b = (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = true }.b) )) , c =  (((\x: Bool .\y: Rec X. X .y) (if true then true else false) ) 0) }.b) }.a) , b = (((\x: Nat .\y: Nat .x) (( \f: Unit .((f ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , b = ({a = true , b = 0 }.b) }.a) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true) ) ) (\a: Nat .\b: Bool .b)) ) ({a = ({a = (let u = true in u) , b = true }.b) , b = (let u = true in 1) }.a)) , c =  (pred ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = 1 }.b) ))) }.b)
(case <l = ({a = (fix (\x: Rec X. X . (let u = true in 0) )) , b = (if true then true else false) , c = (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true }.a) )) }.c) > as Bool of < l = x > => x | < r = y > => y)
({a = (unfold [ Unit ] (fold [ Unit ] ({a = (if ({a = 1 , b = false }.b) then (let u = false in 0) else ({a = 1 , b = 1 }.b)) , b = ({a = true , b = true }.b) }.b) )) , b = ({a = (( \f: Unit .((f ({a = ({a = 0 , b = 1 }.b) , b = ({a = false , b = 0 }.a) , c =  (let u = 0 in u) }.b) ) (((\x: Nat .\y: Rec X. X .y) true ) (fix (\x: Nat . true ))) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Nat .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (pred 1) ) ) (\a: Nat .\b: Unit .b)) }.b) }.b)
({a = ({a = (iszero (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) in u)) , b = ({a = ({a = false , b = ({a = 0 , b = 1 }.b) }.b) , b = ({a = (if true then (iszero 1) else false) , b = ({a = (let u = false in true) , b = (if true then true else false) }.b) }.b) , c = ({a = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) , b = 1 }.b) , b = ({a = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 1 , b = false , c = 0 }.c) }.a) }.a) }.c) }.a) , b = (fix (\x: Unit . (((\x: Unit .\y: Bool .x) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) ({a = false , b = false }.b)) )) }.a)
(unfold [ Bool ] (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (if ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .a)) , b = false }.b) then (( \f: Bool .((f ({a = 0 , b = true }.b) ) false ) ) (\a: Rec X. X .\b: Unit .b)) else (fix (\x: Unit . (let u = false in u) ))) , b = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) , b = (fix (\x: Bool . (if false then false else false) )) , c = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.c) }.b) )) ))
(( \f: Nat .((f ({a = (let u = (let u = (iszero 0) in u) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) , b = (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Bool . true )) )) }.a) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = true }.b) )) , b = (let u = ({a = 0 , b = true , c = 0 }.c) in u) }.b) ) ) (\a: Unit .\b: Unit .b))
(unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) (if (unfold [ Rec X. X ] (fold [ Nat ] false )) then ({a = true , b = false }.b) else ({a = (let u = 0 in u) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) , c =  1 }.b)) ) (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then false else (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)))) ))
({a = ({a = (fix (\x: Rec X. X . (let u = true in 0) )) , b = (case <l = (if (unfold [ Nat ] (fold [ Unit ] false )) then 1 else (succ 0)) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Unit .((f (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false )) in u) ) (let u = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) in u) in (let u = 1 in true)) ) ) (\a: Bool .\b: Rec X. X .a)) , c =  ({a = (let u = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) in (let u = 1 in true)) , b = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.b) }.b)
(succ (( \f: Rec X. X .((f (fix (\x: Nat . (fix (\x: Unit . 0 )) )) ) ({a = (((\x: Rec X. X .\y: Nat .x) 1 ) true) , b = (((\x: Unit .\y: Unit .y) true ) false) }.a) ) ) (\a: Bool .\b: Nat .a)))
(if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (iszero (let u = 0 in 0)) ) ({a = true , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .a)) )) then (( \f: Unit .((f (let u = (unfold [ Nat ] (fold [ Bool ] 1 )) in u) ) (if (unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) true ) true) )) then (let u = 0 in 0) else (if true then 0 else 0)) ) ) (\a: Nat .\b: Bool .a)) else (case <l = (let u = (pred 0) in ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 ))) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (let u = (unfold [ Nat ] (fold [ Rec X. X ] (case <l = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) > as Nat of < l = x > => x | < r = y > => y) )) in (let u = (let u = (pred 1) in ({a = false , b = true }.b)) in u)) in (let u = (let u = 1 in u) in (((\x: Rec X. X .\y: Nat .y) ({a = 1 , b = true }.b) ) ({a = 1 , b = true , c =  1 }.b))))
(((\x: Rec X. X .\y: Nat .x) (let u = ({a = (let u = ({a = false , b = true }.b) in 0) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , c =  ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b) in u) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (let u = 1 in false) , b = (fix (\x: Bool . 0 )) }.a) )))
(iszero ({a = (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = 1 , b = true , c = 0 }.c) in false) )) > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Nat ] (((\x: Unit .\y: Unit .x) 1 ) (fix (\x: Unit . true ))) )) }.b))
(if (unfold [ Bool ] (fold [ Unit ] (case <r = ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , b = ({a = 0 , b = false }.a) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) )) then (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b))) )) ) ({a = (if (iszero 1) then (let u = ({a = 0 , b = 0 }.b) in (succ 0)) else (((\x: Rec X. X .\y: Unit .y) (let u = false in u) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)))) , b = (let u = 0 in true) }.a) ) ) (\a: Unit .\b: Unit .b)) else (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] (pred 0) )) ) (pred (succ 1)) ) ) (\a: Bool .\b: Rec X. X .b)))
(if (let u = (let u = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) in (iszero 0)) in (((\x: Nat .\y: Unit .y) (let u = false in true) ) (((\x: Bool .\y: Bool .x) ({a = true , b = false }.b) ) (if false then false else false)))) then (((\x: Bool .\y: Rec X. X .y) ({a = (pred ({a = 1 , b = true }.a)) , b = (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Unit .y) true ) true) )) , c =  (let u = (((\x: Unit .\y: Bool .x) 0 ) true) in u) }.b) ) (let u = (if (unfold [ Bool ] (fold [ Nat ] ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) )) then (((\x: Rec X. X .\y: Nat .y) (let u = 1 in true) ) ({a = 1 , b = 1 }.b)) else (pred 1)) in (( \f: Nat .((f (unfold [ Bool ] (fold [ Nat ] false )) ) (iszero 1) ) ) (\a: Unit .\b: Nat .a)))) else (((\x: Nat .\y: Rec X. X .x) ({a = ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = 0 }.b) , b = ({a = false , b = (let u = 0 in false) }.b) }.b) ) (let u = (((\x: Bool .\y: Nat .x) (let u = false in u) ) true) in u)))
(let u = ({a = (( \f: Nat .((f (((\x: Bool .\y: Nat .x) false ) false) ) (((\x: Bool .\y: Rec X. X .y) false ) true) ) ) (\a: Bool .\b: Nat .b)) , b = (case <l = (((\x: Bool .\y: Nat .x) ({a = true , b = 1 }.b) ) (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))) > as Nat of < l = x > => x | < r = y > => y) }.a) in (let u = (let u = (fix (\x: Nat . false )) in (((\x: Bool .\y: Nat .y) (if true then false else true) ) (pred 1))) in (case <r = ({a = 0 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y)))
({a = (let u = (((\x: Rec X. X .\y: Unit .x) (if true then 0 else 1) ) true) in u) , b = (let u = ({a = (fix (\x: Bool . (unfold [ Bool ] (fold [ Unit ] (let u = 0 in 0) )) )) , b = (( \f: Nat .((f ({a = 0 , b = false }.b) ) (( \f: Rec X. X .((f (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .b)) , c =  (( \f: Rec X. X .((f 1 ) (fix (\x: Bool . 1 )) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) in (((\x: Unit .\y: Bool .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) ) (if (unfold [ Nat ] (fold [ Bool ] false )) then (case <r = false > as Unit of < l = x > => x | < r = y > => y) else false))) , c =  (if ({a = (if (let u = 0 in false) then 0 else ({a = true , b = 1 }.b)) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)) , c =  (succ (pred 1)) }.b) then (((\x: Unit .\y: Unit .y) false ) ({a = 1 , b = true }.a)) else (pred (case <l = (fix (\x: Nat . 0 )) > as Bool of < l = x > => x | < r = y > => y))) }.b)
(((\x: Rec X. X .\y: Bool .x) (fix (\x: Unit . (fix (\x: Nat . (if (((\x: Rec X. X .\y: Unit .y) false ) false) then 0 else 0) )) )) ) (( \f: Unit .((f (iszero (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )))) ) (if (( \f: Rec X. X .((f (let u = (let u = false in true) in u) ) (if false then true else false) ) ) (\a: Nat .\b: Bool .b)) then (case <r = (if true then true else false) > as Bool of < l = x > => x | < r = y > => y) else (((\x: Unit .\y: Rec X. X .x) ({a = false , b = 1 }.a) ) (iszero 1))) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(unfold [ Nat ] (fold [ Bool ] (( \f: Nat .((f ({a = ({a = 1 , b = true }.b) , b = ({a = 1 , b = true }.b) }.b) ) (let u = (fix (\x: Bool . false )) in u) ) ) (\a: Nat .\b: Bool .b)) ))
(if (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .x) true ) false) ) (fix (\x: Bool . true )) ) ) (\a: Rec X. X .\b: Bool .b)) then ({a = (case <l = (let u = (((\x: Unit .\y: Nat .y) false ) true) in (pred 0)) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) }.b) else (let u = (fix (\x: Unit . (let u = true in false) )) in u))
({a = (let u = (let u = ({a = 0 , b = false }.b) in u) in (((\x: Bool .\y: Unit .y) (iszero 1) ) (pred (unfold [ Nat ] (fold [ Nat ] 0 ))))) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (let u = 1 in u) , b = (if false then false else false) , c = ({a = (pred 1) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) }.a) }.c) )) }.b)
(case <r = (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) ) (fix (\x: Rec X. X . ({a = 0 , b = false , c =  1 }.b) )) ) ) (\a: Rec X. X .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y)
(if ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Rec X. X . true )) )) then (fix (\x: Bool . (case <l = (fix (\x: Rec X. X . (if true then 1 else 1) )) > as Rec X. X of < l = x > => x | < r = y > => y) )) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (pred (( \f: Nat .((f 1 ) (let u = 1 in 0) ) ) (\a: Unit .\b: Unit .a))) )))
(iszero ({a = ({a = (((\x: Nat .\y: Nat .x) (let u = ({a = 1 , b = true }.a) in ({a = false , b = 0 }.b)) ) (let u = false in u)) , b = ({a = (fix (\x: Rec X. X . (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = (let u = 0 in 1) }.a) }.a) , b = ({a = ({a = true , b = 0 }.b) , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .a)) , c = (if false then 0 else 0) }.c) }.b))
(fix (\x: Unit . ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = (let u = 0 in (let u = true in true)) in u) )) ))
(case <r = (if (case <r = ({a = 0 , b = false , c =  ({a = 1 , b = false , c = 1 }.c) }.b) > as Nat of < l = x > => x | < r = y > => y) then ({a = (pred 0) , b = (((\x: Nat .\y: Nat .x) true ) true) }.b) else (fix (\x: Nat . ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ))) > as Bool of < l = x > => x | < r = y > => y)
(let u = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] (let u = 1 in (((\x: Bool .\y: Unit .x) false ) false)) )) ) (iszero (unfold [ Rec X. X ] (fold [ Nat ] (let u = 0 in u) ))) ) ) (\a: Unit .\b: Nat .a)) in (( \f: Bool .((f (((\x: Nat .\y: Unit .y) (let u = 1 in true) ) (pred 1)) ) (succ (if true then 1 else (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)))) ) ) (\a: Nat .\b: Rec X. X .b)))
(( \f: Nat .((f (let u = (succ (fix (\x: Unit . 0 ))) in (let u = false in false)) ) (unfold [ Bool ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Bool ] (let u = 0 in false) )) )) ) ) (\a: Rec X. X .\b: Unit .b))
(if ({a = ({a = (if true then 1 else 0) , b = (fix (\x: Nat . false )) }.a) , b = (((\x: Nat .\y: Unit .x) ({a = (if true then 0 else 1) , b = (let u = false in false) , c =  (((\x: Rec X. X .\y: Bool .x) 0 ) true) }.b) ) (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) ) ) (\a: Bool .\b: Nat .b))) }.b) then (let u = (((\x: Unit .\y: Rec X. X .y) (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Nat ] true )) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .a)) ) (((\x: Nat .\y: Unit .y) true ) false)) in ({a = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = ({a = 0 , b = 0 }.b) }.b) , b = ({a = ({a = 0 , b = (let u = true in u) , c =  1 }.b) , b = (( \f: Bool .((f ({a = 0 , b = false , c = 0 }.c) ) 0 ) ) (\a: Nat .\b: Unit .a)) }.a) , c =  (unfold [ Rec X. X ] (fold [ Unit ] (succ 1) )) }.b)) else (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Rec X. X .((f (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then false else false) ) (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then true else (if true then true else true)) ) ) (\a: Nat .\b: Rec X. X .a)) )))
(let u = (fix (\x: Nat . ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) , b = ({a = false , b = false }.b) }.b) )) in (let u = (let u = ({a = (succ 1) , b = ({a = 1 , b = true }.b) }.a) in ({a = false , b = ({a = 0 , b = true }.a) }.a)) in (((\x: Unit .\y: Unit .x) (if (((\x: Unit .\y: Nat .y) false ) (fix (\x: Unit . false ))) then (let u = 1 in 1) else (succ 1)) ) (( \f: Rec X. X .((f (fix (\x: Nat . (let u = true in true) )) ) (let u = 0 in true) ) ) (\a: Bool .\b: Unit .b)))))
(let u = (unfold [ Bool ] (fold [ Nat ] (let u = (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = true }.a) )) in ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = 1 }.a)) )) in ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f (fix (\x: Bool . true )) ) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) , b = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) }.b) ) ) (\a: Nat .\b: Bool .a)) )))
(unfold [ Nat ] (fold [ Nat ] (((\x: Rec X. X .\y: Bool .x) ({a = (let u = 1 in 1) , b = (let u = ({a = true , b = false }.b) in ({a = 1 , b = 1 }.b)) }.b) ) (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . false )) ))) ))
(let u = (((\x: Rec X. X .\y: Nat .x) (fix (\x: Rec X. X . true )) ) (fix (\x: Rec X. X . (iszero 0) ))) in u)
({a = ({a = (( \f: Unit .((f (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] 1 )) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) ) (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a))) ) ) (\a: Unit .\b: Bool .a)) , b = (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) ({a = 0 , b = true }.a) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) , b = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = false , b = false }.b) )) }.b) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = (unfold [ Rec X. X ] (fold [ Bool ] ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (if false then true else true) )) , b = (let u = 1 in 1) }.b) )) , b = (let u = (iszero (((\x: Rec X. X .\y: Unit .x) 1 ) true)) in u) , c =  ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) , b = (fix (\x: Unit . false )) }.a) }.b) ))
(fix (\x: Nat . (let u = ({a = (( \f: Rec X. X .((f (( \f: Bool .((f (iszero 0) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ) (unfold [ Nat ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) true ) true) )) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (((\x: Nat .\y: Bool .y) false ) false) , b = (pred (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b))) }.b) }.a) in (((\x: Bool .\y: Rec X. X .x) ({a = ({a = 1 , b = false }.a) , b = 0 }.b) ) (let u = (let u = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) in (((\x: Rec X. X .\y: Unit .x) false ) false)) in u))) ))
({a = (if ({a = ({a = ({a = ({a = 0 , b = true }.a) , b = false }.b) , b = (((\x: Nat .\y: Nat .y) false ) 1) }.a) , b = (let u = (iszero 0) in (((\x: Nat .\y: Unit .x) 1 ) false)) }.a) then (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Nat .x) true ) false) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .a))) else (((\x: Rec X. X .\y: Unit .y) (case <r = ({a = false , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = false , b = (succ 0) }.a))) , b = (succ (let u = (( \f: Nat .((f (pred 1) ) 1 ) ) (\a: Nat .\b: Bool .b)) in (case <l = ({a = 0 , b = false , c = 1 }.c) > as Rec X. X of < l = x > => x | < r = y > => y))) }.b)
({a = ({a = (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .y) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = true , c =  (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) }.b) ) (let u = false in false)) ) (fix (\x: Rec X. X . false )) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Nat .\y: Nat .y) (((\x: Rec X. X .\y: Unit .x) ({a = 0 , b = false }.b) ) (iszero 0)) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.b) , b = (let u = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = ({a = false , b = false }.b) }.a) in u) }.b)
({a = (((\x: Unit .\y: Bool .y) (( \f: Rec X. X .((f ({a = ({a = (if true then true else false) , b = false }.b) , b = (let u = false in false) }.b) ) (((\x: Unit .\y: Unit .y) false ) ({a = false , b = true }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) ) (fix (\x: Rec X. X . ({a = 0 , b = 0 }.b) ))) , b = (( \f: Nat .((f (let u = (let u = (( \f: Rec X. X .((f false ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Nat .a)) in (case <l = (((\x: Bool .\y: Rec X. X .y) false ) 1) > as Bool of < l = x > => x | < r = y > => y)) in (iszero (fix (\x: Unit . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )))) ) (iszero (let u = 1 in u)) ) ) (\a: Bool .\b: Bool .b)) , c = ({a = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) in (unfold [ Bool ] (fold [ Bool ] 0 ))) , b = (((\x: Bool .\y: Nat .y) (let u = true in u) ) false) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.c) }.c)
(iszero (if (let u = (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) ) true) in (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a))) then (( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = 0 , b = 1 }.b) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Bool .\b: Unit .b)) ) ({a = false , b = (let u = true in 1) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) else (let u = (let u = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) in (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) in u)))
(let u = (fix (\x: Bool . (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) in u) )) in (fix (\x: Unit . ({a = (( \f: Bool .((f (let u = 1 in 0) ) (((\x: Nat .\y: Rec X. X .x) 1 ) false) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = 0 , b = ({a = true , b = true }.b) , c =  (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.b) , c = (pred (let u = 0 in 0)) }.c) )))
({a = (let u = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) }.b) in u) , b = ({a = (succ (fix (\x: Rec X. X . (succ 1) ))) , b = (unfold [ Bool ] (fold [ Unit ] (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) )) )) }.b) }.b)
(case <l = ({a = (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (iszero (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b))) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (case <l = (pred (succ 1)) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(let u = (( \f: Unit .((f (if (((\x: Rec X. X .\y: Unit .y) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) (iszero 1)) then ({a = (let u = false in 0) , b = false }.b) else (((\x: Unit .\y: Bool .y) false ) true)) ) (let u = (pred 1) in (let u = true in u)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (case <l = (pred (unfold [ Rec X. X ] (fold [ Bool ] ({a = false , b = 1 }.b) ))) > as Bool of < l = x > => x | < r = y > => y))
({a = (((\x: Bool .\y: Unit .y) ({a = (((\x: Bool .\y: Nat .y) ({a = 0 , b = false }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] 0 )) ))) , b = ({a = (iszero 0) , b = true }.b) }.b) ) (( \f: Unit .((f (let u = ({a = 0 , b = ({a = true , b = 0 }.a) , c =  1 }.b) in ({a = false , b = true }.b)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = false }.b) )) ) ) (\a: Nat .\b: Unit .b))) , b = (((\x: Bool .\y: Unit .y) ({a = ({a = (fix (\x: Rec X. X . ({a = 1 , b = false , c =  0 }.b) )) , b = (let u = false in 1) }.b) , b = (let u = ({a = false , b = ({a = 1 , b = true , c = 1 }.c) }.a) in ({a = 0 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b)) }.b) ) ({a = (if (let u = 1 in (if false then false else false)) then (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) else (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a))) , b = (let u = (fix (\x: Nat . false )) in (( \f: Rec X. X .((f ({a = false , b = true }.b) ) (let u = false in true) ) ) (\a: Unit .\b: Nat .b))) }.a)) }.a)
((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (pred (let u = 0 in u)) ))
(( \f: Bool .((f ({a = ({a = ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , b = false }.b) , b = (if false then true else true) }.b) , b = ({a = (((\x: Bool .\y: Nat .x) 1 ) true) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = false in 0) }.b) }.b) ) (unfold [ Unit ] (fold [ Unit ] (if (( \f: Bool .((f false ) (unfold [ Bool ] (fold [ Nat ] false )) ) ) (\a: Bool .\b: Bool .a)) then ({a = false , b = 1 }.a) else (let u = 1 in false)) )) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(((\x: Nat .\y: Nat .x) (unfold [ Unit ] (fold [ Nat ] (( \f: Rec X. X .((f (let u = true in false) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Bool .a)) )) ) ({a = (fix (\x: Unit . (succ (if true then 0 else 0)) )) , b = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) false ) false) )) , c =  (let u = 0 in (let u = 1 in 0)) }.b))
(unfold [ Nat ] (fold [ Bool ] ({a = (((\x: Unit .\y: Unit .x) ({a = (let u = 1 in 1) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b) ) (let u = (fix (\x: Unit . 0 )) in false)) , b = (case <r = ({a = true , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) }.b) ))
(case <r = (let u = (case <l = ({a = true , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) in (case <r = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y)
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) (let u = ({a = 0 , b = true }.b) in u) ) ({a = (if false then 1 else 1) , b = (let u = false in (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b))) , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.c)) ))
({a = ({a = ({a = ({a = (if false then 0 else 1) , b = ({a = 1 , b = false }.b) , c = (((\x: Bool .\y: Bool .x) 1 ) true) }.c) , b = (if (if true then true else true) then ({a = false , b = 1 }.b) else ({a = false , b = 1 }.b)) }.b) , b = (( \f: Bool .((f (( \f: Bool .((f ({a = 0 , b = true , c =  0 }.b) ) (fix (\x: Bool . (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) )) ) ) (\a: Bool .\b: Bool .a)) , c = ({a = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) , b = (case <l = (if false then 1 else 0) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.c) , b = (if (let u = ({a = false , b = 1 }.a) in ({a = 0 , b = false , c =  1 }.b)) then ({a = (let u = (((\x: Nat .\y: Bool .y) true ) false) in u) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.a) else (case <r = (( \f: Bool .((f ({a = 0 , b = false }.b) ) (if false then true else false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y)) , c = ({a = (let u = (((\x: Unit .\y: Bool .y) true ) (let u = 0 in 1)) in u) , b = (fix (\x: Rec X. X . 0 )) }.b) }.c)
(let u = ({a = (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Rec X. X .y) (let u = 1 in true) ) ({a = 1 , b = false }.b)) ) (( \f: Bool .((f 1 ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Rec X. X .b))) , b = (( \f: Bool .((f (( \f: Rec X. X .((f (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = true in u) ) ) (\a: Nat .\b: Nat .b)) , c =  (((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) }.b) in (case <l = (((\x: Bool .\y: Unit .y) (fix (\x: Unit . true )) ) ({a = 1 , b = 1 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (unfold [ Unit ] (fold [ Nat ] (((\x: Nat .\y: Nat .y) (case <r = (unfold [ Rec X. X ] (fold [ Bool ] false )) > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . true ))) )) in ({a = (let u = (pred (let u = 0 in u)) in (((\x: Rec X. X .\y: Nat .y) (let u = true in u) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y))) , b = (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Nat .x) 0 ) false) ) ({a = 0 , b = false , c =  0 }.b)) }.b))
({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Bool . (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .a)) )) )) , b = ({a = ({a = 1 , b = (((\x: Unit .\y: Unit .x) true ) false) , c = (if true then 0 else 0) }.c) , b = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = (let u = false in false) }.b) , c =  (succ 0) }.b) }.b) , b = ({a = (let u = (((\x: Nat .\y: Nat .x) true ) true) in u) , b = (succ ({a = 1 , b = true }.a)) }.a) }.b)
(case <l = ({a = (((\x: Bool .\y: Bool .x) (iszero 1) ) (((\x: Nat .\y: Rec X. X .y) true ) true)) , b = ({a = (let u = true in false) , b = (let u = 0 in (fix (\x: Unit . 1 ))) }.b) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Bool .y) false ) 0) )) , b = (((\x: Unit .\y: Bool .y) (let u = true in true) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = 1 , b = true }.b) ))) , c =  ({a = (((\x: Unit .\y: Nat .x) 1 ) true) , b = ({a = false , b = 1 }.a) , c = (succ (((\x: Nat .\y: Bool .x) 0 ) false)) }.c) }.b) , b = (succ (fix (\x: Rec X. X . (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .x) 0 ) false) ) 0 ) ) (\a: Bool .\b: Nat .a)) ))) }.a)
(unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = (let u = 1 in 0) , b = 0 }.b) in u) ))
(((\x: Bool .\y: Bool .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (if ({a = 1 , b = false , c =  1 }.b) then ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = true in false) )) else (let u = true in false)) )) ) (fix (\x: Unit . (case <r = (fix (\x: Nat . false )) > as Rec X. X of < l = x > => x | < r = y > => y) )))
(unfold [ Unit ] (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Rec X. X .((f (( \f: Bool .((f false ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a)) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .b)) ) (case <r = (( \f: Bool .((f (fix (\x: Unit . true )) ) (let u = true in false) ) ) (\a: Nat .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) ))
(let u = (((\x: Bool .\y: Nat .y) (let u = (((\x: Unit .\y: Bool .y) true ) 1) in (let u = true in u)) ) (pred (succ 0))) in ({a = (pred (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a))) , b = ({a = (let u = (((\x: Unit .\y: Rec X. X .x) 0 ) false) in u) , b = (unfold [ Nat ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) )) , c = (( \f: Nat .((f (let u = 1 in u) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.c) }.b))
(let u = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = true , b = 0 }.b) )) , b = (let u = ({a = 0 , b = 1 }.b) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) }.b) in u)
(((\x: Nat .\y: Unit .x) ({a = ({a = ({a = 0 , b = false , c =  0 }.b) , b = (((\x: Rec X. X .\y: Unit .x) 0 ) true) }.b) , b = (if (((\x: Rec X. X .\y: Rec X. X .x) (if false then false else false) ) (((\x: Nat .\y: Bool .x) false ) true)) then (((\x: Unit .\y: Rec X. X .y) true ) true) else (unfold [ Rec X. X ] (fold [ Nat ] true ))) }.a) ) (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Rec X. X ] (let u = true in u) )) )))
(( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] (let u = ({a = false , b = 0 }.b) in (if (iszero 0) then ({a = 1 , b = false }.b) else (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .a)))) )) ) ({a = (case <r = ({a = 0 , b = true , c =  1 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (let u = false in false) in false) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
(( \f: Bool .((f ({a = ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = (fix (\x: Rec X. X . true )) , c =  (let u = 0 in 0) }.b) , b = (if (((\x: Unit .\y: Bool .x) false ) false) then (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) else (( \f: Bool .((f false ) (unfold [ Nat ] (fold [ Bool ] false )) ) ) (\a: Nat .\b: Rec X. X .b))) }.b) ) (case <r = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = 0 , b = true , c =  0 }.b) ))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a))
({a = (( \f: Nat .((f ({a = ({a = ({a = 0 , b = true , c = 1 }.c) , b = 1 }.b) , b = (fix (\x: Nat . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) , c =  ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = false }.a) }.b) ) (let u = (((\x: Nat .\y: Nat .x) ({a = 1 , b = true }.b) ) (iszero 0)) in (((\x: Bool .\y: Bool .y) true ) false)) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f 0 ) ({a = true , b = 0 }.b) ) ) (\a: Unit .\b: Unit .b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) , b = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Nat ] false )) }.b) }.a) }.b)
(((\x: Nat .\y: Unit .y) (if ({a = false , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.a) then (iszero 0) else ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) , b = ({a = 1 , b = false }.b) }.b)) ) (iszero ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Unit ] true ))) ))))
(fix (\x: Unit . (pred ({a = ({a = true , b = 1 }.b) , b = (let u = (((\x: Rec X. X .\y: Nat .y) true ) ({a = 1 , b = true }.a)) in (fix (\x: Rec X. X . 0 ))) }.b)) ))
(iszero ({a = (if (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) then (pred 0) else 1) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (iszero 0) )) }.a))
(case <l = (((\x: Unit .\y: Nat .y) (iszero ({a = ({a = true , b = 1 }.a) , b = 1 }.b)) ) (let u = (let u = false in 1) in (((\x: Nat .\y: Nat .x) 1 ) false))) > as Nat of < l = x > => x | < r = y > => y)
({a = (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Nat .y) (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (iszero 1)) ) (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = false }.b) ) (if true then false else false))) ) (let u = (case <r = ({a = true , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Nat .((f (iszero 0) ) ({a = 1 , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .b)))) , b = ({a = (fix (\x: Rec X. X . 0 )) , b = ({a = (((\x: Rec X. X .\y: Nat .x) true ) false) , b = false }.b) }.a) }.a)
(if (unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Bool .x) (let u = 1 in (((\x: Unit .\y: Unit .x) true ) false)) ) (( \f: Nat .((f ({a = 1 , b = (let u = 1 in true) }.b) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) ) (\a: Bool .\b: Rec X. X .a))) )) then (case <l = (let u = 0 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = ({a = (succ 0) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , c = (let u = false in 1) }.c) , b = ({a = (iszero 0) , b = 1 }.b) }.b))
(let u = (if ({a = (if false then 1 else 0) , b = (((\x: Bool .\y: Nat .x) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) false) , c =  (((\x: Rec X. X .\y: Bool .x) 0 ) (fix (\x: Bool . true ))) }.b) then ({a = (let u = (let u = 1 in 1) in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) , b = (( \f: Unit .((f 0 ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) else ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = ({a = (unfold [ Unit ] (fold [ Nat ] 1 )) , b = true , c = 0 }.c) }.b)) in (if ({a = (succ 0) , b = (if false then true else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) }.b) then (let u = (let u = true in u) in (pred 0)) else (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Unit ] (let u = 1 in true) )) ) (( \f: Unit .((f 1 ) (unfold [ Bool ] (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Nat .a)))))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Nat . (((\x: Nat .\y: Unit .y) true ) true) )) )) in u)
(( \f: Nat .((f ({a = (((\x: Bool .\y: Nat .x) (case <r = (let u = (let u = false in 1) in false) > as Rec X. X of < l = x > => x | < r = y > => y) ) (if (let u = false in false) then false else (unfold [ Bool ] (fold [ Nat ] false )))) , b = ({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) in (let u = true in (if false then 0 else 0))) , b = (succ (succ 1)) }.b) }.a) ) (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Unit .y) (let u = (fix (\x: Nat . false )) in false) ) (fix (\x: Bool . ({a = 1 , b = true }.b) ))) ) ({a = (fix (\x: Unit . ({a = true , b = 1 }.a) )) , b = (if (((\x: Bool .\y: Nat .y) false ) true) then false else (let u = true in true)) }.b)) ) ) (\a: Nat .\b: Unit .a))
({a = (if (((\x: Nat .\y: Unit .x) (let u = (((\x: Nat .\y: Unit .x) 0 ) true) in (let u = true in u)) ) (if true then false else true)) then (let u = (( \f: Rec X. X .((f ({a = 0 , b = 1 }.b) ) (let u = 1 in 0) ) ) (\a: Bool .\b: Bool .b)) in ({a = (pred 0) , b = (unfold [ Bool ] (fold [ Bool ] true )) , c = (( \f: Bool .((f (if true then 1 else 0) ) (fix (\x: Nat . 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) }.c)) else (pred (succ 1))) , b = ({a = (case <l = ({a = false , b = (let u = false in 1) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = ({a = false , b = ({a = 1 , b = false , c = 0 }.c) }.b) , b = (let u = 0 in ({a = 0 , b = false , c =  1 }.b)) }.a) }.b) }.b)
({a = (( \f: Unit .((f (fix (\x: Unit . ({a = ({a = 1 , b = false , c = 0 }.c) , b = ({a = 0 , b = true , c =  1 }.b) }.b) )) ) (let u = (((\x: Unit .\y: Unit .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) ({a = 1 , b = true , c =  1 }.b)) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Nat .b)) , b = (case <r = (case <r = (if true then true else true) > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) }.b)
(let u = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 1 in u) )) in (((\x: Rec X. X .\y: Unit .x) false ) false)) in (((\x: Nat .\y: Unit .y) (fix (\x: Bool . (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = (let u = false in false) in u) ))))
(case <l = (((\x: Bool .\y: Nat .x) (let u = (let u = (((\x: Unit .\y: Rec X. X .y) false ) 1) in (( \f: Nat .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) 1 ) ) (\a: Rec X. X .\b: Nat .b))) in (let u = (unfold [ Bool ] (fold [ Unit ] false )) in ({a = false , b = 1 }.b))) ) ({a = (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Rec X. X .\y: Bool .y) true ) 0) , b = (let u = 0 in true) }.b) }.b)) > as Bool of < l = x > => x | < r = y > => y)
(succ (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .a)) }.a) )) )))
(iszero (let u = (( \f: Nat .((f (fix (\x: Rec X. X . false )) ) (let u = (let u = 0 in true) in u) ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = (( \f: Rec X. X .((f true ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) in (((\x: Rec X. X .\y: Unit .y) true ) 1))))
({a = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) (let u = false in u) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) )) , b = (((\x: Unit .\y: Rec X. X .x) (let u = (unfold [ Nat ] (fold [ Nat ] 1 )) in (succ (((\x: Bool .\y: Unit .x) 0 ) ({a = 1 , b = false , c =  0 }.b)))) ) (let u = (( \f: Nat .((f (let u = 1 in 0) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ({a = (((\x: Rec X. X .\y: Nat .x) true ) true) , b = (let u = false in 1) }.a))) }.b)
(((\x: Bool .\y: Bool .y) ({a = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) true ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Unit .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (let u = 1 in u) ) ) (\a: Unit .\b: Nat .a)) }.a) ) (case <r = (let u = ({a = true , b = false }.b) in (let u = 0 in false)) > as Bool of < l = x > => x | < r = y > => y))
(let u = (let u = (((\x: Bool .\y: Unit .x) 1 ) ({a = 1 , b = false , c =  0 }.b)) in u) in u)
(( \f: Nat .((f (case <l = (pred ({a = 1 , b = true , c = 0 }.c)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (succ ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) , b = (succ 0) }.b)) ) ) (\a: Nat .\b: Nat .a))
(pred (succ (pred (((\x: Bool .\y: Unit .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true , c = 1 }.c)))))
(if (( \f: Bool .((f (let u = (( \f: Unit .((f ({a = (iszero 0) , b = 1 }.a) ) (fix (\x: Bool . false )) ) ) (\a: Bool .\b: Nat .b)) in (let u = (((\x: Nat .\y: Rec X. X .x) false ) false) in false)) ) (fix (\x: Bool . (let u = true in u) )) ) ) (\a: Bool .\b: Bool .b)) then ({a = (fix (\x: Bool . (( \f: Nat .((f (fix (\x: Rec X. X . true )) ) false ) ) (\a: Bool .\b: Rec X. X .a)) )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.a) else ({a = (( \f: Nat .((f (if (if false then true else true) then ({a = true , b = false }.b) else (((\x: Bool .\y: Nat .y) false ) false)) ) (iszero (succ 0)) ) ) (\a: Unit .\b: Nat .a)) , b = (( \f: Rec X. X .((f (( \f: Nat .((f true ) (let u = false in u) ) ) (\a: Nat .\b: Nat .a)) ) (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) in (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) ) ) (\a: Unit .\b: Bool .b)) }.b))
(case <l = (let u = (case <r = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) in (( \f: Unit .((f (((\x: Bool .\y: Nat .x) (let u = 1 in 1) ) (case <r = ({a = 1 , b = false , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = true , b = 1 }.b) ) ) (\a: Unit .\b: Nat .b))) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Nat .x) (let u = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (fix (\x: Unit . 1 )) }.b) in (unfold [ Bool ] (fold [ Bool ] (let u = 0 in 1) ))) ) (let u = (((\x: Unit .\y: Unit .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) ) (let u = false in u)) in u))
({a = (fix (\x: Rec X. X . ({a = ({a = 0 , b = 1 }.b) , b = ({a = 1 , b = false }.b) , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.c) )) , b = (if (let u = (( \f: Bool .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) (if (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) then (let u = true in 0) else 1) ) ) (\a: Bool .\b: Unit .b)) in (case <r = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y)) then (( \f: Unit .((f (fix (\x: Rec X. X . 0 )) ) (unfold [ Unit ] (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Unit .\y: Unit .x) 1 ) ({a = true , b = 1 }.a)) ))) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (pred (let u = (fix (\x: Rec X. X . 0 )) in u)) ))
(let u = (succ (fix (\x: Rec X. X . ({a = 1 , b = true , c = 1 }.c) ))) in (iszero ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (pred 0) ))))
(let u = ({a = (((\x: Rec X. X .\y: Unit .y) (let u = 1 in false) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = 0 in true) }.a) in u)
(let u = ({a = (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .b)) in (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b))) , b = (( \f: Nat .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) }.b) in u)
(let u = (let u = ({a = (let u = 1 in 1) , b = true , c = 1 }.c) in (let u = (((\x: Nat .\y: Bool .y) true ) 1) in (fix (\x: Bool . 1 )))) in u)
({a = ({a = (let u = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a)) in u) , b = (( \f: Nat .((f (pred (((\x: Bool .\y: Bool .x) 0 ) false)) ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) , b = (let u = (let u = ({a = true , b = 1 }.a) in (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a))) in u) , c = (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Bool .y) ({a = ({a = true , b = false }.b) , b = true }.b) ) ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.a)) ) (((\x: Bool .\y: Rec X. X .y) (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .y) true ) false) ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = false , b = 0 }.a))) }.c)
(iszero ({a = (( \f: Unit .((f (let u = true in 1) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in 1) )) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Unit .((f (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) , c = ({a = (( \f: Nat .((f (pred 0) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = true , b = true }.b) }.a) }.c))
({a = (((\x: Nat .\y: Nat .y) (if (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Unit .y) false ) (if true then false else true)) )) then (let u = 0 in true) else ({a = false , b = ({a = true , b = 1 }.a) }.b)) ) (if ({a = 1 , b = true , c =  0 }.b) then ({a = 0 , b = 0 }.b) else (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)))) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (if (let u = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) in u) then (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] true )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)) else (let u = (((\x: Bool .\y: Unit .y) false ) 1) in (let u = false in u))) )) }.a)
(( \f: Nat .((f (iszero ({a = (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Bool .x) 0 ) false) ) ({a = true , b = 1 }.a)) , b = (let u = true in u) , c = ({a = 0 , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .a)) }.a) }.c)) ) (if (( \f: Nat .((f (( \f: Bool .((f (let u = 0 in false) ) (iszero (let u = true in 0)) ) ) (\a: Nat .\b: Nat .b)) ) (let u = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .b)) in (((\x: Nat .\y: Unit .y) true ) true)) ) ) (\a: Bool .\b: Bool .b)) then (iszero ({a = (let u = true in 0) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.a)) else (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) )))) ) ) (\a: Nat .\b: Unit .a))
(((\x: Rec X. X .\y: Nat .x) (if (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) in (let u = 1 in false)) then (let u = 1 in (let u = 0 in 1)) else (pred 0)) ) (iszero (unfold [ Unit ] (fold [ Nat ] (let u = 0 in u) ))))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <l = (fix (\x: Nat . (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) )) > as Unit of < l = x > => x | < r = y > => y) ))
(let u = (( \f: Rec X. X .((f (let u = (if true then false else true) in (succ 0)) ) (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f ({a = true , b = 1 }.a) ) (fix (\x: Bool . true )) ) ) (\a: Nat .\b: Nat .a)) ) ({a = 1 , b = true , c = 0 }.c)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Nat .x) (pred (unfold [ Unit ] (fold [ Bool ] 1 ))) ) (fix (\x: Bool . (let u = false in false) ))) )))
(if (( \f: Unit .((f (let u = (let u = ({a = true , b = 0 }.a) in ({a = 0 , b = true , c =  1 }.b)) in (iszero ({a = (let u = 1 in u) , b = false , c = 1 }.c))) ) (let u = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Bool .\y: Nat .x) true ) false) , c = 1 }.c) in ({a = true , b = (iszero 0) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) then (((\x: Bool .\y: Bool .x) (let u = (let u = 1 in 1) in 0) ) (case <r = (fix (\x: Bool . false )) > as Nat of < l = x > => x | < r = y > => y)) else (if (( \f: Unit .((f (if (iszero 1) then (((\x: Rec X. X .\y: Nat .x) false ) false) else true) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .b)) then ({a = ({a = ({a = 0 , b = true , c = 1 }.c) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (( \f: Rec X. X .((f false ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .b)) }.a) else (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) in u)))
(let u = (let u = (((\x: Rec X. X .\y: Unit .y) (let u = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u) ) ({a = ({a = false , b = 1 }.b) , b = ({a = 0 , b = false }.b) , c =  0 }.b)) in u) in ({a = (((\x: Unit .\y: Bool .x) (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) (let u = 1 in true)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b))
({a = (let u = (if (fix (\x: Rec X. X . false )) then (((\x: Rec X. X .\y: Unit .y) true ) 1) else ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 ))) in u) , b = (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) false ) (unfold [ Nat ] (fold [ Bool ] true ))) ) (( \f: Bool .((f (let u = true in true) ) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Bool .\b: Rec X. X .a)) }.a)
({a = (let u = (case <r = (let u = 0 in (((\x: Bool .\y: Nat .x) false ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = (if false then false else true) in ({a = true , b = 0 }.b))) , b = (unfold [ Unit ] (fold [ Bool ] (case <r = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) )) }.b)
({a = (if (let u = ({a = ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.b) , b = (let u = 0 in false) , c =  (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) in u) then (pred (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) else (( \f: Unit .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .y) false ) 0) ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = (let u = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) , c =  (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) }.b) in (case <l = (succ 1) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b)
(unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .x) ({a = (pred 0) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) }.b) ) (( \f: Unit .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = false }.b) )) ) (case <r = (if true then true else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a))) ))
(( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] (unfold [ Nat ] (fold [ Bool ] (if false then false else false) )) )) ) (iszero (( \f: Nat .((f ({a = 0 , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) }.b) ) ({a = 1 , b = 1 }.b) ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Nat .\b: Unit .b))
(case <l = (((\x: Nat .\y: Bool .x) (case <l = (let u = 0 in u) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (((\x: Bool .\y: Rec X. X .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Unit .x) false ) true)) , b = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) in u) }.a)) > as Bool of < l = x > => x | < r = y > => y)
({a = (succ (let u = (((\x: Bool .\y: Nat .y) false ) true) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) , b = (((\x: Unit .\y: Rec X. X .y) (iszero 1) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = ({a = 0 , b = true , c =  0 }.b) , c =  1 }.b) ))) , c =  ({a = ({a = ({a = 1 , b = true , c = 1 }.c) , b = ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = ({a = 0 , b = 0 }.b) }.a) , c = (let u = 0 in (if false then 1 else 1)) }.c) , b = (let u = true in u) , c = (let u = (pred 1) in u) }.c) }.b)
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (let u = 0 in true) in 0) )) )) )) , b = (iszero ({a = (if true then (((\x: Unit .\y: Unit .x) 1 ) false) else 1) , b = (fix (\x: Unit . true )) }.a)) }.a)
(pred (if ({a = (( \f: Unit .((f ({a = 1 , b = false , c = 1 }.c) ) (((\x: Nat .\y: Rec X. X .x) 1 ) true) ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Rec X. X .x) false ) true) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true ))) }.b) then (((\x: Unit .\y: Bool .y) ({a = (((\x: Nat .\y: Unit .x) true ) false) , b = (iszero 1) }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) else (((\x: Unit .\y: Unit .x) (pred 1) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a)))))
(if (iszero (case <l = ({a = true , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y)) then ({a = (if ({a = ({a = true , b = 1 }.b) , b = ({a = false , b = 1 }.a) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.b) then ({a = false , b = 1 }.a) else (( \f: Rec X. X .((f false ) (((\x: Bool .\y: Rec X. X .x) false ) true) ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = false , b = (((\x: Unit .\y: Nat .y) false ) 0) }.a) }.b) }.b) else (iszero ({a = (fix (\x: Rec X. X . false )) , b = ({a = (((\x: Rec X. X .\y: Unit .y) false ) false) , b = 0 }.b) }.b)))
(case <r = ({a = (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Bool .x) 0 ) (let u = true in u)) ) (( \f: Bool .((f (fix (\x: Rec X. X . false )) ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .a))) , b = ({a = ({a = 1 , b = true }.b) , b = (fix (\x: Rec X. X . 1 )) }.a) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Nat .y) (let u = (let u = (let u = (let u = true in u) in u) in u) in ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ))) ) (( \f: Rec X. X .((f (case <l = (((\x: Nat .\y: Rec X. X .y) true ) 0) > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <l = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)))
(let u = (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f true ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = (let u = 1 in 1) in u)) in u)
(let u = (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Unit .y) false ) 0) ) (let u = true in u)) in (case <l = (pred (case <l = ({a = true , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = ({a = false , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) in ({a = 1 , b = 0 }.b)) )) , b = (if ({a = (( \f: Rec X. X .((f (let u = true in 1) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Nat .a)) , b = ({a = (succ 1) , b = (let u = (let u = 1 in false) in u) }.b) , c =  (((\x: Nat .\y: Rec X. X .y) ({a = 1 , b = true , c =  1 }.b) ) (((\x: Unit .\y: Unit .y) false ) 0)) }.b) then (iszero (((\x: Nat .\y: Nat .y) false ) 1)) else (let u = (let u = 0 in true) in ({a = 1 , b = false }.b))) }.b)
(iszero (pred (succ 0)))
(let u = ({a = (let u = 1 in ({a = true , b = 0 }.a)) , b = (( \f: Bool .((f (pred 0) ) 1 ) ) (\a: Unit .\b: Bool .a)) }.b) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if (unfold [ Unit ] (fold [ Bool ] false )) then (unfold [ Rec X. X ] (fold [ Unit ] false )) else (let u = 1 in false)) )))
(case <l = (case <l = (if (((\x: Unit .\y: Unit .x) true ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b))) then (pred (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b))) else ({a = false , b = 1 }.b)) > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Unit . (if (let u = (let u = false in u) in (((\x: Unit .\y: Bool .x) false ) true)) then (( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) ) (if false then false else false) ) ) (\a: Bool .\b: Unit .a)) else ({a = ({a = 1 , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) }.a) , b = (((\x: Bool .\y: Nat .y) false ) false) }.b)) ))
(unfold [ Rec X. X ] (fold [ Unit ] (case <l = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) ))
(unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] (if (unfold [ Unit ] (fold [ Nat ] false )) then (iszero 1) else true) )) ))
(succ (case <l = ({a = (succ 1) , b = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f ({a = (let u = 0 in ({a = 1 , b = false }.a)) , b = (((\x: Nat .\y: Rec X. X .x) true ) true) , c = (let u = 0 in u) }.c) ) (( \f: Nat .((f (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) ({a = (iszero 0) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b))) ) (((\x: Nat .\y: Bool .y) ({a = false , b = false }.b) ) ({a = 0 , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f ({a = false , b = (if true then 0 else 1) }.b) ) ({a = false , b = 0 }.b) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .b))
(((\x: Unit .\y: Bool .y) (if (unfold [ Bool ] (fold [ Bool ] (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) in false) )) then ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = (iszero 1) }.b) else (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = true }.b) ))) ) ({a = (pred 1) , b = ({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) in (unfold [ Unit ] (fold [ Unit ] true ))) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) }.b) }.b))
(((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Unit .x) (( \f: Nat .((f (if (if false then true else true) then (if false then false else false) else (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .a))) ) ({a = 1 , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in false) ))) ) (if (( \f: Unit .((f (let u = true in u) ) ({a = true , b = 0 }.a) ) ) (\a: Unit .\b: Unit .b)) then (( \f: Rec X. X .((f ({a = (fix (\x: Unit . 0 )) , b = false , c =  (unfold [ Nat ] (fold [ Nat ] 1 )) }.b) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Nat .a)) else ({a = ({a = 0 , b = true , c =  1 }.b) , b = (let u = false in u) }.b)))
(( \f: Nat .((f (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) (let u = 1 in u) ) ({a = (if false then true else false) , b = true }.b)) ) (fix (\x: Rec X. X . ({a = (((\x: Bool .\y: Rec X. X .y) true ) 0) , b = 1 }.b) )) ) ) (\a: Unit .\b: Rec X. X .a)) ) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] 1 )) ) 1 ) ) (\a: Unit .\b: Unit .b)) )) in (case <l = (fix (\x: Unit . (unfold [ Nat ] (fold [ Bool ] 1 )) )) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .b))
({a = (let u = (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = (((\x: Rec X. X .\y: Unit .y) false ) true) }.b) )) in (fix (\x: Bool . (let u = 1 in 0) ))) , b = ({a = ({a = ({a = 1 , b = false }.b) , b = (let u = false in u) }.b) , b = (iszero 1) }.b) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) (case <r = ({a = false , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) ) (succ ({a = 1 , b = true }.a))) )) }.c)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = false , c =  (pred 0) }.b) )) then (pred 0) else ({a = ({a = 0 , b = ({a = 0 , b = true }.a) }.b) , b = (((\x: Bool .\y: Bool .x) (if true then 0 else 0) ) true) }.b)) ))
(((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Bool .x) true ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = 1 in (let u = true in false))) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero 1) )) )))
({a = (unfold [ Bool ] (fold [ Nat ] (( \f: Nat .((f (let u = true in u) ) (((\x: Bool .\y: Unit .y) false ) false) ) ) (\a: Unit .\b: Bool .b)) )) , b = (unfold [ Unit ] (fold [ Bool ] ({a = ({a = (let u = ({a = false , b = false }.b) in ({a = 0 , b = false }.b)) , b = ({a = 1 , b = false }.a) }.a) , b = (pred (let u = ({a = 1 , b = false , c = 0 }.c) in u)) }.b) )) }.a)
(let u = (( \f: Rec X. X .((f (let u = ({a = 1 , b = false , c =  1 }.b) in ({a = false , b = 1 }.a)) ) (if (( \f: Rec X. X .((f (let u = false in false) ) (let u = true in false) ) ) (\a: Bool .\b: Nat .b)) then (fix (\x: Bool . ({a = true , b = false }.b) )) else ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) ) ) (\a: Unit .\b: Rec X. X .b)) in (pred (pred (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))))
({a = (let u = (( \f: Unit .((f (fix (\x: Nat . (let u = 0 in u) )) ) (pred ({a = 1 , b = false }.a)) ) ) (\a: Unit .\b: Rec X. X .b)) in u) , b = (iszero (let u = (pred 1) in (let u = (if true then 0 else 1) in u))) , c = (let u = ({a = (succ 1) , b = (fix (\x: Rec X. X . false )) , c =  ({a = false , b = (fix (\x: Nat . 0 )) }.b) }.b) in (((\x: Bool .\y: Rec X. X .x) (let u = (iszero 1) in ({a = 1 , b = false }.a)) ) (let u = false in true))) }.c)
(unfold [ Nat ] (fold [ Bool ] (let u = (unfold [ Nat ] (fold [ Bool ] 1 )) in (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) in u)) ))
(if ({a = (( \f: Nat .((f ({a = false , b = false }.b) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) , b = (let u = (unfold [ Bool ] (fold [ Nat ] true )) in (succ 1)) }.a) then ({a = (( \f: Bool .((f (( \f: Bool .((f 1 ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Nat .a)) ) (succ 0) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Unit .\y: Bool .x) (if (let u = true in false) then (unfold [ Bool ] (fold [ Nat ] false )) else false) ) (iszero ({a = 1 , b = 1 }.b))) , c =  (succ (pred 0)) }.b) else ({a = ({a = (((\x: Nat .\y: Bool .x) (((\x: Unit .\y: Unit .x) false ) true) ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .a))) , b = (((\x: Nat .\y: Rec X. X .x) true ) false) }.b) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = true in 1) )) }.a))
(((\x: Bool .\y: Unit .x) (((\x: Nat .\y: Unit .x) (if (unfold [ Bool ] (fold [ Unit ] true )) then (( \f: Unit .((f (iszero 1) ) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .a)) else ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (let u = false in true) , c =  ({a = 0 , b = false , c = 1 }.c) }.b)) ) (( \f: Rec X. X .((f (let u = true in (let u = true in u)) ) ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = false }.b) ) ) (\a: Nat .\b: Bool .b))) ) ({a = (if ({a = (iszero (fix (\x: Bool . 1 ))) , b = (iszero 1) }.b) then ({a = (let u = true in u) , b = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = 1 }.b) }.b) else (fix (\x: Nat . ({a = 0 , b = 1 }.b) ))) , b = (((\x: Nat .\y: Bool .y) (iszero (pred 0)) ) (iszero (let u = 1 in 1))) , c =  (( \f: Rec X. X .((f (let u = 0 in 0) ) (let u = 0 in u) ) ) (\a: Unit .\b: Bool .a)) }.b))
(unfold [ Unit ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (case <l = ({a = false , b = (((\x: Unit .\y: Rec X. X .x) 1 ) true) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) ))
(( \f: Rec X. X .((f (if (iszero ({a = 0 , b = true }.a)) then (if false then (if true then false else true) else (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a))) else ({a = (((\x: Unit .\y: Nat .x) 1 ) false) , b = ({a = 0 , b = true }.b) }.b)) ) ({a = (case <r = ({a = 1 , b = false , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Rec X. X . 1 )) , b = (let u = false in true) }.b) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) )) , b = (( \f: Bool .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) ) 0 ) ) (\a: Unit .\b: Bool .a)) }.b) )) ))
(case <l = (let u = (let u = (let u = 1 in u) in u) in (( \f: Bool .((f (let u = 0 in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) ) (unfold [ Unit ] (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Nat .b))) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Unit .y) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Nat .\y: Bool .x) ({a = (unfold [ Nat ] (fold [ Unit ] false )) , b = (((\x: Unit .\y: Bool .y) false ) 0) }.a) ) ({a = 1 , b = false }.b))) ) (unfold [ Unit ] (fold [ Rec X. X ] (if (iszero 1) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) else (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b))) )))
(((\x: Nat .\y: Rec X. X .x) (succ (let u = (let u = 1 in false) in (let u = 1 in u))) ) (((\x: Bool .\y: Rec X. X .y) ({a = (let u = ({a = (pred 0) , b = false }.b) in u) , b = (case <l = (((\x: Bool .\y: Unit .x) 1 ) false) > as Unit of < l = x > => x | < r = y > => y) }.a) ) (( \f: Bool .((f ({a = (let u = false in 1) , b = (fix (\x: Rec X. X . false )) }.b) ) (let u = (( \f: Rec X. X .((f ({a = true , b = 1 }.b) ) (((\x: Unit .\y: Nat .x) 1 ) true) ) ) (\a: Nat .\b: Unit .b)) in ({a = false , b = false }.b)) ) ) (\a: Unit .\b: Rec X. X .a))))
(let u = (if (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) then ({a = (iszero 1) , b = (let u = 1 in 1) }.a) else ({a = 1 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = 1 , b = false , c = 1 }.c) }.b)) in u)
(let u = (let u = ({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 )) in ({a = true , b = 1 }.b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = false , c =  1 }.b) ) false) , c =  (pred 0) }.b) in (let u = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) )) ) (case <r = ({a = true , b = 1 }.a) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) in u)) in u)
(if (let u = (( \f: Rec X. X .((f false ) (if true then false else false) ) ) (\a: Nat .\b: Nat .a)) in (( \f: Nat .((f ({a = false , b = 0 }.a) ) false ) ) (\a: Bool .\b: Nat .a))) then (pred ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = (iszero 1) , b = (((\x: Rec X. X .\y: Nat .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) 0) }.b) ))) else (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) true ) 0) ))) )))
(unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Bool . (pred (succ ({a = (let u = 1 in u) , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) }.a))) )) ))
(( \f: Bool .((f (( \f: Bool .((f ({a = (((\x: Nat .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) (let u = 0 in u)) , b = ({a = 0 , b = false , c =  (if false then 1 else 0) }.b) }.b) ) (let u = (( \f: Rec X. X .((f ({a = (let u = true in 0) , b = (let u = true in u) , c = 1 }.c) ) (if false then 1 else 0) ) ) (\a: Nat .\b: Nat .a)) in (unfold [ Bool ] (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] true )) ))) ) ) (\a: Bool .\b: Unit .a)) ) (let u = (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) true ) ({a = false , b = true }.b)) ) ({a = ({a = true , b = 0 }.b) , b = (((\x: Unit .\y: Rec X. X .y) true ) false) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) in u) ) ) (\a: Nat .\b: Rec X. X .b))
(let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) (pred 1) ) ({a = 1 , b = false , c =  1 }.b)) )) )) in u)
(((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Rec X. X .x) (iszero ({a = (if false then true else true) , b = (if false then 0 else 0) }.b)) ) ({a = (pred 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) }.b)) ) (iszero (if (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)) then (( \f: Unit .((f (let u = 0 in u) ) (pred 1) ) ) (\a: Nat .\b: Nat .a)) else ({a = 1 , b = 1 }.b))))
(if (unfold [ Nat ] (fold [ Bool ] (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) )) then (if (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = 1 in false) )) ) (let u = 0 in ({a = 1 , b = true , c =  0 }.b)) ) ) (\a: Rec X. X .\b: Unit .a)) then (unfold [ Bool ] (fold [ Unit ] 1 )) else (pred (fix (\x: Bool . 1 )))) else (let u = (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) false ) ({a = 1 , b = true , c = 1 }.c)) )) in u))
(case <r = (( \f: Rec X. X .((f ({a = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b)) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.a) ) (iszero 1) ) ) (\a: Unit .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y)
(let u = (pred ({a = (( \f: Nat .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (if true then ({a = 1 , b = true }.a) else (pred 1)) }.b)) in (pred (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = 1 in u))))
(iszero ({a = (let u = (pred 0) in (let u = 0 in false)) , b = (( \f: Rec X. X .((f (succ 0) ) 1 ) ) (\a: Nat .\b: Unit .a)) }.b))
(let u = (unfold [ Nat ] (fold [ Unit ] (succ (unfold [ Bool ] (fold [ Bool ] (let u = ({a = 1 , b = false , c =  0 }.b) in ({a = true , b = 0 }.b)) ))) )) in (( \f: Unit .((f (let u = (fix (\x: Unit . (let u = 1 in false) )) in u) ) (( \f: Nat .((f (( \f: Unit .((f (case <r = (if false then true else true) > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) ) (\a: Bool .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) ({a = false , b = 1 }.a) ) false) ) ({a = ({a = true , b = 1 }.a) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.a) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Bool .a)))
(let u = ({a = (let u = (( \f: Bool .((f (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) (unfold [ Bool ] (fold [ Bool ] false )) ) ) (\a: Bool .\b: Unit .b)) in u) , b = (if true then 0 else ({a = 1 , b = true }.a)) }.b) in u)
(fix (\x: Rec X. X . (case <l = (( \f: Bool .((f (fix (\x: Bool . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (let u = (unfold [ Unit ] (fold [ Nat ] 0 )) in ({a = 1 , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) ))
(( \f: Unit .((f (( \f: Nat .((f (if (unfold [ Bool ] (fold [ Bool ] false )) then (iszero 0) else (unfold [ Nat ] (fold [ Unit ] (let u = 0 in true) ))) ) (case <r = (let u = (fix (\x: Rec X. X . false )) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) ) (iszero (let u = (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .b)) in (let u = 0 in 1)) in (succ (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)))) ) ) (\a: Unit .\b: Bool .b))
(((\x: Bool .\y: Bool .x) (unfold [ Bool ] (fold [ Nat ] (fix (\x: Rec X. X . (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 ))) )) )) ) (if (( \f: Bool .((f (let u = true in false) ) ({a = (((\x: Unit .\y: Bool .x) true ) false) , b = (((\x: Nat .\y: Rec X. X .y) true ) false) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) then (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in u) else (((\x: Bool .\y: Bool .y) true ) true)) else (( \f: Unit .((f true ) (unfold [ Unit ] (fold [ Nat ] true )) ) ) (\a: Unit .\b: Unit .b))))
({a = (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Nat .y) (fix (\x: Nat . false )) ) (let u = 1 in true)) ) (unfold [ Unit ] (fold [ Bool ] ({a = (if false then 0 else 0) , b = true , c =  ({a = 1 , b = true , c = 1 }.c) }.b) ))) , b = (if (( \f: Rec X. X .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) (let u = true in true)) ) ) (\a: Unit .\b: Nat .b)) then (((\x: Bool .\y: Rec X. X .x) (pred 0) ) (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y)) else (let u = ({a = (iszero 1) , b = 1 }.b) in ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Bool . 1 )) )))) }.b)
({a = (if ({a = (succ 1) , b = (((\x: Rec X. X .\y: Unit .x) false ) false) }.b) then (( \f: Bool .((f (if ({a = true , b = true }.b) then 0 else 1) ) ({a = true , b = 0 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) else (( \f: Bool .((f (( \f: Unit .((f 1 ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Unit .\b: Bool .b)) ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (((\x: Nat .\y: Rec X. X .y) (let u = false in u) ) (let u = true in ({a = 0 , b = false , c =  0 }.b))) , c = (fix (\x: Bool . (let u = ({a = ({a = false , b = true }.b) , b = (if true then false else false) }.b) in (fix (\x: Unit . ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = (let u = 1 in false) }.a) ))) )) }.c)
({a = (( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , b = (let u = 1 in u) }.b) ) (pred (let u = 1 in u)) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Bool .\y: Rec X. X .x) ({a = ({a = 0 , b = true , c = 1 }.c) , b = (let u = (succ 1) in false) , c = (let u = 0 in 1) }.c) ) (fix (\x: Bool . ({a = (fix (\x: Rec X. X . 1 )) , b = false , c =  (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ))) }.b)
(((\x: Unit .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Bool ] (iszero ({a = 0 , b = false }.a)) )) ) (((\x: Unit .\y: Rec X. X .y) ({a = (let u = true in 1) , b = (((\x: Rec X. X .\y: Nat .y) true ) true) }.b) ) ({a = 0 , b = false }.b)))
(((\x: Bool .\y: Bool .x) (if ({a = false , b = (let u = true in u) }.b) then ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = true , c =  (let u = false in 0) }.b) else (let u = ({a = true , b = true }.b) in (( \f: Unit .((f true ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Bool .b)))) ) ({a = ({a = false , b = (fix (\x: Nat . 0 )) }.b) , b = (let u = (let u = false in true) in u) , c =  (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b))
(( \f: Rec X. X .((f ({a = ({a = true , b = ({a = 0 , b = 1 }.b) }.a) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = true }.b) ) (pred (unfold [ Unit ] (fold [ Bool ] 1 )))) }.a) ) (if (iszero ({a = 0 , b = true }.a)) then (((\x: Unit .\y: Rec X. X .y) true ) (unfold [ Nat ] (fold [ Bool ] false ))) else ({a = (let u = (unfold [ Nat ] (fold [ Rec X. X ] false )) in u) , b = ({a = 1 , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c =  1 }.b) }.b)) ) ) (\a: Unit .\b: Unit .a))
({a = (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f ({a = (let u = (let u = 0 in 0) in u) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .a)) }.b) ) (let u = false in u) ) ) (\a: Nat .\b: Nat .b)) ) (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (let u = 1 in true))) , b = (unfold [ Unit ] (fold [ Rec X. X ] (let u = ({a = (let u = true in 1) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.b) in (let u = (((\x: Unit .\y: Bool .x) 1 ) true) in (succ 0))) )) }.b)
({a = ({a = (((\x: Unit .\y: Bool .x) 0 ) (fix (\x: Bool . false ))) , b = ({a = 0 , b = ({a = 0 , b = false , c =  1 }.b) }.b) , c = (let u = 1 in u) }.c) , b = ({a = (iszero 1) , b = (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Nat .y) true ) (let u = true in true)) ) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b))) }.b) , c =  ({a = ({a = (let u = false in u) , b = (let u = (succ 1) in ({a = 1 , b = false , c = 1 }.c)) }.b) , b = (let u = true in u) , c = (unfold [ Bool ] (fold [ Unit ] (let u = true in 1) )) }.c) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) (((\x: Unit .\y: Bool .y) false ) false)) ) (((\x: Rec X. X .\y: Nat .y) (let u = 0 in false) ) (if false then false else false)) ) ) (\a: Nat .\b: Rec X. X .b)) ))
({a = (if (((\x: Unit .\y: Unit .y) false ) false) then (( \f: Nat .((f (if false then 0 else (((\x: Unit .\y: Unit .y) false ) 0)) ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Unit .a)) else ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) false ) 1) ))) , b = ({a = (( \f: Unit .((f ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = 1 }.b) ) (( \f: Rec X. X .((f (fix (\x: Nat . 1 )) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .b)) , b = (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .x) false ) true) )) , c =  ({a = 0 , b = (if true then 0 else 1) }.b) }.b) , c = (let u = (case <r = ({a = (pred 1) , b = (let u = ({a = 0 , b = false , c =  0 }.b) in u) }.b) > as Bool of < l = x > => x | < r = y > => y) in ({a = (pred (((\x: Unit .\y: Bool .x) 1 ) true)) , b = ({a = (((\x: Bool .\y: Bool .y) false ) 1) , b = (((\x: Nat .\y: Nat .y) false ) false) }.b) , c = ({a = false , b = 0 }.b) }.c)) }.c)
(if (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) ) (((\x: Unit .\y: Unit .y) false ) (let u = false in u))) then ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (((\x: Nat .\y: Rec X. X .x) (let u = false in false) ) false) , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.c) else (succ (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Nat .\y: Nat .y) false ) (if true then 0 else 0)) ) ) (\a: Bool .\b: Nat .a))))
(case <r = ({a = (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) ) (let u = true in true) ) ) (\a: Unit .\b: Rec X. X .b)) , b = ({a = ({a = true , b = 1 }.b) , b = 1 }.b) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Bool .x) ({a = ({a = (let u = 0 in u) , b = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) }.a) , b = ({a = (fix (\x: Rec X. X . 0 )) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) }.b) ) (((\x: Unit .\y: Bool .y) ({a = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , b = false }.b) ) ({a = (if false then false else false) , b = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.a)))
(let u = ({a = (case <l = (pred ({a = 0 , b = true , c = 0 }.c)) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (let u = true in 0) ) (fix (\x: Nat . 0 )) ) ) (\a: Nat .\b: Nat .a)) }.b) in (( \f: Bool .((f ({a = (unfold [ Rec X. X ] (fold [ Unit ] true )) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.a) ) (case <r = (( \f: Unit .((f (iszero 1) ) (let u = 0 in false) ) ) (\a: Rec X. X .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)))
(( \f: Unit .((f ({a = (let u = (if (let u = 1 in false) then (fix (\x: Bool . 0 )) else 0) in (pred 1)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , c = (let u = (fix (\x: Rec X. X . true )) in (if (unfold [ Bool ] (fold [ Unit ] false )) then 1 else (((\x: Unit .\y: Unit .x) 0 ) false))) }.c) ) (( \f: Bool .((f ({a = (let u = true in (let u = 1 in u)) , b = ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = 1 }.a) , c = (let u = 1 in 1) }.c) ) (( \f: Unit .((f (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) in u) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Nat .a))
(let u = ({a = (( \f: Rec X. X .((f (pred 1) ) (succ 0) ) ) (\a: Bool .\b: Bool .a)) , b = (iszero ({a = true , b = (pred 1) }.b)) }.a) in (pred ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 ))))
(if (case <r = ({a = ({a = false , b = ({a = 1 , b = false }.a) }.b) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c =  ({a = (if false then 0 else 1) , b = (iszero 0) }.a) }.b) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Rec X. X .y) (let u = (fix (\x: Nat . false )) in (let u = true in false)) ) (((\x: Bool .\y: Nat .y) ({a = (if true then true else ({a = 1 , b = false , c =  1 }.b)) , b = (let u = true in 0) }.a) ) ({a = (let u = 0 in u) , b = (let u = 1 in true) , c =  (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) }.b))) else (unfold [ Rec X. X ] (fold [ Nat ] (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y) )))
(iszero (let u = (((\x: Nat .\y: Nat .y) (let u = ({a = 1 , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.b) in (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b))) ) (case <r = (if true then false else true) > as Bool of < l = x > => x | < r = y > => y)) in ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = (fix (\x: Rec X. X . 1 )) in u) ))))
({a = (let u = ({a = 1 , b = true }.b) in u) , b = ({a = (case <l = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Bool ] (fold [ Rec X. X ] true )) in false) , c = ({a = ({a = 0 , b = false }.a) , b = (( \f: Bool .((f 1 ) (fix (\x: Nat . 0 )) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) }.c) }.a)
(((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Nat .x) ({a = (( \f: Nat .((f 0 ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = 0 in u) }.b) ) (( \f: Nat .((f (((\x: Unit .\y: Nat .x) true ) false) ) (if true then false else true) ) ) (\a: Rec X. X .\b: Nat .b))) ) (if (let u = (iszero ({a = 1 , b = false , c = 0 }.c)) in ({a = true , b = 1 }.a)) then ({a = (let u = 1 in u) , b = (if true then (fix (\x: Rec X. X . true )) else (let u = false in false)) , c =  ({a = (pred 1) , b = (fix (\x: Nat . 1 )) }.b) }.b) else ({a = ({a = 1 , b = true }.b) , b = (((\x: Rec X. X .\y: Bool .y) true ) 0) }.a)))
(case <l = ({a = (let u = (((\x: Bool .\y: Unit .y) true ) 0) in u) , b = (( \f: Nat .((f (fix (\x: Unit . ({a = 1 , b = false }.b) )) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) > as Bool of < l = x > => x | < r = y > => y)
(pred (succ (let u = (pred ({a = false , b = 0 }.b)) in (case <l = (if true then 1 else 1) > as Nat of < l = x > => x | < r = y > => y))))
(let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (pred 1) )) , b = (let u = (((\x: Rec X. X .\y: Unit .x) (if true then false else true) ) ({a = true , b = true }.b)) in (fix (\x: Rec X. X . 0 ))) }.b) in u)
(iszero (if (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Nat ] false )) ) (let u = false in false) ) ) (\a: Bool .\b: Nat .b)) ) (case <r = (let u = true in false) > as Unit of < l = x > => x | < r = y > => y)) then (((\x: Rec X. X .\y: Unit .x) (let u = (let u = 1 in 1) in u) ) (iszero 1)) else ({a = ({a = true , b = 0 }.b) , b = ({a = 1 , b = false }.a) }.b)))
({a = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = false , b = (((\x: Unit .\y: Unit .y) false ) true) }.b) )) in (let u = (( \f: Unit .((f (let u = true in false) ) (let u = false in true) ) ) (\a: Unit .\b: Bool .b)) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in 0) )))) , b = (let u = (case <l = (((\x: Unit .\y: Rec X. X .x) 1 ) false) > as Bool of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Nat .x) ({a = true , b = 1 }.a) ) (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = true }.b) )))) , c =  (fix (\x: Rec X. X . ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = true }.a) )) }.b)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (((\x: Nat .\y: Nat .x) (let u = true in false) ) (if false then (let u = 1 in false) else true)) in (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Unit .\y: Bool .y) true ) true) else (((\x: Bool .\y: Nat .x) ({a = 1 , b = false , c =  1 }.b) ) true))) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Nat .y) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , b = (succ 1) }.a) ) ({a = ({a = 0 , b = 1 }.b) , b = (unfold [ Rec X. X ] (fold [ Bool ] false )) , c = ({a = 0 , b = false , c = 1 }.c) }.c)) ))
(let u = ({a = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (pred (succ 1)) }.b) in u)
(fix (\x: Bool . (fix (\x: Bool . (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) )) ))
(let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (if (iszero 0) then (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) in 0) else ({a = 0 , b = (fix (\x: Unit . false )) , c = 1 }.c)) )) in (let u = (unfold [ Bool ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) (iszero 1) ) (let u = true in 1)) )) in (if (let u = 1 in true) then (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) )) else (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))))
(case <r = (((\x: Rec X. X .\y: Bool .y) ({a = (unfold [ Unit ] (fold [ Nat ] true )) , b = ({a = true , b = 1 }.b) }.a) ) (case <r = ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = 1 }.b) , b = (let u = 0 in false) }.b) > as Bool of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y)
({a = (let u = ({a = (fix (\x: Rec X. X . (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .a)) )) , b = (case <l = ({a = 0 , b = true , c = 1 }.c) > as Bool of < l = x > => x | < r = y > => y) }.a) in (let u = (fix (\x: Rec X. X . (let u = true in true) )) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y))) , b = (let u = (((\x: Unit .\y: Unit .x) (let u = true in true) ) (if (((\x: Nat .\y: Nat .y) true ) true) then true else true)) in (((\x: Rec X. X .\y: Unit .x) (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f 1 ) ({a = true , b = 1 }.b) ) ) (\a: Bool .\b: Unit .b)) )) ) ({a = ({a = 0 , b = false , c = 0 }.c) , b = (let u = false in u) , c =  0 }.b))) }.a)
(((\x: Bool .\y: Bool .y) (iszero (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Unit ] (fix (\x: Nat . true )) )) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )))) ) (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Bool .((f (if true then true else true) ) (iszero 0) ) ) (\a: Rec X. X .\b: Nat .b)) )))
(( \f: Unit .((f (let u = (let u = ({a = true , b = true }.b) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = false }.b) ))) in u) ) (fix (\x: Bool . (if ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = (pred 1) }.a) then ({a = (let u = 0 in 0) , b = (((\x: Rec X. X .\y: Bool .x) true ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) , c =  (fix (\x: Nat . (((\x: Nat .\y: Nat .x) 1 ) false) )) }.b) else (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = ({a = 0 , b = 1 }.b) }.a) ))) )) ) ) (\a: Nat .\b: Unit .a))
(let u = ({a = (succ (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b))) , b = (let u = false in u) , c = (unfold [ Unit ] (fold [ Unit ] 1 )) }.c) in (((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Nat .x) (let u = (if (iszero 0) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else ({a = 1 , b = false }.b)) in u) ) ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Unit .y) true ) false) , c =  (case <l = ({a = true , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) }.b)) ) ({a = ({a = 1 , b = false }.a) , b = (((\x: Unit .\y: Bool .x) ({a = true , b = true }.b) ) (((\x: Unit .\y: Nat .x) false ) false)) , c = ({a = ({a = 0 , b = false }.b) , b = 0 }.b) }.c)))
(fix (\x: Nat . ({a = ({a = (if false then (unfold [ Bool ] (fold [ Bool ] 1 )) else 1) , b = (case <r = ({a = false , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = 0 , b = (unfold [ Unit ] (fold [ Nat ] true )) , c = 0 }.c) }.b) , b = (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Bool .x) 1 ) false) ) (let u = false in u)) }.a) ))
({a = (( \f: Nat .((f (if ({a = 0 , b = false }.b) then 0 else (if false then 1 else 1)) ) (succ (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (succ (unfold [ Bool ] (fold [ Unit ] (fix (\x: Unit . (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) )) ))) }.b)
(if ({a = (fix (\x: Nat . (((\x: Rec X. X .\y: Unit .y) true ) false) )) , b = (case <l = (let u = true in 1) > as Bool of < l = x > => x | < r = y > => y) }.a) then (let u = (((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Unit .x) 1 ) false) ) ({a = 1 , b = false , c =  1 }.b)) in ({a = (( \f: Bool .((f false ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = 1 , b = true }.a) }.a)) else (( \f: Unit .((f ({a = ({a = false , b = 1 }.b) , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ) (if false then (fix (\x: Nat . true )) else false) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(fix (\x: Unit . (( \f: Rec X. X .((f (if (((\x: Unit .\y: Nat .x) false ) true) then (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) else (let u = true in 0)) ) ({a = (let u = 1 in u) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
(( \f: Nat .((f ({a = (((\x: Unit .\y: Bool .y) true ) 1) , b = (( \f: Unit .((f ({a = 0 , b = false }.a) ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) (if (if (((\x: Nat .\y: Rec X. X .y) false ) (if true then true else true)) then (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) else (let u = true in false)) then (let u = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = 1 }.b) in u) else (let u = false in (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)))) ) ) (\a: Unit .\b: Unit .a))
(if (fix (\x: Bool . (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (fix (\x: Nat . true )) else (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b))) )) then (case <r = (if ({a = 0 , b = false , c =  1 }.b) then ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero 1) )) else ({a = false , b = 0 }.a)) > as Unit of < l = x > => x | < r = y > => y) else (case <r = ({a = false , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.a) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (( \f: Unit .((f (( \f: Bool .((f ({a = (let u = 1 in u) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.a) ) (pred 0) ) ) (\a: Bool .\b: Rec X. X .a)) ) (pred ({a = 1 , b = false }.a)) ) ) (\a: Rec X. X .\b: Unit .b)) in (((\x: Rec X. X .\y: Bool .y) (let u = (let u = (pred 1) in ({a = true , b = 0 }.a)) in (let u = 1 in true)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (if (if false then false else false) then (((\x: Rec X. X .\y: Nat .y) true ) 1) else 1) ))))
(fix (\x: Unit . (pred (succ (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)))) ))
({a = (let u = ({a = (if (((\x: Unit .\y: Bool .x) (let u = 1 in true) ) (fix (\x: Bool . false ))) then (let u = true in u) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) ))) , b = ({a = (unfold [ Unit ] (fold [ Bool ] 1 )) , b = (let u = 0 in ({a = false , b = 0 }.a)) , c = (succ (fix (\x: Nat . 0 ))) }.c) }.a) in u) , b = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) )) in (( \f: Nat .((f 0 ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Nat .b))) }.a)
(if (case <r = (fix (\x: Unit . ({a = 0 , b = false }.b) )) > as Unit of < l = x > => x | < r = y > => y) then ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 1 in false) )) , b = (pred (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) }.a) else ({a = (( \f: Rec X. X .((f ({a = (fix (\x: Nat . 0 )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , c = (if false then 1 else 0) }.c) ) (let u = (if ({a = 0 , b = true }.b) then 0 else 0) in ({a = false , b = (((\x: Nat .\y: Rec X. X .x) 0 ) false) }.b)) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) }.b) }.b))
(if (iszero (succ (let u = (((\x: Unit .\y: Unit .x) true ) true) in ({a = 1 , b = false , c = 0 }.c)))) then (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = (iszero 1) , c =  1 }.b) )) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = false , b = false }.b) , b = (fix (\x: Bool . true )) }.b) )))
({a = (let u = (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) false ) false) ) 1) in (let u = (succ 0) in ({a = 0 , b = true , c =  1 }.b))) , b = (if (((\x: Nat .\y: Unit .y) ({a = 1 , b = true }.b) ) (((\x: Nat .\y: Bool .x) (fix (\x: Bool . false )) ) true)) then (unfold [ Rec X. X ] (fold [ Unit ] false )) else (((\x: Nat .\y: Nat .x) (if true then false else true) ) (((\x: Rec X. X .\y: Bool .y) ({a = false , b = true }.b) ) (let u = true in false)))) }.b)
({a = (((\x: Unit .\y: Rec X. X .x) (let u = (if (fix (\x: Unit . true )) then 0 else ({a = 1 , b = false , c = 1 }.c)) in u) ) (fix (\x: Bool . (let u = 0 in true) ))) , b = (( \f: Rec X. X .((f ({a = (if (((\x: Unit .\y: Bool .y) true ) false) then true else (((\x: Bool .\y: Bool .x) true ) false)) , b = (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = ({a = 0 , b = true , c = 0 }.c) in 1) else (let u = true in 1)) }.a) ) ({a = (iszero 1) , b = ({a = 0 , b = 0 }.b) }.a) ) ) (\a: Unit .\b: Nat .b)) }.b)
(((\x: Nat .\y: Bool .x) (((\x: Unit .\y: Unit .x) (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) (( \f: Rec X. X .((f (let u = ({a = 1 , b = true , c =  1 }.b) in false) ) (iszero 0) ) ) (\a: Bool .\b: Unit .a))) ) (( \f: Unit .((f (( \f: Nat .((f (((\x: Bool .\y: Nat .x) true ) false) ) (((\x: Unit .\y: Nat .y) false ) false) ) ) (\a: Rec X. X .\b: Nat .a)) ) (fix (\x: Bool . ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = ({a = 1 , b = false }.b) , c =  (unfold [ Unit ] (fold [ Unit ] 0 )) }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
({a = (case <l = (pred (let u = (( \f: Unit .((f 1 ) (succ 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (fix (\x: Bool . 0 )))) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (fix (\x: Unit . ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = 0 in false) )) )) in u) }.b)
(let u = (((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Bool .x) 1 ) true) ) (fix (\x: Rec X. X . true ))) ) (iszero ({a = 0 , b = true , c = 0 }.c))) in u)
(( \f: Nat .((f ({a = (fix (\x: Nat . ({a = 0 , b = (iszero 0) , c = ({a = 0 , b = false }.a) }.c) )) , b = (case <r = (((\x: Nat .\y: Rec X. X .y) true ) true) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (if (((\x: Unit .\y: Nat .x) true ) false) then 0 else 1) }.c) ) (( \f: Rec X. X .((f (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 0 , b = true , c = 0 }.c) )) ) (let u = ({a = 0 , b = false , c =  1 }.b) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 ))) ) ) (\a: Bool .\b: Unit .b)) ) (((\x: Nat .\y: Bool .x) (fix (\x: Unit . (let u = 0 in u) )) ) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in true)) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(case <r = (let u = (fix (\x: Bool . (if (fix (\x: Bool . false )) then (unfold [ Unit ] (fold [ Rec X. X ] true )) else (let u = (((\x: Rec X. X .\y: Nat .y) false ) 1) in (((\x: Nat .\y: Rec X. X .y) false ) false))) )) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (case <r = ({a = 0 , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) ))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) ) (iszero (let u = (succ 1) in u)) ) ) (\a: Nat .\b: Bool .a)) ) (if ({a = (( \f: Bool .((f false ) (fix (\x: Rec X. X . false )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = false , b = 1 }.a) }.b) then (((\x: Bool .\y: Bool .y) (fix (\x: Unit . (fix (\x: Nat . true )) )) ) ({a = ({a = true , b = 1 }.b) , b = 0 }.b)) else (let u = ({a = (let u = false in u) , b = 1 }.a) in ({a = ({a = false , b = false }.b) , b = 1 }.b))))
({a = (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Rec X. X .x) ({a = (if false then false else true) , b = true }.b) ) (iszero 1)) ) (((\x: Unit .\y: Bool .y) false ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)))) , b = (( \f: Bool .((f (((\x: Unit .\y: Unit .x) ({a = 1 , b = true , c = 1 }.c) ) (let u = false in u)) ) (if false then 1 else 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
(let u = ({a = (((\x: Nat .\y: Rec X. X .x) (if true then (fix (\x: Bool . 0 )) else 0) ) ({a = 1 , b = true }.b)) , b = (((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Unit .y) false ) true) ) ({a = true , b = 0 }.a)) , c = (( \f: Rec X. X .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) 0 ) ) (\a: Bool .\b: Nat .b)) }.c) in u)
(iszero ({a = (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in 0) , b = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = (((\x: Rec X. X .\y: Unit .y) (if false then true else true) ) ({a = false , b = true }.b)) , c = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.c) }.b))
(((\x: Unit .\y: Nat .y) (( \f: Unit .((f (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = false , b = ({a = true , b = true }.b) }.b) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Nat .\b: Unit .a)) ) (((\x: Unit .\y: Unit .x) (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Rec X. X .x) true ) ({a = 0 , b = true , c =  0 }.b)) ) (((\x: Unit .\y: Bool .y) true ) 0)) ) (let u = (fix (\x: Nat . 1 )) in u) ) ) (\a: Nat .\b: Bool .a)) ) (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in ({a = 0 , b = false }.b))))
(((\x: Rec X. X .\y: Bool .y) ({a = (fix (\x: Bool . ({a = (let u = 0 in u) , b = (pred 1) }.b) )) , b = (( \f: Unit .((f (( \f: Bool .((f true ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (( \f: Nat .((f (let u = 1 in true) ) false ) ) (\a: Unit .\b: Nat .a)) , b = (fix (\x: Nat . true )) }.b) ) ) (\a: Nat .\b: Unit .a)) }.b) ) (( \f: Rec X. X .((f ({a = ({a = false , b = 1 }.b) , b = (let u = false in false) }.a) ) ({a = ({a = 1 , b = false }.a) , b = ({a = false , b = 1 }.b) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(iszero (((\x: Bool .\y: Bool .x) (( \f: Rec X. X .((f (pred 0) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) ) (if (unfold [ Nat ] (fold [ Unit ] true )) then false else ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )))))
(let u = (pred ({a = ({a = true , b = ({a = 1 , b = true }.a) }.a) , b = (case <l = (pred 1) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) in (( \f: Unit .((f (if (fix (\x: Rec X. X . ({a = 0 , b = false }.b) )) then ({a = (let u = 1 in u) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.b) else (((\x: Nat .\y: Unit .x) false ) (if false then false else true))) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = (((\x: Unit .\y: Nat .x) true ) false) , c =  (pred 1) }.b) ) ) (\a: Unit .\b: Unit .a)))
(let u = (((\x: Rec X. X .\y: Bool .y) (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 ))) ) (if (((\x: Bool .\y: Unit .x) true ) true) then (iszero 0) else (let u = 0 in false))) in (if (((\x: Nat .\y: Nat .y) (let u = true in true) ) true) then (fix (\x: Nat . (let u = 0 in u) )) else ({a = (succ (((\x: Nat .\y: Rec X. X .x) 1 ) true)) , b = (let u = (fix (\x: Rec X. X . 0 )) in ({a = false , b = 1 }.a)) , c = (succ 1) }.c)))
({a = (( \f: Nat .((f ({a = (let u = (let u = true in true) in ({a = 0 , b = false }.b)) , b = ({a = ({a = 1 , b = true , c = 1 }.c) , b = true , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) }.c) }.b) ) (( \f: Bool .((f (case <l = (let u = 0 in u) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f 0 ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = (if false then false else (fix (\x: Rec X. X . false ))) in u) , c =  ({a = (succ (succ 0)) , b = (let u = (let u = 1 in true) in (let u = (let u = 1 in false) in u)) , c = (( \f: Nat .((f ({a = 1 , b = false }.a) ) (((\x: Bool .\y: Bool .x) 1 ) false) ) ) (\a: Rec X. X .\b: Nat .a)) }.c) }.b)
(((\x: Bool .\y: Bool .y) (case <r = (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) ))) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Unit ] (case <l = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) in 0) > as Nat of < l = x > => x | < r = y > => y) )))
(iszero (if (let u = (let u = false in true) in u) then (( \f: Nat .((f (succ 1) ) ({a = (succ 0) , b = ({a = false , b = 0 }.b) }.b) ) ) (\a: Bool .\b: Nat .a)) else (((\x: Nat .\y: Rec X. X .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .x) false ) true) )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )))))
(( \f: Nat .((f (( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = true }.a) )) ) ({a = 0 , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ) (fix (\x: Nat . (((\x: Nat .\y: Unit .y) ({a = 1 , b = false , c =  0 }.b) ) (pred 0)) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(let u = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Bool .x) ({a = false , b = true }.b) ) ({a = 1 , b = false , c =  1 }.b)) ) (( \f: Nat .((f (let u = (let u = 1 in false) in u) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b))) in u)
(((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Unit .x) 1 ) true) , b = (let u = false in false) , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.b) ) ) (\a: Bool .\b: Nat .a)) ) ({a = (((\x: Nat .\y: Nat .x) (let u = 0 in false) ) (iszero (if (unfold [ Unit ] (fold [ Unit ] false )) then 1 else 1))) , b = ({a = (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Rec X. X .x) (if false then 1 else 1) ) (let u = true in false)) ) (unfold [ Bool ] (fold [ Bool ] false ))) , b = (( \f: Bool .((f (let u = 1 in true) ) (let u = ({a = false , b = 1 }.a) in (iszero 1)) ) ) (\a: Rec X. X .\b: Unit .a)) }.a) }.a))
(let u = (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) true) , b = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) }.a) in (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f 1 ) (if true then 0 else 1) ) ) (\a: Unit .\b: Unit .b)) ))) in (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) ) (let u = false in 0)) ) (let u = (unfold [ Nat ] (fold [ Unit ] false )) in (let u = 1 in false))))
(((\x: Nat .\y: Rec X. X .y) ({a = ({a = 0 , b = false , c = (if true then 1 else 1) }.c) , b = ({a = ({a = 1 , b = false , c = 1 }.c) , b = (let u = 0 in false) }.b) , c =  (((\x: Nat .\y: Rec X. X .y) false ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 ))) }.b) ) (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) false ) false) ) (if (let u = true in false) then (if true then false else ({a = false , b = 1 }.a)) else (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) in u)) ) ) (\a: Bool .\b: Nat .a)))
(let u = ({a = ({a = 1 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (let u = (((\x: Nat .\y: Rec X. X .x) 1 ) false) in u) }.a) in (iszero (((\x: Bool .\y: Rec X. X .y) ({a = ({a = true , b = false }.b) , b = 1 }.a) ) (( \f: Rec X. X .((f 1 ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) ) ) (\a: Nat .\b: Bool .a)))))
(fix (\x: Rec X. X . ({a = (case <l = (fix (\x: Rec X. X . 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f ({a = true , b = 0 }.a) ) (((\x: Unit .\y: Nat .y) false ) true) ) ) (\a: Bool .\b: Bool .a)) , c =  (((\x: Rec X. X .\y: Bool .y) ({a = (fix (\x: Unit . true )) , b = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.a) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) ))
(let u = (pred ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 1 in u) }.b)) in (case <r = (( \f: Bool .((f (let u = true in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) ({a = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (( \f: Nat .((f (pred (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a))) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u)
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f ({a = (let u = ({a = false , b = 0 }.b) in ({a = false , b = 0 }.a)) , b = (let u = false in u) }.b) ) (((\x: Rec X. X .\y: Bool .x) ({a = true , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.b) ) (( \f: Nat .((f false ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Unit .b)) ))
({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) ({a = 0 , b = true , c =  0 }.b) ) (((\x: Nat .\y: Unit .y) true ) 1)) )) in ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = ({a = 0 , b = false }.b) }.a) ))) , b = ({a = (let u = ({a = true , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) in u) , b = (let u = (if true then true else true) in u) , c =  (let u = (fix (\x: Unit . (pred 1) )) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = true in 0) ))) }.b) , c =  (( \f: Rec X. X .((f ({a = (iszero 1) , b = (pred 1) }.b) ) (let u = false in 1) ) ) (\a: Unit .\b: Unit .b)) }.b)
(let u = (((\x: Unit .\y: Unit .y) (let u = true in u) ) (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .y) false ) false) ))) in (case <l = (let u = (pred (let u = (pred 1) in (fix (\x: Rec X. X . 1 )))) in ({a = 1 , b = false , c = 0 }.c)) > as Nat of < l = x > => x | < r = y > => y))
({a = (((\x: Unit .\y: Nat .y) ({a = (iszero 1) , b = (unfold [ Unit ] (fold [ Bool ] true )) }.b) ) (if false then 0 else 1)) , b = (let u = ({a = (let u = false in u) , b = (( \f: Nat .((f (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .b)) ) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) in u) }.a)
(let u = ({a = (((\x: Nat .\y: Rec X. X .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) )) ) ({a = 0 , b = true , c =  0 }.b)) , b = ({a = (fix (\x: Rec X. X . ({a = 1 , b = false }.a) )) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c =  (((\x: Rec X. X .\y: Bool .y) true ) 1) }.b) }.b) in u)
(((\x: Bool .\y: Unit .x) (if (unfold [ Rec X. X ] (fold [ Unit ] (let u = true in u) )) then (unfold [ Rec X. X ] (fold [ Bool ] (let u = false in true) )) else (iszero (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)))) ) (((\x: Rec X. X .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in (((\x: Nat .\y: Nat .x) true ) false)) )) ) ({a = (fix (\x: Bool . false )) , b = ({a = false , b = 0 }.b) }.a)))
(unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f (let u = ({a = (((\x: Rec X. X .\y: Bool .y) true ) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .a))) , b = (iszero 1) }.b) in (iszero ({a = true , b = 0 }.b))) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = true }.b) )) ) ) (\a: Nat .\b: Unit .a)) ))
({a = (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Bool .x) ({a = false , b = 0 }.a) ) (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Nat ] false )) ))) ) (((\x: Nat .\y: Unit .x) true ) false)) , b = ({a = (succ (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) , b = (let u = (let u = false in false) in false) }.a) }.a)
(((\x: Nat .\y: Rec X. X .y) (let u = ({a = ({a = 1 , b = true , c =  1 }.b) , b = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u) }.a) in u) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero ({a = 1 , b = false }.a)) )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (iszero (succ 0)) )) }.b))
(((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = 0 , b = 0 }.b) in (let u = 1 in u)) ) (((\x: Unit .\y: Unit .x) (fix (\x: Unit . (iszero 0) )) ) ({a = (unfold [ Rec X. X ] (fold [ Bool ] false )) , b = (let u = true in u) }.b))) ) (let u = (let u = (((\x: Unit .\y: Rec X. X .x) true ) true) in (let u = (let u = true in u) in ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )))) in (iszero (((\x: Rec X. X .\y: Unit .x) 0 ) false))))
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (succ (((\x: Bool .\y: Rec X. X .x) 0 ) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .a)))) ))
({a = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .y) false ) false) )) ) ({a = (((\x: Nat .\y: Rec X. X .x) false ) (unfold [ Bool ] (fold [ Bool ] false ))) , b = (if (let u = false in u) then (let u = false in u) else (unfold [ Nat ] (fold [ Unit ] true ))) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = (case <l = ({a = false , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) in (succ 0)) )) }.a)
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = 1 in u) , b = (unfold [ Bool ] (fold [ Nat ] true )) }.b) )) , b = ({a = (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = false , b = true }.b) )) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b))) ) (fix (\x: Nat . 0 )) ) ) (\a: Nat .\b: Bool .a)) }.b) }.a)
({a = (let u = ({a = (((\x: Bool .\y: Bool .y) true ) 0) , b = (let u = 0 in true) }.a) in (((\x: Rec X. X .\y: Unit .x) (let u = true in u) ) (((\x: Nat .\y: Bool .x) false ) true))) , b = (( \f: Bool .((f (iszero (succ (let u = true in 1))) ) (( \f: Nat .((f ({a = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) , b = ({a = true , b = 0 }.b) }.a) ) ({a = false , b = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .a)) }.b)
({a = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (fix (\x: Nat . (( \f: Bool .((f false ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Bool .\b: Bool .a)) )) }.a) , b = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Nat . ({a = 0 , b = false , c =  1 }.b) )) ) ({a = true , b = ({a = 0 , b = 0 }.b) }.a)) , c =  (( \f: Nat .((f (case <l = (case <l = (pred ({a = 0 , b = false }.a)) > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) (case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = true }.b) )) in ({a = 1 , b = ({a = 0 , b = true }.b) , c = ({a = true , b = 0 }.b) }.c)) ))
({a = (( \f: Rec X. X .((f ({a = (let u = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)) in 1) , b = (iszero 0) }.a) ) (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = (let u = true in u) , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.c) ) ({a = (let u = false in true) , b = ({a = 1 , b = true }.a) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (if (let u = ({a = 0 , b = true , c = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.c) in (iszero 1)) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .y) true ) true) )) else (((\x: Bool .\y: Rec X. X .x) (( \f: Bool .((f (((\x: Nat .\y: Unit .y) false ) false) ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) (fix (\x: Unit . false )))) , c =  (pred (let u = ({a = true , b = (fix (\x: Nat . false )) }.b) in ({a = 1 , b = true , c = 1 }.c))) }.b)
({a = (( \f: Rec X. X .((f (let u = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) in (succ 1)) ) ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) ) (\a: Nat .\b: Bool .b)) , b = ({a = (((\x: Unit .\y: Bool .x) true ) (iszero 0)) , b = (( \f: Nat .((f (fix (\x: Bool . false )) ) (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) )) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) }.a)
(((\x: Rec X. X .\y: Bool .x) (fix (\x: Nat . (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Bool .x) false ) ({a = false , b = 1 }.a)) ) (( \f: Nat .((f 1 ) (pred 0) ) ) (\a: Nat .\b: Nat .a))) )) ) (fix (\x: Unit . (((\x: Unit .\y: Nat .x) ({a = (((\x: Nat .\y: Nat .y) false ) true) , b = ({a = 1 , b = false , c = 1 }.c) }.a) ) (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .y) true ) false) ))) )))
({a = ({a = (case <l = (fix (\x: Unit . 1 )) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) }.b) , b = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ({a = false , b = 0 }.a) )) }.b) }.b)
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if (((\x: Nat .\y: Nat .y) false ) true) then (if (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) then false else true) else (let u = true in u)) )) , b = (( \f: Nat .((f ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .b)) , b = 1 }.b) ) (( \f: Nat .((f (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (unfold [ Unit ] (fold [ Nat ] 0 )) else 0) ) ({a = true , b = 0 }.b) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .a)) }.a)
(iszero ({a = (if ({a = false , b = 0 }.a) then (let u = true in u) else (( \f: Unit .((f (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Bool .a))) , b = (case <l = (pred 0) > as Unit of < l = x > => x | < r = y > => y) }.b))
(iszero (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] 1 )) ) (succ (let u = true in 1)) ) ) (\a: Nat .\b: Rec X. X .a)))
(let u = (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) 0 ) (((\x: Bool .\y: Bool .x) true ) false)) ) ({a = ({a = (pred 1) , b = true , c = 0 }.c) , b = (fix (\x: Unit . (((\x: Bool .\y: Rec X. X .x) false ) true) )) }.a) ) ) (\a: Rec X. X .\b: Bool .a)) in u)
(succ (((\x: Bool .\y: Bool .y) (let u = (if false then 0 else 0) in ({a = 1 , b = (((\x: Rec X. X .\y: Unit .y) true ) false) , c =  (pred 1) }.b)) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = true , c =  (let u = 1 in 1) }.b) ) (case <l = (((\x: Unit .\y: Nat .y) true ) 0) > as Rec X. X of < l = x > => x | < r = y > => y))))
(let u = ({a = (fix (\x: Bool . (unfold [ Unit ] (fold [ Unit ] 1 )) )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (if true then false else true) )) , c = (unfold [ Unit ] (fold [ Bool ] (pred 0) )) }.c) in (let u = (pred (if false then (unfold [ Unit ] (fold [ Nat ] 0 )) else 0)) in (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = false , b = 1 }.b) )) in (if false then (pred 1) else 0))))
(((\x: Bool .\y: Bool .x) ({a = (if (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) then ({a = (let u = 1 in u) , b = false , c =  (if true then 0 else 1) }.b) else (let u = true in u)) , b = (fix (\x: Unit . (pred ({a = 0 , b = (let u = false in true) , c = ({a = 0 , b = 1 }.b) }.c)) )) }.b) ) (( \f: Unit .((f ({a = ({a = (((\x: Bool .\y: Unit .y) true ) false) , b = 0 }.a) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.a) ) ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = (let u = false in true) }.b) ) ) (\a: Unit .\b: Nat .a)))
(if ({a = (( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.b) )) ) ({a = (let u = false in 0) , b = (let u = 0 in true) }.a) ) ) (\a: Nat .\b: Nat .a)) , b = ({a = (if ({a = 1 , b = true }.b) then ({a = true , b = 0 }.a) else (let u = false in u)) , b = ({a = 0 , b = (iszero 0) , c =  (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.b) }.b) , c =  (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = 0 }.b) )) }.b) then (((\x: Unit .\y: Unit .y) (let u = ({a = (let u = false in u) , b = (((\x: Rec X. X .\y: Unit .x) false ) false) }.b) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = ({a = false , b = 1 }.a) , c =  0 }.b) ))) ) (iszero ({a = 0 , b = (unfold [ Nat ] (fold [ Unit ] false )) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c))) else (fix (\x: Unit . (let u = ({a = ({a = 0 , b = false }.a) , b = (let u = true in false) , c =  1 }.b) in (iszero 1)) )))
(case <l = (fix (\x: Unit . (if ({a = false , b = 1 }.a) then ({a = 0 , b = (if true then false else false) }.a) else ({a = false , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Bool ] (if (( \f: Bool .((f ({a = (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b))) , b = (let u = true in false) }.b) ) (let u = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , b = 1 }.b) in ({a = false , b = true }.b)) ) ) (\a: Unit .\b: Unit .a)) then (let u = (((\x: Unit .\y: Rec X. X .x) 0 ) ({a = 1 , b = true }.b)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ))) else (( \f: Rec X. X .((f (succ ({a = false , b = 1 }.b)) ) (let u = (if false then true else false) in ({a = false , b = 0 }.b)) ) ) (\a: Nat .\b: Unit .a))) ))
(( \f: Rec X. X .((f ({a = (unfold [ Unit ] (fold [ Nat ] false )) , b = (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = true }.a) )) }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (fix (\x: Nat . 0 )) , b = (case <r = ({a = true , b = 0 }.a) > as Unit of < l = x > => x | < r = y > => y) , c = (((\x: Bool .\y: Nat .x) 0 ) false) }.c) )) ) ) (\a: Rec X. X .\b: Unit .a))
(unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) ({a = (( \f: Nat .((f 0 ) (let u = 0 in 0) ) ) (\a: Unit .\b: Unit .a)) , b = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) , c =  ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b)) , b = (pred 0) }.b) }.b) ) (let u = (((\x: Unit .\y: Bool .y) false ) false) in u)) ))
(( \f: Rec X. X .((f (let u = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Nat .x) (unfold [ Bool ] (fold [ Bool ] 0 )) ) true) }.b) in (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .a)) ) (((\x: Rec X. X .\y: Bool .x) false ) (let u = 1 in false))) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Nat .b))) ) (( \f: Nat .((f (let u = ({a = 0 , b = true , c = 0 }.c) in (if false then false else false)) ) (( \f: Nat .((f (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) ) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .a))
(succ ({a = (fix (\x: Rec X. X . ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) )) , b = ({a = false , b = (iszero 1) }.b) }.a))
(pred (succ (unfold [ Unit ] (fold [ Bool ] 1 ))))
(( \f: Nat .((f (let u = (succ 1) in (((\x: Nat .\y: Nat .y) (let u = 1 in false) ) (if false then true else false))) ) (let u = (let u = ({a = (((\x: Bool .\y: Bool .x) 1 ) true) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .a)) , c =  0 }.b) in u) in (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) in (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)))) ) ) (\a: Nat .\b: Nat .b))
(if (unfold [ Rec X. X ] (fold [ Unit ] (let u = ({a = false , b = false }.b) in (unfold [ Nat ] (fold [ Rec X. X ] false ))) )) then (let u = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Bool .x) true ) true) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ))) else (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Bool .y) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) false) ) (let u = true in (let u = 1 in false))))
(pred (( \f: Nat .((f (( \f: Rec X. X .((f ({a = 1 , b = 1 }.b) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Unit .\b: Nat .a)) ) (if (if false then false else true) then ({a = 1 , b = 1 }.b) else (if ({a = 0 , b = true }.b) then 0 else (let u = true in 1))) ) ) (\a: Nat .\b: Rec X. X .b)))
(let u = ({a = (((\x: Bool .\y: Unit .y) ({a = true , b = 1 }.a) ) (if false then 1 else 1)) , b = (fix (\x: Bool . true )) , c = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Bool ] 1 )) )) }.c) in (((\x: Bool .\y: Bool .x) ({a = ({a = ({a = 0 , b = false , c = 1 }.c) , b = (let u = false in false) }.a) , b = (fix (\x: Bool . (let u = false in false) )) }.b) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = (iszero 0) , c =  1 }.b) , c =  (if (let u = false in u) then ({a = (((\x: Bool .\y: Nat .y) false ) 1) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c = 0 }.c) else (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) }.b)))
({a = (( \f: Bool .((f (((\x: Nat .\y: Bool .x) 1 ) true) ) (((\x: Rec X. X .\y: Nat .y) ({a = 1 , b = false , c =  0 }.b) ) 0) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Nat .((f (iszero ({a = 0 , b = false }.a)) ) (fix (\x: Unit . (let u = (((\x: Bool .\y: Nat .x) false ) true) in (((\x: Rec X. X .\y: Nat .y) false ) false)) )) ) ) (\a: Unit .\b: Unit .a)) }.a)
({a = (((\x: Unit .\y: Nat .x) (if (((\x: Unit .\y: Rec X. X .y) (let u = true in u) ) ({a = false , b = 0 }.a)) then ({a = (( \f: Unit .((f ({a = 1 , b = true }.a) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = true , b = true }.b) }.a) else (let u = (if false then false else false) in ({a = 0 , b = false , c = 0 }.c))) ) (( \f: Unit .((f ({a = true , b = false }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b))) , b = ({a = (((\x: Unit .\y: Nat .x) ({a = false , b = 1 }.a) ) (let u = false in u)) , b = (( \f: Unit .((f true ) (let u = 1 in true) ) ) (\a: Nat .\b: Unit .b)) }.b) }.b)
(iszero ({a = (((\x: Unit .\y: Unit .y) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .b)) ) (let u = true in false)) , b = (let u = ({a = 0 , b = (fix (\x: Rec X. X . true )) }.a) in u) }.b))
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (( \f: Bool .((f ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (let u = true in false) }.b) ) (iszero 1) ) ) (\a: Nat .\b: Nat .a)) , b = (pred (let u = 0 in u)) }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (iszero (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) )))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (if false then (unfold [ Unit ] (fold [ Unit ] 0 )) else 1) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) ))
(unfold [ Unit ] (fold [ Rec X. X ] (if (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .b)) in ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) then (iszero ({a = 0 , b = false }.a)) else (((\x: Rec X. X .\y: Bool .y) (iszero 0) ) (iszero (let u = 1 in u)))) ))
(if (case <r = ({a = (pred 1) , b = (( \f: Bool .((f false ) (fix (\x: Rec X. X . false )) ) ) (\a: Rec X. X .\b: Nat .a)) , c =  (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) then (iszero (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in (( \f: Bool .((f 0 ) (succ 0) ) ) (\a: Unit .\b: Unit .a)))) else (let u = (iszero ({a = 0 , b = 0 }.b)) in u))
(let u = (iszero ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) ({a = (((\x: Bool .\y: Nat .y) false ) 1) , b = false }.a) ) ({a = 1 , b = true }.b)) ))) in (let u = (( \f: Bool .((f (fix (\x: Rec X. X . (if false then (fix (\x: Bool . 0 )) else 1) )) ) (((\x: Bool .\y: Unit .x) (succ 0) ) (if (fix (\x: Rec X. X . false )) then ({a = 1 , b = false }.b) else (let u = 1 in true))) ) ) (\a: Nat .\b: Rec X. X .a)) in u))
(fix (\x: Bool . (let u = ({a = (iszero (let u = 1 in 1)) , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) }.b) in (let u = (let u = 1 in (iszero 0)) in u)) ))
({a = (let u = (succ (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .y) true ) 0) ) (fix (\x: Nat . 1 )) ) ) (\a: Nat .\b: Bool .b))) in u) , b = (( \f: Rec X. X .((f (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .y) true ) 1) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] (((\x: Bool .\y: Unit .y) true ) 1) )) )) ) ) (\a: Unit .\b: Bool .a)) ) (let u = ({a = (pred 1) , b = (fix (\x: Rec X. X . (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b)) )) }.a) in u) ) ) (\a: Unit .\b: Bool .b)) }.b)
({a = (fix (\x: Rec X. X . (fix (\x: Nat . 1 )) )) , b = ({a = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (iszero 0) }.a) , b = ({a = (fix (\x: Rec X. X . 0 )) , b = (let u = true in true) , c =  (((\x: Nat .\y: Rec X. X .x) 0 ) true) }.b) , c =  ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) }.b) }.b)
(if ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = 1 in true) )) then ({a = (((\x: Nat .\y: Nat .x) (let u = 0 in 0) ) ({a = ({a = true , b = 0 }.a) , b = ({a = 0 , b = true }.a) }.a)) , b = ({a = (fix (\x: Nat . 0 )) , b = ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = 0 }.a) , c =  (unfold [ Bool ] (fold [ Rec X. X ] 1 )) }.b) }.b) else (fix (\x: Nat . (if ({a = 0 , b = (iszero 0) }.b) then (fix (\x: Nat . true )) else (case <r = false > as Bool of < l = x > => x | < r = y > => y)) )))
({a = (( \f: Rec X. X .((f (case <l = ({a = (( \f: Rec X. X .((f 0 ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .b)) , b = (((\x: Unit .\y: Bool .y) true ) false) , c = ({a = false , b = 1 }.b) }.c) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Unit .y) ({a = (let u = false in false) , b = false }.b) ) ({a = 0 , b = (iszero 1) }.a)) ) ) (\a: Unit .\b: Bool .a)) , b = (( \f: Nat .((f ({a = (((\x: Unit .\y: Rec X. X .x) false ) true) , b = ({a = 0 , b = 0 }.b) }.a) ) (if ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) )) then ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .b)) , b = (fix (\x: Bool . 0 )) }.a) else (((\x: Nat .\y: Rec X. X .y) ({a = true , b = true }.b) ) (unfold [ Bool ] (fold [ Rec X. X ] true )))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
(unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Bool . (((\x: Bool .\y: Unit .x) ({a = 0 , b = true }.a) ) (((\x: Unit .\y: Unit .y) false ) false)) )) ))
(( \f: Bool .((f ({a = (fix (\x: Nat . ({a = 1 , b = true }.b) )) , b = (succ (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b))) }.a) ) (iszero (pred (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = false }.a) )))) ) ) (\a: Rec X. X .\b: Unit .a))
(fix (\x: Unit . (if (((\x: Rec X. X .\y: Unit .x) (let u = 0 in true) ) false) then ({a = ({a = false , b = 0 }.b) , b = (unfold [ Unit ] (fold [ Unit ] 0 )) }.b) else (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a))) ))
(unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f (let u = (fix (\x: Bool . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) )) in u) ) (let u = (let u = true in false) in (((\x: Bool .\y: Nat .y) false ) 0)) ) ) (\a: Nat .\b: Bool .b)) ))
(if (((\x: Nat .\y: Bool .x) (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] true )) ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) ) (iszero (((\x: Bool .\y: Nat .y) false ) 0))) then ({a = ({a = 0 , b = ({a = 0 , b = true , c =  0 }.b) }.a) , b = ({a = ({a = false , b = 1 }.a) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) , c =  (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) }.b) else (((\x: Unit .\y: Nat .x) (let u = false in (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b))) ) (case <r = ({a = 0 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y)))
(succ (( \f: Nat .((f (fix (\x: Nat . (unfold [ Bool ] (fold [ Nat ] 1 )) )) ) (if (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in false) )) then (fix (\x: Unit . 0 )) else ({a = 1 , b = false , c = 1 }.c)) ) ) (\a: Unit .\b: Rec X. X .a)))
(let u = (iszero (((\x: Unit .\y: Bool .y) false ) 0)) in u)
(( \f: Bool .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = (case <l = ({a = 0 , b = true , c = 0 }.c) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) }.a) )) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Nat .y) false ) false) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) false ) 0) ))) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (((\x: Unit .\y: Nat .x) (( \f: Unit .((f (let u = 0 in u) ) (if true then 0 else 0) ) ) (\a: Bool .\b: Rec X. X .b)) ) (if (((\x: Rec X. X .\y: Unit .y) true ) true) then (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) else (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)))) in u)
(case <r = (((\x: Nat .\y: Bool .y) (case <r = (((\x: Rec X. X .\y: Nat .x) false ) true) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Unit ] (fold [ Bool ] 1 )) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a)) }.b)) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) )) , b = ({a = (let u = true in u) , b = (iszero 0) }.b) , c =  (case <l = (let u = true in 0) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = 0 in 0) )) ) (if ({a = (pred 0) , b = false , c =  (let u = 0 in u) }.b) then ({a = (((\x: Unit .\y: Nat .y) false ) false) , b = (pred 1) }.b) else ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) ) ) (\a: Bool .\b: Nat .a)) }.b)
(( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .a)) in u) )) ) (((\x: Nat .\y: Unit .y) (let u = 1 in (((\x: Bool .\y: Bool .y) false ) true)) ) (let u = (((\x: Bool .\y: Unit .y) true ) 1) in (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .a)))) ) ) (\a: Unit .\b: Nat .b))
(fix (\x: Rec X. X . (if ({a = (let u = (let u = 1 in u) in u) , b = ({a = (let u = true in false) , b = false }.b) }.b) then (fix (\x: Bool . (if (let u = 0 in true) then false else ({a = true , b = false }.b)) )) else (( \f: Bool .((f (fix (\x: Unit . (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) )) ) (case <r = (let u = ({a = true , b = false }.b) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a))) ))
(( \f: Unit .((f (if ({a = (if (let u = true in u) then true else (fix (\x: Rec X. X . false ))) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) }.b) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in ({a = true , b = 0 }.b)) )) else ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = (unfold [ Rec X. X ] (fold [ Unit ] (iszero 1) )) }.a)) ) (if (let u = ({a = true , b = false }.b) in u) then (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) )) else (succ (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) false ) 0) )))) ) ) (\a: Rec X. X .\b: Unit .a))
(pred (( \f: Rec X. X .((f (fix (\x: Unit . (((\x: Bool .\y: Nat .y) ({a = true , b = (pred 0) }.a) ) (((\x: Bool .\y: Bool .y) true ) 1)) )) ) (pred (let u = true in 1)) ) ) (\a: Nat .\b: Bool .a)))
(case <r = (let u = ({a = ({a = (((\x: Nat .\y: Unit .y) true ) 0) , b = false }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.a) in u) > as Bool of < l = x > => x | < r = y > => y)
(iszero (pred (((\x: Unit .\y: Rec X. X .y) (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Nat .\y: Bool .x) (iszero 0) ) true) else (((\x: Unit .\y: Rec X. X .x) false ) false)) ) (let u = ({a = 1 , b = 1 }.b) in (succ 1)))))
(unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f ({a = (let u = (((\x: Nat .\y: Nat .x) 0 ) false) in (unfold [ Bool ] (fold [ Nat ] true ))) , b = (((\x: Unit .\y: Unit .x) (let u = 1 in u) ) true) }.a) ) (if ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = false }.b) then (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) else (let u = (let u = true in true) in u)) ) ) (\a: Bool .\b: Rec X. X .a)) ))
(if ({a = (let u = ({a = (iszero 0) , b = (((\x: Rec X. X .\y: Unit .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) (let u = 0 in true)) }.a) in ({a = (let u = 0 in u) , b = (unfold [ Unit ] (fold [ Unit ] 1 )) }.b)) , b = (unfold [ Bool ] (fold [ Bool ] ({a = (let u = (fix (\x: Nat . 1 )) in true) , b = ({a = 0 , b = false , c =  1 }.b) }.b) )) , c =  (((\x: Unit .\y: Bool .y) (let u = (((\x: Nat .\y: Rec X. X .y) false ) true) in u) ) (((\x: Rec X. X .\y: Bool .y) (let u = true in false) ) ({a = 1 , b = false , c = 0 }.c))) }.b) then (( \f: Nat .((f (( \f: Nat .((f ({a = false , b = 1 }.a) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Bool .\y: Bool .y) false ) true) )) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Nat .x) ({a = true , b = 1 }.a) ) (let u = false in u)) ) ) (\a: Bool .\b: Bool .b)) else (if ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Nat .y) false ) false) )) , b = (iszero 1) }.b) then (let u = ({a = (let u = 1 in u) , b = true }.a) in (let u = false in u)) else (((\x: Unit .\y: Nat .x) (case <r = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = true , b = 1 }.a) )) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (fix (\x: Nat . true )) , b = true }.b))))
(((\x: Rec X. X .\y: Unit .y) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) )) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) ) (iszero ({a = 1 , b = (iszero 1) }.a)))
(succ ({a = (pred 0) , b = (iszero (pred 1)) , c = (((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Bool .x) true ) false) ) (if true then 1 else 1)) }.c))
(let u = ({a = ({a = (((\x: Nat .\y: Bool .x) 1 ) true) , b = (if true then false else false) , c =  ({a = 1 , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b) }.b) , b = (let u = ({a = (fix (\x: Rec X. X . false )) , b = (let u = false in false) }.b) in u) }.b) in u)
({a = ({a = (( \f: Nat .((f (iszero 1) ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = (case <l = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) (((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Bool ] false )) ) (iszero 0))) )) , c = (case <l = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) (succ 0) ) ) (\a: Rec X. X .\b: Bool .b)) )) )) > as Bool of < l = x > => x | < r = y > => y) }.c)
(let u = (let u = ({a = (let u = ({a = true , b = true }.b) in u) , b = (pred (unfold [ Nat ] (fold [ Nat ] 1 ))) }.a) in u) in u)
(iszero (let u = (fix (\x: Bool . (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) )) in u))
(let u = (( \f: Nat .((f (if (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) then (case <l = (((\x: Rec X. X .\y: Nat .y) false ) 1) > as Unit of < l = x > => x | < r = y > => y) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) ) (( \f: Nat .((f ({a = true , b = (let u = 0 in 0) }.b) ) (let u = 0 in u) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Nat .\b: Rec X. X .b)) in u)
(let u = (let u = (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Bool ] 1 )) )) )) in (((\x: Rec X. X .\y: Unit .y) (unfold [ Bool ] (fold [ Bool ] (iszero 1) )) ) (let u = (((\x: Bool .\y: Nat .y) false ) (unfold [ Nat ] (fold [ Bool ] false ))) in (((\x: Bool .\y: Bool .y) false ) 0)))) in u)
(unfold [ Bool ] (fold [ Rec X. X ] (if (let u = (( \f: Unit .((f (((\x: Nat .\y: Unit .y) false ) 1) ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Unit .b)) in (let u = (unfold [ Unit ] (fold [ Rec X. X ] true )) in ({a = 1 , b = true }.b))) then ({a = (((\x: Unit .\y: Rec X. X .y) true ) false) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 1 in u) )) }.b) else (succ ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = 1 }.b))) ))
({a = (case <l = (case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f ({a = ({a = (succ 1) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) (iszero ({a = 0 , b = false , c = 1 }.c)) ) ) (\a: Bool .\b: Unit .b)) ) (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) false ) (unfold [ Nat ] (fold [ Unit ] false ))) )) in (((\x: Rec X. X .\y: Rec X. X .y) (let u = 0 in true) ) (((\x: Nat .\y: Nat .x) true ) true)))) }.b)
(((\x: Rec X. X .\y: Unit .x) (unfold [ Unit ] (fold [ Rec X. X ] (let u = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .y) true ) false) )) in u) )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero (let u = (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = false , c = 0 }.c) ) (let u = 1 in true)) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) )))
(iszero (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Nat .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) true) ) ({a = ({a = 1 , b = true , c = 0 }.c) , b = false }.a)) )))
(succ (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)))
(if (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Bool ] false )) )) in (( \f: Bool .((f false ) ({a = 1 , b = true }.b) ) ) (\a: Rec X. X .\b: Unit .a))) then (case <r = (( \f: Rec X. X .((f (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) in true) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) ) (\a: Unit .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) else (( \f: Nat .((f ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) true) , b = (((\x: Rec X. X .\y: Nat .y) (let u = true in u) ) false) }.b) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = 1 }.a) ) ) (\a: Nat .\b: Rec X. X .a)))
(let u = (((\x: Rec X. X .\y: Bool .x) (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) (iszero ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.b))) in (( \f: Unit .((f ({a = (((\x: Bool .\y: Unit .y) true ) false) , b = ({a = true , b = 0 }.a) }.b) ) (case <r = (((\x: Unit .\y: Unit .y) true ) false) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)))
(succ (pred (let u = ({a = 1 , b = (unfold [ Bool ] (fold [ Unit ] true )) }.a) in ({a = false , b = ({a = true , b = 1 }.b) }.b))))
(case <l = (((\x: Nat .\y: Bool .x) (pred ({a = 0 , b = true }.a)) ) (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Nat ] true )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )))) > as Bool of < l = x > => x | < r = y > => y)
(case <l = ({a = (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) in 0) in (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) , b = (let u = ({a = 1 , b = false }.b) in (let u = 0 in u)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(let u = (unfold [ Unit ] (fold [ Rec X. X ] (if (((\x: Unit .\y: Nat .x) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .a))) then ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) else (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Unit ] (fold [ Bool ] 0 )) ))) )) in (case <l = (( \f: Nat .((f ({a = (unfold [ Rec X. X ] (fold [ Bool ] true )) , b = (((\x: Nat .\y: Nat .y) false ) 1) }.b) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = false , c = 0 }.c) )) ) ) (\a: Nat .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y))
(pred (if (iszero 0) then (( \f: Nat .((f (if (((\x: Rec X. X .\y: Rec X. X .y) true ) true) then (unfold [ Bool ] (fold [ Nat ] 0 )) else (succ 0)) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .b)) else (if (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .a)) then (fix (\x: Rec X. X . ({a = 1 , b = false }.a) )) else (((\x: Rec X. X .\y: Nat .y) (let u = true in false) ) (unfold [ Unit ] (fold [ Bool ] 1 ))))))
(unfold [ Nat ] (fold [ Nat ] ({a = (if ({a = ({a = true , b = 1 }.a) , b = 1 }.a) then (let u = false in 0) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (let u = (let u = ({a = 1 , b = false }.a) in (fix (\x: Unit . 0 ))) in (let u = (let u = (((\x: Nat .\y: Nat .x) 0 ) true) in 1) in ({a = 1 , b = (fix (\x: Unit . false )) , c =  0 }.b))) , c = ({a = (if true then true else true) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) }.c) ))
({a = (let u = (unfold [ Unit ] (fold [ Rec X. X ] ({a = (fix (\x: Rec X. X . 0 )) , b = ({a = true , b = 0 }.b) }.b) )) in (let u = (iszero 1) in ({a = (((\x: Rec X. X .\y: Nat .y) false ) 0) , b = ({a = false , b = 0 }.b) }.b))) , b = ({a = ({a = (pred (fix (\x: Nat . 1 ))) , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)) }.a) , b = (let u = (((\x: Rec X. X .\y: Unit .y) true ) false) in u) , c =  (let u = (( \f: Unit .((f (((\x: Unit .\y: Bool .x) (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) true) ) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = ({a = 0 , b = false }.b) }.a) ) ) (\a: Bool .\b: Unit .b)) in ({a = false , b = 0 }.b)) }.b) }.a)
(((\x: Bool .\y: Rec X. X .y) ({a = ({a = (succ 1) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) , c = (pred 1) }.c) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = 1 in false) )) }.b) ) (case <l = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = 0 , b = 0 }.b) in u) ) (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) then (let u = true in u) else true)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f (if true then true else true) ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) }.c) > as Bool of < l = x > => x | < r = y > => y))
(unfold [ Bool ] (fold [ Rec X. X ] ({a = (pred (succ 0)) , b = (fix (\x: Rec X. X . ({a = (let u = 0 in u) , b = (if true then false else (iszero 0)) , c =  (succ 1) }.b) )) }.a) ))
({a = (((\x: Bool .\y: Bool .y) (iszero (fix (\x: Rec X. X . 0 ))) ) (( \f: Unit .((f 1 ) (let u = 0 in u) ) ) (\a: Nat .\b: Rec X. X .b))) , b = (((\x: Unit .\y: Bool .y) (case <r = (( \f: Bool .((f (if true then true else true) ) (((\x: Rec X. X .\y: Bool .y) false ) true) ) ) (\a: Bool .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) else 1) ) ) (\a: Bool .\b: Rec X. X .a)) in u)) }.b)
(let u = (unfold [ Unit ] (fold [ Rec X. X ] ({a = ({a = 1 , b = false , c =  1 }.b) , b = (case <r = ({a = true , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) in (unfold [ Rec X. X ] (fold [ Nat ] (succ ({a = 0 , b = true }.a)) )))
(( \f: Bool .((f (( \f: Rec X. X .((f ({a = ({a = (let u = false in 1) , b = (let u = false in u) }.b) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) )) ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (let u = true in u) ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = (( \f: Unit .((f (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) true ) ) (\a: Bool .\b: Rec X. X .b)) in (((\x: Bool .\y: Bool .y) false ) true))) ) ) (\a: Nat .\b: Nat .a))
(unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , b = (if true then 1 else 0) }.a) ) (iszero (((\x: Nat .\y: Rec X. X .y) false ) ({a = 1 , b = false , c = 1 }.c)))) ))
(let u = (((\x: Bool .\y: Unit .x) (case <l = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (if ({a = true , b = (unfold [ Bool ] (fold [ Nat ] false )) }.b) then (((\x: Bool .\y: Rec X. X .y) false ) (let u = false in false)) else (unfold [ Rec X. X ] (fold [ Nat ] true )))) in ({a = (unfold [ Unit ] (fold [ Nat ] (let u = (let u = 1 in u) in u) )) , b = ({a = ({a = (let u = 1 in 1) , b = true }.b) , b = (let u = (fix (\x: Unit . 0 )) in u) }.b) }.b))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (fix (\x: Nat . false )) , b = (let u = ({a = 0 , b = false }.a) in u) }.a) ))
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) false ) true) ) ({a = true , b = 1 }.b)) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)) }.a) in (let u = (let u = false in u) in u)) ))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Bool . false )) )) , b = (( \f: Unit .((f ({a = (let u = false in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 1 ))) , b = (fix (\x: Bool . (let u = 0 in u) )) }.b) ) (case <l = (pred (unfold [ Unit ] (fold [ Bool ] 0 ))) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) }.a)
(let u = ({a = (let u = (((\x: Nat .\y: Rec X. X .y) false ) false) in u) , b = (case <r = (( \f: Rec X. X .((f (if true then true else true) ) true ) ) (\a: Bool .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) }.b) in u)
({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Unit .y) true ) 1) ) (((\x: Nat .\y: Nat .x) false ) false)) in (( \f: Bool .((f (( \f: Bool .((f (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = 0 , b = ({a = 0 , b = false }.b) , c =  0 }.b) ) ) (\a: Bool .\b: Bool .b))) , b = (((\x: Bool .\y: Unit .x) (( \f: Unit .((f 1 ) (let u = 0 in 0) ) ) (\a: Nat .\b: Nat .a)) ) ({a = ({a = (let u = false in 0) , b = 0 }.b) , b = (iszero ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 ))) }.b)) }.b)
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = ({a = (( \f: Unit .((f true ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = 1 , b = false , c = 0 }.c) }.b) , b = (((\x: Nat .\y: Bool .x) true ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) , c =  (( \f: Bool .((f (let u = 0 in 0) ) (((\x: Rec X. X .\y: Unit .x) 0 ) ({a = 1 , b = false , c =  0 }.b)) ) ) (\a: Unit .\b: Bool .a)) }.b) ))
({a = ({a = (( \f: Nat .((f (let u = (succ 0) in ({a = 1 , b = (succ 1) }.b)) ) ({a = (pred 0) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) , c = 1 }.c) ) ) (\a: Bool .\b: Unit .b)) , b = (( \f: Nat .((f (if (fix (\x: Rec X. X . false )) then false else ({a = 0 , b = true , c =  1 }.b)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Nat .\b: Bool .b)) }.b) , b = (((\x: Nat .\y: Bool .x) (pred (( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] 1 )) ) (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Unit .b))) ) (if (( \f: Unit .((f (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .b)) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Nat .\b: Rec X. X .b)) then (let u = false in u) else (iszero 0))) }.a)
(if (case <r = (if ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) then (if false then true else true) else (( \f: Unit .((f (fix (\x: Unit . true )) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Nat .a))) > as Nat of < l = x > => x | < r = y > => y) then ({a = (let u = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = false , b = 0 }.b)) in (if (( \f: Rec X. X .((f (let u = 1 in false) ) (let u = 0 in true) ) ) (\a: Rec X. X .\b: Bool .a)) then (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) else ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = 1 in true) )))) , b = ({a = (case <r = (((\x: Rec X. X .\y: Bool .x) false ) false) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b) }.b) else ({a = ({a = 0 , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) }.b) , b = (((\x: Bool .\y: Rec X. X .y) (let u = true in u) ) (((\x: Unit .\y: Bool .y) false ) 1)) }.b))
(((\x: Unit .\y: Nat .x) (let u = (fix (\x: Rec X. X . (case <r = (((\x: Rec X. X .\y: Unit .x) false ) true) > as Nat of < l = x > => x | < r = y > => y) )) in (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in u)) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = (case <r = ({a = true , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = false , c =  0 }.b) )) }.b) ) (let u = ({a = (case <l = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = (if false then true else false) }.b) in u)))
(if ({a = (( \f: Nat .((f (let u = ({a = 1 , b = 1 }.b) in (unfold [ Unit ] (fold [ Rec X. X ] true ))) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Nat .a)) , b = (if (let u = true in u) then (let u = ({a = 1 , b = ({a = 1 , b = false , c =  0 }.b) }.a) in (if true then (((\x: Bool .\y: Unit .x) 1 ) false) else 0)) else (( \f: Rec X. X .((f (succ 1) ) 1 ) ) (\a: Bool .\b: Bool .b))) }.a) then (( \f: Nat .((f ({a = (let u = true in u) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.a) ) ({a = (((\x: Nat .\y: Unit .y) (let u = false in false) ) ({a = (((\x: Bool .\y: Nat .x) false ) false) , b = true }.b)) , b = (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] false )) ) (let u = false in true) ) ) (\a: Bool .\b: Bool .b)) }.b) ) ) (\a: Nat .\b: Unit .a)) else (let u = ({a = (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) )) , b = (if (let u = true in u) then (((\x: Unit .\y: Unit .y) false ) true) else ({a = 1 , b = true , c =  0 }.b)) }.b) in (if (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (let u = 1 in false) else (if true then false else true)) then ({a = 1 , b = false , c =  1 }.b) else ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) , c =  0 }.b))))
(case <r = (( \f: Bool .((f (let u = (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = false , c =  1 }.b) ) false) in (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b))) ) (let u = (let u = 1 in 1) in (let u = true in u)) ) ) (\a: Nat .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Nat . ({a = (iszero (((\x: Bool .\y: Nat .y) ({a = 1 , b = false , c =  1 }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 )))) , b = (((\x: Unit .\y: Rec X. X .y) (let u = false in false) ) (if (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b)) then false else ({a = 1 , b = true , c =  0 }.b))) }.b) ))
(let u = (fix (\x: Rec X. X . ({a = ({a = false , b = 0 }.b) , b = (fix (\x: Nat . false )) }.a) )) in ({a = ({a = (((\x: Rec X. X .\y: Bool .x) true ) ({a = true , b = 0 }.a)) , b = ({a = (pred 0) , b = (let u = 0 in 0) }.b) }.b) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (((\x: Bool .\y: Bool .y) (let u = ({a = 0 , b = true , c =  1 }.b) in false) ) (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) in 0)) }.b))
(let u = (((\x: Rec X. X .\y: Bool .x) (case <r = (( \f: Unit .((f false ) ({a = false , b = 1 }.a) ) ) (\a: Nat .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (let u = ({a = true , b = false }.b) in (let u = 0 in true)) in ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = false , c =  0 }.b))) in u)
(unfold [ Bool ] (fold [ Nat ] (if (((\x: Unit .\y: Bool .y) ({a = 1 , b = true , c =  1 }.b) ) (let u = false in false)) then ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (let u = 1 in false) , b = ({a = 0 , b = 1 }.b) }.a) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.b) else (((\x: Nat .\y: Rec X. X .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) ) ({a = 1 , b = ({a = 1 , b = false , c =  1 }.b) , c =  (let u = 1 in u) }.b))) ))
(let u = (fix (\x: Rec X. X . (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) )) in u)
(fix (\x: Rec X. X . ({a = (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (fix (\x: Nat . (( \f: Rec X. X .((f true ) (let u = 1 in false) ) ) (\a: Bool .\b: Rec X. X .b)) )) }.a) ))
({a = (succ (let u = ({a = 0 , b = (let u = false in true) }.b) in (unfold [ Unit ] (fold [ Rec X. X ] ({a = true , b = 0 }.b) )))) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Bool ] (let u = true in true) )) )) , c =  (let u = (((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (let u = 0 in 1)) in u) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (let u = (iszero ({a = 0 , b = true , c = 1 }.c)) in u) ))
({a = ({a = (let u = (let u = true in false) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Bool .((f (( \f: Bool .((f ({a = true , b = 1 }.b) ) 1 ) ) (\a: Unit .\b: Nat .b)) ) (case <l = ({a = 0 , b = false }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) }.b)
({a = (( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] (let u = false in (let u = 0 in u)) )) ) (if (iszero 0) then (((\x: Bool .\y: Nat .y) (fix (\x: Unit . true )) ) 1) else (pred 1)) ) ) (\a: Bool .\b: Unit .b)) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = (( \f: Bool .((f ({a = 1 , b = true , c =  0 }.b) ) false ) ) (\a: Nat .\b: Unit .b)) in ({a = true , b = 1 }.b)) )) }.b)
({a = (if (unfold [ Bool ] (fold [ Bool ] (let u = true in u) )) then (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) else (( \f: Bool .((f (let u = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) in true) ) (fix (\x: Bool . ({a = 0 , b = true , c =  0 }.b) )) ) ) (\a: Nat .\b: Rec X. X .b))) , b = (((\x: Rec X. X .\y: Unit .x) (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in ({a = 1 , b = true , c =  1 }.b)) ) (( \f: Nat .((f ({a = 1 , b = true }.b) ) ({a = 1 , b = (let u = true in u) }.b) ) ) (\a: Rec X. X .\b: Bool .b))) }.b)
(((\x: Nat .\y: Rec X. X .y) (fix (\x: Nat . ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = true , b = 0 }.a) in true) )) )) ) (case <r = (fix (\x: Nat . ({a = 1 , b = true , c =  (fix (\x: Unit . 0 )) }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Bool .x) (let u = (if (let u = ({a = 0 , b = false }.b) in u) then (if (((\x: Nat .\y: Bool .y) (let u = false in true) ) (((\x: Nat .\y: Unit .x) false ) false)) then (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) else ({a = 1 , b = true }.a)) else ({a = 0 , b = true }.a)) in u) ) ({a = (case <l = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = true , c = 0 }.c)) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Bool .\y: Bool .y) true ) true) , b = ({a = ({a = 0 , b = true , c = 1 }.c) , b = true }.b) }.b) }.b))
(unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) ({a = (((\x: Rec X. X .\y: Bool .x) true ) true) , b = 0 }.a) ) (let u = (fix (\x: Rec X. X . 0 )) in u)) ))
({a = (( \f: Bool .((f ({a = (let u = (fix (\x: Bool . 1 )) in u) , b = (unfold [ Nat ] (fold [ Unit ] 0 )) }.b) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) in u) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (unfold [ Unit ] (fold [ Bool ] (((\x: Unit .\y: Unit .x) false ) true) )) }.b)
(if (let u = ({a = (((\x: Nat .\y: Bool .x) true ) false) , b = (((\x: Nat .\y: Nat .x) false ) false) }.b) in u) then ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f (let u = true in true) ) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = (((\x: Bool .\y: Nat .x) true ) true) , c =  (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Nat .\b: Nat .a)) )) else (if (let u = ({a = true , b = 1 }.a) in (let u = 1 in true)) then (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false , c =  0 }.b) )) else (( \f: Unit .((f true ) (((\x: Rec X. X .\y: Bool .x) false ) false) ) ) (\a: Rec X. X .\b: Nat .b))))
(case <r = (case <r = (( \f: Unit .((f (if (iszero 1) then false else true) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)
(let u = (( \f: Nat .((f (let u = (let u = (if false then true else false) in (let u = true in 1)) in (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true)) ) (pred ({a = 0 , b = true , c = 1 }.c)) ) ) (\a: Unit .\b: Unit .b)) in (if (((\x: Nat .\y: Bool .y) (if ({a = 1 , b = false }.b) then (let u = true in true) else (if false then false else true)) ) (( \f: Bool .((f ({a = 0 , b = false , c =  0 }.b) ) (let u = false in true) ) ) (\a: Unit .\b: Rec X. X .b))) then (( \f: Bool .((f ({a = 0 , b = true }.a) ) (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ) ) (\a: Rec X. X .\b: Bool .b)) else ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = false , c = 0 }.c) ))))
({a = (succ (let u = (succ ({a = 1 , b = 1 }.b)) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )))) , b = (((\x: Nat .\y: Rec X. X .x) ({a = (((\x: Nat .\y: Unit .x) false ) false) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) }.b) ) (let u = ({a = (( \f: Unit .((f ({a = 1 , b = true }.a) ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , c = (succ 1) }.c) in (fix (\x: Rec X. X . true )))) }.b)
(( \f: Rec X. X .((f ({a = (( \f: Nat .((f (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .b)) ) ({a = 1 , b = 0 }.b)) ) (if true then 0 else 0) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = ({a = true , b = 0 }.b) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  (pred 0) }.b) }.a) ) (( \f: Bool .((f (succ (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b))) ) (fix (\x: Bool . ({a = (fix (\x: Bool . 0 )) , b = false }.a) )) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Bool .b))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Bool .x) false ) (((\x: Bool .\y: Bool .y) true ) true)) ) (fix (\x: Unit . false ))) in (iszero (pred 0))) ))
({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (if false then 1 else 1) in (pred 1)) )) , b = (fix (\x: Rec X. X . (case <r = ({a = 0 , b = false , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y) )) , c =  (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = 0 , b = false }.b) )) in (( \f: Nat .((f ({a = 1 , b = true }.a) ) 1 ) ) (\a: Nat .\b: Nat .a))) }.b)
(let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (succ 0) )) in (if (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else ({a = 1 , b = (iszero 1) }.a)))
(( \f: Bool .((f (unfold [ Unit ] (fold [ Bool ] (if (let u = ({a = false , b = 1 }.b) in (unfold [ Nat ] (fold [ Nat ] true ))) then ({a = (let u = 1 in 1) , b = false , c = 1 }.c) else (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .x) 1 ) false) ))) )) ) ({a = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) in (pred (unfold [ Nat ] (fold [ Bool ] 0 )))) , b = ({a = (pred ({a = 0 , b = false }.a)) , b = ({a = (pred 0) , b = (unfold [ Rec X. X ] (fold [ Nat ] ({a = false , b = 0 }.a) )) , c =  ({a = 1 , b = 1 }.b) }.b) }.a) }.b) ) ) (\a: Nat .\b: Unit .a))
(( \f: Rec X. X .((f (let u = (( \f: Nat .((f 0 ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) in (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Unit .\y: Nat .y) (let u = false in u) ) ({a = true , b = 0 }.b)) else (case <l = (let u = 0 in 0) > as Bool of < l = x > => x | < r = y > => y))) ) (unfold [ Bool ] (fold [ Rec X. X ] (case <l = (((\x: Bool .\y: Nat .y) false ) 0) > as Bool of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Nat .b))
(((\x: Nat .\y: Bool .x) ({a = (iszero (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) , b = (( \f: Rec X. X .((f (( \f: Unit .((f ({a = false , b = true }.b) ) (unfold [ Unit ] (fold [ Bool ] false )) ) ) (\a: Nat .\b: Bool .a)) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Unit .b)) }.b) ) (unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .y) (iszero 0) ) false) )))
(((\x: Rec X. X .\y: Bool .y) (let u = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) , b = (let u = (let u = false in true) in true) , c = (pred 1) }.c) in ({a = (let u = false in 1) , b = (unfold [ Unit ] (fold [ Nat ] false )) }.b)) ) (iszero (succ ({a = 1 , b = true }.a))))
(let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (if ({a = ({a = 1 , b = true , c =  0 }.b) , b = 0 }.a) then ({a = true , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b) else (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) ) ({a = true , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.b) ) ) (\a: Nat .\b: Nat .b)) )) in (case <r = (unfold [ Bool ] (fold [ Bool ] true )) > as Rec X. X of < l = x > => x | < r = y > => y))
(( \f: Nat .((f ({a = (( \f: Rec X. X .((f ({a = true , b = 1 }.b) ) (pred 1) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Nat .((f ({a = (fix (\x: Unit . false )) , b = (let u = 1 in true) }.b) ) (let u = false in (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .a))) ) ) (\a: Rec X. X .\b: Bool .b)) , c = (let u = (let u = ({a = 1 , b = true }.b) in u) in (let u = 0 in u)) }.c) ) (((\x: Bool .\y: Nat .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) ) (fix (\x: Unit . (iszero (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ))) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(((\x: Nat .\y: Nat .y) (fix (\x: Rec X. X . (( \f: Nat .((f (( \f: Rec X. X .((f (if false then false else false) ) (((\x: Unit .\y: Bool .x) (let u = 0 in false) ) (fix (\x: Rec X. X . true ))) ) ) (\a: Nat .\b: Bool .b)) ) (( \f: Unit .((f (if false then false else false) ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Bool .b)) )) ) (let u = (((\x: Unit .\y: Bool .y) (fix (\x: Nat . false )) ) ({a = false , b = 0 }.a)) in (iszero (let u = (fix (\x: Rec X. X . false )) in (if false then 0 else 0)))))
(( \f: Bool .((f ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = (unfold [ Nat ] (fold [ Bool ] false )) }.b) ) (((\x: Bool .\y: Nat .y) (case <r = ({a = 1 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Bool .y) (if true then true else true) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)))) ) ) (\a: Nat .\b: Nat .a))
(let u = (succ (let u = (if false then false else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true ))) in (((\x: Rec X. X .\y: Rec X. X .y) ({a = 0 , b = true }.b) ) (succ 1)))) in (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = false }.b)) ) (((\x: Rec X. X .\y: Unit .y) (let u = true in u) ) ({a = (fix (\x: Nat . 0 )) , b = false }.b)) ) ) (\a: Unit .\b: Nat .b)))
({a = (succ ({a = (( \f: Rec X. X .((f false ) ({a = 0 , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = 0 , b = 1 }.b) }.b)) , b = (unfold [ Rec X. X ] (fold [ Nat ] (case <r = ({a = (((\x: Unit .\y: Rec X. X .y) true ) 0) , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) , c =  (( \f: Bool .((f (let u = (((\x: Bool .\y: Nat .x) (if true then false else true) ) false) in ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 ))) ) (( \f: Nat .((f (let u = 0 in 0) ) (if (if false then true else (let u = 0 in true)) then (if true then 0 else 0) else ({a = 1 , b = (let u = false in true) }.a)) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Bool .a)) }.b)
(( \f: Unit .((f (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 0 , b = false }.b) )) ) ({a = (let u = true in 0) , b = (iszero 1) }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = (((\x: Rec X. X .\y: Nat .y) ({a = (iszero 0) , b = (( \f: Bool .((f (((\x: Bool .\y: Nat .x) 1 ) false) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .b)) }.a) ) (let u = 0 in u)) in (if (fix (\x: Rec X. X . true )) then (let u = false in u) else (let u = (let u = 0 in false) in false))) ) ) (\a: Rec X. X .\b: Unit .b))
(unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f (( \f: Bool .((f (case <l = (let u = (let u = 1 in true) in ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Bool .y) true ) (((\x: Rec X. X .\y: Unit .x) 0 ) true)) ) ) (\a: Bool .\b: Unit .b)) ) (let u = (if (((\x: Unit .\y: Rec X. X .y) false ) false) then 1 else 0) in ({a = false , b = 0 }.b)) ) ) (\a: Nat .\b: Bool .b)) ))
({a = (case <r = (let u = ({a = 1 , b = false }.b) in u) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .b)) ) (succ ({a = 1 , b = false }.a))) }.a)
(if (let u = (if (if (let u = false in false) then (((\x: Unit .\y: Nat .x) false ) true) else ({a = 0 , b = true }.b)) then (((\x: Bool .\y: Nat .y) (case <r = (fix (\x: Unit . true )) > as Nat of < l = x > => x | < r = y > => y) ) (let u = false in u)) else ({a = 1 , b = true , c =  (((\x: Nat .\y: Unit .x) 0 ) true) }.b)) in (( \f: Rec X. X .((f (( \f: Bool .((f (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) (((\x: Nat .\y: Nat .x) (let u = ({a = false , b = 0 }.a) in u) ) ({a = true , b = 1 }.a)) ) ) (\a: Rec X. X .\b: Nat .a))) then (let u = (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = 0 }.b) )) in (((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Bool .x) 1 ) true) ) (((\x: Bool .\y: Rec X. X .x) false ) false))) else (case <l = ({a = (iszero 0) , b = (let u = (pred 1) in u) }.b) > as Bool of < l = x > => x | < r = y > => y))
(pred (( \f: Unit .((f (((\x: Nat .\y: Nat .x) (pred (let u = 0 in 1)) ) (let u = true in true)) ) (( \f: Bool .((f (succ ({a = 1 , b = 0 }.b)) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .a)))
(((\x: Bool .\y: Unit .x) ({a = ({a = 0 , b = false }.b) , b = (((\x: Rec X. X .\y: Unit .x) ({a = false , b = 0 }.a) ) (fix (\x: Bool . false ))) }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .y) (if (let u = 0 in false) then ({a = 0 , b = true , c =  1 }.b) else true) ) ({a = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) , b = 0 }.b) , b = (let u = 1 in false) , c =  ({a = 0 , b = true , c = 1 }.c) }.b)) )))
({a = (case <l = (succ (case <l = (let u = 1 in u) > as Unit of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (( \f: Rec X. X .((f (if false then false else true) ) (((\x: Unit .\y: Bool .y) false ) true) ) ) (\a: Bool .\b: Unit .b)) )) }.b)
(let u = (unfold [ Nat ] (fold [ Bool ] (((\x: Bool .\y: Unit .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b))) )) in (let u = (if (if (((\x: Rec X. X .\y: Rec X. X .x) false ) false) then false else (iszero 0)) then ({a = (pred 0) , b = (((\x: Nat .\y: Rec X. X .x) false ) false) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) )) }.b) else ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) , b = (fix (\x: Nat . true )) }.b)) in (let u = (let u = false in u) in (((\x: Unit .\y: Unit .y) true ) true))))
(let u = (let u = ({a = (iszero 0) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) in (( \f: Bool .((f (let u = false in 1) ) (( \f: Bool .((f 1 ) (pred 1) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Nat .\b: Unit .b))) in ({a = ({a = (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Bool .y) false ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b))) ) (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = true , c =  1 }.b) ))) , b = (case <l = (fix (\x: Rec X. X . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Rec X. X .((f ({a = (if false then 1 else 1) , b = (let u = true in true) }.b) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) in u) }.c))
(iszero (case <l = (if ({a = ({a = 1 , b = false , c =  1 }.b) , b = 0 }.a) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) else ({a = 0 , b = 1 }.b)) > as Unit of < l = x > => x | < r = y > => y))
(let u = (let u = (fix (\x: Bool . (( \f: Bool .((f (if true then 0 else 1) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .a)) )) in (((\x: Bool .\y: Unit .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) ) (iszero 0))) in ({a = (pred (pred (if true then 0 else 1))) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) true ) true) )) }.a))
(pred (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = 0 }.b) )))
(succ ({a = ({a = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .b)) , b = (fix (\x: Rec X. X . 0 )) }.a) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b))
({a = ({a = (if ({a = 0 , b = false , c =  0 }.b) then (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) else ({a = 0 , b = true }.b)) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) 0 ) false) ) (fix (\x: Bool . 1 )) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) , b = ({a = (( \f: Bool .((f (fix (\x: Nat . (let u = false in u) )) ) (( \f: Nat .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .a)) , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (if (((\x: Bool .\y: Rec X. X .y) true ) false) then ({a = (let u = 0 in false) , b = 0 }.b) else (let u = false in 0)) }.b) }.b)
(let u = (let u = (pred (((\x: Nat .\y: Nat .x) 1 ) false)) in u) in u)
(let u = (let u = (case <r = (( \f: Unit .((f true ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Nat .x) (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) 0 ) true) ) 1 ) ) (\a: Unit .\b: Bool .b)) ) ({a = 0 , b = true }.b))) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (let u = ({a = 0 , b = false , c =  0 }.b) in (succ 0)) )))
(( \f: Unit .((f (succ (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) in (let u = ({a = false , b = 1 }.b) in 1))) ) (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) in (let u = true in 1)) in (( \f: Unit .((f ({a = true , b = 0 }.b) ) 0 ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Bool .\b: Bool .a))
({a = (unfold [ Unit ] (fold [ Rec X. X ] ({a = (let u = false in u) , b = (let u = false in 1) }.a) )) , b = (let u = ({a = ({a = 1 , b = false }.b) , b = (pred ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) }.b) in u) }.b)
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] (case <r = ({a = (fix (\x: Unit . false )) , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) )) )) ))
(( \f: Unit .((f (succ (let u = 1 in u)) ) (((\x: Nat .\y: Rec X. X .y) (let u = false in u) ) (if (fix (\x: Rec X. X . true )) then (if true then 0 else 1) else (((\x: Bool .\y: Nat .x) 0 ) true))) ) ) (\a: Nat .\b: Nat .a))
(( \f: Unit .((f ({a = (let u = ({a = false , b = true }.b) in u) , b = ({a = (succ ({a = 0 , b = true }.a)) , b = ({a = false , b = true }.b) }.b) }.b) ) (fix (\x: Bool . (( \f: Rec X. X .((f (let u = 0 in (let u = 1 in false)) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .b)) )) ) ) (\a: Unit .\b: Nat .a))
(let u = (let u = (( \f: Bool .((f ({a = 0 , b = false , c =  1 }.b) ) true ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) in (fix (\x: Bool . false ))) in (let u = true in ({a = true , b = 0 }.a)))) in (let u = (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) in u) in (unfold [ Unit ] (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ))) in (((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f false ) (fix (\x: Bool . false )) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (if true then ({a = 1 , b = 0 }.b) else (unfold [ Bool ] (fold [ Unit ] 0 ))) }.a))))
(pred (let u = (( \f: Bool .((f (let u = true in 0) ) 1 ) ) (\a: Unit .\b: Bool .b)) in u))
(let u = ({a = (( \f: Unit .((f (((\x: Unit .\y: Nat .x) 1 ) true) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = (unfold [ Nat ] (fold [ Unit ] (let u = 1 in u) )) , b = (case <r = (if true then true else false) > as Nat of < l = x > => x | < r = y > => y) }.b) }.a) in u)
(fix (\x: Nat . (let u = (( \f: Unit .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Bool .\b: Nat .a)) in u) ))
(unfold [ Bool ] (fold [ Rec X. X ] (pred (if false then (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) else ({a = 0 , b = true , c = 1 }.c))) ))
(( \f: Unit .((f ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (if true then true else false) )) , b = (if true then 0 else 0) }.a) , b = (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .x) 1 ) true) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Nat .\b: Nat .a)) }.a) ) ({a = (((\x: Nat .\y: Rec X. X .x) (let u = 0 in 0) ) (((\x: Rec X. X .\y: Unit .y) false ) false)) , b = ({a = ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) , b = (if (unfold [ Rec X. X ] (fold [ Unit ] false )) then false else ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true ))) , c =  (fix (\x: Nat . (pred 1) )) }.b) }.b) ) ) (\a: Nat .\b: Unit .b))
(((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) (fix (\x: Unit . false )) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (let u = (( \f: Rec X. X .((f (let u = true in 1) ) (let u = true in 1) ) ) (\a: Unit .\b: Nat .b)) in (if true then 0 else ({a = 0 , b = true , c = 0 }.c))) , b = (( \f: Unit .((f (let u = 0 in false) ) (case <r = (let u = false in true) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) , c =  (succ (( \f: Unit .((f ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) , b = 1 }.b) ) (succ (((\x: Nat .\y: Nat .y) false ) 1)) ) ) (\a: Rec X. X .\b: Nat .b))) }.b))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Unit ] (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . false )) )) )) ))
(case <l = (let u = (let u = ({a = 0 , b = true , c =  0 }.b) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 ))) in (let u = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) in (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)))) > as Bool of < l = x > => x | < r = y > => y)
({a = (((\x: Nat .\y: Nat .y) (let u = (let u = (iszero 0) in (fix (\x: Rec X. X . 0 ))) in ({a = 1 , b = false }.b)) ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a))) , b = (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f (fix (\x: Bool . 1 )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Unit .a)) )) }.a)
(unfold [ Nat ] (fold [ Rec X. X ] (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (pred 1) , b = (if true then false else true) }.a) )) in u) ))
(((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Bool .x) (unfold [ Bool ] (fold [ Nat ] false )) ) (if (iszero (fix (\x: Unit . 1 ))) then ({a = (pred 0) , b = false , c =  ({a = 1 , b = 0 }.b) }.b) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = false in u) )))) ) ({a = (let u = ({a = 0 , b = true }.a) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in u) )) }.a))
({a = ({a = (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .y) true ) 0) ) (fix (\x: Unit . 1 )) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false ))) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (((\x: Bool .\y: Rec X. X .x) true ) true) , c =  ({a = 1 , b = 0 }.b) }.b) ) ) (\a: Nat .\b: Bool .a)) }.b) , b = (unfold [ Bool ] (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] (pred (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) )) )) }.b)
(( \f: Bool .((f (let u = (((\x: Rec X. X .\y: Nat .y) false ) (iszero 0)) in u) ) ({a = (let u = (let u = (((\x: Bool .\y: Rec X. X .y) false ) false) in u) in (( \f: Nat .((f (iszero 1) ) false ) ) (\a: Bool .\b: Rec X. X .a))) , b = (succ ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = 0 , b = false , c =  0 }.b) , c = ({a = true , b = 1 }.b) }.c)) }.a) ) ) (\a: Unit .\b: Nat .a))
({a = (((\x: Nat .\y: Unit .x) (if (iszero 1) then (((\x: Bool .\y: Bool .x) true ) true) else ({a = false , b = true }.b)) ) (iszero ({a = (let u = 1 in 0) , b = true , c = (succ 1) }.c))) , b = (case <l = ({a = (fix (\x: Rec X. X . 0 )) , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) }.a)
({a = (( \f: Unit .((f (if ({a = 0 , b = false }.b) then (succ (fix (\x: Nat . 1 ))) else (if (((\x: Bool .\y: Unit .y) false ) false) then (let u = 1 in u) else (( \f: Rec X. X .((f (fix (\x: Rec X. X . 1 )) ) 0 ) ) (\a: Rec X. X .\b: Nat .a)))) ) ({a = (let u = 1 in u) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) }.b) ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Nat .\y: Unit .x) (let u = true in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (iszero 0) ))) , c =  (case <l = (if (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) then 1 else (((\x: Unit .\y: Unit .y) true ) 0)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(let u = (( \f: Nat .((f (let u = 1 in 1) ) ({a = (((\x: Unit .\y: Nat .y) true ) 1) , b = false }.a) ) ) (\a: Rec X. X .\b: Unit .b)) in (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (( \f: Bool .((f (fix (\x: Nat . true )) ) false ) ) (\a: Nat .\b: Bool .a))))
(let u = ({a = (case <r = (fix (\x: Rec X. X . false )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Nat .\y: Unit .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) false) in u) }.b) in (let u = (case <r = (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in (fix (\x: Rec X. X . false ))) > as Nat of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Unit .y) (iszero 0) ) ({a = false , b = 1 }.b))))
({a = (let u = ({a = (pred 1) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.a) in (pred ({a = (pred 0) , b = ({a = true , b = 1 }.a) , c = (pred 0) }.c))) , b = (( \f: Bool .((f (case <r = (fix (\x: Nat . ({a = false , b = 1 }.a) )) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (let u = ({a = 0 , b = true }.b) in (let u = 1 in true)) in u) ) ) (\a: Unit .\b: Rec X. X .a)) , c = (if ({a = (((\x: Bool .\y: Rec X. X .y) false ) 0) , b = (iszero 1) , c =  ({a = (fix (\x: Rec X. X . 0 )) , b = ({a = true , b = 0 }.a) }.a) }.b) then (pred ({a = 1 , b = false , c = 0 }.c)) else (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .y) false ) 0) ) (((\x: Unit .\y: Unit .x) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true ))) ) ) (\a: Unit .\b: Rec X. X .a))) }.c)
({a = (succ (if true then ({a = 0 , b = 0 }.b) else 1)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) }.b)
(( \f: Nat .((f (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in u) ) (pred ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = 1 in u) }.b)) ) ) (\a: Bool .\b: Unit .a))
(((\x: Unit .\y: Bool .y) ({a = (( \f: Rec X. X .((f (let u = 1 in false) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Unit .\y: Rec X. X .y) (((\x: Unit .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] false )) ) (let u = true in u)) ) ({a = true , b = 1 }.b)) }.a) ) (unfold [ Unit ] (fold [ Nat ] ({a = (let u = false in 0) , b = (let u = ({a = 0 , b = false , c =  0 }.b) in u) , c = (let u = 0 in 1) }.c) )))
(case <l = (if (let u = (fix (\x: Rec X. X . true )) in (unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) true ) false) ))) then ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = 1 }.b) else (fix (\x: Bool . (if false then 1 else 1) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = (((\x: Unit .\y: Unit .y) true ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) , b = (fix (\x: Nat . ({a = 1 , b = false , c =  0 }.b) )) }.b) in (let u = ({a = ({a = 0 , b = true , c = 1 }.c) , b = (((\x: Nat .\y: Bool .x) false ) true) }.b) in u))
(let u = ({a = (pred ({a = 0 , b = 1 }.b)) , b = (let u = false in ({a = 1 , b = false }.a)) }.b) in (pred (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in u)))
({a = (let u = (( \f: Nat .((f (let u = (let u = (let u = true in false) in (let u = 1 in 1)) in (unfold [ Bool ] (fold [ Nat ] 0 ))) ) (if (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) then 1 else (if false then 0 else 0)) ) ) (\a: Nat .\b: Bool .b)) in (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) ))) , b = (let u = ({a = (fix (\x: Nat . 0 )) , b = (unfold [ Bool ] (fold [ Nat ] true )) }.a) in u) }.b)
({a = ({a = (let u = ({a = true , b = 1 }.a) in (unfold [ Nat ] (fold [ Nat ] false ))) , b = (( \f: Nat .((f ({a = 0 , b = false , c =  1 }.b) ) false ) ) (\a: Rec X. X .\b: Bool .a)) }.b) , b = (((\x: Bool .\y: Rec X. X .x) ({a = (let u = false in 1) , b = ({a = false , b = ({a = 1 , b = false }.a) }.a) , c = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.c) ) (((\x: Nat .\y: Bool .x) ({a = 0 , b = true , c =  0 }.b) ) ({a = (succ 1) , b = (let u = 1 in false) }.b))) }.a)
({a = (( \f: Unit .((f (( \f: Bool .((f (let u = true in u) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Bool .b)) ) (let u = (((\x: Nat .\y: Bool .y) ({a = 1 , b = true }.b) ) ({a = false , b = false }.b)) in u) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) false ) false) )) ) (( \f: Nat .((f 1 ) ({a = 1 , b = false }.a) ) ) (\a: Nat .\b: Rec X. X .a))) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Bool .\b: Rec X. X .a)) }.a)
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Unit . true )) ) (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)))) )) , b = (( \f: Rec X. X .((f (fix (\x: Nat . (((\x: Nat .\y: Bool .x) 1 ) false) )) ) (( \f: Nat .((f (if true then 0 else 1) ) ({a = 0 , b = 1 }.b) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Unit .b)) }.a)
(unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .y) (((\x: Unit .\y: Unit .y) ({a = 0 , b = false , c =  1 }.b) ) (unfold [ Bool ] (fold [ Nat ] false ))) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ))
({a = (( \f: Unit .((f (((\x: Unit .\y: Unit .x) (unfold [ Nat ] (fold [ Rec X. X ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = true }.b)) ) (((\x: Rec X. X .\y: Rec X. X .x) (let u = false in 1) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in u)) ) ) (\a: Nat .\b: Nat .b)) , b = (let u = ({a = 1 , b = true , c =  (let u = true in 1) }.b) in u) , c = ({a = ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  0 }.b) , b = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) then (( \f: Nat .((f (((\x: Nat .\y: Bool .y) false ) 0) ) (pred 1) ) ) (\a: Unit .\b: Unit .b)) else (let u = 0 in u)) }.b) }.c)
({a = (if (let u = (( \f: Unit .((f (iszero 0) ) (let u = 0 in false) ) ) (\a: Unit .\b: Rec X. X .a)) in u) then (fix (\x: Nat . (let u = false in (iszero 1)) )) else (if (fix (\x: Bool . (((\x: Bool .\y: Bool .x) false ) false) )) then (let u = 1 in true) else ({a = true , b = false }.b))) , b = (case <l = (let u = ({a = 0 , b = false , c = 0 }.c) in (((\x: Rec X. X .\y: Unit .x) 0 ) (fix (\x: Nat . true )))) > as Nat of < l = x > => x | < r = y > => y) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (let u = true in true) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.a) ))
({a = (iszero (let u = true in (pred 0))) , b = (fix (\x: Bool . (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (iszero ({a = 0 , b = false }.a)) )) in (let u = (succ (if true then 0 else 1)) in (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)))) )) }.b)
(if (let u = (((\x: Nat .\y: Rec X. X .y) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b)) ) (unfold [ Nat ] (fold [ Bool ] false ))) in (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in u)) then (((\x: Nat .\y: Bool .y) ({a = ({a = true , b = 0 }.b) , b = (let u = false in false) , c =  (unfold [ Nat ] (fold [ Unit ] 0 )) }.b) ) (((\x: Nat .\y: Nat .x) (if true then ({a = false , b = false }.b) else (fix (\x: Rec X. X . true ))) ) (let u = 1 in true))) else (if (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Bool .y) true ) false) ) (unfold [ Bool ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ))) then (((\x: Unit .\y: Rec X. X .y) true ) (iszero 1)) else (fix (\x: Bool . (unfold [ Bool ] (fold [ Unit ] true )) ))))
(( \f: Bool .((f ({a = (( \f: Nat .((f (let u = (fix (\x: Unit . 0 )) in u) ) (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) in ({a = 0 , b = true , c = 0 }.c)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (succ ({a = false , b = 0 }.b)) }.b) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (pred (((\x: Rec X. X .\y: Bool .x) 0 ) ({a = true , b = 0 }.a))) )) ) ) (\a: Rec X. X .\b: Bool .a))
({a = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) true ) (if true then true else false)) ) (( \f: Bool .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ({a = 0 , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .b)) , b = (fix (\x: Nat . ({a = (if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) then true else (unfold [ Nat ] (fold [ Bool ] true ))) , b = (((\x: Bool .\y: Unit .x) false ) true) }.b) )) }.b)
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Bool ] (fold [ Nat ] false )) ) (let u = 0 in 0)) )) )) , b = (((\x: Nat .\y: Nat .x) ({a = (if (((\x: Nat .\y: Bool .x) true ) false) then 0 else ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 ))) , b = (( \f: Rec X. X .((f true ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .b)) , c =  (pred 1) }.b) ) (let u = false in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )))) , c = ({a = (let u = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (((\x: Nat .\y: Unit .y) false ) false) , c = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.c) in ({a = (fix (\x: Bool . true )) , b = 0 }.b)) , b = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c = (succ ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .y) true ) 0) ))) }.c) }.c)
(let u = (let u = (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = false , c = 1 }.c) )) in (let u = (((\x: Rec X. X .\y: Unit .y) false ) 0) in u)) in u)
({a = (if (case <r = (((\x: Bool .\y: Nat .y) ({a = (if false then false else false) , b = false }.b) ) (let u = true in u)) > as Unit of < l = x > => x | < r = y > => y) then (succ (if true then 1 else 0)) else ({a = (succ 1) , b = (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = 1 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Bool .b)) }.b)) , b = (let u = (iszero (succ (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)))) in ({a = (case <r = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (( \f: Bool .((f ({a = true , b = false }.b) ) false ) ) (\a: Unit .\b: Nat .b)) )) }.b)) }.a)
(((\x: Nat .\y: Unit .x) (if (let u = (fix (\x: Bool . false )) in u) then ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) )) , b = (let u = 0 in u) }.a) else (let u = (succ (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) in (if false then false else true))) ) (((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f (let u = 1 in true) ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) ) (case <r = (let u = 1 in true) > as Nat of < l = x > => x | < r = y > => y)))
(if (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Rec X. X ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) ))) then ({a = (( \f: Nat .((f ({a = 0 , b = 1 }.b) ) (((\x: Unit .\y: Rec X. X .y) false ) 0) ) ) (\a: Unit .\b: Nat .b)) , b = (( \f: Bool .((f (( \f: Bool .((f (let u = false in 1) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) else (succ (if (let u = 0 in (iszero 1)) then (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) else ({a = 0 , b = true , c = 1 }.c))))
(unfold [ Unit ] (fold [ Bool ] ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (if ({a = 1 , b = ({a = false , b = 0 }.a) }.b) then (( \f: Nat .((f 0 ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Bool .b)) else (pred 0)) )) ))
(succ (if (let u = (((\x: Unit .\y: Nat .y) ({a = (unfold [ Bool ] (fold [ Unit ] true )) , b = 0 }.a) ) ({a = ({a = 1 , b = false , c = 0 }.c) , b = false , c = 1 }.c)) in (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) , b = false }.b) in (((\x: Nat .\y: Rec X. X .x) (let u = false in u) ) true))) then ({a = (succ 1) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) }.a) else (unfold [ Bool ] (fold [ Rec X. X ] (case <l = ({a = 1 , b = false }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ))))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (case <r = (let u = ({a = 0 , b = false , c =  1 }.b) in true) > as Nat of < l = x > => x | < r = y > => y) ))
(succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = true }.a) )) , b = (((\x: Rec X. X .\y: Rec X. X .x) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) false) , c = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Unit .y) true ) true) ) (((\x: Rec X. X .\y: Nat .x) 0 ) false)) }.c) )))
(fix (\x: Bool . ({a = (let u = (let u = (iszero 0) in false) in ({a = 1 , b = true , c = 0 }.c)) , b = (unfold [ Bool ] (fold [ Rec X. X ] (let u = true in ({a = false , b = 1 }.a)) )) }.b) ))
(fix (\x: Bool . (( \f: Nat .((f ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = true in u) , c = ({a = 1 , b = false , c = 1 }.c) }.c) ) (let u = ({a = false , b = 0 }.b) in (pred 1)) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(((\x: Unit .\y: Bool .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = (let u = false in false) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = false , b = 0 }.b) )) }.b) )) ) (((\x: Nat .\y: Nat .y) (iszero (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) (let u = 1 in true)))
(case <r = (fix (\x: Bool . ({a = (((\x: Nat .\y: Bool .x) ({a = true , b = false }.b) ) (fix (\x: Nat . true ))) , b = (fix (\x: Nat . 1 )) }.a) )) > as Nat of < l = x > => x | < r = y > => y)
(unfold [ Nat ] (fold [ Rec X. X ] (let u = (( \f: Rec X. X .((f (let u = 0 in 1) ) (succ 0) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true ))) ))
(let u = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] false )) )) ) (( \f: Unit .((f (let u = true in true) ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Bool .a))) )) in (((\x: Unit .\y: Nat .x) (((\x: Unit .\y: Nat .x) (( \f: Rec X. X .((f (case <l = (pred 1) > as Nat of < l = x > => x | < r = y > => y) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Rec X. X .a)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ))) ) ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , b = (if true then (let u = false in true) else false) }.b)))
({a = (( \f: Unit .((f ({a = ({a = true , b = true }.b) , b = (((\x: Bool .\y: Unit .x) 0 ) false) }.a) ) (iszero ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) false ) 1) ))) ) ) (\a: Unit .\b: Nat .b)) , b = (let u = (((\x: Nat .\y: Bool .x) true ) (let u = 0 in true)) in ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) }.a)) }.b)
(((\x: Bool .\y: Bool .y) (iszero ({a = 0 , b = (pred 0) }.b)) ) (pred (fix (\x: Bool . ({a = ({a = 1 , b = false }.a) , b = (if true then false else false) }.a) ))))
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) in ({a = 1 , b = true }.b)) ) (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) ))
(let u = (case <l = ({a = true , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) in (pred ({a = (((\x: Bool .\y: Bool .y) false ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a))) , b = (((\x: Nat .\y: Unit .y) ({a = false , b = false }.b) ) (fix (\x: Rec X. X . true ))) , c = (( \f: Nat .((f (((\x: Bool .\y: Unit .y) false ) 0) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) }.c)))
({a = (let u = ({a = ({a = 0 , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) , b = (((\x: Bool .\y: Nat .y) true ) true) }.b) in (case <r = ({a = true , b = 1 }.a) > as Bool of < l = x > => x | < r = y > => y)) , b = (case <l = (succ (let u = 1 in 1)) > as Bool of < l = x > => x | < r = y > => y) }.a)
({a = (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (((\x: Bool .\y: Bool .x) false ) true) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Unit .a)) ) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = ({a = true , b = false }.b) , c =  (let u = 0 in u) }.b)) , b = ({a = (let u = 0 in u) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = true in true) )) }.a) }.a)
(( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .a)) , b = ({a = true , b = 1 }.a) }.b) ) (iszero ({a = false , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Unit .b)) ) (case <r = (let u = ({a = 0 , b = (let u = true in u) }.b) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a))
(((\x: Unit .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] (let u = ({a = 0 , b = true , c = 0 }.c) in (let u = false in u)) )) ) ({a = (let u = (unfold [ Unit ] (fold [ Unit ] 0 )) in u) , b = ({a = ({a = true , b = 1 }.a) , b = (fix (\x: Bool . 0 )) }.b) }.b))
(let u = ({a = (let u = (pred 0) in u) , b = (iszero ({a = 1 , b = true , c = ({a = false , b = 1 }.b) }.c)) }.b) in (((\x: Unit .\y: Nat .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = 1 , b = false , c =  0 }.b) , b = 0 }.a) )) ) (fix (\x: Unit . (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .a)) ))))
(( \f: Nat .((f (let u = (let u = (let u = 1 in u) in (((\x: Unit .\y: Bool .x) 1 ) false)) in u) ) (( \f: Bool .((f (case <l = (if true then 0 else 0) > as Bool of < l = x > => x | < r = y > => y) ) (if ({a = 0 , b = (fix (\x: Unit . true )) , c =  (((\x: Bool .\y: Bool .x) 1 ) false) }.b) then ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) else (pred 1)) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .b))
({a = (let u = (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) ({a = false , b = 1 }.b) ) ) (\a: Bool .\b: Unit .b)) in (let u = (if false then 0 else 0) in ({a = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b))) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) )) , c =  ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (succ (let u = 0 in 0)) )) }.b)
(unfold [ Nat ] (fold [ Nat ] (( \f: Nat .((f (iszero (let u = false in 1)) ) (if (((\x: Bool .\y: Nat .y) false ) true) then (unfold [ Bool ] (fold [ Bool ] true )) else (let u = 0 in true)) ) ) (\a: Nat .\b: Rec X. X .b)) ))
(((\x: Bool .\y: Unit .y) (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Rec X. X . 0 )) , b = true , c =  1 }.b) }.b) ) (let u = (let u = 0 in true) in false)) ) (iszero (case <l = (((\x: Nat .\y: Nat .x) 0 ) false) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .b)) ) (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = false }.b) )) )))
(let u = ({a = (let u = (iszero 0) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b))) , b = (pred (((\x: Unit .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) ({a = 1 , b = 0 }.b))) }.b) in (if (if (let u = false in u) then (unfold [ Unit ] (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] true )) )) else ({a = true , b = 1 }.a)) then (fix (\x: Bool . false )) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) ))))
(( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Bool . false )) )) ) (case <r = (iszero (((\x: Bool .\y: Nat .x) 1 ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b))
(pred (let u = (succ 0) in u))
({a = (((\x: Rec X. X .\y: Nat .x) (( \f: Unit .((f (let u = false in u) ) ({a = (let u = 1 in 1) , b = (( \f: Nat .((f ({a = true , b = 1 }.a) ) (let u = 0 in true) ) ) (\a: Rec X. X .\b: Unit .a)) , c =  ({a = 0 , b = false }.a) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = (((\x: Unit .\y: Unit .y) true ) false) , b = (fix (\x: Unit . 1 )) }.a) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = true }.b) )))) , b = (let u = (iszero 1) in (let u = (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) 1 ) false) )) in u)) }.a)
({a = ({a = ({a = (let u = ({a = false , b = false }.b) in true) , b = (( \f: Rec X. X .((f (fix (\x: Nat . 1 )) ) (((\x: Rec X. X .\y: Bool .y) true ) 0) ) ) (\a: Nat .\b: Bool .a)) }.b) , b = (let u = ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = (succ 1) }.a) in (((\x: Rec X. X .\y: Unit .x) (( \f: Rec X. X .((f true ) (let u = 0 in true) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = 0 , b = (((\x: Rec X. X .\y: Unit .x) false ) false) }.b))) }.b) , b = (if ({a = (let u = 1 in 0) , b = (((\x: Nat .\y: Unit .y) (fix (\x: Unit . false )) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b))) }.b) then (case <r = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) > as Nat of < l = x > => x | < r = y > => y) else (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .x) true ) true) ) ({a = 0 , b = (fix (\x: Rec X. X . true )) }.b))) }.b)
(let u = (((\x: Bool .\y: Unit .x) (let u = true in true) ) (((\x: Bool .\y: Bool .y) (fix (\x: Unit . (((\x: Bool .\y: Bool .y) true ) false) )) ) (iszero (fix (\x: Unit . 1 ))))) in ({a = (( \f: Unit .((f (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in u) ) (let u = false in 1) ) ) (\a: Nat .\b: Unit .a)) , b = (if (let u = 1 in false) then ({a = false , b = 1 }.a) else (let u = 0 in false)) , c =  (fix (\x: Unit . (fix (\x: Nat . 1 )) )) }.b))
(pred (((\x: Nat .\y: Rec X. X .x) (let u = (let u = 1 in u) in ({a = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 1 , b = 0 }.b) }.b)) ) (if (fix (\x: Rec X. X . false )) then ({a = false , b = true }.b) else (unfold [ Unit ] (fold [ Unit ] ({a = false , b = false }.b) )))))
(unfold [ Rec X. X ] (fold [ Nat ] ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = false , c = 1 }.c) , b = (fix (\x: Bool . (let u = false in true) )) , c = (let u = 1 in u) }.c) ))
(let u = (if (case <r = (let u = (let u = 1 in true) in true) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f (let u = (let u = 0 in false) in 1) ) (((\x: Rec X. X .\y: Nat .x) 1 ) true) ) ) (\a: Nat .\b: Bool .a)) else (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) else (if false then (let u = false in 0) else (((\x: Nat .\y: Bool .x) 1 ) true)))) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )) )))
(((\x: Rec X. X .\y: Unit .x) ({a = ({a = (let u = (fix (\x: Nat . 1 )) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) , b = (((\x: Nat .\y: Nat .x) 0 ) false) }.b) , b = (let u = (( \f: Unit .((f (pred 1) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .a)) in (((\x: Rec X. X .\y: Nat .y) false ) false)) , c = (let u = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) , b = ({a = 1 , b = true }.a) }.b) in (let u = 1 in 0)) }.c) ) (fix (\x: Unit . (( \f: Rec X. X .((f ({a = 1 , b = true }.b) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .b)) )))
({a = (( \f: Bool .((f (( \f: Rec X. X .((f (fix (\x: Unit . true )) ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Unit .\y: Unit .y) false ) true) ) ) (\a: Nat .\b: Nat .a)) , b = (( \f: Nat .((f (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in (if (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) then 1 else 1)) ) (let u = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) in u) ) ) (\a: Unit .\b: Bool .b)) }.a)
({a = (( \f: Rec X. X .((f (case <l = ({a = 0 , b = (pred 1) }.b) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Nat .y) false ) true) ) (unfold [ Nat ] (fold [ Bool ] 1 ))) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (let u = (( \f: Bool .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) (let u = 0 in u) ) ) (\a: Nat .\b: Bool .a)) in u) , b = (fix (\x: Rec X. X . ({a = (((\x: Nat .\y: Bool .x) true ) false) , b = false }.b) )) }.b) , c =  ({a = (if (( \f: Rec X. X .((f (let u = true in u) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) then (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = true }.b) )) else (( \f: Bool .((f ({a = 0 , b = false }.b) ) (case <r = (iszero 1) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b))) , b = (let u = ({a = 0 , b = true }.a) in u) }.b) }.b)
(if (( \f: Nat .((f (let u = (case <r = (( \f: Rec X. X .((f (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) false ) ) (\a: Nat .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) in u) ) (((\x: Rec X. X .\y: Bool .y) ({a = (pred 1) , b = (let u = false in u) , c =  0 }.b) ) (((\x: Bool .\y: Unit .x) (( \f: Bool .((f true ) (fix (\x: Unit . false )) ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Bool .((f (let u = false in u) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .a)))) ) ) (\a: Nat .\b: Nat .b)) then (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f (let u = 1 in 0) ) (pred 0) ) ) (\a: Rec X. X .\b: Bool .a)) )) )) else (pred ({a = (fix (\x: Nat . 1 )) , b = (( \f: Unit .((f false ) (if true then true else true) ) ) (\a: Unit .\b: Rec X. X .a)) }.a)))
(let u = (let u = ({a = ({a = 0 , b = ({a = true , b = 1 }.a) , c =  1 }.b) , b = (pred ({a = 1 , b = false }.a)) }.b) in (fix (\x: Bool . (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ))) in u)
({a = (((\x: Unit .\y: Nat .x) ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = true }.b) ) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) in true)) , b = ({a = (( \f: Bool .((f ({a = 0 , b = false , c = 0 }.c) ) (let u = 1 in 0) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = (let u = 0 in u) }.b) }.b) }.b)
({a = (((\x: Nat .\y: Bool .x) (succ (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) ) ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Bool .\y: Bool .y) true ) (((\x: Bool .\y: Unit .x) true ) false)) }.b)) , b = (let u = (((\x: Bool .\y: Rec X. X .y) (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) in false) ) ({a = 1 , b = 0 }.b)) in ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) , b = (unfold [ Unit ] (fold [ Nat ] false )) }.b)) }.b)
(let u = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) in u) in u)
({a = (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) 1 ) false) ) (if (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) then 0 else 1) ) ) (\a: Nat .\b: Unit .b)) in u) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f (let u = false in u) ) (let u = 0 in true) ) ) (\a: Bool .\b: Rec X. X .a)) )) , c =  ({a = (fix (\x: Nat . (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) , b = (let u = (succ (succ 0)) in (((\x: Nat .\y: Nat .x) (if true then false else true) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) false))) }.a) }.b)
(case <r = ({a = (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) , b = ({a = (fix (\x: Unit . (unfold [ Unit ] (fold [ Bool ] 1 )) )) , b = (( \f: Nat .((f (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Unit .\b: Nat .a)) , c = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = false }.a) }.c) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (let u = (( \f: Bool .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .a)) in (fix (\x: Rec X. X . ({a = ({a = 1 , b = false , c =  0 }.b) , b = (((\x: Nat .\y: Unit .x) false ) true) }.b) ))) ) ({a = (let u = ({a = 1 , b = false }.a) in (let u = true in u)) , b = (succ 0) }.a) ) ) (\a: Bool .\b: Bool .b))
(iszero (pred ({a = ({a = true , b = 0 }.b) , b = (let u = true in u) , c = ({a = 1 , b = 1 }.b) }.c)))
(let u = ({a = (fix (\x: Rec X. X . ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = true }.b) )) , b = ({a = ({a = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 1 , b = (fix (\x: Nat . false )) }.a) }.a) , b = (case <r = (unfold [ Nat ] (fold [ Bool ] false )) > as Bool of < l = x > => x | < r = y > => y) }.b) }.b) in (let u = ({a = (let u = 1 in false) , b = (fix (\x: Rec X. X . (let u = 0 in 0) )) }.b) in u))
(( \f: Rec X. X .((f (let u = ({a = ({a = (if false then 0 else 1) , b = (iszero 1) , c = 1 }.c) , b = (if (((\x: Rec X. X .\y: Rec X. X .x) false ) false) then false else true) }.a) in u) ) (( \f: Nat .((f ({a = ({a = false , b = 0 }.a) , b = (let u = 1 in u) }.b) ) (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = true , c =  0 }.b) )) then (case <l = (((\x: Bool .\y: Unit .x) 0 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) else (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Nat .\b: Unit .b))
(let u = (if ({a = (iszero 0) , b = (fix (\x: Unit . 0 )) }.a) then (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] 1 )) )) else (((\x: Bool .\y: Unit .x) (let u = 1 in u) ) ({a = 1 , b = false , c =  1 }.b))) in (let u = (fix (\x: Rec X. X . ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false }.b) )) in (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) > as Rec X. X of < l = x > => x | < r = y > => y)))
(case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (case <l = (if ({a = 0 , b = false }.b) then ({a = 1 , b = 1 }.b) else (((\x: Unit .\y: Unit .x) 0 ) true)) > as Unit of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Unit . ({a = (( \f: Bool .((f (((\x: Bool .\y: Unit .x) ({a = 1 , b = 1 }.b) ) true) ) (((\x: Unit .\y: Rec X. X .x) 0 ) false) ) ) (\a: Unit .\b: Nat .b)) , b = (case <r = (iszero (if false then 1 else 0)) > as Unit of < l = x > => x | < r = y > => y) , c = ({a = (if false then 0 else 0) , b = true , c = (fix (\x: Nat . 0 )) }.c) }.c) ))
(let u = (unfold [ Rec X. X ] (fold [ Nat ] ({a = (if false then (let u = 0 in true) else (((\x: Nat .\y: Rec X. X .x) true ) false)) , b = (( \f: Nat .((f ({a = 1 , b = false , c = 1 }.c) ) (succ 0) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) )) in u)
(( \f: Bool .((f ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (succ (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) }.b) ) (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) in (let u = true in (let u = 1 in 1))) ) ) (\a: Unit .\b: Unit .a))
(( \f: Unit .((f (( \f: Bool .((f (( \f: Nat .((f (((\x: Bool .\y: Bool .x) 1 ) false) ) (if true then 1 else 0) ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Nat .((f (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) 0 ) true) ) ({a = 0 , b = true }.a) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .a)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Nat .((f (let u = ({a = false , b = 0 }.a) in (((\x: Nat .\y: Unit .y) true ) 1)) ) ({a = 0 , b = ({a = 0 , b = false , c = 1 }.c) }.b) ) ) (\a: Unit .\b: Bool .b)) )) ) ) (\a: Bool .\b: Rec X. X .a))
(case <r = (((\x: Rec X. X .\y: Unit .x) ({a = (let u = true in u) , b = (let u = 1 in u) }.a) ) ({a = (( \f: Unit .((f 1 ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Bool .\b: Nat .b)) , b = (let u = 1 in (((\x: Nat .\y: Rec X. X .y) false ) false)) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Nat .y) ({a = ({a = (let u = false in false) , b = (let u = 1 in 1) }.b) , b = (let u = ({a = true , b = false }.b) in u) }.b) ) (unfold [ Rec X. X ] (fold [ Nat ] (succ (unfold [ Unit ] (fold [ Bool ] (if false then 1 else 1) ))) )))
({a = ({a = (((\x: Unit .\y: Bool .y) (let u = 1 in false) ) 0) , b = (iszero ({a = 0 , b = true , c = 1 }.c)) }.a) , b = ({a = (( \f: Bool .((f false ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = false in false) }.b) }.a)
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (succ (case <l = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) > as Unit of < l = x > => x | < r = y > => y)) ))
(( \f: Unit .((f (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] false )) )) in (((\x: Unit .\y: Bool .y) ({a = 0 , b = true , c =  1 }.b) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) ) ({a = ({a = ({a = 1 , b = true , c =  0 }.b) , b = (succ 0) }.b) , b = ({a = ({a = 0 , b = true , c =  (succ 0) }.b) , b = (((\x: Nat .\y: Bool .x) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (iszero 1)) }.b) }.a) ) ) (\a: Unit .\b: Nat .a))
(let u = (let u = (let u = (((\x: Bool .\y: Rec X. X .y) (let u = 0 in false) ) (fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .y) true ) 1) ))) in u) in u) in (case <r = ({a = 0 , b = (let u = false in true) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
(unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) in (iszero 0)) ) (( \f: Unit .((f (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) ) (((\x: Bool .\y: Unit .x) true ) true) ) ) (\a: Bool .\b: Unit .a)) ) ({a = 0 , b = (((\x: Nat .\y: Unit .x) false ) false) , c =  1 }.b) ) ) (\a: Bool .\b: Nat .a))) ))
(case <l = (((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .x) (succ 0) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false ))) ) (unfold [ Nat ] (fold [ Unit ] (case <r = (((\x: Nat .\y: Bool .y) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) ))) > as Bool of < l = x > => x | < r = y > => y)
(case <r = (fix (\x: Unit . ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) , c =  (pred 0) }.b) )) > as Unit of < l = x > => x | < r = y > => y)
(let u = (case <r = ({a = (unfold [ Bool ] (fold [ Unit ] (fix (\x: Unit . true )) )) , b = (let u = 1 in 0) }.a) > as Bool of < l = x > => x | < r = y > => y) in ({a = ({a = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = 0 }.b) , b = ({a = (let u = true in 1) , b = true , c =  1 }.b) , c =  (let u = ({a = 0 , b = true , c = 0 }.c) in (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true)) }.b))
(( \f: Rec X. X .((f (case <l = (succ (((\x: Rec X. X .\y: Nat .x) 0 ) (((\x: Unit .\y: Bool .y) false ) true))) > as Bool of < l = x > => x | < r = y > => y) ) (pred (((\x: Nat .\y: Unit .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 0 in u))) ) ) (\a: Unit .\b: Unit .a))
(( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = (pred 0) , b = (unfold [ Bool ] (fold [ Nat ] 1 )) }.b) )) ) (let u = (let u = (pred ({a = 0 , b = true , c = 0 }.c)) in u) in (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then 0 else 1)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(((\x: Rec X. X .\y: Nat .y) (fix (\x: Rec X. X . (( \f: Bool .((f (fix (\x: Unit . false )) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Unit .a)) )) ) (pred (((\x: Unit .\y: Bool .y) (let u = false in u) ) (((\x: Nat .\y: Unit .y) true ) 1))))
({a = (if (let u = (fix (\x: Rec X. X . true )) in (fix (\x: Unit . false ))) then (succ (((\x: Nat .\y: Bool .y) false ) 1)) else ({a = (((\x: Bool .\y: Bool .x) true ) true) , b = (let u = true in 1) }.b)) , b = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Unit ] ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) , b = ({a = (let u = 1 in 1) , b = true , c = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) }.c) }.b) )) ) (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .b)) }.b)
(let u = ({a = (case <l = (pred (succ 1)) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) )) , c = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) ) (if false then 0 else 0) ) ) (\a: Nat .\b: Bool .a)) }.c) in u)
(unfold [ Nat ] (fold [ Nat ] (case <l = ({a = (let u = (((\x: Nat .\y: Nat .y) true ) true) in (((\x: Nat .\y: Unit .y) true ) 0)) , b = (( \f: Unit .((f (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) false ) ) (\a: Unit .\b: Bool .b)) , c = (fix (\x: Unit . (let u = (pred 0) in u) )) }.c) > as Unit of < l = x > => x | < r = y > => y) ))
({a = (fix (\x: Rec X. X . (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (if true then 1 else 0)) )) , b = ({a = ({a = (let u = 0 in u) , b = (case <r = ({a = 0 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (succ 1) }.c) , b = (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Nat .y) true ) false) ) false) }.a) }.b)
({a = (( \f: Bool .((f (let u = (((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) true ) false) ) false) in (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) in u)) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .a)) , b = (let u = 0 in u) }.a) )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = ({a = 0 , b = (iszero 0) }.b) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.b)
(case <r = (let u = ({a = (pred (let u = true in 1)) , b = (pred 0) }.b) in ({a = (if true then (let u = 1 in true) else false) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in (if (let u = 0 in false) then (let u = false in 0) else 0)) in u)
(case <l = (succ (let u = (case <r = ({a = false , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = ({a = 1 , b = true , c = 1 }.c) in u))) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Unit . ({a = (( \f: Bool .((f (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a)) ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (succ ({a = 1 , b = 1 }.b)) }.b) ))
(let u = (if (case <r = (iszero (let u = 1 in 1)) > as Rec X. X of < l = x > => x | < r = y > => y) then (case <r = (unfold [ Nat ] (fold [ Rec X. X ] false )) > as Unit of < l = x > => x | < r = y > => y) else (unfold [ Nat ] (fold [ Bool ] (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) true ) false) )) ))) in (fix (\x: Nat . (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = true }.a) )) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) true ) 0) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Unit .a)) )))
(let u = (( \f: Nat .((f (((\x: Nat .\y: Bool .y) (let u = true in u) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = 1 in 0) ))) ) ({a = (unfold [ Unit ] (fold [ Nat ] true )) , b = (case <l = ({a = false , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Nat .\b: Bool .b)) in (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.b) )) in u))
(( \f: Bool .((f (((\x: Bool .\y: Unit .y) ({a = true , b = 0 }.a) ) (if (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) then (((\x: Unit .\y: Rec X. X .y) true ) 1) else (if false then 1 else 0))) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (( \f: Bool .((f (fix (\x: Nat . 0 )) ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = (let u = false in 1) }.a) }.a) )) ) ) (\a: Unit .\b: Nat .b))
(( \f: Unit .((f ({a = (if ({a = 1 , b = false }.b) then (let u = ({a = 0 , b = false }.b) in (((\x: Unit .\y: Rec X. X .x) 0 ) true)) else ({a = 0 , b = true , c = 1 }.c)) , b = (let u = (fix (\x: Bool . ({a = 0 , b = true , c = 0 }.c) )) in (pred 1)) }.b) ) ({a = (fix (\x: Rec X. X . (case <l = (fix (\x: Rec X. X . 0 )) > as Nat of < l = x > => x | < r = y > => y) )) , b = (if ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) then ({a = 0 , b = false }.b) else (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .a))) , c = (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .a)) in (succ 0)) }.c) ) ) (\a: Bool .\b: Unit .b))
({a = (( \f: Nat .((f (let u = (let u = 0 in false) in (if false then true else (iszero 1))) ) ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (unfold [ Nat ] (fold [ Unit ] true )) }.b) ) ) (\a: Unit .\b: Unit .b)) , b = ({a = (((\x: Unit .\y: Nat .y) (let u = false in u) ) (fix (\x: Bool . false ))) , b = (let u = (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Unit .y) false ) true) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) in (iszero (if true then 0 else 1))) }.b) }.b)
(((\x: Rec X. X .\y: Bool .x) (( \f: Rec X. X .((f (( \f: Bool .((f (if false then 1 else 0) ) (((\x: Unit .\y: Bool .y) true ) 0) ) ) (\a: Nat .\b: Unit .a)) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , c = ({a = true , b = 1 }.b) }.c) ) ) (\a: Bool .\b: Bool .a)) ) (if (unfold [ Unit ] (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] false )) )) then (fix (\x: Unit . false )) else ({a = 1 , b = true , c =  (if true then 0 else 0) }.b)))
(( \f: Nat .((f (if ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f 0 ) (let u = 1 in u) ) ) (\a: Bool .\b: Rec X. X .a)) }.a) then (((\x: Rec X. X .\y: Bool .y) (iszero 1) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a))) else (( \f: Rec X. X .((f (let u = 1 in 1) ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Bool .a))) ) (fix (\x: Nat . ({a = ({a = 1 , b = true , c = 1 }.c) , b = (( \f: Unit .((f (let u = true in false) ) (if true then false else true) ) ) (\a: Rec X. X .\b: Bool .a)) }.a) )) ) ) (\a: Unit .\b: Nat .b))
(((\x: Bool .\y: Unit .y) (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) )) ) (fix (\x: Bool . (fix (\x: Unit . false )) )) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) in (((\x: Unit .\y: Bool .y) true ) 1)) , b = (iszero (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) }.a))
(let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Rec X. X . (if (let u = false in u) then ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) else (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) )) )) in u)
((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = (let u = (succ 1) in 1) in (let u = (pred 0) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)))) ))
({a = ({a = (unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) 0 ) true) )) , b = (((\x: Bool .\y: Unit .y) false ) true) }.a) , b = (let u = (succ ({a = 0 , b = 0 }.b)) in ({a = ({a = false , b = 0 }.b) , b = (((\x: Rec X. X .\y: Bool .y) true ) (let u = true in u)) }.a)) }.b)
((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (pred (succ 0)) ))
(( \f: Rec X. X .((f (case <r = (let u = 1 in (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a))) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Bool ] (let u = (((\x: Bool .\y: Rec X. X .y) true ) true) in u) )) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = (let u = (let u = true in (let u = 0 in false)) in ({a = ({a = 1 , b = 1 }.b) , b = (let u = 0 in true) , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.b)) in u)
({a = ({a = (( \f: Rec X. X .((f (let u = 1 in (unfold [ Unit ] (fold [ Nat ] 0 ))) ) ({a = (pred 1) , b = (let u = true in (((\x: Unit .\y: Rec X. X .x) true ) true)) }.a) ) ) (\a: Nat .\b: Nat .b)) , b = (fix (\x: Nat . ({a = 1 , b = false , c =  1 }.b) )) }.b) , b = (unfold [ Rec X. X ] (fold [ Unit ] (pred (let u = 0 in 0)) )) }.a)
(if (case <r = (iszero (((\x: Rec X. X .\y: Bool .y) false ) 0)) > as Nat of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Rec X. X .y) ({a = (let u = 1 in u) , b = (if false then ({a = 1 , b = false , c =  0 }.b) else true) , c =  (let u = 1 in u) }.b) ) ({a = 1 , b = true }.b)) else (case <r = (((\x: Unit .\y: Unit .x) ({a = (iszero 0) , b = false }.b) ) ({a = true , b = true }.b)) > as Nat of < l = x > => x | < r = y > => y))
({a = (let u = (( \f: Unit .((f ({a = (let u = 1 in u) , b = (fix (\x: Nat . true )) , c =  ({a = 0 , b = 1 }.b) }.b) ) (unfold [ Bool ] (fold [ Unit ] ({a = true , b = 1 }.a) )) ) ) (\a: Bool .\b: Bool .b)) in (case <l = (let u = false in 1) > as Unit of < l = x > => x | < r = y > => y)) , b = (case <r = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = false , b = false }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) ({a = 1 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (succ (pred (let u = true in 1)))) )) }.b)
(if ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = ({a = (let u = 1 in u) , b = false }.b) , c =  ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = (let u = true in u) , c = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.c) }.b) then ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = (let u = false in 1) , b = (((\x: Rec X. X .\y: Nat .x) 1 ) false) }.b) in (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .b))) )) else ({a = (unfold [ Rec X. X ] (fold [ Bool ] false )) , b = (( \f: Bool .((f true ) (if true then false else true) ) ) (\a: Unit .\b: Bool .a)) }.b))
(let u = (((\x: Bool .\y: Rec X. X .x) (( \f: Nat .((f (case <l = (( \f: Unit .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) ({a = 1 , b = 1 }.b) ) ) (\a: Unit .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) ) (succ (let u = 1 in 1)) ) ) (\a: Rec X. X .\b: Bool .a)) ) (( \f: Bool .((f (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b))) ) (let u = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .b)) in (iszero 1)) ) ) (\a: Bool .\b: Unit .a))) in (fix (\x: Bool . ({a = ({a = 1 , b = true , c =  1 }.b) , b = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = false , c = 0 }.c) }.a) )))
(((\x: Bool .\y: Unit .y) ({a = (( \f: Nat .((f ({a = (let u = 0 in (if true then 0 else 1)) , b = (((\x: Unit .\y: Bool .x) true ) true) }.a) ) (case <l = (( \f: Rec X. X .((f (fix (\x: Nat . 0 )) ) (let u = true in 1) ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) , b = (let u = ({a = 0 , b = ({a = 0 , b = true }.b) , c =  0 }.b) in u) }.b) ) (((\x: Unit .\y: Nat .y) (if (( \f: Bool .((f (iszero (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) ) (((\x: Unit .\y: Rec X. X .x) (let u = 0 in false) ) false) ) ) (\a: Rec X. X .\b: Nat .b)) then (let u = (let u = 1 in u) in (let u = false in false)) else (((\x: Bool .\y: Bool .x) false ) (let u = false in false))) ) ({a = (succ 0) , b = (((\x: Unit .\y: Rec X. X .y) false ) true) }.a)))
(( \f: Unit .((f (( \f: Unit .((f (succ (pred 1)) ) (case <l = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) (fix (\x: Nat . 1 ))) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) ) (fix (\x: Nat . (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) )) ) ) (\a: Nat .\b: Nat .b))
(let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (((\x: Nat .\y: Rec X. X .x) 0 ) false) , b = (fix (\x: Nat . (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) )) , c = (pred (let u = true in 1)) }.c) )) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) , b = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) (fix (\x: Unit . 0 )) ) ) (\a: Rec X. X .\b: Nat .a)) }.a) )))
({a = (((\x: Unit .\y: Bool .x) ({a = (unfold [ Nat ] (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] 1 )) )) , b = (let u = ({a = 1 , b = 0 }.b) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) }.a) ) ({a = (succ 1) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) }.b)) , b = ({a = (let u = ({a = ({a = false , b = 0 }.a) , b = (let u = false in false) }.b) in (iszero (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false))) , b = ({a = (iszero (((\x: Nat .\y: Unit .y) true ) 0)) , b = ({a = (let u = 0 in 0) , b = ({a = 1 , b = true }.b) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) }.a) }.b) }.a)
({a = (pred (((\x: Bool .\y: Bool .x) (((\x: Bool .\y: Bool .x) 0 ) true) ) (((\x: Nat .\y: Nat .x) true ) false))) , b = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Nat . (unfold [ Unit ] (fold [ Rec X. X ] true )) )) ) ({a = ({a = 1 , b = true }.a) , b = false , c =  ({a = 0 , b = true }.a) }.b)) }.a)
(((\x: Nat .\y: Unit .x) (case <r = ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (((\x: Bool .\y: Nat .x) (((\x: Rec X. X .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) (let u = false in u)) ) (let u = (fix (\x: Bool . (((\x: Bool .\y: Rec X. X .x) 0 ) true) )) in (let u = true in false))) ) (let u = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Nat .a)) in ({a = ({a = true , b = 1 }.b) , b = ({a = 1 , b = false , c =  0 }.b) }.b)) ) ) (\a: Bool .\b: Nat .b)))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = ({a = (fix (\x: Unit . 1 )) , b = false }.a) , b = (let u = 1 in (if true then true else true)) }.a) , b = ({a = (((\x: Nat .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Nat ] 1 )) ) (((\x: Bool .\y: Rec X. X .x) true ) true)) , b = (iszero 0) }.a) }.b) ))
({a = (( \f: Nat .((f (pred (succ 1)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = 1 }.b) )) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Nat .y) (let u = ({a = 0 , b = ({a = true , b = true }.b) }.b) in ({a = false , b = 1 }.a)) ) ({a = ({a = (let u = true in true) , b = 1 }.b) , b = ({a = false , b = 1 }.a) }.b)) , c = ({a = (( \f: Nat .((f (let u = false in 1) ) ({a = 1 , b = false , c = (((\x: Unit .\y: Bool .x) 0 ) true) }.c) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = ({a = false , b = (((\x: Bool .\y: Unit .x) 1 ) true) }.a) }.a) }.b) }.c)
(((\x: Nat .\y: Unit .x) (if ({a = (((\x: Unit .\y: Nat .x) false ) ({a = false , b = true }.b)) , b = (if false then false else false) }.b) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Bool ] 1 )) )) else (((\x: Nat .\y: Rec X. X .y) true ) 0)) ) (((\x: Nat .\y: Rec X. X .x) (let u = (if false then true else false) in ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false ))) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] false )) ))))
(let u = (case <r = (fix (\x: Unit . ({a = ({a = 1 , b = false }.a) , b = (fix (\x: Bool . true )) , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b) )) > as Bool of < l = x > => x | < r = y > => y) in u)
(( \f: Nat .((f (( \f: Unit .((f (if ({a = true , b = false }.b) then (((\x: Bool .\y: Rec X. X .y) ({a = true , b = false }.b) ) ({a = 0 , b = true }.a)) else ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Nat . 0 )) ))) ) (let u = (pred 0) in u) ) ) (\a: Rec X. X .\b: Unit .b)) ) (succ (( \f: Nat .((f (((\x: Unit .\y: Unit .y) false ) 0) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = 1 }.b) )) ) ) (\a: Bool .\b: Nat .b))) ) ) (\a: Nat .\b: Bool .b))
(( \f: Unit .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = (((\x: Unit .\y: Rec X. X .y) ({a = true , b = true }.b) ) 1) , b = ({a = 0 , b = false , c =  ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.b) }.b) )) ) (((\x: Rec X. X .\y: Bool .x) (let u = ({a = 1 , b = false }.a) in (let u = true in u)) ) (if (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) true ) false) )) then (case <r = (( \f: Nat .((f (iszero 1) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) else ({a = 1 , b = false }.b))) ) ) (\a: Nat .\b: Nat .b))
(let u = ({a = (unfold [ Bool ] (fold [ Bool ] (let u = (iszero 0) in 0) )) , b = (( \f: Bool .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Bool .b)) , c =  (let u = (let u = false in true) in ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = (let u = 0 in u) }.b)) }.b) in u)
({a = (if (let u = (let u = 0 in u) in (((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Nat .y) true ) false) ) false)) then ({a = false , b = 1 }.b) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 ))) , b = (iszero (succ (pred 1))) }.b)
(((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Nat .x) (fix (\x: Unit . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) )) ) ({a = ({a = 0 , b = false , c = 0 }.c) , b = (fix (\x: Nat . false )) }.b)) ) ({a = (case <r = ({a = 1 , b = ({a = false , b = 1 }.a) , c =  1 }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (if ({a = 1 , b = false , c =  1 }.b) then (succ (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) else (((\x: Rec X. X .\y: Unit .x) 1 ) true)) }.a))
(unfold [ Bool ] (fold [ Nat ] (let u = (((\x: Bool .\y: Bool .x) (fix (\x: Rec X. X . 1 )) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .a)) ))) in u) ))
(iszero (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) ({a = false , b = 0 }.b)) )))
(if (iszero (((\x: Unit .\y: Bool .x) (fix (\x: Nat . (let u = 1 in 0) )) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y))) then ({a = ({a = (fix (\x: Unit . 0 )) , b = (case <r = ({a = true , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) , c = (((\x: Nat .\y: Nat .x) 1 ) true) }.c) , b = (( \f: Bool .((f (let u = (unfold [ Nat ] (fold [ Bool ] true )) in (fix (\x: Bool . true ))) ) (let u = ({a = 1 , b = false }.b) in u) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) else ({a = (succ (let u = 0 in u)) , b = ({a = (let u = true in 0) , b = false }.b) , c =  (let u = false in (((\x: Rec X. X .\y: Unit .x) 1 ) false)) }.b))
(((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f (((\x: Nat .\y: Unit .y) (if ({a = 1 , b = true }.b) then false else false) ) ({a = 0 , b = true , c =  0 }.b)) ) ({a = ({a = 1 , b = false }.a) , b = (if (let u = true in u) then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else false) }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (case <l = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f ({a = 1 , b = (((\x: Rec X. X .\y: Nat .y) false ) true) }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .a)) , c = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) in u) }.c))
(if (let u = (( \f: Nat .((f (((\x: Nat .\y: Nat .y) false ) 0) ) (((\x: Nat .\y: Rec X. X .x) 0 ) (unfold [ Nat ] (fold [ Bool ] false ))) ) ) (\a: Bool .\b: Rec X. X .a)) in (fix (\x: Unit . false ))) then (case <l = (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f (fix (\x: Rec X. X . 0 )) ) 1 ) ) (\a: Unit .\b: Nat .a)) )) > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = (if false then 0 else 1) in u))
(((\x: Unit .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) (pred 0) ) (if true then (let u = false in u) else true)) )) ) ({a = (( \f: Unit .((f (succ 1) ) (((\x: Rec X. X .\y: Unit .y) true ) 1) ) ) (\a: Bool .\b: Nat .b)) , b = (iszero (pred (pred 1))) }.b))
(iszero ({a = (succ ({a = (((\x: Unit .\y: Unit .y) true ) 0) , b = false }.a)) , b = ({a = false , b = false }.b) }.a))
(let u = ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = 1 }.b) , b = ({a = ({a = 1 , b = false , c =  0 }.b) , b = (((\x: Bool .\y: Bool .y) false ) false) }.b) }.b) in u)
(case <l = (pred (( \f: Rec X. X .((f (case <l = (succ 0) > as Bool of < l = x > => x | < r = y > => y) ) ({a = true , b = 1 }.b) ) ) (\a: Bool .\b: Rec X. X .a))) > as Bool of < l = x > => x | < r = y > => y)
({a = (let u = ({a = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = 1 in false) , c =  0 }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = 0 in true) )) }.b) in (if ({a = (fix (\x: Nat . false )) , b = ({a = 1 , b = false }.a) }.a) then (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) false ) 1) )) else ({a = ({a = (if true then false else false) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.b) , b = (((\x: Rec X. X .\y: Nat .y) false ) 0) }.b))) , b = (if (let u = (fix (\x: Rec X. X . 0 )) in (let u = (let u = true in u) in (iszero 1))) then (let u = (let u = ({a = 1 , b = 1 }.b) in u) in (let u = ({a = 0 , b = 0 }.b) in u)) else ({a = ({a = 1 , b = true , c =  0 }.b) , b = ({a = 0 , b = 1 }.b) }.b)) }.b)
(iszero (((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) ({a = 1 , b = true , c =  1 }.b)) ) (((\x: Rec X. X .\y: Unit .x) 0 ) (unfold [ Unit ] (fold [ Unit ] true )))))
(succ ({a = (unfold [ Bool ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) )) , b = (let u = ({a = (if true then true else true) , b = (let u = true in false) }.b) in ({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Bool .y) false ) true) )) , b = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.b)) }.b))
(let u = ({a = ({a = ({a = (let u = 1 in 0) , b = (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) in true) , c = (let u = (succ 1) in 0) }.c) , b = ({a = (fix (\x: Bool . 1 )) , b = (iszero 0) }.a) }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) false ) (fix (\x: Unit . true ))) )) }.b) in ({a = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = (unfold [ Nat ] (fold [ Unit ] 1 )) }.b) , b = (((\x: Rec X. X .\y: Nat .y) (let u = false in u) ) (iszero 0)) }.b))
(pred (((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) true ) true) )) ) (succ (let u = 1 in (pred 1)))))
(fix (\x: Rec X. X . ({a = (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) in u) , b = (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) (fix (\x: Unit . 1 )) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) ({a = (let u = false in 0) , b = (let u = false in true) }.a) ) ) (\a: Unit .\b: Unit .a)) }.b) ))
(((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = (((\x: Nat .\y: Nat .x) ({a = true , b = true }.b) ) true) , c =  (let u = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) in ({a = 0 , b = true }.a)) }.b) ) (let u = ({a = ({a = 1 , b = false }.a) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.a) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false ))) ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = (((\x: Unit .\y: Nat .x) (if ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) then true else (unfold [ Nat ] (fold [ Rec X. X ] false ))) ) (fix (\x: Rec X. X . false ))) in (let u = (iszero 1) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )))))
(((\x: Bool .\y: Rec X. X .y) (( \f: Nat .((f (( \f: Unit .((f (let u = false in u) ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) ) (((\x: Unit .\y: Rec X. X .y) (((\x: Nat .\y: Unit .x) (let u = 0 in false) ) (fix (\x: Bool . true ))) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ))) ) ) (\a: Rec X. X .\b: Unit .a)) ) (if (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Rec X. X .y) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) (let u = false in true)) ) (if true then false else true)) then ({a = true , b = 1 }.a) else (fix (\x: Rec X. X . (let u = false in u) ))))
(iszero (( \f: Unit .((f (fix (\x: Bool . ({a = 1 , b = false , c = 1 }.c) )) ) ({a = (if (let u = (if false then true else false) in (unfold [ Rec X. X ] (fold [ Nat ] true ))) then ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) , b = (( \f: Bool .((f ({a = 1 , b = 1 }.b) ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) ) ) (\a: Bool .\b: Nat .a)))
(let u = (case <r = (let u = (let u = 1 in false) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) in u)
({a = (((\x: Rec X. X .\y: Unit .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .x) 1 ) (unfold [ Bool ] (fold [ Unit ] false ))) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = false , b = 1 }.a) ))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = (iszero 0) in u) )) , c = (( \f: Nat .((f (((\x: Bool .\y: Unit .y) (fix (\x: Nat . (let u = false in u) )) ) (unfold [ Bool ] (fold [ Nat ] 1 ))) ) (let u = (succ (pred ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 )))) in u) ) ) (\a: Nat .\b: Unit .b)) }.c)
(((\x: Bool .\y: Nat .y) ({a = (( \f: Rec X. X .((f (fix (\x: Nat . (((\x: Unit .\y: Rec X. X .y) true ) 0) )) ) (unfold [ Nat ] (fold [ Rec X. X ] (succ 0) )) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = (pred (succ 0)) , b = (let u = (let u = 1 in false) in u) , c =  (unfold [ Bool ] (fold [ Unit ] 0 )) }.b) , c =  (let u = (pred (unfold [ Nat ] (fold [ Unit ] 1 ))) in u) }.b) ) (( \f: Unit .((f ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = true }.a) , b = (let u = 0 in (let u = 0 in u)) }.b) ) (((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Nat ] false )) ) (iszero 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = false , c = 0 }.c) ))) ) ) (\a: Bool .\b: Unit .a)))
(fix (\x: Bool . (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) ({a = 1 , b = false , c =  1 }.b) ) (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) (((\x: Nat .\y: Rec X. X .y) (( \f: Rec X. X .((f (let u = 1 in false) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Bool .b)) ) (case <r = (((\x: Unit .\y: Nat .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .b)) ))
(( \f: Nat .((f ({a = (unfold [ Unit ] (fold [ Nat ] (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) in false) )) , b = ({a = (let u = 1 in (unfold [ Bool ] (fold [ Unit ] 1 ))) , b = ({a = ({a = 0 , b = false }.b) , b = true }.b) }.a) }.b) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (if true then 0 else 1) )) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ))) ) ) (\a: Unit .\b: Nat .a))
(((\x: Unit .\y: Unit .x) (case <r = ({a = (let u = 0 in u) , b = (let u = 1 in (unfold [ Rec X. X ] (fold [ Nat ] false ))) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (iszero 0) , b = (let u = (let u = false in true) in u) }.b))
(pred ({a = (succ (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = (let u = (iszero 0) in true) , b = (((\x: Nat .\y: Bool .y) (if true then false else true) ) (if false then 1 else 1)) }.a) , c = (pred (unfold [ Unit ] (fold [ Nat ] 0 ))) }.c))
({a = ({a = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = 0 , b = 0 }.b) )) }.b) , b = (let u = (let u = (((\x: Rec X. X .\y: Nat .x) (pred 0) ) false) in (let u = (pred 0) in (unfold [ Rec X. X ] (fold [ Bool ] 0 )))) in (pred (( \f: Nat .((f (((\x: Unit .\y: Bool .x) 0 ) false) ) 0 ) ) (\a: Unit .\b: Nat .b)))) }.b)
(let u = (((\x: Bool .\y: Bool .x) ({a = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) , c = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.c) , b = (((\x: Nat .\y: Rec X. X .y) true ) true) }.a) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = ({a = 0 , b = false , c =  0 }.b) }.b) ))) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (( \f: Rec X. X .((f (if false then 1 else 1) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .a)) , b = ({a = 0 , b = false , c =  1 }.b) , c = (let u = (succ 1) in u) }.c) )))
({a = (let u = (succ (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a))) in (fix (\x: Unit . 1 ))) , b = (((\x: Nat .\y: Nat .x) ({a = (let u = (((\x: Nat .\y: Nat .y) true ) false) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (fix (\x: Nat . true )) , c =  (succ 0) }.b) ) ({a = (let u = ({a = 1 , b = true , c = 0 }.c) in u) , b = (if ({a = true , b = 0 }.a) then true else (let u = 1 in true)) }.b)) , c =  (( \f: Bool .((f (fix (\x: Bool . 0 )) ) ({a = (if true then false else false) , b = (((\x: Unit .\y: Nat .y) (fix (\x: Rec X. X . false )) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (( \f: Bool .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (if false then true else true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u) ))
(pred (succ (case <l = ({a = (pred 0) , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y)))
({a = (case <l = (if (if ({a = true , b = false }.b) then false else (case <r = true > as Bool of < l = x > => x | < r = y > => y)) then (if ({a = true , b = 0 }.a) then (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) else 1) else (((\x: Rec X. X .\y: Bool .x) 0 ) false)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Unit .\y: Unit .x) ({a = 1 , b = true , c = 0 }.c) ) (fix (\x: Unit . false ))) }.b)) , c = ({a = (if (if true then false else true) then (pred ({a = 0 , b = false , c = 1 }.c)) else (pred ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 )))) , b = (fix (\x: Rec X. X . (let u = (let u = true in u) in (let u = false in true)) )) }.a) }.c)
(((\x: Rec X. X .\y: Nat .y) (let u = (case <l = (((\x: Bool .\y: Rec X. X .x) 0 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = ({a = 1 , b = 1 }.b) , b = ({a = false , b = true }.b) }.b)) ) (if (((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Nat .y) (let u = 1 in false) ) (iszero 0)) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) then (iszero (let u = (unfold [ Nat ] (fold [ Unit ] 0 )) in (if true then 0 else 0))) else (((\x: Rec X. X .\y: Bool .x) (((\x: Rec X. X .\y: Unit .x) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) ) false) ) (let u = true in u))))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Rec X. X ] (pred (let u = 0 in u)) )) ))
(let u = (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) ({a = 0 , b = 1 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (if true then (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) else ({a = 0 , b = false , c = 1 }.c)) ) ) (\a: Unit .\b: Rec X. X .a)) in u)
(let u = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = 0 }.b) )) , b = (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) , b = (let u = (let u = 1 in false) in u) , c = (pred 0) }.c) }.b) in ({a = (case <l = (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Bool .y) false ) 0) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ))) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = true , c =  0 }.b) ) (let u = false in u)) else (((\x: Unit .\y: Rec X. X .x) true ) false)) )) , c = (succ (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.c))
({a = (iszero (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a))) , b = ({a = ({a = ({a = true , b = 0 }.a) , b = (pred 1) }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (let u = false in 1) , b = ({a = 0 , b = false , c =  1 }.b) , c =  (let u = true in 0) }.b) )) , c =  (pred (unfold [ Unit ] (fold [ Unit ] 1 ))) }.b) }.b)
(if (let u = ({a = (fix (\x: Rec X. X . 0 )) , b = ({a = (iszero 1) , b = ({a = 0 , b = true , c =  1 }.b) }.b) }.a) in (fix (\x: Rec X. X . ({a = (let u = false in true) , b = (iszero 1) }.b) ))) then (((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Bool .y) (( \f: Unit .((f (iszero 1) ) true ) ) (\a: Unit .\b: Bool .a)) ) (unfold [ Nat ] (fold [ Rec X. X ] false ))) ) (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y)) else (unfold [ Bool ] (fold [ Rec X. X ] ({a = (fix (\x: Unit . 0 )) , b = (if true then false else true) , c =  (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) )))
({a = (let u = (if (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) then ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) else ({a = 1 , b = false , c = 1 }.c)) in ({a = (((\x: Bool .\y: Nat .x) ({a = 1 , b = false }.a) ) true) , b = ({a = (let u = true in u) , b = (((\x: Unit .\y: Unit .y) false ) 0) }.a) }.b)) , b = (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f (iszero (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) ) (let u = false in true) ) ) (\a: Bool .\b: Nat .a)) ) ({a = (let u = (let u = 1 in u) in u) , b = (((\x: Bool .\y: Rec X. X .x) false ) false) , c =  ({a = 0 , b = false }.a) }.b)) }.b)
(((\x: Rec X. X .\y: Nat .y) ({a = (let u = ({a = false , b = 1 }.a) in u) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = true , b = false }.b) )) }.b) ) (fix (\x: Bool . (let u = (let u = true in false) in u) )))
(let u = (let u = (let u = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) in u) in (( \f: Bool .((f (let u = (let u = 0 in u) in (let u = ({a = false , b = 1 }.b) in true)) ) (let u = 0 in false) ) ) (\a: Nat .\b: Bool .a))) in (( \f: Unit .((f ({a = ({a = ({a = 0 , b = 0 }.b) , b = true , c =  (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) , b = (( \f: Rec X. X .((f (fix (\x: Nat . 0 )) ) (let u = 1 in 0) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] 1 )) )) ) ) (\a: Unit .\b: Rec X. X .b)))
(let u = (case <r = (( \f: Nat .((f (let u = true in u) ) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Rec X. X . (case <r = (let u = ({a = 0 , b = false }.a) in true) > as Unit of < l = x > => x | < r = y > => y) )))
(let u = (unfold [ Nat ] (fold [ Nat ] ({a = (((\x: Nat .\y: Unit .x) false ) true) , b = ({a = 1 , b = false , c =  1 }.b) }.b) )) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) 0)) , b = (fix (\x: Bool . (unfold [ Unit ] (fold [ Nat ] true )) )) , c =  (pred (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a))) }.b) )))
(iszero ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = 0 }.b) )) , b = ({a = (( \f: Unit .((f ({a = true , b = (((\x: Unit .\y: Bool .x) false ) false) }.b) ) (if false then (unfold [ Rec X. X ] (fold [ Unit ] false )) else false) ) ) (\a: Nat .\b: Bool .a)) , b = (if ({a = true , b = 0 }.a) then (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) else (let u = (unfold [ Rec X. X ] (fold [ Unit ] true )) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y))) }.b) , c = ({a = ({a = 1 , b = false }.b) , b = (((\x: Nat .\y: Nat .y) false ) 0) }.b) }.c))
(( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) false ) ({a = true , b = 1 }.a)) )) ) ({a = (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (let u = (((\x: Bool .\y: Nat .x) 0 ) true) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)))) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) in u) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Nat .y) ({a = (fix (\x: Rec X. X . (((\x: Unit .\y: Bool .x) 0 ) true) )) , b = (( \f: Bool .((f ({a = true , b = 0 }.a) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Nat .b)) }.b) ) (iszero ({a = (pred 0) , b = 0 }.b))) ) (let u = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) in (((\x: Bool .\y: Bool .x) (if false then true else true) ) (if true then true else false))))
({a = (iszero (let u = (succ 1) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )))) , b = ({a = (unfold [ Unit ] (fold [ Bool ] 1 )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Unit . false )) )) }.a) }.a)
(( \f: Nat .((f (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Bool .y) ({a = false , b = true }.b) ) (fix (\x: Rec X. X . 1 ))) ) (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) in (((\x: Unit .\y: Nat .x) true ) true))) ) (((\x: Rec X. X .\y: Bool .y) ({a = (let u = (pred 1) in u) , b = (iszero 1) , c =  (( \f: Unit .((f 1 ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .a)) }.b) ) (((\x: Bool .\y: Unit .x) ({a = (if false then 0 else 0) , b = false }.a) ) (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = false , c =  0 }.b) )))) ) ) (\a: Unit .\b: Rec X. X .b))
(let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = (let u = false in 1) in ({a = 0 , b = true , c = 0 }.c)) )) )) in u)
(unfold [ Nat ] (fold [ Rec X. X ] ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) , b = (let u = (( \f: Rec X. X .((f (if true then false else true) ) (let u = true in false) ) ) (\a: Bool .\b: Nat .b)) in u) }.a) ))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred (pred 0)) )) , b = (( \f: Unit .((f ({a = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , b = (let u = false in 0) }.a) ) (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) , c =  (((\x: Rec X. X .\y: Bool .x) ({a = ({a = 1 , b = 1 }.b) , b = ({a = 1 , b = true }.b) }.a) ) ({a = (if true then 1 else 1) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  0 }.b)) }.b)
(let u = (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Nat .x) (unfold [ Unit ] (fold [ Nat ] true )) ) (unfold [ Nat ] (fold [ Bool ] false ))) ) (((\x: Unit .\y: Nat .x) (unfold [ Nat ] (fold [ Bool ] false )) ) (iszero 1))) in (if (let u = (((\x: Unit .\y: Unit .y) true ) (fix (\x: Nat . false ))) in u) then (((\x: Nat .\y: Unit .x) 1 ) true) else (unfold [ Nat ] (fold [ Rec X. X ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ))))
(let u = (( \f: Unit .((f (let u = (if true then (let u = false in u) else false) in u) ) (iszero (pred 1)) ) ) (\a: Unit .\b: Nat .a)) in (let u = (let u = (if false then 0 else 1) in true) in ({a = ({a = 0 , b = 1 }.b) , b = ({a = (succ 0) , b = true }.b) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) )) }.c)))
(( \f: Bool .((f ({a = ({a = (let u = (let u = false in 1) in u) , b = (pred 0) }.b) , b = ({a = ({a = 1 , b = 1 }.b) , b = (unfold [ Unit ] (fold [ Nat ] true )) , c =  (((\x: Bool .\y: Rec X. X .x) 0 ) false) }.b) }.b) ) (let u = ({a = (let u = 0 in u) , b = 0 }.b) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = true }.b) ))) ) ) (\a: Unit .\b: Bool .b))
(case <l = (succ (let u = 0 in u)) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Bool .x) (let u = (let u = ({a = 1 , b = false , c = 1 }.c) in (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .a))) in (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 0 in true) )) ))) ) (let u = (let u = (( \f: Bool .((f (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) true ) ) (\a: Bool .\b: Bool .b)) in u) in ({a = (((\x: Nat .\y: Rec X. X .x) true ) false) , b = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .b)) }.b)))
({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = true , b = (let u = 1 in u) }.b) , b = (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.b) )) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = (fix (\x: Bool . false )) in ({a = true , b = 0 }.a)) )) }.b)
({a = (((\x: Nat .\y: Unit .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (if false then false else false) )) ) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) in (fix (\x: Bool . (((\x: Bool .\y: Nat .y) true ) false) )))) , b = (case <l = ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = (if false then 1 else 0) }.b) > as Unit of < l = x > => x | < r = y > => y) }.a)
(unfold [ Unit ] (fold [ Unit ] ({a = (( \f: Unit .((f (fix (\x: Bool . 0 )) ) (((\x: Nat .\y: Bool .y) ({a = false , b = false }.b) ) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Unit .\y: Unit .y) ({a = (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = false }.b) }.b) ) ({a = 0 , b = false , c =  ({a = 1 , b = 1 }.b) }.b)) , c = (pred (( \f: Unit .((f ({a = 0 , b = 1 }.b) ) (fix (\x: Nat . 0 )) ) ) (\a: Nat .\b: Bool .a))) }.c) ))
(( \f: Unit .((f ({a = (let u = 1 in true) , b = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) in (let u = 1 in true)) }.b) ) (fix (\x: Rec X. X . ({a = (let u = false in true) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.a) )) ) ) (\a: Nat .\b: Nat .b))
(case <r = (if ({a = (((\x: Nat .\y: Bool .x) true ) true) , b = (( \f: Rec X. X .((f true ) (let u = 1 in true) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) then ({a = ({a = (( \f: Unit .((f ({a = true , b = 1 }.b) ) (pred 1) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Unit .\y: Unit .y) false ) false) }.b) , b = (let u = (if true then true else true) in 0) }.a) else (( \f: Rec X. X .((f (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) ({a = ({a = 1 , b = 0 }.b) , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) true ) true) ) (let u = 1 in false) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Unit .b))) > as Unit of < l = x > => x | < r = y > => y)
((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (if (( \f: Unit .((f (if false then true else false) ) false ) ) (\a: Rec X. X .\b: Unit .a)) then ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .x) false ) false) )) else (let u = ({a = 0 , b = false , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) in u)) ))
(fix (\x: Bool . ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) , b = (((\x: Unit .\y: Bool .x) ({a = false , b = 1 }.b) ) ({a = (let u = false in 1) , b = true , c =  0 }.b)) }.a) ))
(((\x: Nat .\y: Unit .y) ({a = ({a = (let u = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .b)) in (succ ({a = false , b = 1 }.b))) , b = ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) }.b) }.b) , b = (let u = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) in (let u = true in 1)) }.a) ) ({a = ({a = (pred 0) , b = (let u = (unfold [ Unit ] (fold [ Unit ] false )) in u) , c =  (if true then 0 else 1) }.b) , b = ({a = ({a = 0 , b = true }.a) , b = (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) , c = ({a = 0 , b = 1 }.b) }.c) }.b))
(((\x: Bool .\y: Nat .y) ({a = (let u = (fix (\x: Rec X. X . false )) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = ({a = (fix (\x: Nat . 1 )) , b = (fix (\x: Nat . true )) }.b) , c =  (let u = (let u = 1 in u) in (( \f: Rec X. X .((f (let u = 0 in u) ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Nat .a))) }.b) ) (iszero (fix (\x: Unit . (succ 1) ))))
(((\x: Nat .\y: Unit .y) (let u = (((\x: Rec X. X .\y: Bool .x) ({a = (((\x: Rec X. X .\y: Nat .y) false ) true) , b = (let u = 1 in u) }.a) ) (let u = (let u = 1 in 1) in (let u = 1 in false))) in (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (if false then true else false) ) ) (\a: Rec X. X .\b: Bool .b))) ) (iszero (case <l = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y)))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Nat .((f ({a = 0 , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) , c = (let u = 0 in 0) }.c) ) ({a = (pred 1) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
(fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] (pred (unfold [ Unit ] (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ))) )) ))
(( \f: Nat .((f (let u = (( \f: Rec X. X .((f (succ (let u = 1 in u)) ) (((\x: Nat .\y: Nat .y) (( \f: Unit .((f (((\x: Unit .\y: Bool .y) false ) false) ) (let u = true in u) ) ) (\a: Bool .\b: Nat .a)) ) (succ 0)) ) ) (\a: Rec X. X .\b: Unit .a)) in u) ) (( \f: Rec X. X .((f ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = ({a = 1 , b = 1 }.b) }.b) ) (unfold [ Rec X. X ] (fold [ Unit ] (pred ({a = 0 , b = true }.a)) )) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .b))
(( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) (fix (\x: Rec X. X . true ))) )) ) (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Nat . true )) )) )) ) ) (\a: Rec X. X .\b: Bool .a))
(let u = (fix (\x: Unit . (iszero ({a = 0 , b = 1 }.b)) )) in u)
(((\x: Rec X. X .\y: Rec X. X .x) (case <r = ({a = (if false then true else (let u = 0 in false)) , b = ({a = true , b = 0 }.a) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . (let u = ({a = 0 , b = 0 }.b) in ({a = true , b = false }.b)) )))
(case <r = (fix (\x: Nat . ({a = (( \f: Bool .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = 1 in false) , c =  ({a = ({a = 0 , b = ({a = 1 , b = true , c =  0 }.b) , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.c) , b = (let u = false in 0) }.b) }.b) )) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (iszero (let u = (let u = 1 in u) in u)) , b = (case <l = (if true then 1 else 1) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (let u = (( \f: Nat .((f ({a = 1 , b = (if true then false else true) }.a) ) ({a = true , b = 0 }.b) ) ) (\a: Nat .\b: Bool .b)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = (if true then true else true) , b = (let u = 0 in 1) }.a) ))) }.a)
(unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Rec X. X .x) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) ) ({a = true , b = false }.b)) ) (iszero (((\x: Nat .\y: Rec X. X .x) 1 ) false))) ))
(fix (\x: Unit . (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) (let u = true in false) ) (if false then true else false)) ) (let u = (let u = true in u) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false ))) ) ) (\a: Rec X. X .\b: Bool .b)) ))
(( \f: Nat .((f ({a = (let u = ({a = (((\x: Bool .\y: Rec X. X .y) true ) 1) , b = (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = true }.b) ) (let u = false in true)) , c = ({a = (((\x: Nat .\y: Nat .y) true ) 1) , b = 0 }.b) }.c) in (let u = ({a = true , b = 1 }.b) in (let u = false in u))) , b = (unfold [ Unit ] (fold [ Nat ] (if false then ({a = 0 , b = true }.a) else ({a = 1 , b = false , c = 1 }.c)) )) }.b) ) ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 0 in u) }.b) ) ) (\a: Bool .\b: Nat .a))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Unit .((f (succ 1) ) ({a = false , b = 1 }.b) ) ) (\a: Unit .\b: Nat .a)) ) ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = ({a = 1 , b = (iszero 0) , c = 0 }.c) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(fix (\x: Nat . (if (let u = 0 in (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a))) then (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) else (( \f: Nat .((f (pred 1) ) (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) (unfold [ Unit ] (fold [ Nat ] 1 )) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Bool .b))) ))
({a = (( \f: Rec X. X .((f (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) ({a = 0 , b = true , c = (let u = false in 0) }.c) ) ) (\a: Nat .\b: Nat .a)) ) (((\x: Bool .\y: Rec X. X .y) false ) 1) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = ({a = (succ (case <l = (((\x: Unit .\y: Unit .y) false ) 0) > as Nat of < l = x > => x | < r = y > => y)) , b = (let u = true in u) }.a) , b = (iszero (fix (\x: Nat . 1 ))) }.a) }.b)
({a = (((\x: Bool .\y: Nat .x) ({a = (succ 1) , b = 1 }.b) ) (((\x: Rec X. X .\y: Nat .x) ({a = false , b = 1 }.a) ) true)) , b = (fix (\x: Rec X. X . (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) in u) )) }.b)
(((\x: Unit .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (( \f: Unit .((f (((\x: Bool .\y: Bool .y) true ) false) ) true ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = 1 in u)) )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .b)) in u) )) )))
({a = ({a = (if (unfold [ Nat ] (fold [ Unit ] ({a = ({a = false , b = true }.b) , b = (let u = true in false) }.b) )) then (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = (let u = true in 1) , b = ({a = false , b = 1 }.a) }.a)) , b = (let u = (((\x: Nat .\y: Nat .y) false ) 1) in u) }.b) , b = (iszero (fix (\x: Unit . (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) ))) }.b)
(let u = (( \f: Bool .((f (let u = ({a = 0 , b = 1 }.b) in (unfold [ Rec X. X ] (fold [ Nat ] false ))) ) (( \f: Unit .((f (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in false) ) (iszero 0) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .a)) in (unfold [ Nat ] (fold [ Rec X. X ] (iszero ({a = true , b = 0 }.b)) )))
(let u = (iszero (unfold [ Nat ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) ))) in u)
({a = (( \f: Unit .((f (( \f: Unit .((f (case <l = (unfold [ Unit ] (fold [ Bool ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 0 in 0) ) ) (\a: Nat .\b: Rec X. X .a)) ) (fix (\x: Rec X. X . (let u = 1 in u) )) ) ) (\a: Nat .\b: Bool .b)) , b = (let u = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) , b = ({a = true , b = 1 }.b) }.a) in u) , c =  (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = (unfold [ Rec X. X ] (fold [ Bool ] false )) , c =  (succ 0) }.b) ) (let u = 0 in u)) }.b)
(if (iszero (let u = (let u = ({a = 0 , b = true }.b) in true) in (((\x: Bool .\y: Rec X. X .x) (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) false))) then (( \f: Rec X. X .((f (let u = true in false) ) (( \f: Nat .((f (((\x: Bool .\y: Unit .x) (iszero 0) ) ({a = 1 , b = true , c =  1 }.b)) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Bool .a)) else (if (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in u) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else ({a = ({a = (((\x: Nat .\y: Rec X. X .x) false ) false) , b = (if true then false else false) }.b) , b = ({a = false , b = 0 }.b) }.a)))
(let u = (case <r = (((\x: Nat .\y: Nat .x) false ) true) > as Unit of < l = x > => x | < r = y > => y) in u)
({a = (if ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) }.a) then (if ({a = false , b = true }.b) then ({a = true , b = 1 }.b) else (succ 0)) else ({a = ({a = true , b = 1 }.b) , b = false }.a)) , b = ({a = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) )) , b = (fix (\x: Bool . ({a = 0 , b = true }.b) )) }.b) }.a)
(((\x: Rec X. X .\y: Unit .y) (if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) then ({a = (((\x: Bool .\y: Rec X. X .y) true ) 0) , b = (( \f: Rec X. X .((f false ) (unfold [ Nat ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  (unfold [ Bool ] (fold [ Unit ] 1 )) }.b) else ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = true }.b) ))) ) ({a = (let u = (pred 0) in (let u = true in u)) , b = (case <r = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) }.b))
(((\x: Nat .\y: Bool .x) (((\x: Bool .\y: Unit .y) (iszero (((\x: Rec X. X .\y: Bool .x) 1 ) false)) ) (if (((\x: Nat .\y: Rec X. X .y) true ) true) then (((\x: Rec X. X .\y: Nat .y) true ) 0) else (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)))) ) (if (case <r = (unfold [ Unit ] (fold [ Rec X. X ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Rec X. X .y) false ) ({a = 1 , b = true }.b)) else (let u = (let u = 1 in true) in u)))
(unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = (pred 0) , b = (((\x: Rec X. X .\y: Nat .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) ) true) }.b) ) ({a = (let u = 0 in 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .b)) )) , c =  ({a = 0 , b = 1 }.b) }.b) ) ) (\a: Unit .\b: Nat .b)) ))
({a = ({a = ({a = (pred ({a = 1 , b = false }.a)) , b = (case <r = (let u = true in u) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = (fix (\x: Bool . (fix (\x: Nat . false )) )) }.a) , b = (((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Rec X. X .x) (fix (\x: Nat . false )) ) (((\x: Unit .\y: Nat .y) false ) true)) ) ({a = (( \f: Rec X. X .((f (pred 0) ) (let u = ({a = 0 , b = true }.b) in (unfold [ Nat ] (fold [ Bool ] 0 ))) ) ) (\a: Bool .\b: Bool .b)) , b = (let u = ({a = ({a = 0 , b = false , c =  1 }.b) , b = 0 }.a) in (let u = (((\x: Nat .\y: Unit .y) true ) true) in false)) , c = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Bool .y) true ) false) ) (fix (\x: Bool . 1 ))) }.c)) }.b)
(((\x: Nat .\y: Rec X. X .x) (((\x: Unit .\y: Rec X. X .y) (iszero 1) ) (unfold [ Nat ] (fold [ Bool ] (let u = true in false) ))) ) (( \f: Rec X. X .((f (fix (\x: Bool . (let u = 1 in true) )) ) ({a = (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = true , c = 0 }.c) ) (let u = true in u)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.b) ) ) (\a: Nat .\b: Bool .b)))
(pred (pred ({a = 0 , b = (let u = false in false) , c = (pred 1) }.c)))
(case <r = (((\x: Nat .\y: Bool .x) (fix (\x: Bool . ({a = false , b = 1 }.a) )) ) (iszero 0)) > as Bool of < l = x > => x | < r = y > => y)
({a = (unfold [ Nat ] (fold [ Nat ] (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) in (((\x: Unit .\y: Rec X. X .x) 1 ) false)) )) , b = (let u = (case <l = (if false then 1 else 1) > as Bool of < l = x > => x | < r = y > => y) in u) }.b)
(((\x: Unit .\y: Bool .y) (let u = (( \f: Unit .((f ({a = (fix (\x: Unit . 0 )) , b = false }.b) ) (((\x: Bool .\y: Rec X. X .y) (let u = 0 in false) ) (let u = 0 in false)) ) ) (\a: Rec X. X .\b: Unit .a)) in (case <r = (( \f: Rec X. X .((f (let u = true in u) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (( \f: Nat .((f (let u = 1 in 1) ) (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ) ) (\a: Unit .\b: Rec X. X .b)))
(fix (\x: Unit . (let u = (pred (((\x: Bool .\y: Bool .y) false ) 1)) in u) ))
(((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .x) (iszero 0) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a))) ) (((\x: Nat .\y: Bool .x) (( \f: Bool .((f true ) (((\x: Unit .\y: Nat .x) true ) true) ) ) (\a: Rec X. X .\b: Bool .a)) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Nat .b)) ) (( \f: Unit .((f (succ (((\x: Nat .\y: Bool .x) 1 ) false)) ) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (unfold [ Rec X. X ] (fold [ Bool ] false )) , c = (if false then 0 else 0) }.c) ) ) (\a: Rec X. X .\b: Nat .a)))
(if (fix (\x: Unit . (fix (\x: Unit . false )) )) then (let u = (succ 0) in u) else ({a = (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) then (unfold [ Nat ] (fold [ Unit ] 1 )) else (let u = 1 in u)) , b = (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) false ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .a))) ) (fix (\x: Unit . true ))) }.a))
(( \f: Rec X. X .((f (( \f: Bool .((f (( \f: Bool .((f (iszero (let u = 0 in u)) ) (( \f: Bool .((f (if false then true else false) ) true ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Rec X. X .\y: Nat .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Nat .x) ({a = (let u = false in false) , b = (if true then 1 else 1) }.a) ) (fix (\x: Rec X. X . true ))) ) (fix (\x: Unit . ({a = false , b = true }.b) ))) ) ) (\a: Rec X. X .\b: Bool .b))
({a = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Bool .((f ({a = 0 , b = true }.b) ) true ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = ({a = (let u = true in 1) , b = (let u = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Unit .y) true ) 0) ) ({a = false , b = false }.b)) in (((\x: Unit .\y: Bool .y) true ) 1)) }.b) }.a)
(let u = (if (iszero (( \f: Bool .((f ({a = 0 , b = true , c = 0 }.c) ) ({a = true , b = 1 }.b) ) ) (\a: Nat .\b: Rec X. X .b))) then (let u = (iszero 0) in u) else (fix (\x: Bool . (if true then false else true) ))) in u)
(((\x: Unit .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] (let u = (((\x: Rec X. X .\y: Unit .x) 1 ) true) in u) )) )) ) ({a = (((\x: Bool .\y: Unit .y) ({a = false , b = true }.b) ) ({a = false , b = 0 }.b)) , b = (fix (\x: Nat . (fix (\x: Nat . false )) )) }.b))
(pred (let u = ({a = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in true) }.a) , b = (let u = (iszero 0) in u) , c =  (let u = (fix (\x: Rec X. X . false )) in ({a = 1 , b = 1 }.b)) }.b) in (((\x: Bool .\y: Unit .x) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) (((\x: Bool .\y: Rec X. X .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) false))))
(iszero (let u = (let u = (((\x: Unit .\y: Unit .x) (fix (\x: Bool . true )) ) (iszero 0)) in u) in (( \f: Bool .((f ({a = 0 , b = (if true then false else true) , c = ({a = 0 , b = true , c = 0 }.c) }.c) ) (let u = ({a = false , b = 1 }.b) in (fix (\x: Bool . 0 ))) ) ) (\a: Rec X. X .\b: Bool .b))))
({a = (case <l = (let u = ({a = (((\x: Bool .\y: Unit .x) 0 ) false) , b = true , c =  0 }.b) in (succ 1)) > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Rec X. X .y) (if (iszero 0) then (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) else (let u = true in true)) ) ({a = (let u = (let u = ({a = 0 , b = true }.b) in false) in (let u = 1 in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)))) , b = (fix (\x: Unit . (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) in u) )) }.b)) }.b)
(((\x: Bool .\y: Nat .y) (iszero (let u = (succ (let u = 1 in 1)) in u)) ) (let u = (((\x: Rec X. X .\y: Bool .y) (let u = 1 in true) ) false) in (let u = (let u = false in 0) in (unfold [ Nat ] (fold [ Nat ] (let u = false in true) )))))
(( \f: Nat .((f ({a = ({a = true , b = (let u = true in true) }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = true , c =  0 }.b) )) }.b) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = (let u = 1 in (unfold [ Unit ] (fold [ Nat ] false ))) in (unfold [ Bool ] (fold [ Bool ] false ))) )) ) ) (\a: Nat .\b: Bool .b))
(let u = (let u = (( \f: Unit .((f (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) (let u = true in false) ) ) (\a: Nat .\b: Unit .b)) in u) in (( \f: Bool .((f ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (case <l = (fix (\x: Nat . 1 )) > as Bool of < l = x > => x | < r = y > => y) }.a) ) (case <r = (fix (\x: Bool . (iszero 1) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .x) (fix (\x: Nat . (iszero 0) )) ) (let u = 1 in false)) ))
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = (let u = true in u) , c = 1 }.c) )) , b = ({a = (( \f: Bool .((f (fix (\x: Nat . 1 )) ) ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = 0 }.b) ) ) (\a: Nat .\b: Bool .b)) , b = ({a = ({a = (iszero (let u = 0 in u)) , b = ({a = 0 , b = false }.b) }.b) , b = (let u = (if false then false else true) in u) }.b) }.b) , c =  ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Rec X. X .y) true ) 1) )) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b)
(( \f: Rec X. X .((f (let u = ({a = ({a = false , b = 1 }.b) , b = (let u = 0 in true) , c = (fix (\x: Bool . 0 )) }.c) in u) ) (( \f: Bool .((f (( \f: Unit .((f (if (if true then true else true) then (let u = ({a = 1 , b = true , c = 1 }.c) in u) else (let u = 0 in u)) ) (((\x: Rec X. X .\y: Rec X. X .x) (let u = 1 in u) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Bool .a)) ) (succ (( \f: Bool .((f (let u = 1 in u) ) (fix (\x: Unit . 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .b))
({a = ({a = ({a = (let u = 0 in true) , b = 0 }.b) , b = (unfold [ Bool ] (fold [ Bool ] (((\x: Rec X. X .\y: Unit .y) true ) true) )) }.b) , b = ({a = (succ (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) , c = (unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )) )) }.c) }.b)
(( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in false) ) (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y)) ) (fix (\x: Unit . (if (let u = false in u) then true else (fix (\x: Nat . false ))) )) ) ) (\a: Bool .\b: Bool .b))
({a = (( \f: Unit .((f (case <r = (let u = 0 in false) > as Bool of < l = x > => x | < r = y > => y) ) (if (if false then true else false) then (iszero 1) else true) ) ) (\a: Unit .\b: Nat .a)) , b = (let u = (pred (let u = 1 in 1)) in (((\x: Unit .\y: Nat .x) (iszero 1) ) (case <r = (case <r = false > as Nat of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y))) }.b)
({a = ({a = ({a = (let u = 1 in (let u = 0 in u)) , b = ({a = (pred 1) , b = (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) }.b) , c = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) in u) }.c) , b = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] false )) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Nat .a)) , c = (( \f: Unit .((f (if false then 0 else 1) ) (((\x: Rec X. X .\y: Bool .y) true ) 1) ) ) (\a: Nat .\b: Nat .b)) }.c) , b = (case <r = (unfold [ Rec X. X ] (fold [ Bool ] (iszero 0) )) > as Unit of < l = x > => x | < r = y > => y) }.a)
(let u = (( \f: Rec X. X .((f ({a = ({a = (if false then false else true) , b = true }.b) , b = (let u = (((\x: Rec X. X .\y: Bool .y) true ) false) in (let u = (let u = 1 in true) in 0)) }.a) ) (case <r = ({a = 1 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) in u)
(pred ({a = ({a = (((\x: Bool .\y: Rec X. X .y) true ) false) , b = (( \f: Bool .((f (let u = true in 0) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .b)) }.a) , b = ({a = (let u = (fix (\x: Unit . 0 )) in 1) , b = ({a = true , b = 1 }.a) , c = (pred 1) }.c) }.b))
(( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = ({a = 1 , b = true , c =  1 }.b) , c = 0 }.c) )) ) ({a = (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in ({a = ({a = true , b = 0 }.b) , b = (((\x: Bool .\y: Nat .y) false ) 1) }.b)) , b = (( \f: Nat .((f (fix (\x: Rec X. X . ({a = 0 , b = false , c =  0 }.b) )) ) ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , b = 0 }.a) ) ) (\a: Nat .\b: Bool .a)) , c = (succ (let u = (let u = 0 in u) in u)) }.c) ) ) (\a: Rec X. X .\b: Unit .b))
(case <r = (let u = ({a = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) in (( \f: Unit .((f 1 ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Unit .\b: Nat .b))) , b = (case <r = (if false then false else false) > as Bool of < l = x > => x | < r = y > => y) }.b) in (let u = (((\x: Nat .\y: Rec X. X .x) true ) false) in u)) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Nat ] ({a = ({a = (((\x: Bool .\y: Nat .x) false ) false) , b = ({a = 1 , b = true , c = 1 }.c) }.a) , b = (pred 0) }.a) )) ) (let u = ({a = 1 , b = true , c =  (if true then 1 else 0) }.b) in (let u = (let u = false in false) in (let u = true in true))))
(iszero (((\x: Rec X. X .\y: Bool .x) (let u = (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Nat .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Bool .x) false ) true)) )) in (pred 1)) ) (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] true )) ) (let u = 0 in true) ) ) (\a: Rec X. X .\b: Bool .b))))
(((\x: Nat .\y: Unit .y) (( \f: Nat .((f (iszero (let u = 0 in 1)) ) (unfold [ Unit ] (fold [ Nat ] ({a = (((\x: Bool .\y: Nat .x) 0 ) false) , b = ({a = 1 , b = false , c =  0 }.b) , c =  (((\x: Unit .\y: Unit .x) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = true }.b)) }.b) )) ) ) (\a: Bool .\b: Unit .a)) ) (( \f: Nat .((f (( \f: Bool .((f (let u = false in true) ) (case <r = (((\x: Unit .\y: Unit .y) true ) false) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (((\x: Nat .\y: Nat .y) (((\x: Unit .\y: Bool .x) ({a = false , b = 0 }.a) ) (if true then false else true)) ) (unfold [ Bool ] (fold [ Unit ] ({a = false , b = false }.b) ))) ) ) (\a: Bool .\b: Unit .a)))
({a = (let u = (unfold [ Bool ] (fold [ Unit ] 0 )) in (let u = (let u = true in 0) in 0)) , b = (( \f: Rec X. X .((f (case <r = (unfold [ Unit ] (fold [ Rec X. X ] false )) > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = false , b = 1 }.a) )) ) ) (\a: Unit .\b: Nat .a)) }.b)
(((\x: Bool .\y: Unit .y) ({a = (((\x: Nat .\y: Rec X. X .y) true ) (((\x: Rec X. X .\y: Rec X. X .x) true ) true)) , b = (case <l = (pred 0) > as Unit of < l = x > => x | < r = y > => y) }.a) ) (let u = (pred (succ (let u = 1 in 1))) in u))
(case <l = (let u = (let u = (unfold [ Nat ] (fold [ Bool ] (iszero 1) )) in (((\x: Rec X. X .\y: Unit .x) (let u = 0 in 1) ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .b)))) in (( \f: Bool .((f ({a = (pred 1) , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .a)) }.a) ) (pred (((\x: Unit .\y: Unit .x) 1 ) true)) ) ) (\a: Nat .\b: Nat .a))) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (let u = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Nat .x) false ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = 0 , b = true }.a)) in (fix (\x: Bool . (succ (let u = (succ 1) in u)) ))) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (succ 1) )) , b = (( \f: Nat .((f (if false then true else true) ) (fix (\x: Bool . false )) ) ) (\a: Rec X. X .\b: Nat .a)) }.a) ) ) (\a: Nat .\b: Unit .a))
(case <l = ({a = (succ (((\x: Bool .\y: Nat .y) true ) 1)) , b = (unfold [ Nat ] (fold [ Bool ] (fix (\x: Nat . false )) )) }.a) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = ({a = true , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b) , b = ({a = (if false then 1 else 1) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.b) }.b) , b = (let u = (((\x: Rec X. X .\y: Bool .x) ({a = (fix (\x: Unit . 1 )) , b = (iszero (let u = false in 1)) , c =  (((\x: Nat .\y: Unit .y) false ) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false)) }.b) ) (((\x: Unit .\y: Bool .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) ) (unfold [ Unit ] (fold [ Unit ] false )))) in (((\x: Rec X. X .\y: Unit .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) false ) true) )) ) (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) false ) ) (\a: Nat .\b: Unit .b)))) }.b)
(iszero (fix (\x: Rec X. X . ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.a) )))
(( \f: Unit .((f (fix (\x: Unit . ({a = true , b = 1 }.a) )) ) (let u = ({a = (succ 0) , b = (iszero 0) }.b) in (if (unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = false , b = false }.b) , b = (unfold [ Nat ] (fold [ Unit ] 1 )) }.a) )) then (((\x: Bool .\y: Nat .x) (let u = false in ({a = 1 , b = true }.b)) ) ({a = (((\x: Rec X. X .\y: Nat .y) true ) 0) , b = ({a = true , b = true }.b) , c =  ({a = 1 , b = true }.a) }.b)) else (unfold [ Bool ] (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) )))) ) ) (\a: Nat .\b: Nat .a))
(( \f: Rec X. X .((f ({a = ({a = (((\x: Nat .\y: Rec X. X .x) 0 ) false) , b = (let u = false in u) }.b) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) ) (case <l = (succ (if true then 0 else 0)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a))
(succ (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) in u))
(( \f: Rec X. X .((f (case <l = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (( \f: Rec X. X .((f ({a = (((\x: Unit .\y: Unit .x) 0 ) false) , b = true , c =  (((\x: Unit .\y: Rec X. X .y) true ) 0) }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = true }.b) )) ) ) (\a: Rec X. X .\b: Bool .b)) in (let u = (((\x: Unit .\y: Nat .y) (unfold [ Unit ] (fold [ Nat ] true )) ) ({a = false , b = true }.b)) in (succ 1))) ) ) (\a: Bool .\b: Rec X. X .a))
(let u = ({a = (((\x: Bool .\y: Unit .x) (let u = true in u) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true ))) , b = ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (fix (\x: Rec X. X . false )) }.a) }.a) in ({a = (let u = (succ 1) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (fix (\x: Unit . ({a = 0 , b = false , c = 1 }.c) )) }.a) }.b))
(let u = (fix (\x: Bool . (let u = ({a = true , b = 1 }.b) in ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] false ))) )) in (((\x: Nat .\y: Bool .y) (( \f: Nat .((f ({a = 1 , b = true }.b) ) (iszero (if false then 1 else 0)) ) ) (\a: Nat .\b: Rec X. X .a)) ) (fix (\x: Nat . (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) ))))
(let u = ({a = (((\x: Bool .\y: Nat .x) (fix (\x: Rec X. X . true )) ) (((\x: Nat .\y: Rec X. X .y) false ) (let u = false in false))) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (iszero 1) )) }.b) in u)
(case <r = (let u = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = false }.b)) in u) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (if (let u = (unfold [ Nat ] (fold [ Unit ] true )) in u) then (pred (pred 0)) else (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b)))) , b = (iszero (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u)) , c =  (succ (case <l = (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y)) }.b)
(succ (succ (case <l = (( \f: Nat .((f (((\x: Unit .\y: Nat .y) true ) 1) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y)))
({a = (unfold [ Bool ] (fold [ Unit ] (let u = (case <r = (((\x: Nat .\y: Unit .y) true ) true) > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Nat . 1 ))) )) , b = (( \f: Rec X. X .((f ({a = (succ (pred 1)) , b = (iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 ))) , c =  (((\x: Nat .\y: Nat .y) (let u = ({a = 1 , b = true }.b) in (((\x: Rec X. X .\y: Unit .y) false ) false)) ) (let u = 0 in u)) }.b) ) (let u = ({a = false , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.b) in (let u = 0 in false)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)
(unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f (let u = false in 1) ) ({a = true , b = 1 }.b) ) ) (\a: Nat .\b: Bool .a)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ))) ))
(( \f: Bool .((f ({a = (pred ({a = (succ 1) , b = 0 }.b)) , b = ({a = (((\x: Unit .\y: Unit .x) ({a = 0 , b = ({a = 0 , b = true }.a) }.b) ) (iszero 1)) , b = (iszero ({a = false , b = 1 }.b)) , c =  (((\x: Nat .\y: Bool .y) (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) )) ) ({a = ({a = 0 , b = true , c = 0 }.c) , b = 1 }.b)) }.b) }.b) ) (let u = (let u = false in (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b))) in ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = (fix (\x: Rec X. X . false )) }.b)) ) ) (\a: Unit .\b: Rec X. X .b))
(pred ({a = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = false in false)) ) ) (\a: Bool .\b: Bool .a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Unit .y) false ) true)) }.a))
(let u = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (let u = true in u) , b = 0 }.a) )) in (iszero (pred (( \f: Unit .((f ({a = 1 , b = false , c = 1 }.c) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) ) ) (\a: Nat .\b: Rec X. X .b)))))
(( \f: Rec X. X .((f (if ({a = (if true then false else (fix (\x: Unit . true ))) , b = (( \f: Nat .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 1) ) ) (\a: Bool .\b: Unit .a)) }.b) then ({a = (((\x: Bool .\y: Unit .x) 1 ) false) , b = false , c = 1 }.c) else ({a = (let u = 1 in 0) , b = ({a = (let u = false in 1) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  1 }.b) , c = (let u = 1 in 0) }.c)) ) (succ (case <l = (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = true , c = 1 }.c) )) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .b))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (if (let u = (let u = true in (let u = 1 in true)) in ({a = false , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.b)) then ({a = (iszero (if true then 1 else 0)) , b = ({a = 1 , b = true , c =  1 }.b) }.b) else (case <r = (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .a)) )) > as Rec X. X of < l = x > => x | < r = y > => y)) ))
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .x) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = (let u = false in 1) , b = (iszero 1) }.b)) ))
(let u = (let u = (( \f: Rec X. X .((f (pred 0) ) (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ) (\a: Bool .\b: Unit .b)) in (( \f: Unit .((f (let u = 1 in false) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if false then false else false) )) ) ) (\a: Rec X. X .\b: Unit .b))) in u)
(fix (\x: Nat . ({a = (if (unfold [ Bool ] (fold [ Bool ] false )) then ({a = true , b = true }.b) else (let u = 1 in false)) , b = (if (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) then (let u = true in u) else (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .b))) }.b) ))
(iszero ({a = (((\x: Rec X. X .\y: Unit .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = true , b = false }.b) )) ) (succ 0)) , b = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) }.a))
(((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] true )) ) (((\x: Unit .\y: Nat .y) (fix (\x: Bool . true )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Rec X. X .y) false ) true) ))) ) ) (\a: Nat .\b: Bool .a)) ) (if (case <r = (let u = ({a = 1 , b = 1 }.b) in (fix (\x: Nat . false ))) > as Rec X. X of < l = x > => x | < r = y > => y) then (case <l = (if false then 0 else 0) > as Unit of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) ) (((\x: Bool .\y: Rec X. X .y) false ) false))))
(((\x: Bool .\y: Bool .x) (let u = (((\x: Nat .\y: Nat .x) 1 ) ({a = false , b = true }.b)) in ({a = 1 , b = 1 }.b)) ) (case <r = (iszero (( \f: Nat .((f ({a = false , b = 0 }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Rec X. X .b))) > as Bool of < l = x > => x | < r = y > => y))
({a = (pred (( \f: Rec X. X .((f (pred 0) ) (((\x: Nat .\y: Rec X. X .x) 0 ) (((\x: Bool .\y: Nat .x) false ) false)) ) ) (\a: Unit .\b: Nat .b))) , b = ({a = ({a = (case <l = (let u = true in 0) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in u) }.b) , b = (let u = ({a = (((\x: Rec X. X .\y: Unit .x) (iszero 0) ) true) , b = (((\x: Bool .\y: Unit .y) false ) 0) }.a) in ({a = 0 , b = true }.b)) , c =  ({a = (fix (\x: Nat . ({a = (succ 1) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) , c =  (let u = 0 in 1) }.b) )) , b = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = false in 1)) }.b) }.b) , c = (((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .x) (succ 1) ) (iszero 1)) ) ({a = false , b = false }.b)) }.c)
(let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .y) ({a = true , b = 1 }.a) ) (((\x: Rec X. X .\y: Unit .x) 0 ) false)) )) in (iszero ({a = ({a = 0 , b = 0 }.b) , b = (unfold [ Nat ] (fold [ Unit ] 0 )) }.b)))
({a = (fix (\x: Unit . (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .b)) ) (let u = 1 in false)) )) , b = ({a = (let u = 0 in (fix (\x: Nat . 1 ))) , b = ({a = (fix (\x: Rec X. X . 1 )) , b = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , c =  (((\x: Rec X. X .\y: Unit .y) true ) 0) }.b) , c = (fix (\x: Rec X. X . ({a = 0 , b = true , c = 1 }.c) )) }.c) }.a)
(fix (\x: Nat . (unfold [ Unit ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = 1 , b = ({a = 0 , b = false }.a) }.b) , b = (((\x: Nat .\y: Nat .y) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) 1) }.b) )) )) ))
(( \f: Nat .((f (if ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) ({a = true , b = true }.b)) , b = (pred 1) }.a) then (((\x: Rec X. X .\y: Bool .y) (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) (let u = 1 in (let u = 1 in 0))) else (case <l = ({a = 0 , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y)) ) (let u = (fix (\x: Unit . (iszero 1) )) in (pred ({a = 0 , b = true , c = 1 }.c))) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (( \f: Unit .((f (( \f: Unit .((f ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = (iszero 1) , c =  (((\x: Unit .\y: Nat .y) false ) 0) }.b) ) (((\x: Unit .\y: Rec X. X .x) ({a = true , b = 1 }.a) ) true) ) ) (\a: Nat .\b: Unit .a)) ) (if (fix (\x: Nat . true )) then (((\x: Nat .\y: Bool .x) false ) true) else (if true then ({a = 1 , b = false , c =  0 }.b) else true)) ) ) (\a: Bool .\b: Nat .b)) in ({a = (fix (\x: Nat . 0 )) , b = ({a = 1 , b = (let u = 1 in true) , c = 0 }.c) }.b))
({a = (fix (\x: Unit . (((\x: Rec X. X .\y: Unit .y) (if true then false else true) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a))) )) , b = (( \f: Bool .((f (( \f: Rec X. X .((f ({a = 1 , b = true }.b) ) ({a = 0 , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Nat .a)) ) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (iszero (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b))) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) , c = (succ (( \f: Unit .((f (((\x: Nat .\y: Nat .x) 1 ) true) ) (( \f: Nat .((f 0 ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .b))) }.c)
({a = ({a = (if (let u = true in u) then 1 else 0) , b = (let u = (unfold [ Bool ] (fold [ Unit ] true )) in u) , c =  (pred ({a = (pred 1) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = 0 }.c)) }.b) , b = ({a = ({a = (( \f: Rec X. X .((f (let u = true in true) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (case <l = (((\x: Rec X. X .\y: Nat .y) (let u = true in u) ) (pred 1)) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = ({a = ({a = true , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) }.b) , b = (fix (\x: Nat . true )) , c =  ({a = 1 , b = (let u = 0 in u) }.b) }.b) , c = (if (iszero ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 ))) then (pred ({a = 1 , b = false }.a)) else (fix (\x: Unit . (((\x: Nat .\y: Bool .x) ({a = 0 , b = false , c = 0 }.c) ) (let u = 0 in true)) ))) }.c) }.b)
({a = ({a = (((\x: Nat .\y: Rec X. X .y) ({a = 1 , b = ({a = true , b = false }.b) }.b) ) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Bool .y) true ) 1) }.b)) , b = ({a = (iszero 0) , b = (pred (if false then 0 else 1)) }.a) }.a) , b = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Nat . true )) )) in u) , c =  (((\x: Nat .\y: Bool .y) (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) true ) (let u = 1 in false)) ) ({a = (((\x: Bool .\y: Unit .x) 0 ) true) , b = (let u = true in false) , c =  ({a = 1 , b = 0 }.b) }.b) ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Rec X. X .((f (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) false ) 0) )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = 1 , b = false }.a) )) ) ) (\a: Bool .\b: Rec X. X .a))) }.b)
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero (fix (\x: Unit . 0 ))) )) , b = ({a = (case <l = (if true then 1 else 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if (let u = 0 in true) then (pred 1) else (fix (\x: Bool . 1 ))) }.b) }.a)
(unfold [ Bool ] (fold [ Unit ] ({a = (let u = (let u = ({a = true , b = 1 }.a) in (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a))) in u) , b = (fix (\x: Nat . ({a = 1 , b = true , c = 0 }.c) )) }.b) ))
(let u = (succ ({a = ({a = (let u = false in false) , b = (if true then 0 else 1) }.b) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) , b = (if true then 0 else 1) }.b) }.b)) in u)
(if ({a = (if (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a)) then (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) else (let u = true in 1)) , b = (let u = 1 in true) }.b) then (unfold [ Bool ] (fold [ Nat ] ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in true) }.b) )) else (((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Bool .x) ({a = true , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) }.b) ) (iszero 1)) ) ({a = (unfold [ Nat ] (fold [ Bool ] true )) , b = (((\x: Rec X. X .\y: Bool .y) true ) 0) }.a)))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (if ({a = 0 , b = false }.b) then (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .b)) else (( \f: Rec X. X .((f false ) ({a = false , b = false }.b) ) ) (\a: Unit .\b: Unit .b))) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.a) ))
(( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .y) false ) false) ))) ) (( \f: Bool .((f (let u = ({a = 0 , b = false }.b) in (unfold [ Bool ] (fold [ Nat ] 0 ))) ) (( \f: Bool .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Unit .\b: Rec X. X .a))
({a = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Nat .y) false ) 1) , b = (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) )) , c =  (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) in (succ 0)) }.b) )) , b = (if ({a = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (pred 1)) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.b) then (( \f: Nat .((f ({a = 0 , b = ({a = 1 , b = false , c = 1 }.c) }.b) ) (fix (\x: Nat . 0 )) ) ) (\a: Unit .\b: Rec X. X .a)) else (if (iszero 1) then ({a = 1 , b = 1 }.b) else (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)))) }.b)
(if (if (let u = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)) in u) then ({a = true , b = ({a = true , b = 1 }.b) }.a) else (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b))) then ({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) , b = (fix (\x: Nat . true )) }.a) , b = (iszero (((\x: Bool .\y: Unit .x) 1 ) (let u = false in false))) }.b) else (iszero (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Nat .y) (if false then true else false) ) (let u = 0 in u)) ) (iszero (( \f: Unit .((f (let u = 0 in 0) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Nat .a))))))
({a = ({a = ({a = ({a = (fix (\x: Bool . false )) , b = (let u = (((\x: Rec X. X .\y: Bool .y) false ) 1) in u) }.a) , b = ({a = (((\x: Nat .\y: Bool .y) false ) 0) , b = (((\x: Nat .\y: Rec X. X .y) true ) true) }.a) }.a) , b = ({a = (succ (((\x: Unit .\y: Rec X. X .x) 0 ) true)) , b = (iszero (let u = (((\x: Unit .\y: Bool .x) 1 ) true) in 1)) }.a) }.b) , b = (let u = (let u = (succ ({a = 0 , b = 0 }.b)) in (iszero (( \f: Nat .((f 1 ) (let u = 1 in u) ) ) (\a: Nat .\b: Bool .b)))) in u) }.a)
(let u = (( \f: Bool .((f (if (fix (\x: Bool . false )) then ({a = 0 , b = 0 }.b) else (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) ) (let u = (unfold [ Nat ] (fold [ Nat ] false )) in 0) ) ) (\a: Nat .\b: Rec X. X .b)) in ({a = (fix (\x: Bool . 0 )) , b = ({a = 0 , b = (iszero 0) }.a) }.b))
(iszero (((\x: Rec X. X .\y: Unit .y) (if (iszero 1) then ({a = 1 , b = false }.b) else (iszero (let u = 0 in 1))) ) ({a = 1 , b = 0 }.b)))
({a = (( \f: Bool .((f (pred 1) ) (((\x: Rec X. X .\y: Nat .y) ({a = true , b = (unfold [ Unit ] (fold [ Nat ] true )) }.b) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Unit .b)) , b = (((\x: Bool .\y: Nat .y) ({a = (if (if true then true else true) then 0 else (((\x: Bool .\y: Bool .y) true ) 1)) , b = (iszero 1) , c =  (let u = true in 1) }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .a))) }.a)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .b)) )) in u) ))
(let u = (pred (( \f: Bool .((f (let u = 0 in u) ) (pred 1) ) ) (\a: Bool .\b: Bool .a))) in (((\x: Bool .\y: Nat .y) (let u = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = false }.b) in u) ) (iszero (let u = (((\x: Unit .\y: Unit .y) true ) true) in ({a = false , b = 0 }.b)))))
({a = (( \f: Rec X. X .((f (let u = (((\x: Rec X. X .\y: Bool .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) in ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .a)) , b = (let u = 1 in 0) }.a)) ) (((\x: Nat .\y: Unit .y) (let u = ({a = true , b = 1 }.b) in (((\x: Rec X. X .\y: Unit .y) false ) false)) ) (fix (\x: Unit . (((\x: Bool .\y: Unit .y) true ) true) ))) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (pred (if (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Unit .x) true ) false) ) false) then (let u = (if false then 1 else 1) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b))) else ({a = (((\x: Nat .\y: Unit .y) false ) true) , b = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) in ({a = false , b = 0 }.b)) }.b))) }.a)
(let u = ({a = (((\x: Bool .\y: Bool .x) ({a = 0 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) ) (let u = 1 in true)) , b = (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in (succ 0)) }.a) in u)
(case <l = ({a = ({a = ({a = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) in false) , b = ({a = 0 , b = 0 }.b) }.b) , b = ({a = (if false then 1 else 1) , b = ({a = 0 , b = false , c =  0 }.b) }.b) }.a) , b = (((\x: Nat .\y: Unit .y) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) , c =  0 }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false ))) }.a) > as Bool of < l = x > => x | < r = y > => y)
({a = (let u = ({a = 0 , b = (unfold [ Nat ] (fold [ Nat ] false )) , c =  1 }.b) in (if false then 1 else (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)))) , b = (iszero (pred ({a = 0 , b = true }.a))) , c = (( \f: Bool .((f (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (( \f: Unit .((f ({a = 1 , b = 0 }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Rec X. X .b)) in u) ) ) (\a: Bool .\b: Rec X. X .b)) }.c)
(iszero ({a = (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) false) ) (( \f: Unit .((f (let u = 1 in u) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b))) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (case <l = (if false then 0 else 1) > as Bool of < l = x > => x | < r = y > => y) )) }.b))
(iszero (((\x: Bool .\y: Bool .y) ({a = ({a = true , b = false }.b) , b = ({a = true , b = 1 }.b) }.a) ) (pred (fix (\x: Nat . 0 )))))
(pred (fix (\x: Unit . ({a = 0 , b = 1 }.b) )))
({a = (pred ({a = (succ 0) , b = ({a = true , b = false }.b) }.a)) , b = ({a = ({a = (case <r = (((\x: Bool .\y: Nat .y) true ) true) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.b) , b = (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) (let u = 0 in u)) ) (((\x: Unit .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Bool ] true )) ) true)) }.a) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (( \f: Nat .((f (( \f: Unit .((f ({a = 0 , b = true , c = 1 }.c) ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false , c =  0 }.b) ) ({a = 0 , b = 0 }.b)) ) ) (\a: Bool .\b: Unit .b)) )) }.b)
(((\x: Bool .\y: Bool .y) ({a = (fix (\x: Rec X. X . (let u = (succ 1) in (let u = (unfold [ Rec X. X ] (fold [ Nat ] true )) in (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)))) )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) }.b) ) (let u = (let u = (let u = true in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) in ({a = 1 , b = (if true then false else false) , c =  0 }.b)) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)))
({a = ({a = (let u = (pred 0) in u) , b = ({a = (let u = 0 in u) , b = (iszero 1) }.b) , c =  (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) in ({a = (succ 0) , b = (let u = false in u) }.a)) }.b) , b = (case <r = (case <r = ({a = 0 , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(let u = (let u = ({a = (let u = 0 in 0) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) , c =  (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.b) in u) in (((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) (let u = 1 in false)) )) ) (( \f: Bool .((f (fix (\x: Unit . ({a = false , b = true }.b) )) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .b))))
(fix (\x: Nat . (succ (let u = (let u = false in ({a = 1 , b = false , c =  0 }.b)) in (fix (\x: Unit . 0 )))) ))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = (pred (fix (\x: Bool . 1 ))) , b = ({a = ({a = (let u = (let u = false in u) in (fix (\x: Bool . false ))) , b = (if false then 1 else 0) }.a) , b = (((\x: Unit .\y: Rec X. X .y) true ) (unfold [ Nat ] (fold [ Bool ] false ))) }.b) , c = (((\x: Nat .\y: Nat .x) (case <l = (if false then 1 else 0) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.a)) }.c) ))
(let u = (succ (((\x: Nat .\y: Bool .y) (if false then false else false) ) (((\x: Nat .\y: Unit .y) true ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)))) in (let u = ({a = (let u = true in u) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.a) }.b) in u))
(let u = (let u = (((\x: Unit .\y: Nat .y) (let u = 0 in (let u = true in u)) ) (((\x: Rec X. X .\y: Bool .y) (fix (\x: Bool . (let u = 0 in false) )) ) (unfold [ Nat ] (fold [ Rec X. X ] false )))) in (let u = (unfold [ Unit ] (fold [ Nat ] (succ 1) )) in ({a = 1 , b = ({a = 0 , b = true , c =  1 }.b) , c =  (pred 1) }.b))) in u)
(let u = ({a = (unfold [ Nat ] (fold [ Unit ] ({a = true , b = 0 }.b) )) , b = (((\x: Rec X. X .\y: Nat .x) true ) false) , c = (succ 0) }.c) in (iszero (let u = (case <l = (pred 1) > as Rec X. X of < l = x > => x | < r = y > => y) in u)))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] (if (if false then true else false) then ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) else (let u = (((\x: Nat .\y: Nat .y) false ) 1) in (((\x: Nat .\y: Bool .y) false ) true))) )) ))
({a = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (if true then (let u = true in u) else (((\x: Unit .\y: Unit .y) false ) false)) )) in (( \f: Bool .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) false) , b = 1 }.b) ) ) (\a: Nat .\b: Bool .a))) , b = (unfold [ Unit ] (fold [ Nat ] (if ({a = ({a = 1 , b = false }.a) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) then (( \f: Unit .((f ({a = false , b = true }.b) ) (unfold [ Unit ] (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Unit .b)) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Unit . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ))) )) }.b)
(fix (\x: Bool . (((\x: Rec X. X .\y: Bool .x) (if (if true then false else true) then ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) else (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b))) ) ({a = 1 , b = false }.b)) ))
(unfold [ Bool ] (fold [ Nat ] (iszero ({a = (if true then 1 else 0) , b = ({a = 0 , b = false , c =  0 }.b) }.a)) ))
({a = ({a = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , b = (let u = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) in false) }.b) , b = ({a = false , b = ({a = 1 , b = 1 }.b) }.b) }.b) , b = (let u = (( \f: Nat .((f ({a = 0 , b = false }.a) ) (((\x: Bool .\y: Bool .x) 0 ) true) ) ) (\a: Bool .\b: Rec X. X .a)) in (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in u)) }.a)
(let u = (fix (\x: Unit . (let u = (((\x: Unit .\y: Rec X. X .y) false ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) in u) )) in (((\x: Unit .\y: Bool .x) (let u = (( \f: Nat .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (if true then false else true) ) ) (\a: Nat .\b: Unit .b)) in u) ) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .x) false ) false) )) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in u) }.a)))
(unfold [ Nat ] (fold [ Unit ] (case <r = (( \f: Rec X. X .((f true ) (iszero 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) ))
({a = (let u = (( \f: Nat .((f 0 ) ({a = 1 , b = 1 }.b) ) ) (\a: Bool .\b: Bool .b)) in ({a = 1 , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b)) , b = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in true) )) ) ({a = (if false then 1 else 0) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) }.b) ) ) (\a: Bool .\b: Bool .b)) , c = (fix (\x: Unit . (succ ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = (let u = false in u) , c = 1 }.c)) )) }.c)
({a = ({a = (let u = (let u = (unfold [ Bool ] (fold [ Unit ] 1 )) in u) in u) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = true , c =  0 }.b) )) }.b) , b = ({a = (fix (\x: Nat . (((\x: Bool .\y: Unit .y) (let u = false in u) ) ({a = true , b = (let u = 0 in u) }.a)) )) , b = (((\x: Rec X. X .\y: Unit .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) ({a = 0 , b = false }.b)) }.b) }.a)
({a = (((\x: Unit .\y: Nat .x) ({a = (let u = ({a = false , b = 1 }.a) in u) , b = (let u = 1 in 1) }.b) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.b)) , b = (( \f: Rec X. X .((f (( \f: Unit .((f (pred (let u = true in (fix (\x: Nat . 1 )))) ) (((\x: Bool .\y: Nat .x) (( \f: Nat .((f (let u = 0 in 0) ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) ) (unfold [ Rec X. X ] (fold [ Nat ] true ))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = 0 , b = false , c =  0 }.b) , b = ({a = 1 , b = false }.a) }.b) )) ) ) (\a: Nat .\b: Rec X. X .b)) }.b)
(((\x: Nat .\y: Unit .y) ({a = (fix (\x: Nat . (let u = false in u) )) , b = (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) in (iszero 0)) }.b) ) (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Unit .y) false ) false) ) (((\x: Rec X. X .\y: Unit .x) 0 ) true)) in (((\x: Rec X. X .\y: Rec X. X .x) 1 ) ({a = false , b = true }.b))) in (((\x: Unit .\y: Bool .x) (pred 0) ) (((\x: Bool .\y: Rec X. X .y) false ) true))))
(fix (\x: Bool . (fix (\x: Unit . (let u = (let u = ({a = 0 , b = 0 }.b) in false) in (((\x: Nat .\y: Bool .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) true)) )) ))
(( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Bool .y) ({a = 1 , b = true }.b) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a))) ) (unfold [ Unit ] (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ))) ) (((\x: Nat .\y: Unit .y) (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] false )) )) ) ({a = ({a = true , b = 0 }.a) , b = (((\x: Bool .\y: Nat .x) true ) (unfold [ Rec X. X ] (fold [ Nat ] false ))) }.b)) ) ) (\a: Rec X. X .\b: Bool .b))
({a = (if (( \f: Rec X. X .((f (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = false }.b) )) in ({a = (fix (\x: Bool . false )) , b = (let u = 1 in 0) }.a)) ) ({a = (let u = false in true) , b = ({a = 1 , b = true , c =  1 }.b) }.b) ) ) (\a: Unit .\b: Nat .a)) then ({a = (let u = (((\x: Nat .\y: Bool .x) 0 ) true) in u) , b = (((\x: Rec X. X .\y: Unit .x) ({a = true , b = false }.b) ) ({a = 1 , b = false }.b)) , c =  (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in 0) }.b) else ({a = ({a = (((\x: Bool .\y: Nat .x) 1 ) true) , b = true }.b) , b = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = true }.b) )) }.b)) , b = (let u = ({a = ({a = ({a = 0 , b = true }.a) , b = (let u = 1 in u) }.b) , b = ({a = ({a = true , b = 0 }.b) , b = false , c =  0 }.b) }.a) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in (succ 1)) ))) }.b)
(iszero (((\x: Rec X. X .\y: Nat .x) ({a = ({a = false , b = 1 }.b) , b = (let u = false in false) , c = (pred 1) }.c) ) ({a = (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (unfold [ Unit ] (fold [ Bool ] ({a = false , b = false }.b) )) }.b)))
(iszero (((\x: Nat .\y: Bool .y) (let u = (let u = (((\x: Unit .\y: Nat .x) ({a = 0 , b = true , c =  0 }.b) ) true) in ({a = false , b = 0 }.b)) in (unfold [ Nat ] (fold [ Rec X. X ] false ))) ) (( \f: Nat .((f ({a = 1 , b = false }.a) ) ({a = (((\x: Rec X. X .\y: Unit .y) true ) 0) , b = (unfold [ Unit ] (fold [ Unit ] true )) }.a) ) ) (\a: Rec X. X .\b: Bool .b))))
(unfold [ Unit ] (fold [ Rec X. X ] (if ({a = (unfold [ Rec X. X ] (fold [ Nat ] (pred 0) )) , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .b)) }.b) then (let u = (let u = 0 in false) in (((\x: Rec X. X .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) true)) else (case <r = ({a = 1 , b = false , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y)) ))
(succ (let u = (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = ({a = 0 , b = false }.b) , c =  (let u = true in 1) }.b) )) in ({a = (fix (\x: Nat . 0 )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c)))
({a = (let u = (if (if true then false else true) then (let u = 1 in 1) else (fix (\x: Unit . 1 ))) in (( \f: Unit .((f (fix (\x: Rec X. X . true )) ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Nat .b))) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = (let u = (if false then 0 else 0) in 1) in u) )) }.b)
({a = ({a = (if ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) then (iszero 0) else (((\x: Rec X. X .\y: Rec X. X .y) true ) true)) , b = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = ({a = 0 , b = 0 }.b) }.b) )) }.a) , b = ({a = (( \f: Bool .((f ({a = 0 , b = false }.b) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (case <l = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) else (let u = (pred 0) in u)) > as Unit of < l = x > => x | < r = y > => y) }.a) }.b)
(let u = (let u = (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) )) )) in ({a = (succ ({a = false , b = 1 }.b)) , b = (case <r = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) , c =  (let u = 0 in u) }.b)) in (let u = (let u = (let u = true in 0) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) in (((\x: Rec X. X .\y: Unit .x) (let u = (((\x: Bool .\y: Unit .y) true ) false) in (((\x: Rec X. X .\y: Unit .y) false ) false)) ) ({a = ({a = 0 , b = true }.a) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , c =  (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.b))))
(( \f: Unit .((f (case <l = (( \f: Rec X. X .((f ({a = 0 , b = (fix (\x: Nat . 1 )) }.b) ) (succ 1) ) ) (\a: Nat .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = (succ (((\x: Bool .\y: Nat .x) 1 ) true)) , b = (if (((\x: Bool .\y: Rec X. X .x) false ) true) then 0 else 1) }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Nat .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.a)) , b = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b)) }.b) ) (let u = (iszero (case <l = ({a = false , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y)) in ({a = (fix (\x: Bool . (fix (\x: Unit . 1 )) )) , b = (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) , c =  (((\x: Rec X. X .\y: Bool .y) true ) 1) }.b)) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Bool . ({a = (fix (\x: Nat . ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .x) 1 ) false) )) )) , b = (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) in u) }.a) ))
(((\x: Rec X. X .\y: Nat .x) (if ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) then (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (fix (\x: Nat . (((\x: Bool .\y: Nat .x) 1 ) false) )) , b = (if false then false else true) , c =  (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.b))
(let u = (((\x: Bool .\y: Unit .x) (pred (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) ) (((\x: Nat .\y: Unit .y) (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) in ({a = 0 , b = true , c =  1 }.b)) ) (let u = true in u))) in u)
(((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Bool .y) (((\x: Unit .\y: Unit .x) false ) ({a = false , b = false }.b)) ) ({a = (((\x: Nat .\y: Nat .y) true ) 0) , b = false }.a)) ) (fix (\x: Rec X. X . (if ({a = false , b = false }.b) then (iszero 1) else (((\x: Rec X. X .\y: Unit .x) false ) false)) )))
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Bool .((f ({a = ({a = 1 , b = 1 }.b) , b = false , c = (pred 0) }.c) ) ({a = 1 , b = 0 }.b) ) ) (\a: Nat .\b: Unit .a)) )) , b = (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Bool .\y: Unit .y) (let u = (let u = 1 in u) in (let u = false in false)) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b))) )) ) (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Rec X. X ] false )) ))) }.a)
(if ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) then (( \f: Bool .((f (if (iszero 0) then false else true) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = false , c =  0 }.b) )) ) ) (\a: Bool .\b: Unit .a)) else ({a = 1 , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .a)) }.b)) )) then (fix (\x: Unit . (case <r = (unfold [ Rec X. X ] (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) )) else ({a = (let u = ({a = 0 , b = true , c = 1 }.c) in true) , b = (let u = ({a = 0 , b = false , c = 0 }.c) in u) }.a))
(let u = (let u = (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) (case <l = (unfold [ Nat ] (fold [ Unit ] 0 )) > as Unit of < l = x > => x | < r = y > => y)) in (let u = (pred 0) in false)) in (((\x: Nat .\y: Unit .y) (iszero ({a = 0 , b = true , c = 1 }.c)) ) (let u = (let u = ({a = 1 , b = false }.b) in 0) in ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )))))
(((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f (let u = (unfold [ Nat ] (fold [ Bool ] (succ 1) )) in ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = ({a = 0 , b = true }.a) }.a)) ) (iszero ({a = 1 , b = (let u = true in 1) }.b)) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = (((\x: Unit .\y: Rec X. X .x) (let u = (fix (\x: Bool . true )) in u) ) (unfold [ Nat ] (fold [ Nat ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) ))) , b = (unfold [ Unit ] (fold [ Bool ] (let u = true in false) )) }.b))
(let u = (((\x: Rec X. X .\y: Nat .x) ({a = (((\x: Nat .\y: Bool .x) (fix (\x: Rec X. X . 1 )) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a))) , b = (let u = 0 in false) , c =  ({a = (let u = 0 in u) , b = false }.a) }.b) ) (unfold [ Unit ] (fold [ Nat ] (let u = false in true) ))) in (unfold [ Unit ] (fold [ Unit ] ({a = ({a = (let u = 0 in 1) , b = false , c = (let u = 1 in u) }.c) , b = (let u = true in u) , c =  ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (iszero 0) }.a) }.b) )))
(( \f: Bool .((f ({a = (( \f: Bool .((f ({a = ({a = true , b = 1 }.a) , b = 0 }.b) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) , b = ({a = (iszero (let u = 0 in 0)) , b = (let u = ({a = false , b = 0 }.b) in ({a = false , b = false }.b)) }.b) , c = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = true }.a) )) }.b) }.c) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) (iszero 0) ) (if false then 0 else 0)) ) (fix (\x: Nat . (let u = true in 0) )) ) ) (\a: Bool .\b: Nat .b)) ) (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .x) 1 ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) )) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .b))
(if (case <r = (let u = (((\x: Unit .\y: Nat .x) 0 ) false) in (fix (\x: Rec X. X . true ))) > as Nat of < l = x > => x | < r = y > => y) then (iszero (pred (let u = ({a = true , b = 0 }.b) in 0))) else ({a = (pred (pred (( \f: Bool .((f (fix (\x: Bool . 1 )) ) 1 ) ) (\a: Unit .\b: Unit .b)))) , b = (if (case <r = (if true then true else false) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = ({a = 1 , b = 0 }.b) in (let u = true in true)) else (iszero (((\x: Bool .\y: Nat .x) 1 ) false))) , c =  (let u = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) 1 ) ) (\a: Nat .\b: Unit .a)) in u) }.b))
(succ (case <l = ({a = (let u = 0 in 0) , b = (unfold [ Nat ] (fold [ Nat ] true )) }.a) > as Rec X. X of < l = x > => x | < r = y > => y))
({a = (pred (( \f: Bool .((f (((\x: Nat .\y: Nat .y) ({a = false , b = 1 }.a) ) 1) ) (pred 0) ) ) (\a: Nat .\b: Rec X. X .b))) , b = (fix (\x: Nat . (( \f: Nat .((f 0 ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Nat .b)) )) }.b)
(pred (let u = ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a)) )) , c =  ({a = true , b = 0 }.b) }.b) in (let u = ({a = (iszero 1) , b = ({a = 0 , b = 1 }.b) }.a) in ({a = 1 , b = false , c = ({a = true , b = 1 }.b) }.c))))
(( \f: Rec X. X .((f ({a = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) in ({a = true , b = 1 }.a)) , b = (unfold [ Nat ] (fold [ Bool ] ({a = 1 , b = 1 }.b) )) }.a) ) (unfold [ Unit ] (fold [ Nat ] (let u = (unfold [ Bool ] (fold [ Nat ] true )) in u) )) ) ) (\a: Unit .\b: Unit .a))
(fix (\x: Unit . ({a = (let u = ({a = (let u = ({a = false , b = 0 }.a) in true) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .a)) }.b) in ({a = (((\x: Unit .\y: Bool .x) 0 ) true) , b = false }.b)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .x) (((\x: Unit .\y: Unit .x) 1 ) true) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .a))) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Nat .b)) )) }.b) ))
(( \f: Unit .((f (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then ({a = ({a = (fix (\x: Unit . true )) , b = 1 }.b) , b = ({a = true , b = false }.b) }.b) else ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) ))) ) (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Bool ] (let u = (iszero 0) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) )) ) (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] true )) ) (unfold [ Nat ] (fold [ Nat ] false )) ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Unit .\b: Bool .a))
(pred (((\x: Rec X. X .\y: Bool .y) ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) in u) , b = (unfold [ Rec X. X ] (fold [ Unit ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) }.a) ) (pred (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))))
({a = ({a = (((\x: Rec X. X .\y: Unit .y) (fix (\x: Unit . true )) ) (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) ))) , b = (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Unit ] true )) )) , c = ({a = ({a = true , b = (let u = 1 in 0) }.b) , b = ({a = ({a = true , b = 1 }.a) , b = false }.b) }.a) }.c) , b = (((\x: Rec X. X .\y: Nat .y) (((\x: Nat .\y: Unit .y) true ) (let u = 1 in false)) ) ({a = (iszero 0) , b = (let u = false in 0) }.a)) , c =  (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = 1 , b = true , c = 0 }.c) in u) )) in (let u = (pred 0) in u)) }.b)
(let u = ({a = (unfold [ Unit ] (fold [ Rec X. X ] ({a = (fix (\x: Unit . (let u = 0 in true) )) , b = (fix (\x: Rec X. X . (if false then 0 else 0) )) }.b) )) , b = ({a = (fix (\x: Bool . ({a = true , b = false }.b) )) , b = (let u = 1 in 1) }.a) , c = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f (succ 0) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) )) }.c) in u)
(case <r = (( \f: Unit .((f (if (unfold [ Bool ] (fold [ Rec X. X ] false )) then (( \f: Nat .((f (let u = true in u) ) (if false then false else false) ) ) (\a: Nat .\b: Unit .b)) else (iszero 0)) ) (((\x: Bool .\y: Nat .x) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .b)) ) ({a = (let u = false in true) , b = false }.b)) ) ) (\a: Rec X. X .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y)
(unfold [ Bool ] (fold [ Bool ] ({a = ({a = (( \f: Bool .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Bool .y) false ) true) ) true) ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = (let u = (let u = 0 in u) in (((\x: Bool .\y: Bool .x) 0 ) false)) , b = (let u = (let u = 0 in false) in (let u = false in 1)) }.b) }.a) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) , b = (let u = 1 in true) , c =  (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) }.b) ))
(case <r = ({a = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (pred 1) }.a) , b = (( \f: Rec X. X .((f (if false then false else true) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (if (let u = (iszero 0) in true) then (( \f: Rec X. X .((f (fix (\x: Rec X. X . 0 )) ) (let u = true in 0) ) ) (\a: Bool .\b: Nat .a)) else ({a = (let u = true in ({a = false , b = 0 }.b)) , b = ({a = false , b = 1 }.a) , c = ({a = false , b = 0 }.b) }.c)) , b = ({a = (iszero (succ ({a = true , b = 0 }.b))) , b = ({a = (let u = false in u) , b = (((\x: Unit .\y: Nat .y) false ) 0) }.b) }.a) }.b)
(((\x: Bool .\y: Bool .y) (iszero (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = true }.a) ))) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Bool .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) ) (((\x: Nat .\y: Bool .x) false ) true)) )))
(fix (\x: Unit . (if ({a = (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) in u) , b = (let u = true in u) }.b) then ({a = (let u = (pred 0) in (((\x: Nat .\y: Rec X. X .x) 0 ) true)) , b = ({a = (((\x: Nat .\y: Rec X. X .x) true ) false) , b = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) in true) }.b) , c =  ({a = true , b = 0 }.b) }.b) else (let u = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = (((\x: Nat .\y: Nat .y) true ) true) }.a) in ({a = (iszero 0) , b = (unfold [ Unit ] (fold [ Nat ] 0 )) }.a))) ))
(((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Unit .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = 1 , b = false }.b)) ) (case <r = (fix (\x: Nat . (fix (\x: Bool . false )) )) > as Unit of < l = x > => x | < r = y > => y)) ) (if (if (iszero 0) then false else ({a = true , b = 0 }.a)) then (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (let u = 1 in true) in u) )) else ({a = ({a = 0 , b = false }.a) , b = (iszero 0) , c =  1 }.b)))
(unfold [ Bool ] (fold [ Bool ] (pred (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) ))) ))
(if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) )) then (iszero (fix (\x: Bool . (let u = (let u = true in 0) in (if true then 0 else 0)) ))) else (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y) )) then (iszero (succ 0)) else (if (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) > as Nat of < l = x > => x | < r = y > => y) then (iszero 1) else (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)))))
(iszero (case <l = (((\x: Nat .\y: Nat .y) ({a = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .b)) , b = (fix (\x: Unit . 1 )) }.a) ) ({a = 1 , b = false , c = 0 }.c)) > as Bool of < l = x > => x | < r = y > => y))
(let u = (let u = (( \f: Bool .((f (((\x: Bool .\y: Bool .y) true ) ({a = 1 , b = 1 }.b)) ) (if (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a)) then 0 else 1) ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = ({a = (let u = false in 0) , b = false , c =  1 }.b) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = (let u = true in false) }.a) }.b)) in ({a = (fix (\x: Nat . (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in u) )) , b = (( \f: Unit .((f (succ 0) ) (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Rec X. X .b)) }.b))
(((\x: Nat .\y: Bool .x) ({a = (( \f: Nat .((f (fix (\x: Unit . (let u = 0 in u) )) ) (( \f: Unit .((f 1 ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .a)) , b = (((\x: Unit .\y: Bool .x) (( \f: Nat .((f true ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = 1 , b = false , c =  0 }.b)) }.b) ) (( \f: Rec X. X .((f ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) )) , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) }.b) ) (if true then true else ({a = 0 , b = false , c =  1 }.b)) ) ) (\a: Bool .\b: Bool .a)))
(((\x: Bool .\y: Unit .x) (( \f: Unit .((f (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) in (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .b))) ) ({a = (( \f: Unit .((f 1 ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.a) }.b) ) ) (\a: Bool .\b: Bool .a)) ) (case <r = (let u = (((\x: Nat .\y: Bool .y) false ) true) in u) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Rec X. X .\y: Unit .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (case <r = ({a = 0 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (let u = ({a = ({a = (((\x: Rec X. X .\y: Unit .y) true ) 1) , b = (let u = 0 in u) }.b) , b = (( \f: Nat .((f (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Bool .\y: Bool .x) false ) true) ) ) (\a: Nat .\b: Nat .b)) }.a) in u))
(let u = ({a = (((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Unit .y) false ) (((\x: Bool .\y: Bool .x) 1 ) false)) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true)) , b = (let u = (((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Rec X. X .x) 1 ) false) ) true) in (((\x: Nat .\y: Bool .x) (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) (unfold [ Nat ] (fold [ Rec X. X ] false )))) }.b) in u)
(pred (case <l = (if ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = ({a = 1 , b = false , c = 1 }.c) , b = (((\x: Rec X. X .\y: Bool .x) false ) false) , c =  1 }.b) )) then (let u = 0 in 1) else (let u = (let u = 0 in u) in ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.c))) > as Unit of < l = x > => x | < r = y > => y))
(succ (fix (\x: Unit . (( \f: Bool .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Nat .\b: Unit .b)) )))
({a = (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) false ) false) )) , b = ({a = (case <l = ({a = (iszero 1) , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (if (((\x: Unit .\y: Bool .y) true ) true) then (if true then false else true) else (((\x: Rec X. X .\y: Unit .x) (if true then false else false) ) ({a = true , b = 1 }.a))) }.a) }.a)
(unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) , b = ({a = 0 , b = true }.a) }.a) , b = (let u = (let u = 1 in 1) in 0) }.a) in u) ))
(((\x: Bool .\y: Bool .x) (case <r = (((\x: Rec X. X .\y: Nat .y) (if true then false else false) ) (( \f: Rec X. X .((f ({a = true , b = false }.b) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Nat .b))) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (let u = (fix (\x: Rec X. X . 0 )) in ({a = false , b = 0 }.b)) , b = (let u = (iszero 1) in u) }.b))
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = (if false then 0 else 1) }.b) )) ))
(succ (pred (if (unfold [ Bool ] (fold [ Bool ] (fix (\x: Unit . false )) )) then ({a = 1 , b = ({a = 0 , b = false }.b) }.a) else (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)))))
(( \f: Unit .((f (succ ({a = (if ({a = true , b = 0 }.a) then (let u = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) in (let u = 1 in u)) else (( \f: Nat .((f ({a = 1 , b = false }.a) ) ({a = 0 , b = false }.a) ) ) (\a: Nat .\b: Unit .a))) , b = (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) , c = (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = 1 }.b) )) }.c)) ) ({a = (succ (let u = 0 in 1)) , b = ({a = (if false then (let u = false in 1) else ({a = false , b = 1 }.b)) , b = ({a = 0 , b = false }.b) }.b) , c = (case <l = (unfold [ Rec X. X ] (fold [ Nat ] (let u = true in 0) )) > as Bool of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Bool .\b: Bool .a))
(let u = (pred (unfold [ Unit ] (fold [ Rec X. X ] (succ (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) ))) in u)
({a = ({a = (( \f: Bool .((f (((\x: Unit .\y: Nat .y) true ) 1) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) in u) ) ) (\a: Bool .\b: Nat .b)) , b = (unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f (let u = 0 in true) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) }.b) , b = ({a = ({a = ({a = (pred ({a = 1 , b = false , c = 1 }.c)) , b = (pred 0) }.b) , b = (case <r = (fix (\x: Bool . true )) > as Unit of < l = x > => x | < r = y > => y) , c = (let u = 1 in 1) }.c) , b = (fix (\x: Unit . (((\x: Bool .\y: Rec X. X .y) false ) 1) )) }.b) }.b)
(((\x: Nat .\y: Unit .y) (if (let u = ({a = 0 , b = false , c =  0 }.b) in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) then (let u = (let u = 0 in true) in true) else (unfold [ Nat ] (fold [ Bool ] (if true then true else true) ))) ) (unfold [ Nat ] (fold [ Nat ] ({a = (let u = (let u = true in false) in (let u = false in u)) , b = (( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] 0 )) ) ({a = 1 , b = 1 }.b) ) ) (\a: Bool .\b: Nat .a)) }.a) )))
(((\x: Nat .\y: Bool .y) (( \f: Bool .((f (let u = (case <l = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then 0 else (let u = 1 in 1)) > as Unit of < l = x > => x | < r = y > => y) in (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) false ) true) ) (((\x: Bool .\y: Unit .x) false ) false) ) ) (\a: Nat .\b: Nat .b))) ) ({a = (( \f: Nat .((f ({a = 0 , b = 0 }.b) ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = true in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false ))) }.b) ) ) (\a: Nat .\b: Nat .b)) ) ({a = (pred ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 ))) , b = (let u = (((\x: Bool .\y: Unit .x) false ) false) in u) }.b))
(( \f: Nat .((f (fix (\x: Bool . (succ (( \f: Rec X. X .((f (let u = (let u = 1 in 0) in u) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a))) )) ) (((\x: Bool .\y: Rec X. X .y) ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a)) , b = ({a = false , b = (let u = true in 1) }.b) }.a) ) (((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Rec X. X .y) true ) 1) ) false)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(succ ({a = ({a = ({a = true , b = 0 }.b) , b = (let u = 1 in 1) }.b) , b = (( \f: Nat .((f (( \f: Rec X. X .((f ({a = false , b = ({a = 0 , b = true , c =  1 }.b) }.b) ) (let u = (let u = 1 in u) in true) ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = ({a = ({a = 0 , b = true }.b) , b = true }.b) in u) ) ) (\a: Rec X. X .\b: Nat .a)) , c = ({a = (( \f: Nat .((f (if false then false else false) ) (((\x: Unit .\y: Nat .x) true ) true) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (succ (((\x: Bool .\y: Unit .y) true ) 1)) }.b) }.c))
({a = (case <l = ({a = (let u = 0 in u) , b = (let u = ({a = false , b = false }.b) in u) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . ({a = (let u = (let u = (if true then false else true) in true) in (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) }.a) )) }.b)
(let u = (case <r = (let u = (let u = ({a = true , b = 0 }.b) in false) in u) > as Bool of < l = x > => x | < r = y > => y) in (let u = (( \f: Unit .((f ({a = (((\x: Bool .\y: Unit .x) false ) true) , b = 0 }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = false in u) }.a)))
({a = (pred (((\x: Bool .\y: Unit .x) (fix (\x: Bool . 0 )) ) true)) , b = (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = ({a = false , b = true }.b) }.a) )) }.b)
(let u = (case <l = ({a = 1 , b = ({a = 0 , b = false }.a) }.b) > as Bool of < l = x > => x | < r = y > => y) in (( \f: Bool .((f ({a = (fix (\x: Rec X. X . 0 )) , b = (fix (\x: Bool . false )) , c =  (pred ({a = 1 , b = 0 }.b)) }.b) ) (if ({a = 1 , b = true }.b) then (((\x: Unit .\y: Nat .y) true ) false) else ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true ))) ) ) (\a: Rec X. X .\b: Bool .b)))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ) ({a = true , b = (let u = false in false) }.b)) )) ))
(pred (( \f: Unit .((f (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . (((\x: Unit .\y: Unit .x) 1 ) false) )) ) ) (\a: Rec X. X .\b: Nat .a)))
(unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f (( \f: Nat .((f (fix (\x: Nat . ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) )) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Bool .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = true , b = 0 }.a)) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Unit .\y: Bool .y) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = ({a = 1 , b = false }.b) , b = ({a = 0 , b = 1 }.b) }.a)) ) ) (\a: Nat .\b: Unit .b)) ))
({a = (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Nat ] 0 )) ))) , b = ({a = (succ (let u = false in 1)) , b = (let u = ({a = 0 , b = (let u = 0 in false) , c = 0 }.c) in (( \f: Bool .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Bool .\y: Bool .y) true ) true) ) ) (\a: Bool .\b: Rec X. X .a))) }.b) , c = (let u = ({a = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) in true) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) , b = 0 }.b) }.a) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) false ) 1) ))) }.c)
(let u = (iszero (fix (\x: Nat . ({a = (((\x: Bool .\y: Rec X. X .x) true ) true) , b = 1 }.b) ))) in (case <l = (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) then (((\x: Rec X. X .\y: Nat .x) 0 ) true) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) > as Bool of < l = x > => x | < r = y > => y))
(((\x: Rec X. X .\y: Unit .y) (fix (\x: Rec X. X . ({a = (iszero 0) , b = (let u = true in (let u = false in true)) }.b) )) ) (if ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , b = ({a = true , b = 0 }.a) }.b) then ({a = (unfold [ Nat ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] true )) )) )) , b = (case <l = (succ 1) > as Bool of < l = x > => x | < r = y > => y) }.b) else (((\x: Unit .\y: Rec X. X .x) ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = 1 }.b) , b = (let u = 1 in true) , c = (( \f: Unit .((f (((\x: Unit .\y: Nat .y) true ) 0) ) 1 ) ) (\a: Nat .\b: Unit .a)) }.c) ) (let u = true in u))))
({a = (((\x: Bool .\y: Nat .x) (case <l = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) true ) true) )) , b = (fix (\x: Nat . true )) }.b)) , b = (if ({a = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .b)) , b = (let u = (unfold [ Nat ] (fold [ Nat ] true )) in u) }.b) then (((\x: Rec X. X .\y: Bool .y) (iszero (let u = 0 in u)) ) (let u = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) in u)) else (((\x: Bool .\y: Bool .x) (let u = (((\x: Unit .\y: Unit .x) true ) false) in (( \f: Rec X. X .((f true ) (iszero 1) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .b)))) }.b)
(( \f: Rec X. X .((f ({a = (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) then (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Nat .x) 0 ) false) ) false) else (succ 0)) , b = ({a = (unfold [ Unit ] (fold [ Nat ] 1 )) , b = ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = true , c =  (unfold [ Bool ] (fold [ Rec X. X ] 1 )) }.b) }.a) }.b) ) (let u = (iszero (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .x) 1 ) true) ))) in ({a = (if false then true else false) , b = ({a = 0 , b = true , c = 0 }.c) }.b)) ) ) (\a: Nat .\b: Unit .b))
(if (((\x: Unit .\y: Unit .y) (let u = ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = true , c =  (let u = true in 0) }.b) in (((\x: Rec X. X .\y: Bool .y) true ) (let u = false in u))) ) (( \f: Rec X. X .((f (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = false , b = false }.b)) ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b))) then (( \f: Rec X. X .((f (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f (let u = true in u) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) else (let u = true in u)) ) ({a = (let u = true in u) , b = ({a = 0 , b = false }.a) }.a) ) ) (\a: Bool .\b: Unit .b)) else ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (iszero 0) )) )))
(case <r = (let u = (( \f: Unit .((f ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = (((\x: Nat .\y: Nat .x) 0 ) true) }.a) ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .a)) in u) > as Unit of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . (let u = 1 in u) )) )) ))
({a = ({a = (if ({a = false , b = true }.b) then ({a = 1 , b = 1 }.b) else (fix (\x: Rec X. X . 0 ))) , b = ({a = (( \f: Bool .((f (((\x: Unit .\y: Bool .y) false ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 ))) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = (((\x: Bool .\y: Bool .y) (unfold [ Unit ] (fold [ Unit ] false )) ) 1) in (unfold [ Unit ] (fold [ Nat ] ({a = true , b = 1 }.a) ))) }.b) , c =  (let u = (case <l = (((\x: Bool .\y: Nat .x) 0 ) true) > as Unit of < l = x > => x | < r = y > => y) in u) }.b) , b = (case <l = ({a = (fix (\x: Unit . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = false , b = false }.b) )) }.a) > as Nat of < l = x > => x | < r = y > => y) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) (let u = (((\x: Unit .\y: Bool .x) (let u = true in false) ) (fix (\x: Rec X. X . true ))) in (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f false ) (let u = true in true) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .a))) ) (if (unfold [ Bool ] (fold [ Bool ] true )) then (if false then false else false) else ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )))) ))
(pred (let u = (let u = (let u = true in 0) in ({a = true , b = 1 }.b)) in u))
(((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Bool .y) (let u = (( \f: Nat .((f false ) (fix (\x: Unit . false )) ) ) (\a: Nat .\b: Unit .a)) in (let u = true in u)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Nat . true )) ))) ) ({a = (case <r = ({a = ({a = 1 , b = ({a = true , b = 1 }.a) , c =  1 }.b) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) in (((\x: Unit .\y: Rec X. X .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) false)) }.b))
(((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Unit .y) (let u = (let u = false in ({a = true , b = 1 }.b)) in (fix (\x: Unit . (((\x: Unit .\y: Nat .x) false ) (if false then true else true)) ))) ) (((\x: Rec X. X .\y: Unit .y) (case <r = (fix (\x: Bool . false )) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . true )))) ) (( \f: Bool .((f (((\x: Unit .\y: Nat .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = false , b = true }.b)) ) (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Rec X. X .x) true ) false) ) ({a = 0 , b = false , c =  0 }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(iszero ({a = (( \f: Bool .((f (let u = false in u) ) (if false then true else true) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Nat .\y: Nat .x) (let u = (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) )) in (succ 0)) ) ({a = true , b = 1 }.a)) }.b))
(( \f: Unit .((f (let u = ({a = (let u = true in true) , b = ({a = ({a = true , b = true }.b) , b = false }.b) }.b) in u) ) ({a = ({a = 1 , b = (let u = true in u) , c = ({a = false , b = 1 }.b) }.c) , b = (let u = (( \f: Unit .((f ({a = 0 , b = false }.a) ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Unit .a)) in (fix (\x: Nat . true ))) , c =  (let u = ({a = true , b = false }.b) in (if true then (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) else 0)) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (iszero (let u = true in (((\x: Unit .\y: Bool .x) 1 ) false))) in (if (let u = false in true) then (let u = (if (fix (\x: Bool . true )) then true else ({a = 1 , b = false , c =  1 }.b)) in (let u = false in false)) else ({a = true , b = (let u = 1 in u) }.a)))
(fix (\x: Bool . (case <r = ({a = ({a = false , b = 0 }.a) , b = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.a) > as Unit of < l = x > => x | < r = y > => y) ))
(iszero (((\x: Bool .\y: Nat .y) (if (let u = true in u) then ({a = false , b = false }.b) else ({a = 1 , b = (((\x: Nat .\y: Bool .y) true ) false) }.b)) ) (let u = ({a = 1 , b = false , c =  1 }.b) in 1)))
(pred (((\x: Rec X. X .\y: Unit .x) ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = false }.a) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) true ) true) ))))
(unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f (((\x: Unit .\y: Bool .x) ({a = false , b = true }.b) ) true) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Nat .\b: Rec X. X .a)) )) ))
(if (fix (\x: Nat . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = (let u = false in 0) , b = (iszero 0) , c =  ({a = 1 , b = false , c = 0 }.c) }.b) )) )) then (if (let u = (((\x: Nat .\y: Nat .x) ({a = 1 , b = 0 }.b) ) (let u = true in u)) in ({a = true , b = false }.b)) then (let u = (if false then 0 else 0) in u) else (succ (pred 0))) else (let u = ({a = 1 , b = ({a = true , b = 0 }.a) , c = 0 }.c) in (let u = ({a = 0 , b = true }.a) in 0)))
({a = (if (if (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) true ) ) (\a: Bool .\b: Rec X. X .a)) then (if false then true else true) else (iszero 1)) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = false }.b) )) else ({a = 1 , b = true }.b)) , b = (unfold [ Unit ] (fold [ Unit ] ({a = ({a = (let u = false in false) , b = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) , b = ({a = (succ 1) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) }.a) }.b) )) }.a)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] ({a = (((\x: Nat .\y: Unit .y) true ) 1) , b = (pred 1) }.b) )) ) (((\x: Rec X. X .\y: Unit .x) (pred (((\x: Rec X. X .\y: Unit .x) 0 ) true)) ) (let u = ({a = 0 , b = true , c =  0 }.b) in u)) ) ) (\a: Unit .\b: Bool .b))
(case <l = ({a = (let u = ({a = 0 , b = true , c =  ({a = true , b = 1 }.b) }.b) in ({a = 0 , b = false , c =  1 }.b)) , b = (let u = 0 in 0) }.b) > as Nat of < l = x > => x | < r = y > => y)
(let u = (( \f: Nat .((f (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) in (((\x: Bool .\y: Nat .y) false ) true)) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] (if true then 0 else 0) )) in ({a = true , b = false }.b)) ) ) (\a: Unit .\b: Bool .b)) in (unfold [ Bool ] (fold [ Bool ] (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) 1 ) false) ) (let u = (let u = 0 in 1) in 0) ) ) (\a: Unit .\b: Unit .a)) )))
(fix (\x: Bool . (((\x: Rec X. X .\y: Bool .y) (fix (\x: Bool . (iszero 0) )) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 ))) ))
(if (let u = ({a = ({a = false , b = 0 }.a) , b = (unfold [ Unit ] (fold [ Bool ] 1 )) }.b) in ({a = (let u = false in 1) , b = (let u = ({a = 1 , b = true , c =  0 }.b) in u) , c =  ({a = false , b = 1 }.b) }.b)) then ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (if (if false then true else false) then (let u = true in true) else ({a = false , b = true }.b)) )) else (let u = (let u = (pred 1) in (((\x: Bool .\y: Nat .y) false ) true)) in u))
(let u = (iszero ({a = (pred 0) , b = true , c = 1 }.c)) in u)
(( \f: Bool .((f (((\x: Bool .\y: Unit .y) ({a = 0 , b = (fix (\x: Bool . true )) }.b) ) (fix (\x: Nat . (( \f: Nat .((f ({a = 1 , b = true , c =  1 }.b) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Bool .y) (iszero ({a = 1 , b = true , c = 1 }.c)) ) ({a = 1 , b = ({a = 1 , b = false }.b) , c =  (let u = 1 in 0) }.b)) )) ) ) (\a: Nat .\b: Nat .b))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = (let u = (((\x: Unit .\y: Nat .y) false ) 1) in 1) }.b) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.b) )) , b = ({a = (( \f: Rec X. X .((f false ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = 1 , b = (let u = 0 in true) , c = 1 }.c) }.a) , c = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = true , c = (succ 1) }.c) }.c) }.b) ))
(succ (( \f: Nat .((f (pred ({a = 0 , b = true , c = 0 }.c)) ) ({a = 1 , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .b)))
(if (let u = ({a = (( \f: Nat .((f (let u = true in u) ) (iszero 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (((\x: Rec X. X .\y: Unit .x) ({a = true , b = false }.b) ) true) }.b) in (((\x: Unit .\y: Bool .y) (iszero (( \f: Unit .((f (unfold [ Bool ] (fold [ Bool ] 1 )) ) 0 ) ) (\a: Bool .\b: Rec X. X .a))) ) ({a = 1 , b = true }.b))) then (((\x: Bool .\y: Unit .y) (let u = (pred (((\x: Bool .\y: Bool .x) 1 ) false)) in (fix (\x: Bool . true ))) ) (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Bool .x) true ) true) ) ({a = true , b = 1 }.b))) else (succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (if (let u = false in u) then 1 else 0) ))))
(((\x: Bool .\y: Unit .y) ({a = (( \f: Unit .((f (((\x: Nat .\y: Bool .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (if true then true else false)) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Bool .\b: Rec X. X .a)) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) }.b) ) ({a = ({a = (case <l = (let u = 0 in u) > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) true ) false) )) }.b) , b = ({a = (( \f: Nat .((f (let u = false in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) (let u = ({a = 1 , b = false }.a) in 0) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = 0 , b = (succ 1) }.b) }.b) }.a))
(if (fix (\x: Rec X. X . (( \f: Rec X. X .((f (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) ({a = false , b = true }.b) ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)) )) then ({a = (succ (case <l = (((\x: Bool .\y: Rec X. X .x) ({a = 0 , b = 0 }.b) ) false) > as Unit of < l = x > => x | < r = y > => y)) , b = (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) , c =  ({a = ({a = 1 , b = 0 }.b) , b = (let u = true in u) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) }.c) }.b) else ({a = (case <r = ({a = true , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) in 0) }.a))
(fix (\x: Bool . (( \f: Rec X. X .((f (( \f: Bool .((f (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Unit .\b: Bool .b)) ) ({a = (let u = 1 in false) , b = (fix (\x: Bool . 0 )) }.b) ) ) (\a: Unit .\b: Bool .a)) ))
(((\x: Unit .\y: Rec X. X .x) ({a = (if (let u = true in false) then (pred 1) else (let u = false in (let u = true in 1))) , b = (((\x: Rec X. X .\y: Bool .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . false ))) , c = (let u = 0 in u) }.c) ) ({a = (( \f: Unit .((f (( \f: Rec X. X .((f ({a = 0 , b = false , c = 1 }.c) ) (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] 1 )) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .a)) ) (fix (\x: Rec X. X . (succ 1) )) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (case <r = ({a = true , b = 1 }.a) > as Bool of < l = x > => x | < r = y > => y) , c =  ({a = ({a = (iszero (pred 0)) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.a) , b = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.b) }.b) }.b))
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .y) (( \f: Nat .((f ({a = 1 , b = false , c =  0 }.b) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = ({a = 1 , b = false }.b) in (( \f: Unit .((f ({a = 1 , b = true , c = 0 }.c) ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Nat .\b: Bool .b)))) )) , b = (((\x: Bool .\y: Bool .x) (((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Nat ] true )) ) (( \f: Unit .((f true ) (((\x: Nat .\y: Nat .x) true ) true) ) ) (\a: Bool .\b: Bool .a))) ) ({a = (let u = 0 in false) , b = (fix (\x: Unit . true )) }.b)) , c = (pred (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = true }.a) ))) }.c)
(let u = (( \f: Rec X. X .((f (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (pred 0) in ({a = true , b = 0 }.b)) ) ) (\a: Bool .\b: Rec X. X .b)) in (if (unfold [ Unit ] (fold [ Nat ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] ({a = false , b = true }.b) )) )) )) then (((\x: Nat .\y: Nat .y) (fix (\x: Bool . ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = false }.b) )) ) (iszero ({a = 1 , b = false , c = 0 }.c))) else ({a = (( \f: Rec X. X .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = (case <r = (let u = false in false) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)))
(let u = (((\x: Bool .\y: Unit .x) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) , b = (let u = false in true) }.b) ) (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Nat .y) true ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ) (let u = true in (iszero 1)))) in (fix (\x: Rec X. X . (( \f: Nat .((f (let u = true in u) ) (fix (\x: Nat . false )) ) ) (\a: Bool .\b: Unit .a)) )))
(let u = ({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) in u) , b = (((\x: Unit .\y: Rec X. X .y) ({a = 0 , b = true }.b) ) false) }.b) in (if (iszero ({a = true , b = 0 }.b)) then (((\x: Bool .\y: Unit .y) (unfold [ Bool ] (fold [ Rec X. X ] true )) ) (fix (\x: Bool . 0 ))) else (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in ({a = true , b = ({a = true , b = 1 }.b) }.b))))
(if ({a = (succ (succ 0)) , b = (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) false ) true) )) }.b) then (case <r = (iszero 0) > as Rec X. X of < l = x > => x | < r = y > => y) else (iszero ({a = (( \f: Nat .((f 0 ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (if false then false else true) , c = (let u = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) in 1) }.c)))
(fix (\x: Rec X. X . (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .y) (let u = true in u) ) true) )) in (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .y) false ) (pred 0)) ))) ))
(fix (\x: Bool . (case <r = (if (((\x: Unit .\y: Nat .x) false ) true) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else (let u = false in u)) > as Bool of < l = x > => x | < r = y > => y) ))
(let u = ({a = (let u = (((\x: Bool .\y: Unit .x) 1 ) false) in ({a = true , b = 0 }.b)) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) , c =  (((\x: Nat .\y: Nat .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) 1) }.b) in u)
({a = (let u = (let u = (unfold [ Unit ] (fold [ Unit ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) )) in u) in (( \f: Nat .((f (( \f: Unit .((f (fix (\x: Bool . 0 )) ) (( \f: Bool .((f (succ 0) ) 1 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Unit .a)) ) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) )) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Nat .\b: Nat .a))) , b = (pred (fix (\x: Bool . (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ))) }.b)
(succ (((\x: Rec X. X .\y: Rec X. X .y) ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (fix (\x: Nat . true )) , c =  0 }.b) ) (let u = 0 in 1)))
(( \f: Rec X. X .((f ({a = (fix (\x: Bool . ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = ({a = true , b = 1 }.a) , b = true }.b) }.b) )) , b = (((\x: Unit .\y: Bool .x) (let u = ({a = true , b = 1 }.b) in (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (let u = ({a = false , b = 1 }.a) in u)) }.b) ) (iszero (((\x: Bool .\y: Unit .y) (if (((\x: Rec X. X .\y: Bool .y) true ) true) then false else (iszero 1)) ) ({a = 1 , b = true , c = 0 }.c))) ) ) (\a: Nat .\b: Unit .b))
(((\x: Bool .\y: Bool .x) ({a = (unfold [ Bool ] (fold [ Bool ] (let u = true in u) )) , b = ({a = (let u = ({a = ({a = 1 , b = true }.b) , b = ({a = 0 , b = false , c = 1 }.c) }.a) in (if ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) then 0 else (succ 1))) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.a) }.a) ) ({a = ({a = (let u = 0 in true) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.a) , b = ({a = ({a = (let u = true in true) , b = 1 }.b) , b = (let u = ({a = false , b = 1 }.b) in 0) }.b) }.a))
(let u = ({a = (((\x: Nat .\y: Bool .y) (iszero (pred (((\x: Nat .\y: Rec X. X .y) false ) 1))) ) (if false then ({a = false , b = 1 }.a) else false)) , b = ({a = (let u = true in u) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.b) }.a) in u)
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = (( \f: Bool .((f (((\x: Bool .\y: Unit .x) false ) true) ) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = 0 }.a) ) ) (\a: Bool .\b: Bool .b)) in (((\x: Unit .\y: Nat .x) (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (( \f: Unit .((f true ) ({a = false , b = false }.b) ) ) (\a: Unit .\b: Rec X. X .b)))) ))
({a = (((\x: Nat .\y: Rec X. X .y) (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .y) (let u = true in u) ) ({a = true , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.a))) , b = (( \f: Nat .((f ({a = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = true }.a) , b = (( \f: Bool .((f ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = true , c =  0 }.b) ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Unit .a)) , c =  ({a = 1 , b = (((\x: Unit .\y: Nat .y) false ) false) }.a) }.b) ) (case <r = (((\x: Nat .\y: Nat .y) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) }.b)
(succ (((\x: Nat .\y: Rec X. X .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .x) true ) true) ) false ) ) (\a: Bool .\b: Bool .a)) )) ) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 1 )) , b = false , c = 1 }.c)))
(((\x: Nat .\y: Unit .x) (if (let u = true in (((\x: Bool .\y: Bool .y) true ) true)) then ({a = (unfold [ Unit ] (fold [ Rec X. X ] false )) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.b) else ({a = (((\x: Unit .\y: Unit .y) false ) (unfold [ Unit ] (fold [ Rec X. X ] false ))) , b = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .b)) }.b)) ) (((\x: Nat .\y: Unit .y) (if (iszero 0) then ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false , c =  1 }.b) else ({a = false , b = 0 }.a)) ) ({a = ({a = false , b = 0 }.b) , b = true }.b)))
(( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] (let u = false in u) )) ) (iszero (pred ({a = (((\x: Bool .\y: Bool .x) 0 ) true) , b = (fix (\x: Unit . true )) }.a))) ) ) (\a: Nat .\b: Bool .b))
(((\x: Bool .\y: Rec X. X .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) ({a = 0 , b = true }.b) ) (let u = 1 in ({a = 1 , b = false , c =  0 }.b))) )) )) ) (unfold [ Unit ] (fold [ Rec X. X ] ({a = (fix (\x: Rec X. X . 0 )) , b = (iszero 1) , c = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = 1 }.b) }.c) )))
({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Unit .y) ({a = ({a = 1 , b = true , c =  0 }.b) , b = ({a = 1 , b = true , c = 0 }.c) }.a) ) (succ 1)) )) , b = (fix (\x: Nat . (unfold [ Bool ] (fold [ Unit ] (( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) ) false ) ) (\a: Bool .\b: Unit .a)) )) )) }.b)
({a = (let u = (if false then ({a = 0 , b = 0 }.b) else (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) in (let u = 0 in u)) , b = (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Unit .x) ({a = 1 , b = true , c =  1 }.b) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) (fix (\x: Nat . (case <r = (((\x: Bool .\y: Nat .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Bool .b))) > as Rec X. X of < l = x > => x | < r = y > => y) ))) , c =  (case <l = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (fix (\x: Nat . 0 ))) > as Bool of < l = x > => x | < r = y > => y) }.b)
(let u = (((\x: Rec X. X .\y: Bool .x) ({a = (let u = false in false) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .x) 0 ) true) )) }.b) ) (case <r = ({a = true , b = true }.b) > as Nat of < l = x > => x | < r = y > => y)) in (unfold [ Unit ] (fold [ Unit ] (case <r = (fix (\x: Unit . (fix (\x: Rec X. X . false )) )) > as Unit of < l = x > => x | < r = y > => y) )))
(( \f: Bool .((f (fix (\x: Nat . (let u = (let u = 1 in u) in u) )) ) (pred (((\x: Unit .\y: Rec X. X .y) ({a = (let u = 1 in true) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a) ) (let u = 0 in u))) ) ) (\a: Rec X. X .\b: Bool .a))
(( \f: Unit .((f (pred (let u = ({a = (if true then 1 else 1) , b = (fix (\x: Unit . 1 )) }.b) in (pred 1))) ) (( \f: Nat .((f (pred (fix (\x: Nat . (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) in ({a = 1 , b = false , c = 1 }.c)) ))) ) (fix (\x: Rec X. X . ({a = true , b = 1 }.b) )) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Bool .\b: Rec X. X .b))
(((\x: Unit .\y: Bool .x) (let u = (fix (\x: Bool . (let u = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a)) in u) )) in (iszero 1)) ) (let u = (fix (\x: Rec X. X . (let u = false in u) )) in u))
(((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Nat .x) (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b))) ) (let u = 0 in true)) ) (iszero (let u = (if false then 1 else 0) in (let u = 1 in u))))
({a = ({a = ({a = (fix (\x: Unit . 0 )) , b = 1 }.b) , b = ({a = ({a = true , b = true }.b) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) }.b) , c = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = 0 }.b) )) }.c) , b = (let u = (let u = false in (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b))) in (( \f: Bool .((f (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Rec X. X .x) false ) true) ) (if false then true else false)) ) (((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Bool .y) true ) true) ) (fix (\x: Rec X. X . true ))) ) ) (\a: Nat .\b: Bool .b))) , c =  (case <l = (succ (let u = ({a = false , b = true }.b) in ({a = 1 , b = 1 }.b))) > as Unit of < l = x > => x | < r = y > => y) }.b)
(case <l = (fix (\x: Rec X. X . (let u = ({a = false , b = 1 }.b) in (if true then 0 else 0)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = 0 in u) )) in (fix (\x: Unit . (let u = false in true) ))) in ({a = (succ ({a = 0 , b = false , c = 1 }.c)) , b = (((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Nat .y) false ) true) ) (let u = (fix (\x: Rec X. X . true )) in u)) }.b))
(let u = (let u = (((\x: Rec X. X .\y: Nat .y) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = true , c =  (let u = 1 in u) }.b) ) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .a)) , c = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.c)) in u) in (( \f: Nat .((f (( \f: Unit .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) ) (((\x: Unit .\y: Rec X. X .y) true ) false) ) ) (\a: Rec X. X .\b: Unit .b)) ) (if true then false else ({a = false , b = 0 }.a)) ) ) (\a: Unit .\b: Nat .a)))
(succ (( \f: Bool .((f ({a = (let u = (((\x: Bool .\y: Unit .y) false ) false) in u) , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.b) ) (if true then (((\x: Unit .\y: Nat .y) true ) 1) else (let u = 1 in 0)) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(( \f: Rec X. X .((f ({a = (fix (\x: Nat . (((\x: Bool .\y: Nat .x) true ) true) )) , b = (( \f: Rec X. X .((f (fix (\x: Unit . 1 )) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = true , c = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.c) ) ) (\a: Nat .\b: Nat .a)) }.a) ) (((\x: Rec X. X .\y: Rec X. X .y) (let u = (let u = 1 in u) in ({a = false , b = true }.b)) ) ({a = (case <l = (let u = 1 in 1) > as Bool of < l = x > => x | < r = y > => y) , b = (if false then false else false) , c =  (succ 1) }.b)) ) ) (\a: Rec X. X .\b: Unit .b))
(case <r = (case <r = (let u = (((\x: Unit .\y: Nat .x) ({a = true , b = false }.b) ) false) in ({a = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) , b = true }.b)) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
(if (let u = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if (iszero ({a = 0 , b = 0 }.b)) then (pred 0) else (fix (\x: Nat . 1 ))) }.b) in (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = false }.b) ) (( \f: Unit .((f (if false then true else true) ) (((\x: Rec X. X .\y: Rec X. X .x) false ) true) ) ) (\a: Rec X. X .\b: Unit .b)))) then ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true }.b) )) )) else (fix (\x: Bool . (iszero (if true then 1 else 0)) )))
({a = (case <l = ({a = (((\x: Nat .\y: Nat .x) 0 ) true) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.c) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . true )) )) in u) }.a)
(((\x: Bool .\y: Unit .x) (let u = (let u = (let u = 1 in true) in (let u = true in true)) in ({a = (((\x: Unit .\y: Nat .x) (let u = 1 in 0) ) ({a = 1 , b = true }.b)) , b = (case <r = (let u = false in u) > as Unit of < l = x > => x | < r = y > => y) , c =  (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = 1 }.b) ) (let u = false in u)) }.b)) ) (iszero (let u = true in (((\x: Unit .\y: Unit .y) true ) 0))))
(( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Unit . ({a = 0 , b = (unfold [ Unit ] (fold [ Unit ] true )) }.b) )) )) ) ({a = (succ (let u = true in 0)) , b = (if (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) then ({a = (let u = (let u = 1 in true) in u) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) }.b) else ({a = (let u = (let u = 1 in true) in ({a = true , b = 0 }.b)) , b = ({a = (let u = false in u) , b = ({a = 1 , b = false }.b) }.b) }.b)) }.b) ) ) (\a: Unit .\b: Unit .b))
({a = (( \f: Nat .((f ({a = (( \f: Rec X. X .((f ({a = ({a = 1 , b = true }.a) , b = ({a = false , b = 1 }.a) }.a) ) (let u = true in (if true then 0 else 1)) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = true in u) }.b) ) (((\x: Bool .\y: Rec X. X .y) (fix (\x: Nat . ({a = 0 , b = true }.b) )) ) (iszero 1)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = (let u = (case <l = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) > as Bool of < l = x > => x | < r = y > => y) in (succ (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)))) }.b) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (( \f: Rec X. X .((f (let u = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) in u) ) ({a = (let u = (if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) then ({a = false , b = false }.b) else false) in (let u = (if false then true else false) in true)) , b = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = 1 }.a) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ))
(iszero ({a = (let u = (if false then 1 else 0) in 1) , b = (( \f: Rec X. X .((f 1 ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) }.b))
(pred (let u = (( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (iszero 0) ) ) (\a: Unit .\b: Bool .b)) in ({a = (fix (\x: Unit . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) , b = ({a = 1 , b = false , c = 0 }.c) }.b)))
(fix (\x: Unit . (((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Nat .y) (let u = (case <r = (iszero 1) > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (( \f: Rec X. X .((f ({a = 0 , b = 0 }.b) ) (fix (\x: Unit . 0 )) ) ) (\a: Unit .\b: Rec X. X .a))) ) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Bool .x) true ) false) ))) ))
({a = (let u = (fix (\x: Bool . (fix (\x: Rec X. X . (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) )) in ({a = ({a = true , b = true }.b) , b = (pred (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.b)) , b = ({a = (let u = false in u) , b = (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Unit .y) false ) true) ) (( \f: Nat .((f (pred 0) ) 0 ) ) (\a: Unit .\b: Nat .b))) }.a) }.b)
(unfold [ Nat ] (fold [ Unit ] (let u = (case <r = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) in (let u = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) in u)) ))
(pred (let u = (case <l = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = (if true then 1 else 1) }.b) > as Unit of < l = x > => x | < r = y > => y) in u))
(let u = (((\x: Rec X. X .\y: Bool .y) (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] (pred 1) ))) ) ({a = (fix (\x: Unit . 1 )) , b = (iszero 1) , c =  (fix (\x: Unit . 0 )) }.b)) in ({a = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (let u = (let u = false in u) in 1)) , b = (( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = (pred 1) }.a) ) ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = true , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) }.b))
(((\x: Nat .\y: Rec X. X .x) (pred ({a = ({a = false , b = 0 }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.a)) ) (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Bool . (fix (\x: Rec X. X . (if false then (let u = 1 in false) else ({a = 1 , b = true }.b)) )) )) )))
(fix (\x: Bool . ({a = (succ (((\x: Unit .\y: Nat .x) 1 ) false)) , b = (((\x: Bool .\y: Nat .x) true ) false) }.b) ))
(fix (\x: Unit . ({a = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) )) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .a)) , c = (unfold [ Bool ] (fold [ Unit ] 0 )) }.c) , b = (iszero (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b))) }.b) ))
(if (fix (\x: Unit . (iszero ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 ))) )) then (( \f: Nat .((f (pred (( \f: Bool .((f 0 ) (pred 1) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) (((\x: Nat .\y: Nat .y) (case <r = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] true )) )) > as Nat of < l = x > => x | < r = y > => y) ) (succ 0)) ) ) (\a: Nat .\b: Nat .a)) else ({a = (fix (\x: Unit . (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = false , c =  1 }.b) )) )) , b = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = 1 in 1) )) )) }.b))
(let u = (unfold [ Nat ] (fold [ Unit ] (case <r = (( \f: Unit .((f (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in ({a = 0 , b = true , c =  1 }.b)) ) (iszero 1) ) ) (\a: Bool .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) )) in u)
({a = (pred (let u = (if (((\x: Bool .\y: Bool .y) true ) false) then 1 else (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) in ({a = ({a = 0 , b = false , c =  0 }.b) , b = 1 }.b))) , b = (fix (\x: Bool . ({a = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .a)) , b = (let u = (iszero 1) in (( \f: Unit .((f ({a = 1 , b = true }.b) ) false ) ) (\a: Bool .\b: Nat .b))) }.b) )) }.b)
(let u = (( \f: Bool .((f (let u = (((\x: Nat .\y: Bool .x) 1 ) false) in u) ) (case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) in ({a = ({a = ({a = 1 , b = true }.a) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (if false then (let u = false in 1) else 1) }.a))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) true ) (let u = 0 in u)) ) (((\x: Nat .\y: Bool .y) (let u = false in u) ) (succ 0)) ) ) (\a: Bool .\b: Unit .a)) ))
(if ({a = (case <r = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (let u = (pred 0) in (((\x: Bool .\y: Bool .x) ({a = true , b = 1 }.b) ) true)) , b = (let u = ({a = false , b = 1 }.a) in u) }.a) }.a) then (if (let u = (let u = (((\x: Rec X. X .\y: Bool .y) false ) 1) in (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a))) in u) then ({a = (let u = 0 in (if false then 1 else 0)) , b = ({a = 1 , b = 0 }.b) }.b) else ({a = ({a = (((\x: Unit .\y: Nat .y) false ) 1) , b = false }.a) , b = (if false then true else true) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.c)) else (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) )) )))
({a = (((\x: Bool .\y: Rec X. X .x) (let u = ({a = false , b = false }.b) in u) ) (fix (\x: Unit . (((\x: Unit .\y: Unit .y) true ) true) ))) , b = (let u = (let u = ({a = 1 , b = (let u = true in false) }.b) in u) in (( \f: Nat .((f ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , b = (unfold [ Bool ] (fold [ Bool ] 1 )) }.a) ) ({a = (let u = (fix (\x: Nat . 1 )) in u) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) }.b) ) ) (\a: Unit .\b: Nat .a))) }.b)
(( \f: Nat .((f ({a = (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Nat .y) true ) true) ) (succ 0)) )) , b = ({a = (if (let u = false in ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false ))) then (((\x: Rec X. X .\y: Nat .y) true ) true) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true ))) , b = ({a = ({a = true , b = false }.b) , b = 0 }.b) }.a) , c = (fix (\x: Bool . (fix (\x: Rec X. X . (((\x: Bool .\y: Bool .y) false ) 1) )) )) }.c) ) (case <l = (let u = (( \f: Unit .((f (if true then 0 else (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b))) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Bool .\b: Nat .b)) in (let u = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Nat .a)) in 0)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a))
(unfold [ Rec X. X ] (fold [ Nat ] (if (unfold [ Unit ] (fold [ Bool ] (if false then (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) else (((\x: Bool .\y: Bool .y) false ) false)) )) then ({a = (( \f: Bool .((f ({a = 1 , b = true , c =  1 }.b) ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) , b = (((\x: Unit .\y: Unit .x) 1 ) false) }.a) else (if (let u = 0 in true) then (((\x: Bool .\y: Rec X. X .y) false ) false) else (iszero 1))) ))
(let u = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b)) )) in (case <r = (let u = true in true) > as Unit of < l = x > => x | < r = y > => y)) in (( \f: Unit .((f (( \f: Unit .((f ({a = (( \f: Nat .((f (let u = 1 in true) ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (if (fix (\x: Nat . false )) then (fix (\x: Nat . false )) else ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) ) ) (\a: Bool .\b: Rec X. X .a)) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = (((\x: Nat .\y: Unit .x) true ) true) }.b) )) ) ) (\a: Unit .\b: Nat .a)))
({a = (let u = (let u = ({a = false , b = 1 }.b) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) in ({a = (pred 0) , b = ({a = 0 , b = (let u = 0 in false) , c =  ({a = 0 , b = 1 }.b) }.b) }.b)) , b = (((\x: Unit .\y: Bool .y) (let u = (let u = (succ (let u = true in 0)) in ({a = ({a = 0 , b = true , c = 0 }.c) , b = false , c =  0 }.b)) in u) ) (let u = (( \f: Rec X. X .((f false ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Rec X. X .a)) in u)) }.b)
({a = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f (let u = (unfold [ Rec X. X ] (fold [ Unit ] true )) in ({a = true , b = (let u = 1 in false) }.b)) ) (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .a)) ) (pred ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .y) false ) (unfold [ Bool ] (fold [ Unit ] 1 ))) )))) , b = (((\x: Unit .\y: Bool .y) ({a = (( \f: Nat .((f false ) (iszero 0) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.b) ) ({a = (let u = 1 in 0) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.b)) , c = ({a = (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Nat .x) 1 ) true) ) (let u = 0 in false)) , b = ({a = (fix (\x: Bool . 1 )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) , c = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.c) }.b) }.c)
(case <l = (case <l = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (pred 0) else ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) , b = (pred 1) }.b)) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(pred (((\x: Unit .\y: Bool .y) (let u = (let u = ({a = 0 , b = false }.a) in false) in ({a = ({a = 1 , b = true }.a) , b = true }.b)) ) ({a = (let u = (fix (\x: Rec X. X . 0 )) in ({a = 1 , b = false }.a)) , b = ({a = ({a = 0 , b = true , c =  1 }.b) , b = ({a = true , b = 0 }.a) }.b) }.a)))
({a = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) (fix (\x: Nat . (let u = false in u) )) ) (fix (\x: Nat . 1 ))) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) false ) true) )) , c = ({a = true , b = 0 }.b) }.c) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = ({a = (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) (((\x: Bool .\y: Unit .y) false ) 0) ) ) (\a: Unit .\b: Nat .b)) , b = (case <r = (let u = 0 in true) > as Bool of < l = x > => x | < r = y > => y) , c = (let u = (pred 0) in ({a = 1 , b = true , c = 1 }.c)) }.c) in (let u = false in u)) )) , c =  ({a = (let u = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) in u) , b = (succ ({a = (((\x: Nat .\y: Bool .x) 0 ) true) , b = ({a = 1 , b = true }.b) , c = 0 }.c)) }.b) }.b)
(let u = (pred (let u = (succ 1) in ({a = 1 , b = false }.a))) in (((\x: Nat .\y: Rec X. X .x) ({a = (unfold [ Nat ] (fold [ Unit ] (let u = 0 in u) )) , b = (( \f: Bool .((f (((\x: Nat .\y: Bool .x) 1 ) true) ) (fix (\x: Nat . 0 )) ) ) (\a: Bool .\b: Unit .a)) }.b) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) false ) 1) )) in (((\x: Nat .\y: Bool .y) (iszero 1) ) false))))
({a = (unfold [ Unit ] (fold [ Nat ] (let u = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (let u = false in true) , c = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.c) in (fix (\x: Nat . (unfold [ Nat ] (fold [ Unit ] true )) ))) )) , b = (( \f: Rec X. X .((f (let u = (let u = 1 in true) in (unfold [ Rec X. X ] (fold [ Nat ] 0 ))) ) (let u = (case <r = ({a = ({a = true , b = 0 }.b) , b = false , c =  (pred 0) }.b) > as Nat of < l = x > => x | < r = y > => y) in (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ))) ) ) (\a: Bool .\b: Unit .a)) }.b)
({a = (( \f: Rec X. X .((f ({a = ({a = 1 , b = false , c = 0 }.c) , b = ({a = 0 , b = false , c =  1 }.b) , c = ({a = 1 , b = false }.a) }.c) ) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) , b = (if false then true else false) }.a) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (((\x: Bool .\y: Unit .x) ({a = 1 , b = ({a = true , b = 0 }.a) , c = (if true then 0 else 1) }.c) ) (((\x: Nat .\y: Rec X. X .x) true ) false)) , b = (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] false )) )) ) (iszero 0) ) ) (\a: Bool .\b: Unit .b)) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = 0 in 0) )) }.b) , c =  (fix (\x: Unit . (fix (\x: Unit . (let u = 0 in u) )) )) }.b)
(let u = (if ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = (let u = 0 in 0) }.a) then (unfold [ Bool ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) false ) 1) )) else (let u = (pred ({a = 0 , b = true }.a)) in ({a = false , b = 1 }.b))) in (case <l = (pred (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a))) > as Bool of < l = x > => x | < r = y > => y))
(let u = (( \f: Unit .((f ({a = 0 , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (iszero 1) )) ) ) (\a: Rec X. X .\b: Bool .a)) in (((\x: Nat .\y: Rec X. X .y) (fix (\x: Unit . (fix (\x: Rec X. X . ({a = false , b = false }.b) )) )) ) (fix (\x: Unit . (let u = ({a = false , b = true }.b) in (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a))) ))))
(case <r = (let u = (unfold [ Unit ] (fold [ Bool ] true )) in u) > as Nat of < l = x > => x | < r = y > => y)
(case <r = (unfold [ Bool ] (fold [ Nat ] (fix (\x: Bool . (let u = true in u) )) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <r = (let u = (( \f: Bool .((f (let u = false in 1) ) (let u = true in 0) ) ) (\a: Bool .\b: Nat .b)) in (( \f: Rec X. X .((f (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a))) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (( \f: Nat .((f (( \f: Nat .((f (iszero (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Unit .b)) ) (let u = ({a = 0 , b = true , c =  0 }.b) in u) ) ) (\a: Rec X. X .\b: Unit .a)) ) (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = false , c =  1 }.b) )) ) ({a = (unfold [ Bool ] (fold [ Bool ] ({a = false , b = 0 }.b) )) , b = (fix (\x: Rec X. X . true )) }.b) ) ) (\a: Unit .\b: Unit .b)) )) ) ) (\a: Nat .\b: Rec X. X .b))
(let u = (let u = (if (fix (\x: Rec X. X . true )) then (if true then false else false) else (let u = 1 in (unfold [ Nat ] (fold [ Unit ] false )))) in (case <l = (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in ({a = 0 , b = 0 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y)) in (case <l = (fix (\x: Unit . (if false then 0 else 0) )) > as Rec X. X of < l = x > => x | < r = y > => y))
({a = (case <l = (( \f: Unit .((f 1 ) (let u = 0 in 0) ) ) (\a: Rec X. X .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Bool . (case <r = ({a = (let u = false in false) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.a) > as Unit of < l = x > => x | < r = y > => y) )) , b = (let u = (let u = 0 in u) in u) }.a) , c =  (let u = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = false , b = false }.b) )) in ({a = (succ 0) , b = (fix (\x: Nat . true )) , c = 1 }.c)) in (( \f: Bool .((f (case <l = (if true then 0 else 0) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) true ) (let u = true in 1)) ) ) (\a: Rec X. X .\b: Bool .a))) }.b)
(succ (succ ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (( \f: Nat .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) false ) ) (\a: Rec X. X .\b: Unit .b)) , c = ({a = 1 , b = 0 }.b) }.c)))
(( \f: Bool .((f ({a = (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y) }.b) ) (let u = (if false then true else false) in u) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (let u = (unfold [ Nat ] (fold [ Nat ] (( \f: Unit .((f (let u = 1 in true) ) true ) ) (\a: Unit .\b: Bool .a)) )) in (( \f: Rec X. X .((f ({a = true , b = ({a = 1 , b = true }.a) }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 )) ) ) (\a: Bool .\b: Rec X. X .a))) in (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .b)) ) ({a = (if false then 1 else 1) , b = (let u = false in false) , c =  (( \f: Bool .((f (((\x: Bool .\y: Unit .y) true ) 0) ) 0 ) ) (\a: Unit .\b: Bool .a)) }.b)))
(fix (\x: Bool . (( \f: Nat .((f (if ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] false )) then (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) else (((\x: Unit .\y: Nat .y) true ) 0)) ) (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) (let u = (((\x: Rec X. X .\y: Nat .x) 0 ) false) in (((\x: Unit .\y: Bool .y) true ) ({a = 0 , b = 0 }.b))) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .b)) ))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Unit . (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) )) )) in u)
(fix (\x: Unit . ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (case <l = ({a = false , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) )) ))
(fix (\x: Nat . (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (succ 0) )) in u) ))
(let u = (((\x: Rec X. X .\y: Nat .x) (( \f: Bool .((f (let u = false in u) ) (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) in ({a = false , b = 0 }.a)) ) ) (\a: Rec X. X .\b: Bool .b)) ) (let u = (fix (\x: Unit . 1 )) in (case <r = true > as Bool of < l = x > => x | < r = y > => y))) in (succ (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) (let u = 1 in false)) ) (fix (\x: Nat . (((\x: Nat .\y: Unit .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .a))) )))))
(succ (( \f: Rec X. X .((f (let u = (pred 0) in u) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Bool .a)))
(((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Bool .x) (let u = ({a = (let u = true in 0) , b = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c =  1 }.b) in (if false then false else false)) ) (unfold [ Nat ] (fold [ Unit ] false ))) ) (((\x: Unit .\y: Nat .y) (let u = true in u) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))))
({a = (((\x: Unit .\y: Unit .x) (if (fix (\x: Nat . (let u = 0 in false) )) then (let u = 0 in true) else (((\x: Rec X. X .\y: Rec X. X .y) true ) true)) ) (( \f: Bool .((f (( \f: Bool .((f (iszero (succ 0)) ) (let u = (let u = true in false) in true) ) ) (\a: Bool .\b: Nat .b)) ) ({a = ({a = false , b = 1 }.a) , b = (if false then 0 else 0) }.a) ) ) (\a: Bool .\b: Nat .a))) , b = ({a = ({a = (fix (\x: Rec X. X . (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) )) , b = (fix (\x: Bool . ({a = 1 , b = true }.b) )) }.a) , b = ({a = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Bool ] false )) ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = (let u = 0 in 1) , b = true , c =  1 }.b) }.b) , c = (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Unit .\b: Rec X. X .b)) ) (if ({a = true , b = true }.b) then 1 else ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )))) }.c) }.a)
(unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .y) (fix (\x: Nat . true )) ) (let u = 1 in u)) ) (let u = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) ) (let u = true in false)) in (( \f: Unit .((f ({a = 0 , b = false , c = 1 }.c) ) 0 ) ) (\a: Unit .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Nat .a)) ))
(((\x: Rec X. X .\y: Unit .x) (let u = (let u = (fix (\x: Nat . false )) in (let u = true in ({a = 1 , b = false , c =  0 }.b))) in ({a = (let u = 1 in 0) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .a)) , c = (((\x: Bool .\y: Bool .x) 1 ) true) }.c)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = (( \f: Bool .((f true ) (iszero 1) ) ) (\a: Unit .\b: Unit .a)) , c =  (let u = true in 0) }.b) , b = ({a = ({a = 1 , b = false , c = 1 }.c) , b = (if false then true else false) }.b) }.b) )))
(unfold [ Bool ] (fold [ Nat ] (case <l = (( \f: Nat .((f ({a = 0 , b = true }.a) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) )) ) ) (\a: Unit .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) ))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (let u = true in 0) , b = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = true }.b) , c = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (fix (\x: Bool . false )) , c = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.c) }.c) ))
({a = (iszero (if (let u = true in false) then (fix (\x: Unit . 1 )) else (((\x: Rec X. X .\y: Rec X. X .x) 1 ) (let u = false in true)))) , b = (( \f: Rec X. X .((f ({a = 1 , b = (((\x: Nat .\y: Bool .y) false ) false) , c =  1 }.b) ) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = true in false) )) , b = (succ 1) }.a) ) ) (\a: Rec X. X .\b: Bool .b)) }.b)
(if (iszero (( \f: Rec X. X .((f (fix (\x: Bool . 0 )) ) (case <l = ({a = 1 , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b))) then (iszero (((\x: Nat .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 1 in 1))) else (((\x: Bool .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (((\x: Bool .\y: Nat .x) 0 ) true) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b)))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (let u = (((\x: Nat .\y: Nat .y) true ) false) in true) , b = (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) (let u = false in true) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false ))) ) (let u = 1 in (fix (\x: Rec X. X . false ))) ) ) (\a: Unit .\b: Bool .a)) }.b) ))
(( \f: Unit .((f (succ (pred (case <l = ({a = (((\x: Bool .\y: Unit .x) 0 ) true) , b = ({a = false , b = true }.b) }.a) > as Unit of < l = x > => x | < r = y > => y))) ) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Nat .y) ({a = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in (fix (\x: Nat . false ))) , b = ({a = 0 , b = 0 }.b) }.a) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f (let u = false in false) ) true ) ) (\a: Bool .\b: Rec X. X .a)) ))) ) (succ ({a = (((\x: Bool .\y: Rec X. X .x) false ) true) , b = 1 }.b))) ) ) (\a: Unit .\b: Bool .b))
(let u = (( \f: Unit .((f (( \f: Nat .((f (iszero 1) ) (( \f: Bool .((f (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) (unfold [ Unit ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .a)) ) (fix (\x: Nat . (let u = true in u) )) ) ) (\a: Unit .\b: Rec X. X .b)) in (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] (iszero 1) )) ) (case <r = (((\x: Unit .\y: Bool .y) true ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a))) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
({a = (let u = (if ({a = 1 , b = true , c =  1 }.b) then (unfold [ Bool ] (fold [ Nat ] false )) else (let u = 1 in true)) in (pred ({a = 0 , b = 0 }.b))) , b = (iszero (pred ({a = false , b = 0 }.b))) , c =  (( \f: Nat .((f (let u = ({a = ({a = 1 , b = true , c = 1 }.c) , b = (if false then true else false) , c =  ({a = 1 , b = 1 }.b) }.b) in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 ))) ) (((\x: Bool .\y: Nat .x) (let u = false in (let u = 0 in u)) ) (( \f: Nat .((f (((\x: Nat .\y: Nat .y) false ) false) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b))) ) ) (\a: Nat .\b: Bool .a)) }.b)
(let u = ({a = ({a = (if (((\x: Bool .\y: Rec X. X .x) true ) false) then 1 else ({a = true , b = 1 }.b)) , b = (( \f: Unit .((f (let u = 0 in 0) ) (case <l = (let u = true in 1) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) , b = (fix (\x: Nat . ({a = ({a = false , b = 0 }.b) , b = (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .x) true ) true) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Nat .b)) }.a) )) }.b) in ({a = (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) ) (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (unfold [ Unit ] (fold [ Unit ] (let u = (( \f: Unit .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) false ) ) (\a: Bool .\b: Unit .b)) in (iszero 1)) )) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if false then 1 else 1) )) )) }.b))
(succ (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Nat . (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) )) )) )))
(let u = (if (let u = (( \f: Rec X. X .((f true ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ) (\a: Unit .\b: Bool .a)) in u) then (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .x) 1 ) true) )) else (( \f: Rec X. X .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (let u = true in (let u = 1 in u)) ) ) (\a: Nat .\b: Bool .a))) in (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Unit .y) true ) (let u = false in false)) )) ) (if (((\x: Rec X. X .\y: Bool .y) true ) (let u = 0 in false)) then (if false then true else ({a = false , b = 1 }.a)) else ({a = 1 , b = false }.b)) ) ) (\a: Unit .\b: Nat .b)))
({a = (( \f: Nat .((f (if (let u = ({a = 1 , b = false }.b) in false) then (if (iszero (let u = false in 0)) then (succ 0) else (if false then 1 else 1)) else (succ (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)))) ) (((\x: Rec X. X .\y: Bool .x) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = (((\x: Bool .\y: Nat .x) true ) true) , c = 0 }.c) ) (let u = false in u)) ) ) (\a: Nat .\b: Unit .b)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = (let u = 0 in 0) in (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) > as Bool of < l = x > => x | < r = y > => y)) )) }.a)
(let u = ({a = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 ))) , b = (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) in (iszero 1)) }.a) in u)
(succ (pred (unfold [ Bool ] (fold [ Bool ] (pred 0) ))))
(unfold [ Nat ] (fold [ Unit ] ({a = (let u = (if false then ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 )) else 0) in (((\x: Rec X. X .\y: Nat .x) 0 ) false)) , b = (let u = ({a = true , b = 1 }.b) in ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) , b = false }.b)) }.a) ))
({a = (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) (((\x: Bool .\y: Unit .y) true ) 1)) in ({a = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = 0 in 0) }.a)) in (pred (pred (((\x: Unit .\y: Unit .x) (let u = false in 0) ) true)))) , b = ({a = ({a = (succ 0) , b = (iszero 0) }.a) , b = (( \f: Nat .((f (( \f: Rec X. X .((f true ) (let u = 0 in true) ) ) (\a: Bool .\b: Unit .a)) ) (let u = false in false) ) ) (\a: Unit .\b: Bool .b)) }.a) }.b)
(case <r = (((\x: Rec X. X .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .a)) )) ) (let u = ({a = (let u = true in 1) , b = true , c = 0 }.c) in (fix (\x: Rec X. X . true )))) > as Bool of < l = x > => x | < r = y > => y)
(if (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) in (((\x: Rec X. X .\y: Nat .y) true ) false)) ) (iszero (let u = 1 in u))) ) (let u = ({a = 1 , b = false , c =  1 }.b) in ({a = true , b = 0 }.a)) ) ) (\a: Unit .\b: Bool .b)) then ({a = (let u = ({a = (((\x: Unit .\y: Unit .y) true ) 0) , b = (((\x: Bool .\y: Bool .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = false in u)) , c =  (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.b) in (fix (\x: Rec X. X . false ))) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in (if true then 0 else 1)) )) }.b) else (let u = (unfold [ Rec X. X ] (fold [ Unit ] (let u = true in 1) )) in u))
(let u = (let u = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) in (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .b))) in (( \f: Bool .((f (( \f: Bool .((f (let u = true in false) ) (let u = true in u) ) ) (\a: Rec X. X .\b: Unit .b)) ) (if ({a = (let u = 1 in 1) , b = false }.b) then ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) else ({a = false , b = 0 }.a)) ) ) (\a: Bool .\b: Rec X. X .a))) in (case <l = (let u = 1 in 0) > as Nat of < l = x > => x | < r = y > => y))
(let u = (unfold [ Rec X. X ] (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] (let u = 1 in u) )) )) in u)
(let u = (fix (\x: Rec X. X . (((\x: Nat .\y: Nat .x) (((\x: Rec X. X .\y: Bool .x) true ) false) ) ({a = true , b = false }.b)) )) in (succ (( \f: Unit .((f (pred 0) ) 1 ) ) (\a: Bool .\b: Nat .b))))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (pred (((\x: Unit .\y: Unit .y) (iszero 0) ) ({a = (let u = 1 in u) , b = ({a = true , b = true }.b) , c = 1 }.c))) ))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (fix (\x: Rec X. X . ({a = 1 , b = (iszero 0) }.b) )) in u) ))
(let u = (unfold [ Bool ] (fold [ Unit ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Unit . ({a = 1 , b = true , c =  1 }.b) )) )) )) in (fix (\x: Bool . (let u = (fix (\x: Bool . (let u = ({a = 1 , b = true }.b) in false) )) in (( \f: Rec X. X .((f false ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a))) )))
(case <r = ({a = ({a = (let u = (((\x: Bool .\y: Bool .y) false ) false) in ({a = 0 , b = true }.b)) , b = (let u = (let u = 0 in 0) in u) }.b) , b = (iszero ({a = (((\x: Bool .\y: Bool .x) true ) true) , b = 1 }.b)) , c =  (( \f: Unit .((f (pred (if false then 1 else ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )))) ) (let u = ({a = false , b = (succ 0) }.b) in (let u = 1 in (let u = false in 0))) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Unit . (succ ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = false in 1) ))) ))
(let u = (( \f: Unit .((f (if ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) then (( \f: Bool .((f false ) (fix (\x: Unit . false )) ) ) (\a: Unit .\b: Bool .a)) else (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)))) ) (if (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) then (unfold [ Bool ] (fold [ Rec X. X ] (let u = 0 in false) )) else (( \f: Unit .((f (let u = true in false) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Nat .\b: Unit .b)) in ({a = (let u = (let u = true in false) in ({a = 0 , b = (fix (\x: Unit . true )) }.b)) , b = (succ (pred 0)) }.b))
(let u = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (if ({a = 1 , b = true }.b) then (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = 0 , b = 0 }.b)) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Unit ] 1 )) ))) in ({a = ({a = (fix (\x: Nat . (unfold [ Bool ] (fold [ Bool ] false )) )) , b = ({a = ({a = 1 , b = 0 }.b) , b = (let u = true in u) }.b) }.b) , b = ({a = (if ({a = 0 , b = false , c =  1 }.b) then ({a = 0 , b = true }.a) else (((\x: Bool .\y: Nat .x) 0 ) false)) , b = (pred 0) }.b) }.a))
(( \f: Unit .((f (iszero (fix (\x: Bool . (( \f: Unit .((f (fix (\x: Nat . 0 )) ) 1 ) ) (\a: Nat .\b: Nat .a)) ))) ) (let u = (let u = (let u = (( \f: Rec X. X .((f (let u = true in u) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a)) in u) in u) in u) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = ({a = (( \f: Rec X. X .((f (let u = 1 in 0) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = (fix (\x: Nat . 0 )) in (fix (\x: Bool . (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .b)) ))) , c =  (succ ({a = (((\x: Nat .\y: Unit .x) 0 ) false) , b = (( \f: Rec X. X .((f (let u = true in false) ) (unfold [ Bool ] (fold [ Unit ] true )) ) ) (\a: Bool .\b: Rec X. X .b)) }.a)) }.b) in (((\x: Bool .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Bool .\y: Nat .y) ({a = true , b = 1 }.a) ) (let u = false in false)) )) ) (let u = (succ (((\x: Rec X. X .\y: Unit .x) 0 ) true)) in ({a = (let u = 1 in true) , b = ({a = 0 , b = false , c = 1 }.c) }.a))))
(( \f: Bool .((f (pred (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) false) ))) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (let u = (iszero 1) in false) , b = (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (pred 0) else (pred 0)) }.b) )) ) ) (\a: Unit .\b: Nat .b))
({a = ({a = (unfold [ Bool ] (fold [ Unit ] ({a = 1 , b = false }.b) )) , b = ({a = (fix (\x: Unit . 0 )) , b = (let u = true in false) , c = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) }.c) }.a) , b = (((\x: Bool .\y: Nat .x) (((\x: Bool .\y: Bool .x) 0 ) (((\x: Nat .\y: Rec X. X .x) false ) false)) ) (iszero 0)) }.a)
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (let u = ({a = 1 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c = 0 }.c) in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , b = (if true then (let u = 1 in 1) else 0) }.b) ))
(pred (((\x: Unit .\y: Nat .x) ({a = 1 , b = false , c = 1 }.c) ) (( \f: Rec X. X .((f (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Bool .a))))
(case <l = (case <l = (((\x: Nat .\y: Bool .x) ({a = 1 , b = true }.a) ) (((\x: Bool .\y: Bool .y) true ) true)) > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = (pred (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) , b = ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .a)) , b = (((\x: Nat .\y: Bool .x) 1 ) true) }.a) , c =  ({a = (if false then ({a = 1 , b = true }.b) else false) , b = (succ 1) }.b) }.b) ))
(case <l = (let u = ({a = (let u = false in 1) , b = ({a = 1 , b = false , c =  1 }.b) , c = ({a = true , b = 0 }.b) }.c) in u) > as Bool of < l = x > => x | < r = y > => y)
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .a)) )) in ({a = (( \f: Nat .((f (((\x: Nat .\y: Nat .x) 0 ) true) ) (((\x: Nat .\y: Nat .y) false ) 1) ) ) (\a: Nat .\b: Nat .b)) , b = (let u = ({a = 0 , b = false , c =  0 }.b) in (let u = true in true)) , c = (( \f: Rec X. X .((f ({a = 0 , b = false , c = 1 }.c) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = false , c = 0 }.c) )) ) ) (\a: Unit .\b: Rec X. X .a)) }.c))
(let u = (let u = (((\x: Rec X. X .\y: Bool .y) (( \f: Nat .((f ({a = 0 , b = false }.b) ) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = 1 }.b)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = 1 in false) ))) in u)
({a = (fix (\x: Unit . (let u = (fix (\x: Nat . ({a = 1 , b = 1 }.b) )) in u) )) , b = ({a = ({a = (pred 1) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true )) , c = (((\x: Bool .\y: Rec X. X .y) false ) 1) }.c) , b = (fix (\x: Rec X. X . (( \f: Unit .((f (((\x: Nat .\y: Unit .x) (let u = false in true) ) true) ) (let u = 1 in false) ) ) (\a: Unit .\b: Bool .b)) )) , c =  (let u = (let u = 0 in 0) in u) }.b) }.a)
({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (succ ({a = 1 , b = false , c = 1 }.c)) )) , b = (((\x: Rec X. X .\y: Bool .x) (if (case <r = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) then (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a)) else ({a = 0 , b = false , c =  (let u = 0 in u) }.b)) ) ({a = (unfold [ Nat ] (fold [ Nat ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) )) , b = (((\x: Bool .\y: Nat .x) 1 ) false) }.a)) , c =  ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (( \f: Nat .((f (fix (\x: Nat . 1 )) ) (let u = (let u = false in 1) in 1) ) ) (\a: Rec X. X .\b: Nat .a)) )) )) }.b)
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) ({a = false , b = 1 }.a) ) (fix (\x: Bool . false ))) )) in (((\x: Unit .\y: Unit .y) ({a = ({a = 0 , b = false , c =  1 }.b) , b = (succ 0) }.a) ) (case <r = (fix (\x: Rec X. X . true )) > as Nat of < l = x > => x | < r = y > => y)))
(if ({a = (let u = ({a = 0 , b = true }.a) in (((\x: Rec X. X .\y: Nat .y) (unfold [ Nat ] (fold [ Unit ] (if false then false else true) )) ) (unfold [ Bool ] (fold [ Nat ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )))) , b = (let u = ({a = true , b = true }.b) in (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) }.b) then (( \f: Rec X. X .((f (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) in u) ) (( \f: Bool .((f (let u = 0 in u) ) (let u = (unfold [ Nat ] (fold [ Bool ] false )) in 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Rec X. X .b)) else ({a = ({a = ({a = (if true then 0 else 0) , b = true , c = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.c) , b = (((\x: Bool .\y: Nat .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) ) (let u = 1 in false)) , c = ({a = ({a = true , b = 1 }.b) , b = (let u = 0 in false) }.a) }.c) , b = (let u = (let u = (( \f: Rec X. X .((f (iszero 0) ) true ) ) (\a: Bool .\b: Nat .b)) in ({a = 1 , b = true }.b)) in (if (let u = true in u) then (case <r = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) , c = (let u = (iszero (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) in (pred (fix (\x: Bool . 0 )))) }.c))
(((\x: Unit .\y: Unit .x) (fix (\x: Unit . ({a = (succ 0) , b = (unfold [ Nat ] (fold [ Bool ] ({a = true , b = false }.b) )) }.b) )) ) (let u = (case <l = (let u = true in 1) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Unit .x) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y))))
(let u = (( \f: Rec X. X .((f (case <l = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) in (if false then 0 else 1)) > as Nat of < l = x > => x | < r = y > => y) ) (succ (let u = 1 in 1)) ) ) (\a: Unit .\b: Bool .a)) in (let u = ({a = ({a = true , b = 1 }.a) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Rec X. X ] 0 )) )) }.a) in (let u = ({a = true , b = 1 }.a) in false)))
({a = ({a = (let u = ({a = true , b = 1 }.b) in u) , b = (((\x: Rec X. X .\y: Rec X. X .x) (if false then true else false) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .b))) , c = (succ (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) }.c) , b = (((\x: Rec X. X .\y: Nat .x) (unfold [ Unit ] (fold [ Bool ] ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = false }.b) )) ) ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , b = (((\x: Bool .\y: Nat .y) false ) ({a = false , b = 0 }.a)) }.b)) }.b)
(let u = (unfold [ Unit ] (fold [ Bool ] (case <l = (succ 1) > as Nat of < l = x > => x | < r = y > => y) )) in ({a = (((\x: Bool .\y: Nat .y) (let u = (fix (\x: Nat . true )) in ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Bool ] true )) , c =  0 }.b)) ) (( \f: Nat .((f (fix (\x: Nat . 1 )) ) (((\x: Unit .\y: Unit .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = true , b = true }.b)) ) ) (\a: Bool .\b: Unit .a))) , b = (let u = (let u = (succ 0) in (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) in u)) in ({a = (succ 0) , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) , c = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.c)) }.b))
(let u = (let u = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.a) in u) in u)
(succ (((\x: Rec X. X .\y: Unit .y) (iszero (pred 1)) ) ({a = ({a = 1 , b = false , c = 1 }.c) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)))
({a = (( \f: Unit .((f (case <r = (fix (\x: Unit . (((\x: Unit .\y: Unit .y) false ) true) )) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Unit ] ({a = (pred 1) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) )) )) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = (if ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) then ({a = ({a = 0 , b = true }.b) , b = (((\x: Rec X. X .\y: Nat .y) false ) true) }.b) else ({a = ({a = (fix (\x: Rec X. X . 0 )) , b = false }.a) , b = ({a = (let u = 1 in u) , b = ({a = 1 , b = true }.b) }.b) , c =  (if false then 1 else (fix (\x: Rec X. X . 0 ))) }.b)) , b = ({a = (if ({a = 0 , b = true , c =  0 }.b) then 0 else (((\x: Rec X. X .\y: Unit .x) 0 ) false)) , b = (let u = false in u) , c = ({a = (pred 1) , b = 1 }.b) }.c) }.a) }.b)
(let u = (((\x: Nat .\y: Nat .x) (case <l = (if false then 0 else 0) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . (let u = 0 in (unfold [ Unit ] (fold [ Bool ] true ))) ))) in (fix (\x: Unit . ({a = (pred 0) , b = (let u = 0 in true) , c =  ({a = (let u = true in 0) , b = ({a = 0 , b = true }.a) }.b) }.b) )))
(pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f ({a = 1 , b = true }.a) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) )) )))
({a = ({a = (unfold [ Unit ] (fold [ Unit ] (if false then 0 else 0) )) , b = (iszero 1) , c = ({a = (let u = true in u) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b) }.c) , b = (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) , c =  ({a = (( \f: Unit .((f ({a = 1 , b = ({a = 1 , b = true }.b) , c = 1 }.c) ) (fix (\x: Bool . 0 )) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) }.b)
(case <l = (succ (( \f: Bool .((f 0 ) (succ 0) ) ) (\a: Rec X. X .\b: Unit .a))) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) in ({a = 0 , b = false , c = 0 }.c)) , b = ({a = (let u = (let u = 1 in true) in u) , b = (pred 0) }.a) , c =  (pred (succ 1)) }.b) ))
(if ({a = (( \f: Bool .((f ({a = true , b = 0 }.b) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a)) , b = (((\x: Unit .\y: Bool .y) false ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false ))) , c =  (let u = (let u = false in u) in ({a = 0 , b = false , c = 1 }.c)) }.b) then (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = true , b = true }.b) in u) ) (( \f: Bool .((f (fix (\x: Nat . (let u = false in true) )) ) (let u = ({a = true , b = 0 }.b) in (((\x: Unit .\y: Nat .y) (let u = 0 in true) ) false)) ) ) (\a: Rec X. X .\b: Rec X. X .a))) else (( \f: Rec X. X .((f (iszero (( \f: Bool .((f 0 ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Unit .((f (iszero ({a = 1 , b = true , c = 0 }.c)) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) )) ) ) (\a: Nat .\b: Rec X. X .a)))
(let u = (( \f: Unit .((f (fix (\x: Unit . 0 )) ) ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 1 in u) }.b) ) ) (\a: Unit .\b: Bool .b)) in u)
({a = (let u = ({a = (fix (\x: Nat . (succ 0) )) , b = (let u = false in ({a = 0 , b = true }.b)) , c = ({a = 1 , b = 0 }.b) }.c) in (fix (\x: Nat . (pred ({a = 0 , b = 1 }.b)) ))) , b = (unfold [ Nat ] (fold [ Rec X. X ] (pred 1) )) }.b)
(unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (case <l = (succ 1) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (case <l = (let u = true in ({a = false , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) ))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) ({a = (let u = 1 in 1) , b = ({a = 0 , b = true , c =  0 }.b) }.b) ) (iszero 1)) )) ))
({a = (((\x: Bool .\y: Bool .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f 1 ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ({a = (((\x: Unit .\y: Unit .x) ({a = (let u = false in 0) , b = (((\x: Bool .\y: Bool .x) true ) false) }.b) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) , b = (if (iszero 0) then (unfold [ Unit ] (fold [ Rec X. X ] true )) else (( \f: Bool .((f true ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Rec X. X .\b: Unit .a))) }.b)) , b = (( \f: Unit .((f ({a = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = false }.b) )) , b = (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 ))) }.a) ) (if ({a = true , b = 0 }.a) then ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) false ) true) }.b) else (iszero (succ 0))) ) ) (\a: Nat .\b: Nat .b)) }.a)
(let u = (let u = ({a = (if false then 0 else 1) , b = (( \f: Unit .((f 0 ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) in (unfold [ Nat ] (fold [ Unit ] ({a = (((\x: Rec X. X .\y: Unit .y) false ) 0) , b = (((\x: Bool .\y: Nat .x) false ) true) }.a) ))) in (fix (\x: Bool . (( \f: Unit .((f (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) ) true ) ) (\a: Bool .\b: Unit .a)) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) )))
({a = ({a = (if (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .y) true ) true) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .b)) then (if (unfold [ Unit ] (fold [ Rec X. X ] false )) then ({a = 0 , b = true , c =  0 }.b) else ({a = true , b = 1 }.a)) else (((\x: Bool .\y: Nat .y) ({a = 0 , b = true }.b) ) (let u = 1 in true))) , b = (( \f: Bool .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Unit .\b: Bool .a)) }.b) , b = (let u = (iszero (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .x) 0 ) true) ) 1 ) ) (\a: Nat .\b: Nat .a))) in u) , c =  (fix (\x: Rec X. X . (((\x: Bool .\y: Unit .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (if false then false else false)) )) }.b)
(unfold [ Bool ] (fold [ Unit ] ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = 1 }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false ))) , b = (let u = (( \f: Unit .((f (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) ) ) (\a: Unit .\b: Bool .a)) in (fix (\x: Nat . 0 ))) }.b) ))
(case <l = (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f ({a = 0 , b = (((\x: Unit .\y: Nat .y) true ) true) , c =  (((\x: Bool .\y: Rec X. X .x) 0 ) true) }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (succ (pred 0))) > as Nat of < l = x > => x | < r = y > => y)
({a = (fix (\x: Unit . (( \f: Rec X. X .((f (pred 0) ) (if false then 1 else 1) ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = (unfold [ Bool ] (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) true) , b = false , c =  1 }.b) )) }.a)
({a = ({a = (( \f: Rec X. X .((f ({a = (let u = true in true) , b = (succ 1) }.a) ) (let u = 1 in ({a = true , b = true }.b)) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Unit .((f (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (iszero 0) in false) ) ) (\a: Nat .\b: Nat .a)) }.b) , b = (succ (pred (unfold [ Rec X. X ] (fold [ Unit ] 1 )))) }.b)
({a = (let u = (let u = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) in ({a = false , b = (fix (\x: Nat . false )) }.b)) in (succ ({a = 0 , b = 1 }.b))) , b = (let u = (fix (\x: Rec X. X . 1 )) in (if (let u = true in u) then (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) else ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )))) , c =  (pred ({a = (let u = 0 in 0) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c = (let u = false in 0) }.c)) }.b)
(case <l = ({a = (if (let u = false in false) then (let u = 1 in 1) else (unfold [ Bool ] (fold [ Unit ] 1 ))) , b = (let u = ({a = 0 , b = true }.a) in (( \f: Unit .((f 1 ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Bool .\b: Nat .a))) }.b) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Unit .x) (pred (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) 0 ) ) (\a: Nat .\b: Unit .a))) ) (let u = ({a = (let u = (let u = true in u) in u) , b = ({a = 1 , b = (let u = 0 in true) }.a) }.a) in (fix (\x: Nat . (fix (\x: Bool . (fix (\x: Unit . (unfold [ Nat ] (fold [ Unit ] false )) )) )) ))))
(let u = ({a = (fix (\x: Nat . ({a = 0 , b = true , c =  1 }.b) )) , b = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) }.a) in ({a = (case <r = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ({a = 1 , b = 1 }.b) ) (((\x: Unit .\y: Unit .x) 0 ) false) ) ) (\a: Unit .\b: Unit .b)) }.a))
(( \f: Rec X. X .((f (pred (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = false , c = 0 }.c) )) in (if true then 1 else (succ 1)))) ) (case <l = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b))
(( \f: Rec X. X .((f (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) ) (((\x: Unit .\y: Nat .x) true ) true)) ) (iszero (if false then 1 else 1))) ) (iszero ({a = ({a = 0 , b = false }.a) , b = ({a = 1 , b = false }.a) }.b)) ) ) (\a: Unit .\b: Unit .b))
(pred ({a = ({a = ({a = true , b = 1 }.b) , b = ({a = 0 , b = false , c = ({a = 1 , b = 0 }.b) }.c) }.b) , b = ({a = ({a = ({a = ({a = 0 , b = 1 }.b) , b = (unfold [ Unit ] (fold [ Nat ] false )) }.b) , b = (succ 1) }.a) , b = ({a = ({a = true , b = ({a = 1 , b = 1 }.b) }.a) , b = (succ (let u = false in 1)) }.b) }.b) }.b))
(unfold [ Bool ] (fold [ Nat ] (fix (\x: Nat . (((\x: Nat .\y: Nat .x) true ) true) )) ))
(case <l = (succ (fix (\x: Unit . 0 ))) > as Bool of < l = x > => x | < r = y > => y)
(if (( \f: Unit .((f (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Nat .y) (if true then true else false) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) )) ) (let u = (fix (\x: Nat . 1 )) in (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Bool .\b: Bool .b)) then (if ({a = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) (let u = 1 in true) ) false) ) (( \f: Rec X. X .((f true ) (let u = true in u) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (( \f: Nat .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Bool .x) 0 ) true) ) ) (\a: Nat .\b: Rec X. X .a)) }.a) then (let u = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b)) in (fix (\x: Nat . 1 ))) else (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (let u = 0 in u) in (pred 0)) ))) else (succ (( \f: Bool .((f ({a = true , b = 1 }.b) ) 0 ) ) (\a: Nat .\b: Nat .a))))
({a = (( \f: Bool .((f (case <l = (succ (succ 1)) > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (pred ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ))) )) ) ) (\a: Bool .\b: Bool .b)) , b = (unfold [ Unit ] (fold [ Unit ] ({a = (let u = 1 in 1) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  ({a = 1 , b = true , c = 0 }.c) }.b) )) , c =  ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (pred (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a))) )) }.b)
(case <r = (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f (fix (\x: Unit . false )) ) (( \f: Nat .((f false ) (unfold [ Unit ] (fold [ Bool ] false )) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Bool .b)) )) > as Bool of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Nat ] ({a = (((\x: Bool .\y: Unit .y) (let u = ({a = false , b = true }.b) in (unfold [ Unit ] (fold [ Rec X. X ] false ))) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) ))) , b = (((\x: Bool .\y: Rec X. X .y) ({a = 0 , b = (let u = false in u) , c =  0 }.b) ) ({a = (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.b)) , c =  (if (((\x: Bool .\y: Unit .x) ({a = true , b = true }.b) ) ({a = 1 , b = ({a = true , b = true }.b) , c =  ({a = 1 , b = false , c = 0 }.c) }.b)) then (if false then 1 else (let u = 0 in u)) else (((\x: Nat .\y: Nat .x) (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Nat ] 0 )) )) ) (let u = false in true))) }.b) ))
({a = (let u = (((\x: Nat .\y: Bool .x) ({a = (unfold [ Nat ] (fold [ Bool ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a))) }.b) ) (iszero (succ 1))) in (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Nat .x) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ) (( \f: Nat .((f (case <r = ({a = 0 , b = true , c =  1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Unit .\b: Bool .a)))) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .x) 0 ) false) )) , b = ({a = (((\x: Unit .\y: Unit .y) true ) 1) , b = (( \f: Bool .((f (if false then false else true) ) false ) ) (\a: Nat .\b: Unit .a)) , c =  ({a = false , b = 1 }.b) }.b) , c =  (let u = (let u = 1 in 1) in u) }.b) , c = (( \f: Unit .((f ({a = true , b = (fix (\x: Unit . 0 )) }.b) ) ({a = ({a = 1 , b = (fix (\x: Rec X. X . 1 )) }.b) , b = (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Bool .y) true ) true) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) }.c)
(fix (\x: Rec X. X . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 0 , b = (let u = 1 in false) }.b) )) ))
(let u = (let u = (unfold [ Bool ] (fold [ Nat ] (let u = 0 in false) )) in u) in u)
(iszero (((\x: Nat .\y: Bool .x) (if ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Unit .\y: Bool .y) false ) true) }.b) then (let u = ({a = 1 , b = false }.a) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) else ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) 1 ) true) ))) ) (fix (\x: Nat . (( \f: Nat .((f (if false then true else true) ) false ) ) (\a: Rec X. X .\b: Bool .a)) ))))
(iszero (pred (pred (let u = false in 0))))
(if (if ({a = ({a = (if true then 0 else 0) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) , b = (((\x: Unit .\y: Unit .x) (iszero 0) ) (((\x: Rec X. X .\y: Nat .x) true ) false)) , c =  (let u = (let u = 1 in u) in (fix (\x: Rec X. X . 0 ))) }.b) then (( \f: Unit .((f (case <r = (if true then false else false) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .a)) else ({a = ({a = (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) , b = (unfold [ Bool ] (fold [ Nat ] (iszero 0) )) }.b)) then (pred (succ (pred 0))) else (succ (let u = 1 in u)))
(if (let u = (iszero (if false then 0 else 1)) in u) then (((\x: Unit .\y: Rec X. X .y) (if (fix (\x: Nat . true )) then (((\x: Unit .\y: Rec X. X .x) (let u = true in u) ) (((\x: Unit .\y: Unit .x) false ) true)) else (( \f: Bool .((f false ) ({a = false , b = false }.b) ) ) (\a: Bool .\b: Nat .a))) ) ({a = (if false then false else true) , b = 0 }.b)) else (((\x: Nat .\y: Nat .y) (fix (\x: Bool . (let u = true in true) )) ) ({a = (( \f: Unit .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (( \f: Unit .((f 0 ) (((\x: Nat .\y: Rec X. X .y) true ) 0) ) ) (\a: Nat .\b: Bool .b)) }.b)))
(succ (( \f: Nat .((f ({a = (fix (\x: Bool . 0 )) , b = (let u = 1 in u) }.b) ) (unfold [ Nat ] (fold [ Nat ] ({a = (succ 0) , b = true , c = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.c) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(((\x: Nat .\y: Rec X. X .x) (let u = ({a = (((\x: Bool .\y: Nat .x) 1 ) true) , b = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) in u) ) (fix (\x: Unit . ({a = (iszero 0) , b = (((\x: Bool .\y: Unit .y) true ) 0) }.a) )))
(let u = ({a = ({a = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = 1 }.b) )) , b = (( \f: Rec X. X .((f (if (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) then (fix (\x: Nat . false )) else true) ) ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) ) (\a: Bool .\b: Bool .b)) }.b) , b = (((\x: Bool .\y: Nat .y) (let u = (let u = true in true) in true) ) ({a = 0 , b = false , c = 1 }.c)) }.a) in (let u = (iszero 1) in (if ({a = true , b = 0 }.a) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) else (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) 1 ) false) ) (let u = false in 0) ) ) (\a: Bool .\b: Bool .b)))))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = (let u = 0 in 1) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = 0 in false) )) }.b) ))
({a = (( \f: Nat .((f (fix (\x: Rec X. X . (fix (\x: Unit . false )) )) ) ({a = false , b = (let u = 0 in 1) }.a) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (let u = ({a = ({a = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b)) , b = 1 }.a) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .x) (fix (\x: Nat . false )) ) ({a = true , b = true }.b)) )) }.b) in (iszero (case <l = (pred 0) > as Unit of < l = x > => x | < r = y > => y))) }.b)
(( \f: Rec X. X .((f (iszero (let u = 1 in 1)) ) (iszero ({a = ({a = 0 , b = false , c = 0 }.c) , b = (fix (\x: Bool . ({a = 0 , b = 0 }.b) )) }.b)) ) ) (\a: Nat .\b: Bool .a))
(if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .y) false ) (let u = true in true)) )) then (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = true , b = 1 }.a) in u) ) (case <r = (let u = false in (let u = true in u)) > as Unit of < l = x > => x | < r = y > => y)) else (if (let u = (let u = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) in u) in u) then (( \f: Unit .((f (iszero 0) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = false , b = 1 }.a)) ))))
({a = (unfold [ Nat ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = true , b = 1 }.a) )) )) , b = ({a = ({a = 0 , b = false , c =  (let u = true in 1) }.b) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) }.b)
(case <l = (fix (\x: Unit . (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Bool .x) 0 ) true) ) ({a = true , b = 1 }.a)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (let u = (case <r = ({a = ({a = 1 , b = true , c = 1 }.c) , b = false , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b) > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Bool . (((\x: Bool .\y: Unit .y) ({a = false , b = true }.b) ) (let u = 0 in u)) ))) , b = (if (fix (\x: Bool . true )) then (if (let u = false in true) then false else ({a = 0 , b = false }.b)) else (let u = (((\x: Rec X. X .\y: Unit .y) true ) false) in u)) , c = (( \f: Nat .((f (fix (\x: Bool . (succ ({a = false , b = 1 }.b)) )) ) (unfold [ Nat ] (fold [ Unit ] ({a = (((\x: Unit .\y: Bool .x) false ) true) , b = ({a = (succ 1) , b = ({a = 0 , b = false }.a) }.b) }.b) )) ) ) (\a: Bool .\b: Rec X. X .b)) }.c)
(let u = (( \f: Rec X. X .((f ({a = (((\x: Rec X. X .\y: Unit .y) ({a = 1 , b = false }.b) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = true }.b) )) }.b) ) (( \f: Unit .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .b)) in ({a = (( \f: Bool .((f (let u = 0 in u) ) (let u = 1 in 1) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (if (((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b))) then (((\x: Unit .\y: Unit .x) 1 ) (unfold [ Unit ] (fold [ Rec X. X ] true ))) else ({a = 1 , b = true , c = 0 }.c)) }.b))
(((\x: Bool .\y: Rec X. X .y) ({a = (( \f: Nat .((f (if ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) true ) false) , c =  (fix (\x: Unit . 1 )) }.b) then ({a = true , b = 1 }.a) else (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] true )) )) ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Unit .\y: Nat .x) (let u = ({a = 1 , b = true }.b) in (unfold [ Nat ] (fold [ Bool ] (pred 1) ))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Rec X. X . false )) ))) }.a) ) (fix (\x: Unit . (let u = ({a = 0 , b = 0 }.b) in (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) in u)) )))
(((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Unit .x) ({a = (if true then true else true) , b = 1 }.a) ) (( \f: Unit .((f (((\x: Unit .\y: Nat .x) true ) false) ) true ) ) (\a: Bool .\b: Rec X. X .b))) )) ) (let u = ({a = (let u = true in 1) , b = (let u = 1 in (let u = true in true)) , c =  ({a = 1 , b = (let u = 1 in 1) }.b) }.b) in u))
({a = (fix (\x: Bool . (let u = 1 in u) )) , b = (fix (\x: Unit . ({a = (case <r = (if true then false else true) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Unit ] (fold [ Nat ] 0 )) in u) }.a) )) , c =  (((\x: Unit .\y: Bool .y) (((\x: Nat .\y: Unit .y) ({a = false , b = true }.b) ) (if true then true else false)) ) ({a = ({a = ({a = false , b = 1 }.b) , b = (let u = true in false) , c = (let u = 0 in u) }.c) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) }.a)) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (succ (((\x: Bool .\y: Bool .x) (( \f: Bool .((f 1 ) (let u = false in 1) ) ) (\a: Rec X. X .\b: Bool .a)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )))) ))
(((\x: Nat .\y: Rec X. X .x) (((\x: Unit .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Bool ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) ) (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) )))) ) (( \f: Nat .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Bool ] false )) )) )) ) (((\x: Unit .\y: Rec X. X .y) (let u = (let u = false in true) in u) ) (let u = false in u)) ) ) (\a: Nat .\b: Rec X. X .b)))
(( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .b)) )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = false , c =  0 }.b) ))) ) (let u = (let u = (iszero 1) in u) in ({a = (succ (((\x: Nat .\y: Nat .x) 1 ) true)) , b = (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) false) in false) , c =  (succ 1) }.b)) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (let u = (unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) in u) , b = (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f (( \f: Nat .((f (let u = 1 in 0) ) ({a = 0 , b = 0 }.b) ) ) (\a: Unit .\b: Unit .a)) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a)) )) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (let u = (pred 0) in u) in (case <r = ({a = 1 , b = true , c =  1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) )) ))
(( \f: Bool .((f (let u = (case <r = ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) }.b) > as Nat of < l = x > => x | < r = y > => y) in ({a = (succ 0) , b = (case <r = (((\x: Unit .\y: Rec X. X .x) false ) true) > as Bool of < l = x > => x | < r = y > => y) , c =  (( \f: Nat .((f ({a = 0 , b = 0 }.b) ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) }.b)) ) (fix (\x: Rec X. X . ({a = (((\x: Nat .\y: Bool .x) 1 ) true) , b = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .b)) , c =  (if true then 1 else 1) }.b) )) ) ) (\a: Unit .\b: Rec X. X .a))
({a = (( \f: Rec X. X .((f (( \f: Bool .((f (if ({a = false , b = 0 }.a) then (((\x: Bool .\y: Nat .x) false ) true) else (let u = false in u)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) ) (\a: Nat .\b: Bool .a)) ) (case <r = ({a = 0 , b = ({a = 1 , b = true , c =  0 }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in (((\x: Nat .\y: Unit .x) 0 ) false)) )) }.a)
(( \f: Rec X. X .((f (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (iszero (succ 1)) )) then (let u = (( \f: Unit .((f (((\x: Bool .\y: Bool .x) 0 ) false) ) (pred 1) ) ) (\a: Bool .\b: Nat .a)) in u) else (let u = (let u = 1 in 1) in u)) ) (case <l = ({a = (let u = true in u) , b = (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Bool .x) false ) true) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a))) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b))
(case <r = (iszero (fix (\x: Nat . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ))) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = ({a = ({a = 0 , b = true }.a) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .y) false ) true) )) }.a) , b = (((\x: Unit .\y: Nat .y) false ) 1) }.b) , b = (unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Bool .x) (((\x: Nat .\y: Rec X. X .x) true ) false) ) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Nat .a))) )) , c = (if (unfold [ Nat ] (fold [ Nat ] (fix (\x: Nat . false )) )) then (if ({a = (let u = true in false) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.a) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Unit . 0 )) )) else (((\x: Unit .\y: Rec X. X .x) (if false then 0 else 0) ) ({a = 0 , b = false }.b))) else (((\x: Rec X. X .\y: Nat .x) (if true then 0 else (pred 1)) ) ({a = true , b = 0 }.a))) }.c)
(fix (\x: Rec X. X . (( \f: Bool .((f (if (let u = false in true) then (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = false }.b) )) else (( \f: Rec X. X .((f (let u = true in true) ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Bool .a))) ) ({a = (( \f: Nat .((f true ) (iszero 1) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(pred (if (((\x: Bool .\y: Bool .x) (let u = true in true) ) (case <r = (((\x: Bool .\y: Bool .y) true ) true) > as Nat of < l = x > => x | < r = y > => y)) then ({a = (succ 1) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.b) else ({a = true , b = 0 }.b)))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (fix (\x: Bool . ({a = (fix (\x: Bool . false )) , b = (succ 1) }.b) )) ))
(( \f: Unit .((f (if (case <r = ({a = 1 , b = (((\x: Nat .\y: Nat .x) false ) false) , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y) then ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero 1) )) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) )) }.b) else (fix (\x: Rec X. X . (case <l = (((\x: Rec X. X .\y: Bool .x) 0 ) true) > as Bool of < l = x > => x | < r = y > => y) ))) ) (((\x: Rec X. X .\y: Nat .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) ) (((\x: Bool .\y: Nat .x) ({a = 1 , b = false }.a) ) (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) false ) ) (\a: Rec X. X .\b: Unit .a)))) ) ) (\a: Unit .\b: Unit .b))
(((\x: Bool .\y: Rec X. X .x) (let u = ({a = (let u = (succ 0) in u) , b = (fix (\x: Nat . false )) }.b) in ({a = (succ 1) , b = (let u = false in false) , c = (( \f: Nat .((f ({a = false , b = 1 }.b) ) 0 ) ) (\a: Nat .\b: Bool .b)) }.c)) ) ({a = (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) else 1) , b = (( \f: Bool .((f ({a = 0 , b = false , c =  1 }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) , c =  (unfold [ Unit ] (fold [ Nat ] 0 )) }.b))
({a = (((\x: Unit .\y: Bool .x) (( \f: Unit .((f ({a = (if true then 1 else 0) , b = ({a = ({a = 1 , b = false , c = 1 }.c) , b = false }.a) }.b) ) (succ (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Bool .a)) ) (if (let u = (((\x: Rec X. X .\y: Nat .x) false ) true) in false) then (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) false ) true) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) else (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y))) , b = ({a = (if ({a = (( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] 0 )) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (if true then true else true) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) }.b) then (( \f: Rec X. X .((f ({a = 1 , b = true }.b) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Unit .b)) else (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = true }.b) ))) , b = (((\x: Bool .\y: Rec X. X .y) (((\x: Bool .\y: Unit .x) false ) (fix (\x: Bool . false ))) ) (((\x: Bool .\y: Nat .y) ({a = 1 , b = false , c =  1 }.b) ) 0)) }.a) , c =  (succ ({a = (let u = false in false) , b = 1 }.b)) }.b)
(((\x: Nat .\y: Rec X. X .y) (( \f: Bool .((f (let u = (((\x: Unit .\y: Bool .x) false ) true) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) ) (let u = ({a = true , b = true }.b) in (iszero 1)) ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Rec X. X .\y: Bool .x) (fix (\x: Rec X. X . ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) )) ) (let u = ({a = 1 , b = false }.b) in ({a = false , b = 0 }.a))))
(if ({a = ({a = ({a = true , b = false }.b) , b = (let u = (let u = 0 in u) in u) }.a) , b = (fix (\x: Unit . ({a = ({a = true , b = 0 }.a) , b = (iszero 0) }.b) )) }.b) then (let u = (succ ({a = 1 , b = ({a = 0 , b = false , c =  0 }.b) , c = 1 }.c)) in u) else (if (iszero (if true then 1 else 1)) then (if (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) then ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 1 )) else (pred 0)) else ({a = ({a = 1 , b = false }.a) , b = ({a = false , b = 1 }.a) , c = ({a = 0 , b = true }.a) }.c)))
(( \f: Nat .((f (let u = (fix (\x: Bool . 0 )) in u) ) ({a = (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) (let u = ({a = false , b = 1 }.b) in ({a = true , b = 1 }.a))) , b = ({a = (let u = 0 in u) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b) }.b) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Rec X. X . (let u = (((\x: Rec X. X .\y: Unit .x) ({a = true , b = 0 }.a) ) ({a = 1 , b = true }.b)) in u) ))
({a = ({a = (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) (let u = 1 in (if true then false else false))) , b = (( \f: Bool .((f (( \f: Bool .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.b) ) ) (\a: Unit .\b: Nat .b)) ) (if (((\x: Nat .\y: Unit .x) false ) (unfold [ Nat ] (fold [ Bool ] true ))) then (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)) else (let u = false in u)) ) ) (\a: Bool .\b: Unit .b)) , c = ({a = (let u = (((\x: Nat .\y: Bool .y) false ) 0) in ({a = true , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) , b = (let u = (let u = false in false) in 0) }.b) }.c) , b = ({a = (if (let u = false in u) then (fix (\x: Rec X. X . 1 )) else (let u = ({a = 0 , b = 0 }.b) in (succ 0))) , b = (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Bool .x) true ) true) )) , c =  (case <l = ({a = false , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) , c =  (( \f: Bool .((f (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f (let u = 0 in 1) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Unit .b)) ) (let u = 0 in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )))) ) (((\x: Bool .\y: Bool .y) (if false then ({a = 0 , b = false , c =  1 }.b) else false) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) (((\x: Unit .\y: Unit .y) true ) (succ 1)))) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(let u = (( \f: Bool .((f (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) (((\x: Bool .\y: Rec X. X .x) 1 ) true) ) ) (\a: Nat .\b: Nat .b)) ) ({a = (fix (\x: Rec X. X . true )) , b = ({a = ({a = 1 , b = true }.a) , b = 1 }.b) }.b) ) ) (\a: Nat .\b: Unit .b)) in ({a = (succ ({a = false , b = 1 }.b)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = true in true) )) }.b))
(( \f: Nat .((f (( \f: Nat .((f ({a = 0 , b = false , c =  1 }.b) ) (let u = (( \f: Unit .((f false ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .a)) in (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) ) (\a: Nat .\b: Bool .a)) ) (if (let u = true in u) then ({a = (let u = 0 in u) , b = true }.b) else (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u)) ) ) (\a: Unit .\b: Rec X. X .a))
(( \f: Nat .((f (iszero (pred (pred (case <l = (succ 0) > as Rec X. X of < l = x > => x | < r = y > => y)))) ) (fix (\x: Unit . ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) )) , b = ({a = true , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.b) , c =  (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(((\x: Rec X. X .\y: Bool .x) ({a = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) }.b) , b = (if (case <r = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Unit .\y: Unit .x) 1 ) true) else (let u = 0 in u)) }.b) ) (( \f: Nat .((f ({a = (let u = (let u = true in u) in u) , b = (pred (fix (\x: Bool . 0 ))) }.a) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) in (if false then true else false)) ) ) (\a: Rec X. X .\b: Unit .a)))
(((\x: Nat .\y: Unit .x) ({a = ({a = (succ 0) , b = (iszero 1) , c =  (((\x: Rec X. X .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) ({a = false , b = 1 }.b)) }.b) , b = (iszero (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) }.b) ) (iszero (fix (\x: Unit . ({a = 1 , b = 0 }.b) ))))
(let u = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (succ 0) )) in u) in (succ (( \f: Nat .((f (pred 0) ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Unit .b))))
(( \f: Rec X. X .((f (if (( \f: Bool .((f (if false then true else false) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) then ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = false , c = 0 }.c) else (((\x: Nat .\y: Nat .y) ({a = 1 , b = true }.b) ) ({a = 1 , b = false , c = 0 }.c))) ) (case <l = (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = false }.a) ) false) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a))
({a = (if ({a = (fix (\x: Bool . 0 )) , b = ({a = false , b = false }.b) }.b) then (case <r = ({a = false , b = (let u = 0 in u) }.a) > as Bool of < l = x > => x | < r = y > => y) else (((\x: Rec X. X .\y: Bool .y) (if (iszero 1) then true else (let u = true in u)) ) (( \f: Unit .((f ({a = 0 , b = false , c =  1 }.b) ) true ) ) (\a: Nat .\b: Nat .b)))) , b = (((\x: Unit .\y: Nat .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ) (succ 0)) }.b)
({a = (let u = (pred (succ 1)) in ({a = (((\x: Bool .\y: Bool .x) 0 ) true) , b = (unfold [ Rec X. X ] (fold [ Unit ] ({a = true , b = 1 }.a) )) }.a)) , b = (let u = (succ (pred (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)))) in (fix (\x: Bool . ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = true in u) }.b) ))) }.a)
(case <l = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Rec X. X .x) (let u = 1 in false) ) (let u = true in true)) ) (succ (succ 0))) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (iszero (( \f: Rec X. X .((f (let u = (iszero 0) in (((\x: Rec X. X .\y: Rec X. X .y) false ) ({a = true , b = 1 }.b))) ) (let u = (fix (\x: Bool . 0 )) in u) ) ) (\a: Rec X. X .\b: Bool .b))) ) ({a = (unfold [ Bool ] (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] 1 )) )) , b = (((\x: Rec X. X .\y: Nat .y) (((\x: Nat .\y: Bool .x) ({a = 1 , b = true }.b) ) true) ) (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in u)) }.b) ) ) (\a: Unit .\b: Nat .a))
(fix (\x: Bool . (let u = (fix (\x: Nat . (iszero 1) )) in (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .b)) ) (((\x: Bool .\y: Unit .x) true ) false) ) ) (\a: Unit .\b: Unit .b))) ))
({a = (( \f: Rec X. X .((f (if (unfold [ Nat ] (fold [ Bool ] false )) then (pred 0) else ({a = 0 , b = false }.a)) ) (if (if true then true else false) then 1 else (succ 0)) ) ) (\a: Nat .\b: Nat .a)) , b = (((\x: Nat .\y: Unit .x) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) )) }.b) ) (fix (\x: Unit . (unfold [ Nat ] (fold [ Nat ] (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .b)) )) ))) }.a)
(let u = (case <r = (( \f: Bool .((f (let u = (if true then false else true) in false) ) (let u = (fix (\x: Unit . false )) in u) ) ) (\a: Unit .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) in (( \f: Unit .((f (( \f: Nat .((f ({a = ({a = true , b = 1 }.a) , b = ({a = 1 , b = true }.b) }.b) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = (let u = 1 in u) in (unfold [ Unit ] (fold [ Unit ] true ))) ) ) (\a: Unit .\b: Unit .b)))
(let u = (( \f: Unit .((f (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) in (fix (\x: Unit . 0 ))) ) (let u = (let u = 0 in u) in u) ) ) (\a: Bool .\b: Rec X. X .b)) in (case <l = ({a = (((\x: Unit .\y: Nat .y) true ) 1) , b = (fix (\x: Bool . false )) , c = (if false then 1 else 1) }.c) > as Nat of < l = x > => x | < r = y > => y))
({a = (case <r = (fix (\x: Bool . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = (let u = 1 in false) in 1) )) , b = (let u = true in u) , c = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . true )) , c = (fix (\x: Rec X. X . 1 )) }.c) }.c) }.a)
(let u = (let u = (( \f: Unit .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) ) (let u = (if true then false else false) in (((\x: Unit .\y: Unit .y) true ) 1)) ) ) (\a: Unit .\b: Nat .a)) in u) in u)
(fix (\x: Nat . ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .y) false ) 1) )) , b = (iszero (let u = 1 in u)) }.b) ))
(( \f: Rec X. X .((f (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (( \f: Nat .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) false ) ) (\a: Nat .\b: Rec X. X .b)) )) in u) ) ({a = (if (((\x: Rec X. X .\y: Unit .x) true ) false) then (let u = (let u = 1 in 0) in u) else (let u = (let u = 1 in 0) in u)) , b = (fix (\x: Rec X. X . (( \f: Nat .((f (((\x: Bool .\y: Nat .y) true ) false) ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) , c =  (succ (((\x: Rec X. X .\y: Rec X. X .x) (succ 1) ) (let u = true in true))) }.b) ) ) (\a: Nat .\b: Nat .a))
(((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Bool .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) ) (if true then ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) else true)) ) (( \f: Rec X. X .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Bool .\b: Bool .a))) ) ({a = (let u = (let u = (let u = 0 in u) in false) in (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b))) , b = (( \f: Unit .((f (if false then true else false) ) (let u = 0 in true) ) ) (\a: Bool .\b: Nat .b)) }.b))
(((\x: Nat .\y: Unit .y) ({a = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = false , c =  (let u = 1 in 0) }.b) , b = (succ (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false , c =  0 }.b) ) 1)) }.a) ) (let u = (( \f: Nat .((f ({a = 1 , b = 0 }.b) ) (fix (\x: Unit . 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) in (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) 0 ) ) (\a: Unit .\b: Bool .a)) ))))
(((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .y) ({a = ({a = 0 , b = false }.a) , b = ({a = false , b = 1 }.a) , c =  (if false then 1 else 0) }.b) ) (((\x: Unit .\y: Nat .x) (( \f: Unit .((f ({a = 0 , b = true }.a) ) (fix (\x: Nat . 1 )) ) ) (\a: Nat .\b: Unit .b)) ) (if true then false else false))) ) ({a = (let u = (let u = false in 0) in u) , b = (( \f: Nat .((f (let u = true in u) ) (((\x: Rec X. X .\y: Nat .x) false ) false) ) ) (\a: Nat .\b: Bool .b)) , c =  ({a = (((\x: Nat .\y: Nat .x) 0 ) false) , b = ({a = false , b = 1 }.b) }.b) }.b))
(( \f: Nat .((f (case <r = (let u = (iszero 1) in u) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (let u = (succ 0) in 0) in ({a = (let u = false in 1) , b = (iszero 1) }.b)) ) ) (\a: Rec X. X .\b: Unit .a))
((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Bool . ({a = (let u = 1 in u) , b = (unfold [ Nat ] (fold [ Nat ] true )) , c =  (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) )) ))
(iszero (((\x: Nat .\y: Rec X. X .x) ({a = ({a = (iszero 1) , b = 0 }.b) , b = (unfold [ Unit ] (fold [ Unit ] (let u = 1 in u) )) }.b) ) ({a = 0 , b = true , c =  (((\x: Rec X. X .\y: Nat .x) 1 ) true) }.b)))
(((\x: Nat .\y: Nat .y) (let u = (iszero (((\x: Bool .\y: Nat .x) 1 ) true)) in u) ) (let u = ({a = (succ (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) , b = ({a = (pred 1) , b = (let u = true in false) }.b) , c = ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = (( \f: Nat .((f (iszero 1) ) (iszero 1) ) ) (\a: Bool .\b: Nat .b)) , c = (case <l = (((\x: Nat .\y: Rec X. X .y) false ) 0) > as Unit of < l = x > => x | < r = y > => y) }.c) }.c) in u))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = (fix (\x: Unit . (succ 0) )) , b = (fix (\x: Rec X. X . (if true then false else true) )) }.a) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = true in u) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.a) ))
(((\x: Nat .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Unit ] (if (((\x: Unit .\y: Rec X. X .y) true ) true) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) else (let u = 0 in false)) )) ) (( \f: Rec X. X .((f (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) ) (((\x: Bool .\y: Unit .x) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) (let u = true in false)) ) ) (\a: Rec X. X .\b: Bool .b)))
(if (( \f: Bool .((f (( \f: Bool .((f ({a = (let u = 0 in true) , b = ({a = 0 , b = true , c =  0 }.b) }.b) ) (case <r = (let u = true in true) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Unit .\y: Bool .x) ({a = true , b = 1 }.a) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .b)) then (case <l = (succ (succ ({a = 1 , b = 1 }.b))) > as Nat of < l = x > => x | < r = y > => y) else (( \f: Nat .((f (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) in 1) ) (let u = true in (let u = 0 in 0)) ) ) (\a: Nat .\b: Bool .a)))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = (succ (unfold [ Nat ] (fold [ Bool ] 0 ))) , b = ({a = (let u = false in 1) , b = (( \f: Nat .((f ({a = 0 , b = true , c =  0 }.b) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Bool .b)) }.b) }.b) )) in u)
(unfold [ Nat ] (fold [ Bool ] (pred (((\x: Bool .\y: Nat .y) (fix (\x: Nat . ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) }.b) )) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = ({a = false , b = 0 }.b) }.b))) ))
(let u = (fix (\x: Bool . (((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ({a = 0 , b = false , c =  1 }.b)) )) in u)
({a = (if (let u = 1 in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) then (case <l = (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Unit .x) true ) true) ) (let u = 1 in u)) > as Unit of < l = x > => x | < r = y > => y) else ({a = (let u = true in 1) , b = true , c = (((\x: Bool .\y: Nat .y) true ) 1) }.c)) , b = (let u = ({a = 0 , b = false }.b) in u) , c = (( \f: Nat .((f (( \f: Unit .((f (((\x: Unit .\y: Unit .x) 1 ) true) ) ({a = false , b = 1 }.b) ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Nat .((f (if true then (let u = 1 in u) else (succ 1)) ) (let u = (let u = false in false) in 1) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .b)) }.c)
(if (iszero (if (let u = 1 in false) then (if false then 1 else 0) else (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)))) then (let u = (unfold [ Bool ] (fold [ Bool ] 0 )) in (( \f: Unit .((f (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) (let u = 1 in u) ) ) (\a: Bool .\b: Bool .a))) else (((\x: Bool .\y: Bool .y) (let u = (((\x: Unit .\y: Nat .x) false ) false) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)))
({a = (unfold [ Bool ] (fold [ Unit ] (iszero (fix (\x: Nat . 1 ))) )) , b = ({a = (let u = (let u = (pred 0) in 1) in u) , b = (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) in (((\x: Bool .\y: Bool .y) (let u = 1 in true) ) false)) }.a) }.a)
({a = ({a = (((\x: Bool .\y: Bool .y) (unfold [ Unit ] (fold [ Unit ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) ) (((\x: Rec X. X .\y: Bool .x) 1 ) false)) , b = (((\x: Nat .\y: Bool .x) 0 ) ({a = false , b = 1 }.a)) }.b) , b = (iszero ({a = ({a = 1 , b = 0 }.b) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.b)) }.b)
(let u = (case <l = (pred (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) > as Bool of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Bool .x) ({a = 0 , b = ({a = true , b = false }.b) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .y) true ) true) ))))
(fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] (if (let u = ({a = false , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in u) then ({a = true , b = 1 }.a) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) )) ))
(((\x: Nat .\y: Nat .x) (let u = (( \f: Unit .((f (let u = false in 0) ) (let u = true in 0) ) ) (\a: Rec X. X .\b: Nat .a)) in u) ) (( \f: Nat .((f ({a = (succ 1) , b = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = (let u = false in u) , c =  ({a = 0 , b = false , c = 1 }.c) }.b) }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = 0 , b = true }.b) )) ) ) (\a: Bool .\b: Rec X. X .b)))
(let u = (((\x: Nat .\y: Bool .y) (( \f: Unit .((f ({a = false , b = ({a = 0 , b = true , c =  1 }.b) }.b) ) (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Nat .x) true ) true) ) true) ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = ({a = (let u = 1 in u) , b = (let u = 1 in ({a = false , b = 1 }.b)) }.b) , b = (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Bool .x) true ) true) ) false) , c = ({a = false , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.c)) in (fix (\x: Bool . (if (fix (\x: Bool . true )) then true else true) )))
(((\x: Rec X. X .\y: Bool .x) ({a = (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .y) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) in u) ) (fix (\x: Rec X. X . 0 ))) )) , b = (( \f: Rec X. X .((f (pred 0) ) (fix (\x: Unit . 0 )) ) ) (\a: Nat .\b: Unit .b)) }.b) ) ({a = (unfold [ Bool ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )) ) 1) )) , b = (if (( \f: Unit .((f false ) (((\x: Bool .\y: Rec X. X .x) false ) true) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (((\x: Unit .\y: Bool .y) true ) (let u = false in true)) else ({a = (if true then 0 else 0) , b = false }.b)) }.b))
(((\x: Unit .\y: Nat .x) (succ (succ ({a = (case <r = (((\x: Nat .\y: Bool .x) false ) false) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Unit .x) 1 ) true) }.b))) ) (((\x: Nat .\y: Unit .y) (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) > as Unit of < l = x > => x | < r = y > => y) ) (if ({a = 0 , b = false }.b) then true else (fix (\x: Nat . false )))))
(((\x: Nat .\y: Nat .y) (fix (\x: Bool . (((\x: Nat .\y: Bool .y) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false ))) )) ) (((\x: Bool .\y: Nat .x) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true , c = 1 }.c) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true ))))
(unfold [ Rec X. X ] (fold [ Bool ] (let u = (fix (\x: Nat . ({a = 1 , b = true }.a) )) in (if ({a = false , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) then (let u = true in true) else (fix (\x: Unit . ({a = 0 , b = true , c =  1 }.b) )))) ))
(( \f: Unit .((f (if ({a = false , b = 0 }.a) then ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = true , c = (let u = 1 in 1) }.c) else (( \f: Rec X. X .((f (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) in 0) ) ({a = ({a = 0 , b = false , c = 0 }.c) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Unit .\b: Rec X. X .b))) ) (let u = (succ (((\x: Unit .\y: Bool .y) (let u = 1 in true) ) 1)) in u) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = (fix (\x: Nat . (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) (unfold [ Unit ] (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Nat .a)) )) in (case <l = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) > as Unit of < l = x > => x | < r = y > => y))
(iszero (let u = (((\x: Unit .\y: Bool .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) in u))
(unfold [ Unit ] (fold [ Nat ] (let u = (let u = 1 in true) in (unfold [ Nat ] (fold [ Nat ] (let u = 1 in false) ))) ))
(let u = (let u = (((\x: Unit .\y: Nat .y) ({a = 1 , b = false , c =  0 }.b) ) ({a = ({a = true , b = 1 }.b) , b = (if false then true else true) , c = 1 }.c)) in u) in (if ({a = (let u = 1 in true) , b = (( \f: Unit .((f (let u = 1 in u) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) then ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) else ({a = (unfold [ Nat ] (fold [ Unit ] (iszero 0) )) , b = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true , c = 0 }.c) }.b) }.b)))
(pred (let u = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) in u) in (((\x: Unit .\y: Nat .y) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Nat .\y: Nat .x) ({a = 1 , b = false , c = 1 }.c) ) true))))
(( \f: Nat .((f (succ (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = 1 }.b) ))) ) (((\x: Nat .\y: Unit .x) (if (iszero (fix (\x: Rec X. X . 1 ))) then (succ (if true then 0 else 1)) else ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = true , b = (succ 0) }.b) ))) ) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Nat .y) (iszero 0) ) (((\x: Bool .\y: Rec X. X .x) false ) true)) ))) ) ) (\a: Bool .\b: Bool .a))
(unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Bool ] false )) )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <l = (pred 0) > as Unit of < l = x > => x | < r = y > => y) ))) ))
({a = (case <l = (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = false }.a) )) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = 1 , b = (iszero 1) , c =  0 }.b) ) (unfold [ Bool ] (fold [ Rec X. X ] (let u = true in false) )) ) ) (\a: Unit .\b: Unit .a)) , c = (let u = (let u = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) in u) in (case <l = (let u = 1 in (fix (\x: Rec X. X . 1 ))) > as Unit of < l = x > => x | < r = y > => y)) }.c)
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f (iszero (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) ) ({a = ({a = false , b = 0 }.b) , b = true , c =  (fix (\x: Bool . 1 )) }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ))
(let u = (case <l = (succ (succ 1)) > as Rec X. X of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Unit ] ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = ({a = 0 , b = false }.b) , c = (pred 1) }.c) )))
(let u = (let u = (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in u) )) ) (((\x: Unit .\y: Unit .y) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) 0) ) ) (\a: Unit .\b: Unit .b)) in u) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = (((\x: Rec X. X .\y: Nat .y) false ) 1) }.a) )))
(let u = (( \f: Bool .((f (unfold [ Unit ] (fold [ Unit ] (let u = false in u) )) ) (((\x: Bool .\y: Rec X. X .y) (if true then false else false) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true ))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (( \f: Rec X. X .((f (iszero (let u = 1 in u)) ) (fix (\x: Nat . (iszero (fix (\x: Bool . 1 ))) )) ) ) (\a: Rec X. X .\b: Unit .b)))
({a = ({a = (( \f: Unit .((f (let u = 0 in 0) ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Rec X. X .((f ({a = 1 , b = ({a = 1 , b = false }.b) , c =  1 }.b) ) (fix (\x: Nat . (fix (\x: Bool . true )) )) ) ) (\a: Nat .\b: Bool .b)) , c =  ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = ({a = 0 , b = (let u = true in u) , c = 1 }.c) }.b) }.b) , b = (let u = ({a = (let u = ({a = 1 , b = (((\x: Unit .\y: Unit .y) true ) 0) }.b) in u) , b = (((\x: Bool .\y: Unit .x) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) false) }.a) in u) }.a)
(((\x: Rec X. X .\y: Unit .x) (( \f: Rec X. X .((f (if ({a = (succ 0) , b = false }.b) then ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = 0 }.b) )) else (let u = false in 0)) ) (if (fix (\x: Unit . (let u = true in u) )) then (unfold [ Unit ] (fold [ Rec X. X ] ({a = (((\x: Nat .\y: Nat .y) true ) 1) , b = (let u = false in 1) }.b) )) else (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) in u)) ) ) (\a: Bool .\b: Bool .b)) ) (let u = (case <r = (if (let u = false in u) then true else (((\x: Nat .\y: Unit .x) true ) true)) > as Nat of < l = x > => x | < r = y > => y) in u))
({a = (( \f: Rec X. X .((f ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = 1 , b = true , c =  1 }.b) }.a) ) (( \f: Bool .((f (fix (\x: Nat . 1 )) ) (fix (\x: Nat . 1 )) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .b)) , b = (iszero (unfold [ Unit ] (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) , b = 1 }.b) ))) , c =  ({a = (let u = (((\x: Rec X. X .\y: Nat .y) false ) false) in u) , b = (unfold [ Unit ] (fold [ Bool ] (let u = 1 in u) )) }.b) }.b)
({a = (case <l = (((\x: Bool .\y: Nat .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (succ (pred 0))) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Nat .x) (if (fix (\x: Rec X. X . false )) then (((\x: Nat .\y: Rec X. X .y) true ) false) else ({a = 1 , b = false , c =  0 }.b)) ) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero 0) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.b)) }.b)
({a = (fix (\x: Nat . (fix (\x: Nat . (( \f: Nat .((f ({a = 0 , b = true , c =  1 }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) ) (\a: Unit .\b: Rec X. X .b)) )) )) , b = (iszero ({a = true , b = 0 }.b)) }.b)
((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (( \f: Bool .((f ({a = 1 , b = false , c = 1 }.c) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) true ) true) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Bool .b)) , c =  (case <l = (if false then 1 else 1) > as Nat of < l = x > => x | < r = y > => y) }.b) ))
({a = (succ ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = true , b = (pred 1) }.b) ))) , b = (((\x: Unit .\y: Rec X. X .x) ({a = (let u = 0 in false) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.a) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b)) }.a)
(case <r = (( \f: Unit .((f (fix (\x: Unit . ({a = ({a = true , b = (let u = true in false) }.b) , b = ({a = true , b = ({a = true , b = 0 }.a) }.b) }.b) )) ) (((\x: Unit .\y: Nat .x) (let u = ({a = false , b = 0 }.a) in u) ) (iszero (( \f: Nat .((f 1 ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Unit .a)))) ) ) (\a: Unit .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f ({a = (if (let u = false in true) then 1 else 1) , b = ({a = true , b = false }.b) , c = ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.c) }.c) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) ({a = ({a = 0 , b = false , c = 1 }.c) , b = ({a = true , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.a) }.b) ) (let u = (let u = true in 1) in ({a = 0 , b = false }.a))) )) ) ) (\a: Nat .\b: Nat .b))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (case <l = (if ({a = true , b = 0 }.a) then ({a = 1 , b = false , c = 1 }.c) else (if true then 0 else 0)) > as Bool of < l = x > => x | < r = y > => y) ))
(case <l = (((\x: Bool .\y: Unit .y) (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Bool ] (iszero 0) )) ) (((\x: Rec X. X .\y: Bool .x) (let u = false in u) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (pred 1) , b = ({a = 1 , b = true , c =  1 }.b) , c = ({a = 1 , b = (let u = false in 1) }.b) }.c)) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (unfold [ Nat ] (fold [ Bool ] (iszero (let u = ({a = 0 , b = false , c = 1 }.c) in u)) )) in u)
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if ({a = (if ({a = (pred 1) , b = false }.b) then ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) else (unfold [ Rec X. X ] (fold [ Bool ] ({a = true , b = 1 }.b) ))) , b = (iszero (succ 1)) , c =  (case <l = (let u = 0 in u) > as Nat of < l = x > => x | < r = y > => y) }.b) then (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in ({a = 1 , b = (((\x: Bool .\y: Bool .x) false ) false) , c =  0 }.b)) else (if (( \f: Nat .((f (((\x: Nat .\y: Nat .y) false ) true) ) ({a = true , b = 0 }.a) ) ) (\a: Nat .\b: Rec X. X .a)) then (((\x: Nat .\y: Nat .x) true ) true) else (let u = (let u = true in u) in false))) ))
(let u = ({a = (((\x: Rec X. X .\y: Unit .y) (iszero 0) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = false , b = 0 }.b) ))) , b = (let u = (fix (\x: Nat . 1 )) in (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .a))) , c =  (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) in (((\x: Nat .\y: Bool .y) false ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)))) }.b) in (let u = (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Rec X. X .x) true ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) )) in (if ({a = 1 , b = true }.b) then (unfold [ Rec X. X ] (fold [ Unit ] (succ 1) )) else ({a = 0 , b = 1 }.b))))
({a = (pred (((\x: Unit .\y: Nat .x) ({a = true , b = 1 }.b) ) ({a = 0 , b = (let u = true in false) }.b))) , b = (((\x: Bool .\y: Bool .y) (unfold [ Nat ] (fold [ Unit ] false )) ) (case <r = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y)) , c = (fix (\x: Bool . ({a = (if true then 0 else 1) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) )) }.c)
(case <r = (iszero (((\x: Bool .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) (let u = true in u))) > as Bool of < l = x > => x | < r = y > => y)
({a = (fix (\x: Rec X. X . (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) ({a = 0 , b = true }.b)) ) (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in u) ) ) (\a: Bool .\b: Bool .b)) )) , b = (((\x: Unit .\y: Unit .x) (unfold [ Unit ] (fold [ Rec X. X ] ({a = false , b = 1 }.a) )) ) (( \f: Nat .((f ({a = (fix (\x: Unit . 1 )) , b = ({a = false , b = true }.b) , c =  1 }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Rec X. X .\b: Bool .a))) }.a)
(let u = (( \f: Unit .((f (succ 0) ) (( \f: Unit .((f ({a = true , b = (let u = 0 in u) }.b) ) (let u = 1 in u) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .a)) in u)
(let u = ({a = (( \f: Unit .((f (( \f: Rec X. X .((f (let u = false in 1) ) (((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Rec X. X .x) 0 ) false) ) (let u = true in u)) ) ) (\a: Nat .\b: Unit .b)) ) (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .a)) , b = (let u = (let u = 1 in false) in (let u = ({a = 0 , b = 1 }.b) in false)) , c = (let u = (if (let u = false in u) then ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) else (if true then 0 else 0)) in u) }.c) in u)
(( \f: Rec X. X .((f (let u = ({a = (( \f: Unit .((f ({a = 1 , b = false }.b) ) true ) ) (\a: Nat .\b: Rec X. X .b)) , b = (fix (\x: Unit . (if false then 1 else 1) )) }.b) in ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = 1 }.b) }.a)) ) ({a = (( \f: Unit .((f ({a = 1 , b = (((\x: Nat .\y: Nat .y) true ) 1) }.b) ) (pred (((\x: Unit .\y: Nat .x) 0 ) false)) ) ) (\a: Bool .\b: Unit .a)) , b = (( \f: Bool .((f (if true then ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) else (unfold [ Rec X. X ] (fold [ Bool ] false ))) ) ({a = true , b = ({a = 1 , b = true }.a) }.a) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) ) (\a: Rec X. X .\b: Nat .a))
(fix (\x: Bool . (( \f: Unit .((f ({a = 0 , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) ) (( \f: Unit .((f (((\x: Bool .\y: Nat .x) (fix (\x: Nat . 1 )) ) false) ) (pred 1) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Bool .a)) ))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) in ({a = (( \f: Bool .((f ({a = false , b = 0 }.b) ) (pred 0) ) ) (\a: Unit .\b: Nat .b)) , b = (( \f: Nat .((f (let u = false in false) ) true ) ) (\a: Rec X. X .\b: Bool .b)) }.b)) ))
({a = (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .a)) )) ) (((\x: Unit .\y: Rec X. X .x) false ) false) ) ) (\a: Bool .\b: Unit .b)) )) , b = ({a = (((\x: Bool .\y: Nat .x) ({a = 0 , b = ({a = 0 , b = false , c = 1 }.c) }.b) ) ({a = (let u = false in false) , b = true }.b)) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = true }.b) )) }.a) }.a)
(unfold [ Rec X. X ] (fold [ Nat ] ({a = (if (((\x: Bool .\y: Unit .y) ({a = 1 , b = false , c =  0 }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true ))) then (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) else (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) (let u = 0 in 0) ) ) (\a: Bool .\b: Unit .a)) ))) , b = (((\x: Rec X. X .\y: Bool .x) (fix (\x: Bool . 1 )) ) (fix (\x: Unit . false ))) }.b) ))
(let u = (let u = ({a = (if false then 1 else 0) , b = (((\x: Rec X. X .\y: Nat .x) false ) true) }.b) in u) in (unfold [ Nat ] (fold [ Rec X. X ] (succ (let u = 1 in u)) )))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = ({a = (unfold [ Nat ] (fold [ Nat ] 1 )) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) true ) 1) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) in u) ))
(((\x: Rec X. X .\y: Nat .x) (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = 0 , b = false }.a) , b = ({a = 0 , b = true , c =  0 }.b) }.b) )) in (((\x: Unit .\y: Bool .x) (fix (\x: Bool . ({a = 1 , b = 1 }.b) )) ) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) false ) ) (\a: Unit .\b: Unit .a)))) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) , b = (((\x: Unit .\y: Unit .x) ({a = false , b = (pred 0) }.a) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) }.b))
({a = (if (unfold [ Unit ] (fold [ Bool ] (((\x: Rec X. X .\y: Bool .x) (unfold [ Nat ] (fold [ Bool ] true )) ) (( \f: Rec X. X .((f ({a = 1 , b = true , c =  0 }.b) ) false ) ) (\a: Nat .\b: Bool .a))) )) then (iszero ({a = (let u = true in 0) , b = ({a = 1 , b = true }.b) }.a)) else (iszero (((\x: Bool .\y: Rec X. X .x) 0 ) false))) , b = (case <l = (let u = true in 1) > as Bool of < l = x > => x | < r = y > => y) }.b)
(( \f: Rec X. X .((f (fix (\x: Nat . (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) )) ) (if (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Bool . true )) )) then (fix (\x: Unit . (iszero 1) )) else ({a = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) , b = (let u = false in false) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(( \f: Bool .((f (if (let u = (if true then true else false) in u) then (((\x: Bool .\y: Bool .y) (unfold [ Unit ] (fold [ Unit ] true )) ) (let u = (let u = 1 in false) in u)) else (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .x) false ) true))) ) (unfold [ Nat ] (fold [ Unit ] ({a = false , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.a) )) ) ) (\a: Bool .\b: Nat .a))
({a = (if (iszero (( \f: Rec X. X .((f ({a = 1 , b = false , c = 1 }.c) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a))) then (( \f: Nat .((f (let u = ({a = 1 , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in u) ) (((\x: Nat .\y: Nat .x) 0 ) true) ) ) (\a: Bool .\b: Nat .a)) else (if (let u = true in u) then ({a = 0 , b = 0 }.b) else (unfold [ Rec X. X ] (fold [ Unit ] (let u = 1 in 1) )))) , b = (iszero ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = ({a = 0 , b = true }.b) , c = 1 }.c)) , c =  (fix (\x: Bool . ({a = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) }.a) , b = ({a = 1 , b = 1 }.b) }.b) )) }.b)
(let u = (case <r = (( \f: Nat .((f (if false then true else false) ) (unfold [ Unit ] (fold [ Nat ] true )) ) ) (\a: Unit .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) in ({a = (let u = ({a = (succ 1) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) in (let u = (let u = 1 in true) in (((\x: Rec X. X .\y: Unit .y) true ) (let u = true in false)))) , b = (iszero ({a = 1 , b = (let u = false in u) }.a)) }.b))
({a = ({a = (case <l = (let u = 0 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = ({a = 1 , b = 1 }.b) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 ))) }.b) , b = ({a = (case <l = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) )) }.b) , c = (let u = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) in ({a = (pred 1) , b = ({a = 1 , b = false , c =  1 }.b) , c =  (if true then 0 else 1) }.b)) in (((\x: Nat .\y: Rec X. X .x) (let u = 1 in u) ) (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .y) false ) false) )))) }.c)
(let u = (let u = (if (fix (\x: Nat . false )) then ({a = 1 , b = true }.b) else (((\x: Nat .\y: Nat .x) false ) false)) in (let u = (pred ({a = 0 , b = false }.a)) in u)) in ({a = (if (let u = false in u) then (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = false }.a) ) false) else ({a = ({a = 0 , b = 1 }.b) , b = 0 }.b)) , b = (let u = 1 in false) }.a))
(let u = ({a = ({a = ({a = 0 , b = 0 }.b) , b = (let u = true in true) , c = (((\x: Bool .\y: Unit .y) false ) ({a = 1 , b = false , c = 1 }.c)) }.c) , b = (if false then 0 else 0) }.b) in u)
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (pred (let u = (let u = 1 in u) in (let u = 1 in ({a = true , b = 0 }.b)))) ))
(case <l = ({a = (((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Nat .y) false ) (let u = true in true)) ) ({a = ({a = false , b = 0 }.b) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) , b = ({a = (((\x: Unit .\y: Bool .x) ({a = 1 , b = false }.a) ) ({a = false , b = ({a = 1 , b = false }.b) }.b)) , b = ({a = (fix (\x: Unit . true )) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) }.b) }.a) }.b) > as Nat of < l = x > => x | < r = y > => y)
(if (unfold [ Nat ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] true )) , b = true }.b) , b = (let u = 1 in false) }.b) )) )) then (fix (\x: Rec X. X . (((\x: Unit .\y: Unit .y) ({a = 0 , b = false , c =  0 }.b) ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b))) )) else (iszero (case <l = (if (((\x: Unit .\y: Unit .x) false ) true) then 0 else 0) > as Rec X. X of < l = x > => x | < r = y > => y)))
(unfold [ Bool ] (fold [ Bool ] (fix (\x: Rec X. X . (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 )) in (((\x: Bool .\y: Nat .y) (let u = true in false) ) 0)) )) ))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) (iszero ({a = true , b = 0 }.b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = 1 , b = true , c =  1 }.b)) ))) ) (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b))
(unfold [ Bool ] (fold [ Unit ] (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = ({a = 1 , b = false }.a) in false) )) ) (( \f: Rec X. X .((f (fix (\x: Bool . false )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .b)) ))
(((\x: Bool .\y: Nat .x) (case <l = (succ (let u = 1 in u)) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (case <l = (let u = 0 in 1) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Unit .\y: Rec X. X .y) (fix (\x: Nat . false )) ) 1) in (((\x: Rec X. X .\y: Bool .x) false ) true)) }.b))
(iszero (if ({a = ({a = (fix (\x: Nat . 0 )) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  0 }.b) , b = ({a = 0 , b = true }.a) }.a) then (let u = ({a = (let u = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .a)) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , c =  ({a = 0 , b = 1 }.b) }.b) in ({a = (pred (if false then 1 else 0)) , b = (iszero 1) }.a)) else (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) )) > as Unit of < l = x > => x | < r = y > => y)))
(case <l = (case <l = (if ({a = true , b = false }.b) then (pred 1) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(let u = (( \f: Rec X. X .((f ({a = (fix (\x: Rec X. X . 0 )) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . false )) )) , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) ) (let u = ({a = 1 , b = 1 }.b) in (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Rec X. X .\b: Bool .a)) in ({a = (let u = (if (unfold [ Bool ] (fold [ Bool ] true )) then (let u = true in 0) else (pred 1)) in (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Bool .y) false ) false) ))) , b = (let u = ({a = 0 , b = ({a = 0 , b = false }.b) , c =  1 }.b) in (let u = (if false then 0 else 0) in (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)))) }.b))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (unfold [ Nat ] (fold [ Bool ] (if true then false else false) )) in u) ))
(succ ({a = (((\x: Bool .\y: Bool .x) (pred 1) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false ))) , b = (fix (\x: Nat . (fix (\x: Rec X. X . 1 )) )) }.b))
({a = ({a = (((\x: Unit .\y: Nat .y) (let u = 0 in false) ) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = true }.a)) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (pred 0) , b = (let u = (let u = true in u) in (unfold [ Rec X. X ] (fold [ Unit ] false ))) , c =  (let u = false in 0) }.b) )) }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = true , b = true }.b) , b = false }.b) )) }.b)
({a = ({a = (pred ({a = true , b = 0 }.b)) , b = ({a = ({a = (succ 0) , b = (fix (\x: Nat . ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )) )) }.a) , b = ({a = (fix (\x: Bool . ({a = 0 , b = true , c =  1 }.b) )) , b = (case <l = (fix (\x: Rec X. X . 1 )) > as Nat of < l = x > => x | < r = y > => y) }.a) , c =  (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) , c =  (let u = ({a = ({a = 1 , b = false , c =  1 }.b) , b = (pred 1) }.a) in ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) , c = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.c)) }.b) , b = (( \f: Nat .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) (succ 0) ) ) (\a: Unit .\b: Nat .b)) ) ({a = 1 , b = ({a = false , b = 0 }.a) , c = 0 }.c) ) ) (\a: Unit .\b: Bool .b)) ) (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 ))) ) ) (\a: Bool .\b: Unit .a)) }.a)
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Nat .x) 1 ) true) in (iszero 1)) )) , b = (let u = ({a = (let u = 1 in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b))) , b = (( \f: Rec X. X .((f (let u = ({a = false , b = false }.b) in false) ) (let u = true in false) ) ) (\a: Nat .\b: Bool .b)) }.b) in (succ (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)))) }.b)
(if ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) )) , b = ({a = ({a = false , b = 1 }.a) , b = (if (let u = 0 in true) then (let u = false in false) else ({a = false , b = false }.b)) }.b) }.b) then (( \f: Unit .((f (((\x: Nat .\y: Bool .y) (let u = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a)) in u) ) (let u = 1 in u)) ) ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) true) , b = (unfold [ Nat ] (fold [ Bool ] ({a = true , b = false }.b) )) }.a) ) ) (\a: Unit .\b: Rec X. X .a)) else ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = ({a = 1 , b = true , c = 0 }.c) in true) }.a) )))
({a = (iszero (succ (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) in u))) , b = ({a = (if ({a = true , b = 0 }.a) then (let u = (pred 1) in true) else (let u = false in true)) , b = (case <l = (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .y) true ) 1) )) > as Bool of < l = x > => x | < r = y > => y) }.a) }.b)
(((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (iszero (succ 1)) ) (((\x: Rec X. X .\y: Unit .y) ({a = false , b = true }.b) ) ({a = false , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) }.a)) ) ) (\a: Unit .\b: Rec X. X .a)) ) (unfold [ Nat ] (fold [ Nat ] ({a = (fix (\x: Unit . 0 )) , b = true , c =  1 }.b) )))
(( \f: Rec X. X .((f ({a = (pred (if (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .b)) then (((\x: Bool .\y: Unit .x) 1 ) true) else 1)) , b = ({a = (if false then 1 else 1) , b = (unfold [ Unit ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) true ) false) )) }.b) , c = (pred (( \f: Nat .((f 0 ) ({a = 0 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Unit .a))) }.c) ) (( \f: Bool .((f ({a = true , b = 1 }.b) ) (((\x: Unit .\y: Bool .x) (( \f: Unit .((f 0 ) (let u = 1 in u) ) ) (\a: Nat .\b: Unit .b)) ) ({a = (let u = 1 in true) , b = 0 }.a)) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .a))
(((\x: Nat .\y: Rec X. X .y) (unfold [ Bool ] (fold [ Bool ] (iszero (((\x: Unit .\y: Unit .x) 1 ) false)) )) ) (let u = (( \f: Unit .((f (fix (\x: Bool . ({a = false , b = 0 }.a) )) ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Nat .\b: Unit .a)) in ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (iszero 0) , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.b)))
(case <l = ({a = ({a = 1 , b = (let u = 0 in false) , c = ({a = 1 , b = false }.a) }.c) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = 1 in (iszero 1)) ) ({a = 1 , b = false }.b)) , c = (let u = (let u = false in true) in ({a = 1 , b = true , c = 1 }.c)) }.c) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) true) ) ({a = true , b = 1 }.a)) )) , b = (let u = ({a = false , b = true }.b) in (fix (\x: Unit . 1 ))) }.b) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .x) (let u = (let u = false in true) in ({a = false , b = 1 }.a)) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b))) )) , c =  ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = (((\x: Bool .\y: Unit .y) false ) 1) , b = (if true then true else false) , c = (let u = 1 in 1) }.c) , b = ({a = 1 , b = false }.b) }.a) )) )) }.b)
({a = (let u = (( \f: Rec X. X .((f (fix (\x: Unit . 0 )) ) ({a = (let u = 0 in true) , b = 1 }.b) ) ) (\a: Nat .\b: Bool .b)) in u) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (if true then 1 else 1) )) ) (( \f: Unit .((f (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a))) )) }.b)
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = (let u = 1 in u) , b = (fix (\x: Rec X. X . ({a = 0 , b = true , c =  1 }.b) )) , c = (let u = ({a = (fix (\x: Bool . true )) , b = false }.b) in (unfold [ Bool ] (fold [ Unit ] 1 ))) }.c) ))
({a = (( \f: Nat .((f (pred (unfold [ Bool ] (fold [ Unit ] 1 ))) ) ({a = (succ ({a = 1 , b = 0 }.b)) , b = (let u = false in u) , c = (((\x: Rec X. X .\y: Unit .x) 0 ) true) }.c) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = (succ (pred 1)) , b = ({a = (if (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .b)) then ({a = true , b = true }.b) else true) , b = ({a = 0 , b = true , c =  0 }.b) }.b) , c =  (((\x: Rec X. X .\y: Nat .x) ({a = ({a = 0 , b = false }.b) , b = 0 }.b) ) (((\x: Nat .\y: Bool .x) true ) (((\x: Rec X. X .\y: Unit .y) true ) true))) }.b) }.b)
(((\x: Bool .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] (let u = (unfold [ Rec X. X ] (fold [ Nat ] (let u = true in true) )) in u) )) ) (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Nat . ({a = ({a = 1 , b = false }.a) , b = false }.b) )) ) (pred (let u = false in 1))))
(( \f: Rec X. X .((f (( \f: Unit .((f (((\x: Bool .\y: Nat .y) ({a = 1 , b = false }.b) ) (succ 1)) ) (fix (\x: Unit . ({a = 1 , b = 1 }.b) )) ) ) (\a: Nat .\b: Rec X. X .b)) ) (( \f: Unit .((f (succ (let u = 0 in 0)) ) (( \f: Unit .((f (((\x: Bool .\y: Nat .x) 1 ) true) ) ({a = false , b = 1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Unit . (case <l = (pred ({a = 0 , b = true }.a)) > as Bool of < l = x > => x | < r = y > => y) ))
(if (case <r = (if (iszero (let u = 1 in u)) then (let u = true in u) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true ))) > as Unit of < l = x > => x | < r = y > => y) then (succ (let u = (pred (pred 1)) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) else ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (fix (\x: Bool . (fix (\x: Nat . ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) )) )) , c = (let u = (succ 1) in (fix (\x: Nat . 0 ))) }.c))
(pred (case <l = (fix (\x: Bool . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) )) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Bool .\y: Bool .x) (( \f: Bool .((f ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) false ) false) )) , b = (let u = 0 in u) }.b) ) (pred (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a))) ) ) (\a: Bool .\b: Unit .b)) ) (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Rec X. X .((f (case <r = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (let u = (let u = true in u) in 0) in ({a = 0 , b = true }.b)) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (((\x: Rec X. X .\y: Nat .y) true ) false) , b = (( \f: Unit .((f (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) ) (fix (\x: Unit . false )) ) ) (\a: Bool .\b: Unit .a)) }.b)))
({a = (((\x: Unit .\y: Nat .x) (if ({a = (if true then true else true) , b = (let u = 0 in 1) }.a) then (if false then true else true) else (let u = true in u)) ) (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Unit . ({a = true , b = 1 }.a) )) ))) , b = ({a = (( \f: Bool .((f ({a = (let u = 1 in (let u = false in true)) , b = (let u = 1 in 1) }.b) ) (((\x: Rec X. X .\y: Nat .y) false ) (((\x: Bool .\y: Bool .x) 1 ) false)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = (let u = (succ 0) in 1) , b = (let u = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) in u) }.b) , c =  ({a = (( \f: Unit .((f 0 ) (unfold [ Bool ] (fold [ Unit ] 1 )) ) ) (\a: Unit .\b: Bool .b)) , b = (let u = (if true then true else ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true ))) in u) , c = (if true then ({a = 1 , b = 0 }.b) else 1) }.c) }.b) }.b)
(if (fix (\x: Rec X. X . ({a = (let u = (if true then 1 else 1) in u) , b = ({a = ({a = 1 , b = 1 }.b) , b = (let u = true in u) }.b) }.b) )) then (let u = (let u = ({a = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (iszero 0) , c = (if false then 1 else 1) }.c) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , c =  (unfold [ Nat ] (fold [ Nat ] 0 )) }.b) in (((\x: Unit .\y: Nat .y) (let u = false in u) ) (let u = (let u = true in u) in (succ 1)))) in (if ({a = 0 , b = true , c =  1 }.b) then ({a = ({a = 0 , b = false }.a) , b = (fix (\x: Rec X. X . false )) , c =  1 }.b) else (if ({a = (unfold [ Bool ] (fold [ Unit ] 1 )) , b = (let u = true in false) }.b) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) else (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .a))))) else (((\x: Nat .\y: Nat .x) (fix (\x: Unit . ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)) )) )) ) (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ))))
({a = (let u = ({a = ({a = true , b = 0 }.b) , b = (fix (\x: Bool . true )) , c = (((\x: Nat .\y: Unit .x) 0 ) false) }.c) in u) , b = (( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) true ) 1) )) )) )) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
(( \f: Bool .((f (if ({a = (let u = (let u = false in u) in ({a = false , b = 0 }.a)) , b = (succ (let u = 1 in 1)) }.a) then (unfold [ Unit ] (fold [ Bool ] (if (((\x: Unit .\y: Nat .x) ({a = false , b = false }.b) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a))) then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else (if ({a = true , b = true }.b) then (iszero 0) else false)) )) else (((\x: Rec X. X .\y: Rec X. X .y) ({a = (fix (\x: Unit . 0 )) , b = true , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = false , c =  1 }.b) )))) ) ({a = (unfold [ Bool ] (fold [ Unit ] ({a = ({a = false , b = 1 }.b) , b = ({a = 1 , b = false , c =  0 }.b) , c = (succ 0) }.c) )) , b = ({a = ({a = ({a = (if false then true else true) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Nat .y) true ) 1) )) }.b) , b = (iszero ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 ))) , c =  ({a = (pred 0) , b = 0 }.b) }.b) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) )) }.b) ) ) (\a: Unit .\b: Bool .b))
(let u = (let u = (( \f: Rec X. X .((f (let u = true in false) ) true ) ) (\a: Nat .\b: Bool .a)) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (pred 0) ))) in (if (let u = ({a = true , b = 1 }.a) in u) then ({a = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . false )) , c = 1 }.c) , b = (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) }.a) else ({a = ({a = 1 , b = false , c =  1 }.b) , b = (( \f: Nat .((f (succ 1) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .a)) }.b)))
(let u = (pred ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Rec X. X . 0 )) ))) in ({a = ({a = (((\x: Bool .\y: Unit .y) true ) 0) , b = (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = (pred 1) in u) }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) (((\x: Rec X. X .\y: Unit .x) false ) false)) }.b))
(if (( \f: Unit .((f (((\x: Bool .\y: Unit .x) (fix (\x: Unit . false )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) (fix (\x: Bool . (let u = (let u = false in false) in u) )) ) ) (\a: Bool .\b: Rec X. X .b)) then (if ({a = ({a = true , b = 1 }.a) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) }.b) then ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a))) , b = (let u = 1 in u) }.b) else (( \f: Unit .((f 1 ) (unfold [ Unit ] (fold [ Bool ] 1 )) ) ) (\a: Unit .\b: Unit .a))) else ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = false }.b) )) , b = ({a = ({a = (((\x: Rec X. X .\y: Unit .y) true ) false) , b = true }.b) , b = (unfold [ Nat ] (fold [ Unit ] 1 )) }.b) }.b))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .x) (unfold [ Unit ] (fold [ Bool ] 1 )) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ({a = false , b = 1 }.a) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) ))
(fix (\x: Nat . (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Bool .y) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) (iszero 1)) )) ))
(( \f: Unit .((f (let u = (succ ({a = 0 , b = 0 }.b)) in u) ) (let u = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) in ({a = true , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) }.b)) ) ) (\a: Rec X. X .\b: Bool .b))
(iszero (((\x: Unit .\y: Unit .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) true ) false) )) ) (pred (let u = 0 in 0))))
(pred (case <l = ({a = (((\x: Bool .\y: Unit .x) 1 ) false) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . 0 )) )) }.b) > as Nat of < l = x > => x | < r = y > => y))
(let u = (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) (let u = false in u) ) (((\x: Unit .\y: Rec X. X .y) false ) false)) ) (((\x: Unit .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Bool ] true )) ) (if (let u = true in true) then false else true)) ) ) (\a: Unit .\b: Nat .a)) in u)
({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) )) )) , b = (fix (\x: Nat . ({a = (((\x: Bool .\y: Unit .x) (if ({a = false , b = 0 }.a) then 0 else 1) ) (let u = ({a = 1 , b = 0 }.b) in true)) , b = ({a = 0 , b = ({a = 0 , b = false }.b) , c =  0 }.b) , c =  ({a = 1 , b = false }.a) }.b) )) , c =  ({a = (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Unit .x) false ) true) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) , b = (case <r = (if ({a = false , b = true }.b) then ({a = true , b = true }.b) else ({a = true , b = ({a = 1 , b = true , c = 0 }.c) }.a)) > as Bool of < l = x > => x | < r = y > => y) , c = (unfold [ Nat ] (fold [ Unit ] ({a = false , b = 1 }.b) )) }.c) }.b)
(let u = (let u = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in 0) in ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (let u = 0 in true) , c = (let u = 0 in u) }.c) , b = ({a = (let u = 0 in u) , b = false , c =  0 }.b) }.b)) in u)
({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] (succ 1) )) , b = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  (fix (\x: Nat . 1 )) }.b) }.a) , b = ({a = (((\x: Nat .\y: Bool .x) (let u = 1 in (let u = true in u)) ) ({a = ({a = 0 , b = false }.b) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.a)) , b = (case <l = (let u = (iszero 1) in (let u = 0 in u)) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.b)
(let u = (succ (pred (unfold [ Unit ] (fold [ Unit ] 0 )))) in u)
(if (let u = (let u = ({a = (iszero 1) , b = (fix (\x: Nat . 1 )) }.a) in (unfold [ Bool ] (fold [ Nat ] false ))) in ({a = ({a = true , b = 0 }.a) , b = ({a = 0 , b = 0 }.b) }.a)) then ({a = (fix (\x: Unit . (( \f: Rec X. X .((f (fix (\x: Nat . true )) ) (fix (\x: Rec X. X . false )) ) ) (\a: Bool .\b: Nat .b)) )) , b = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) }.b) }.b) else (unfold [ Nat ] (fold [ Bool ] (let u = ({a = true , b = true }.b) in u) )))
(( \f: Nat .((f ({a = ({a = (if (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .b)) then (unfold [ Bool ] (fold [ Rec X. X ] true )) else true) , b = (((\x: Unit .\y: Unit .y) (let u = false in u) ) (unfold [ Bool ] (fold [ Nat ] false ))) }.b) , b = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (iszero ({a = 0 , b = true }.a)) }.b) }.b) ) (if ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = (let u = false in false) in u) )) then (case <r = ({a = 1 , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) , c =  1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) else (iszero (let u = (((\x: Rec X. X .\y: Bool .x) 0 ) false) in u))) ) ) (\a: Nat .\b: Bool .a))
({a = (succ ({a = (if false then 0 else 0) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c = (let u = 1 in u) }.c)) , b = ({a = (succ (fix (\x: Rec X. X . 1 ))) , b = (( \f: Rec X. X .((f (iszero 0) ) ({a = 0 , b = false }.b) ) ) (\a: Unit .\b: Nat .a)) , c =  ({a = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] 1 )) ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Unit .\y: Rec X. X .y) false ) true) , c = (succ 0) }.c) }.b) , c = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (succ (if true then 1 else 1)) )) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] true )) in (iszero 1)) , c = (case <l = ({a = 0 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.c) }.c)
(( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) (let u = 1 in ({a = 1 , b = false }.b)) ) (let u = (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in 0) in u)) ) ({a = (let u = ({a = 1 , b = ({a = 1 , b = true }.a) }.b) in (let u = (let u = true in false) in (let u = false in 0))) , b = ({a = ({a = true , b = 1 }.b) , b = (iszero 1) }.b) }.a) ) ) (\a: Unit .\b: Bool .a))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (((\x: Rec X. X .\y: Rec X. X .x) (let u = 0 in 1) ) true) in u) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (let u = (if ({a = 1 , b = true , c =  0 }.b) then true else true) in u) in (case <r = (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Bool .y) true ) true) ) (let u = 0 in false)) > as Nat of < l = x > => x | < r = y > => y)) ))
(let u = (( \f: Unit .((f ({a = ({a = 0 , b = (if true then false else true) , c =  1 }.b) , b = ({a = 1 , b = true , c = 0 }.c) }.a) ) ({a = (let u = 1 in true) , b = ({a = 1 , b = (iszero 0) }.a) }.a) ) ) (\a: Nat .\b: Rec X. X .a)) in (((\x: Unit .\y: Rec X. X .y) (if (iszero 1) then ({a = true , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a) else (iszero 0)) ) (iszero ({a = 1 , b = false , c = 1 }.c))))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = false , b = 1 }.b) ))) ))
(pred (( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if false then 1 else (fix (\x: Bool . 1 ))) )) ) ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true , c = ({a = 1 , b = true , c = 1 }.c) }.c) }.b) ) ) (\a: Bool .\b: Unit .b)))
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = ({a = 1 , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , c =  (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Unit .((f 1 ) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ) (\a: Bool .\b: Nat .b)) }.a) , b = (succ (let u = 1 in 0)) }.a) ))
(case <r = (let u = ({a = (succ (let u = 0 in 1)) , b = (let u = 0 in ({a = true , b = true }.b)) }.a) in (let u = (( \f: Nat .((f false ) (let u = 1 in false) ) ) (\a: Unit .\b: Unit .b)) in u)) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Unit .x) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <r = (let u = (((\x: Nat .\y: Nat .y) false ) 0) in true) > as Bool of < l = x > => x | < r = y > => y) }.a) ) (let u = ({a = (pred 1) , b = (let u = true in (if false then true else false)) }.b) in u))
({a = (fix (\x: Bool . (unfold [ Unit ] (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) )) , b = (case <l = (if (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) then (((\x: Rec X. X .\y: Nat .x) (succ 1) ) true) else (((\x: Nat .\y: Bool .y) false ) 1)) > as Nat of < l = x > => x | < r = y > => y) }.b)
(iszero (if (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b)) in (if true then false else false)) then (case <l = (((\x: Unit .\y: Bool .y) false ) 0) > as Nat of < l = x > => x | < r = y > => y) else ({a = (if false then true else false) , b = (fix (\x: Nat . (succ 1) )) }.b)))
(fix (\x: Bool . ({a = ({a = ({a = false , b = 0 }.a) , b = (let u = false in true) }.b) , b = (let u = ({a = 0 , b = 0 }.b) in (let u = true in u)) }.b) ))
(((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Rec X. X .y) (( \f: Bool .((f ({a = false , b = 0 }.a) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) ) ) (\a: Unit .\b: Nat .a)) ) ({a = true , b = ({a = 0 , b = false , c = 0 }.c) }.a)) ) ({a = (let u = (pred 0) in u) , b = (iszero (fix (\x: Bool . 1 ))) , c = ({a = (pred 0) , b = (if true then false else false) , c = (pred (fix (\x: Rec X. X . 0 ))) }.c) }.c))
(case <r = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) )) , b = (pred 0) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Rec X. X .y) (let u = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (let u = false in false) , c =  ({a = false , b = 0 }.b) }.b) in u) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Bool .y) false ) true) ) (let u = 1 in u)) )))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (fix (\x: Bool . (let u = 1 in 0) )) in u) ))
(let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Nat .((f ({a = true , b = 0 }.a) ) ({a = (succ 0) , b = true }.b) ) ) (\a: Rec X. X .\b: Unit .a)) )) in (if ({a = (iszero 0) , b = ({a = false , b = 0 }.a) }.b) then ({a = (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Bool .y) (if true then true else true) ) false) ) (unfold [ Unit ] (fold [ Unit ] false ))) , b = (iszero 1) }.b) else (( \f: Unit .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) ) (\a: Bool .\b: Rec X. X .a))))
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Unit .((f (case <l = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ({a = false , b = 0 }.b) , b = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) }.a) ) ) (\a: Bool .\b: Rec X. X .b)) ))
(let u = ({a = (let u = ({a = 1 , b = true , c =  1 }.b) in (((\x: Bool .\y: Bool .y) false ) 0)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .b)) )) )) , c =  ({a = 0 , b = ({a = 1 , b = true }.a) }.b) }.b) in ({a = (fix (\x: Bool . (if true then 0 else 1) )) , b = (let u = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) in (unfold [ Bool ] (fold [ Rec X. X ] false ))) , c =  (let u = (let u = true in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) in (let u = true in 0)) }.b))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .b)) )) in (((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) ({a = false , b = 0 }.a))) ))
({a = (fix (\x: Nat . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ({a = 0 , b = false , c =  1 }.b) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .b)) }.b) )) )) , b = (let u = ({a = (let u = true in 0) , b = (iszero 0) }.a) in ({a = (let u = ({a = true , b = 1 }.a) in 1) , b = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.b)) }.b)
(( \f: Unit .((f (fix (\x: Nat . (((\x: Unit .\y: Unit .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = false in u)) )) ) (if (iszero (pred 0)) then (((\x: Unit .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .a))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) ) (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) in (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)))) ))
(pred ({a = (((\x: Bool .\y: Bool .x) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .y) true ) (case <r = false > as Nat of < l = x > => x | < r = y > => y))) , b = (case <l = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = false , c = 0 }.c) > as Bool of < l = x > => x | < r = y > => y) }.b))
(case <l = ({a = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Bool ] false )) )) )) , b = (((\x: Bool .\y: Unit .y) (fix (\x: Unit . false )) ) (let u = ({a = false , b = 1 }.a) in (((\x: Bool .\y: Nat .y) true ) 0))) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = (if ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = 1 in false) )) , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.a) then (let u = (pred 0) in u) else ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (if true then false else false) , c = (fix (\x: Nat . (succ 1) )) }.c)) , b = (( \f: Unit .((f (let u = false in (((\x: Unit .\y: Nat .y) false ) true)) ) ({a = ({a = false , b = 0 }.a) , b = (((\x: Nat .\y: Rec X. X .x) 0 ) true) }.a) ) ) (\a: Bool .\b: Bool .a)) }.b)
({a = (let u = ({a = (if false then true else false) , b = ({a = 1 , b = true , c = 0 }.c) }.a) in (fix (\x: Nat . (if true then 1 else (((\x: Rec X. X .\y: Nat .x) 1 ) true)) ))) , b = (iszero ({a = (case <l = (((\x: Unit .\y: Nat .x) 0 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero 1) )) , c = (((\x: Unit .\y: Rec X. X .y) ({a = (((\x: Unit .\y: Rec X. X .y) false ) true) , b = ({a = 1 , b = false , c = 0 }.c) }.a) ) (if false then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) else (((\x: Bool .\y: Rec X. X .y) true ) 1))) }.c)) }.a)
({a = (if ({a = (((\x: Nat .\y: Nat .x) (let u = false in false) ) (((\x: Unit .\y: Nat .y) true ) false)) , b = ({a = 0 , b = 1 }.b) }.a) then (((\x: Bool .\y: Nat .y) false ) (let u = 0 in true)) else (let u = ({a = false , b = false }.b) in false)) , b = (( \f: Rec X. X .((f ({a = (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Unit .y) false ) 0) )) , b = (iszero 1) }.a) ) (( \f: Rec X. X .((f ({a = (fix (\x: Unit . true )) , b = (if false then 0 else 1) }.b) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(if (if ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) true ) false) )) then (let u = (let u = false in u) in (unfold [ Bool ] (fold [ Nat ] true ))) else ({a = (let u = ({a = 1 , b = true }.a) in ({a = 1 , b = false , c =  0 }.b)) , b = ({a = true , b = false }.b) }.b)) then (let u = (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Nat .y) true ) (let u = false in true)) ) (iszero (pred 0))) in u) else (( \f: Rec X. X .((f (let u = (succ (fix (\x: Bool . 1 ))) in (let u = (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )))) ) (((\x: Rec X. X .\y: Nat .x) (let u = false in true) ) (( \f: Unit .((f ({a = 1 , b = true }.b) ) false ) ) (\a: Bool .\b: Unit .a))) ) ) (\a: Nat .\b: Unit .b)))
(let u = (fix (\x: Bool . (fix (\x: Rec X. X . (let u = true in u) )) )) in u)
(( \f: Nat .((f (((\x: Bool .\y: Bool .y) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Unit .\y: Nat .x) (pred 1) ) (let u = false in u))) ) (let u = (pred (((\x: Unit .\y: Unit .x) 1 ) false)) in u) ) ) (\a: Unit .\b: Bool .a))
(((\x: Nat .\y: Bool .y) (let u = (if true then 0 else ({a = 1 , b = 0 }.b)) in (fix (\x: Nat . true ))) ) ({a = (pred ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = (succ 0) }.b)) , b = (if (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = false }.b) ) false) then (pred 1) else (case <l = ({a = 0 , b = false }.a) > as Nat of < l = x > => x | < r = y > => y)) }.b))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) in ({a = false , b = 0 }.a)) )) )) , b = ({a = (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .x) 1 ) true) ))) , b = (let u = (let u = 0 in u) in (iszero ({a = 0 , b = false }.a))) }.a) }.a)
(let u = ({a = (fix (\x: Unit . (( \f: Nat .((f ({a = 1 , b = false }.a) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = ({a = (case <l = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = false in false) }.b) }.b) in (case <r = (( \f: Bool .((f (fix (\x: Bool . false )) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y))
(fix (\x: Unit . ({a = ({a = (succ 1) , b = (fix (\x: Nat . 0 )) }.b) , b = (( \f: Unit .((f ({a = true , b = (succ 1) }.a) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ))
({a = ({a = (( \f: Rec X. X .((f (succ 0) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) , b = (iszero (((\x: Nat .\y: Unit .x) (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) in u) ) (((\x: Rec X. X .\y: Bool .y) true ) true))) }.a) , b = (let u = (if (fix (\x: Rec X. X . false )) then (succ 0) else (((\x: Unit .\y: Rec X. X .x) 0 ) false)) in (iszero (if true then (succ 0) else 0))) }.a)
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Unit ] (let u = ({a = false , b = 0 }.b) in u) )) )) , b = (let u = (case <r = (unfold [ Unit ] (fold [ Nat ] (let u = 0 in true) )) > as Nat of < l = x > => x | < r = y > => y) in (if ({a = (((\x: Rec X. X .\y: Nat .x) false ) false) , b = (let u = false in 1) }.a) then (pred 0) else (if ({a = true , b = true }.b) then (if false then 1 else 0) else (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b))))) }.b)
(( \f: Nat .((f ({a = ({a = ({a = (((\x: Nat .\y: Nat .y) false ) 1) , b = (unfold [ Nat ] (fold [ Unit ] true )) , c = (( \f: Rec X. X .((f (let u = true in 1) ) (((\x: Unit .\y: Rec X. X .y) true ) 0) ) ) (\a: Unit .\b: Nat .b)) }.c) , b = ({a = (if false then false else false) , b = 1 }.b) }.b) , b = ({a = (if false then true else false) , b = (let u = 1 in u) }.b) }.b) ) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (((\x: Nat .\y: Rec X. X .x) (if true then false else false) ) false) }.a) ) ) (\a: Nat .\b: Bool .b))
({a = ({a = ({a = (fix (\x: Bool . false )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .b)) }.b) , b = (fix (\x: Unit . ({a = ({a = 1 , b = false , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) , b = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .b)) )) }.a) )) }.b) , b = (if (if true then false else ({a = true , b = 1 }.a)) then (fix (\x: Rec X. X . (let u = (((\x: Bool .\y: Bool .x) false ) true) in (let u = 0 in u)) )) else (if true then (let u = 1 in u) else (let u = 0 in 0))) }.b)
(iszero (pred (( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = true , c = 1 }.c) )) ) (succ 1) ) ) (\a: Unit .\b: Bool .a))))
(if (if ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Nat .\y: Unit .x) ({a = true , b = true }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) }.b) then (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Bool .x) true ) false) )) )) else ({a = 0 , b = false , c =  1 }.b)) then (let u = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) in (let u = (fix (\x: Bool . 0 )) in ({a = true , b = 1 }.a))) in u) else (case <r = (let u = ({a = true , b = 0 }.a) in ({a = 0 , b = false , c =  1 }.b)) > as Unit of < l = x > => x | < r = y > => y))
(case <l = ({a = (((\x: Unit .\y: Unit .y) false ) 0) , b = (((\x: Rec X. X .\y: Nat .x) true ) true) , c = (fix (\x: Bool . (succ 0) )) }.c) > as Unit of < l = x > => x | < r = y > => y)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = ({a = ({a = 1 , b = true }.b) , b = ({a = 0 , b = false , c = 1 }.c) }.b) in u) ))
({a = (( \f: Unit .((f (let u = (((\x: Rec X. X .\y: Nat .y) ({a = 1 , b = true }.b) ) 0) in (((\x: Nat .\y: Bool .y) true ) 0)) ) (if (( \f: Bool .((f (iszero 0) ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) then ({a = false , b = 0 }.b) else (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Unit .y) false ) 0) ))) ) ) (\a: Nat .\b: Bool .a)) , b = (( \f: Rec X. X .((f (let u = (let u = true in 0) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) ) ({a = ({a = 0 , b = false }.b) , b = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) , c = (let u = (let u = (succ (if true then ({a = 1 , b = false }.a) else (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) in ({a = 0 , b = true , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.c)) in u) }.c)
(let u = (let u = (((\x: Nat .\y: Nat .x) 0 ) (let u = 1 in false)) in u) in u)
(pred (( \f: Rec X. X .((f (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (let u = 1 in (let u = false in 0)) else ({a = 1 , b = true }.a)) ) (((\x: Unit .\y: Rec X. X .y) (if false then false else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) }.a)) ) ) (\a: Rec X. X .\b: Unit .a)))
(let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) (( \f: Rec X. X .((f 0 ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Unit .a)) ) (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y)) ) ({a = ({a = 0 , b = true , c =  (((\x: Bool .\y: Rec X. X .x) 1 ) false) }.b) , b = (let u = (((\x: Unit .\y: Nat .y) true ) 0) in u) }.b) ) ) (\a: Bool .\b: Unit .a)) in (let u = (fix (\x: Bool . (succ 0) )) in u))
(unfold [ Unit ] (fold [ Bool ] (let u = (let u = ({a = false , b = 0 }.b) in ({a = false , b = 1 }.a)) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = (let u = (fix (\x: Unit . false )) in ({a = 0 , b = false }.b)) > as Bool of < l = x > => x | < r = y > => y) ))) ))
(case <r = (fix (\x: Rec X. X . (( \f: Nat .((f (let u = ({a = true , b = 0 }.a) in u) ) (fix (\x: Nat . ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) )) ) ) (\a: Nat .\b: Rec X. X .b)) )) > as Unit of < l = x > => x | < r = y > => y)
({a = (((\x: Nat .\y: Unit .y) (fix (\x: Unit . (( \f: Rec X. X .((f (let u = false in true) ) true ) ) (\a: Unit .\b: Unit .a)) )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in 0) ))) , b = (fix (\x: Unit . (let u = ({a = (let u = (fix (\x: Rec X. X . 0 )) in 1) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.b) in (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) ({a = false , b = 0 }.a) ) ) (\a: Bool .\b: Nat .a))) )) , c =  (case <l = (let u = ({a = 1 , b = true }.a) in (let u = 1 in u)) > as Nat of < l = x > => x | < r = y > => y) }.b)
(pred (succ ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = (((\x: Nat .\y: Nat .x) ({a = 1 , b = false }.b) ) false) }.a)))
({a = (if ({a = (let u = false in u) , b = (pred 1) }.a) then (let u = (case <r = (((\x: Nat .\y: Nat .y) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) in u) else (( \f: Unit .((f (let u = ({a = true , b = true }.b) in u) ) (((\x: Bool .\y: Bool .x) ({a = false , b = 1 }.a) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false ))) ) ) (\a: Rec X. X .\b: Unit .b))) , b = (let u = (fix (\x: Unit . (let u = true in false) )) in (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (unfold [ Bool ] (fold [ Nat ] 1 )) else (((\x: Rec X. X .\y: Unit .y) true ) ({a = true , b = 1 }.b)))) }.b)
(succ (pred (if true then ({a = 1 , b = 1 }.b) else (pred 1))))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = (case <r = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .a)) }.b) )) ))
(pred ({a = (let u = ({a = ({a = 1 , b = false }.a) , b = true }.b) in u) , b = (fix (\x: Bool . ({a = (let u = false in u) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.b) )) }.b))
({a = (let u = (fix (\x: Rec X. X . (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Unit .b)) )) in u) , b = (let u = (case <r = ({a = (fix (\x: Nat . false )) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) }.a) > as Nat of < l = x > => x | < r = y > => y) in (fix (\x: Bool . (let u = false in true) ))) , c = (succ (unfold [ Bool ] (fold [ Rec X. X ] (succ 0) ))) }.c)
(let u = (let u = (let u = (fix (\x: Nat . false )) in u) in (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Bool .y) false ) true) ) (( \f: Nat .((f ({a = 1 , b = false }.a) ) (let u = true in 0) ) ) (\a: Unit .\b: Nat .b)))) in (let u = ({a = ({a = 0 , b = true , c =  0 }.b) , b = ({a = 0 , b = false , c =  0 }.b) }.b) in u))
({a = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Bool . (( \f: Nat .((f false ) (let u = 1 in false) ) ) (\a: Bool .\b: Rec X. X .a)) )) )) , b = ({a = (case <r = (case <r = true > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . ({a = 0 , b = false , c =  0 }.b) )) }.b) }.b)
(((\x: Unit .\y: Bool .x) (if (fix (\x: Unit . ({a = 0 , b = true }.b) )) then (pred (((\x: Bool .\y: Rec X. X .x) 1 ) false)) else (let u = (if false then 1 else 1) in (let u = false in 1))) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Rec X. X .((f true ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .a)) )))
(case <l = (( \f: Rec X. X .((f ({a = (fix (\x: Rec X. X . 0 )) , b = (if (let u = true in false) then 0 else 1) }.b) ) (succ (((\x: Bool .\y: Bool .x) 0 ) false)) ) ) (\a: Rec X. X .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (unfold [ Bool ] (fold [ Nat ] (case <l = (fix (\x: Nat . 1 )) > as Unit of < l = x > => x | < r = y > => y) )) ))
(let u = (fix (\x: Unit . (((\x: Nat .\y: Unit .y) (let u = false in u) ) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) in u)) )) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) true) , b = true , c =  (let u = 1 in u) }.b) )))
(((\x: Rec X. X .\y: Nat .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) (if true then false else (unfold [ Bool ] (fold [ Unit ] true ))) ) ({a = false , b = (succ 1) }.a)) )) ) (let u = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Bool .y) true ) false) ) ({a = (if true then 1 else 0) , b = true , c =  0 }.b)) in u))
(((\x: Unit .\y: Unit .y) (fix (\x: Bool . (( \f: Unit .((f (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) (iszero 0) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) ) ({a = (let u = (let u = ({a = 1 , b = false , c = 0 }.c) in (((\x: Unit .\y: Bool .x) 0 ) false)) in u) , b = (((\x: Nat .\y: Bool .y) (if false then false else true) ) ({a = (let u = 1 in 1) , b = ({a = 0 , b = false }.b) }.b)) }.b))
(unfold [ Bool ] (fold [ Nat ] (case <r = (((\x: Unit .\y: Bool .y) (let u = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) in ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Rec X. X . true )) ))) ) ({a = (iszero 0) , b = true }.b)) > as Nat of < l = x > => x | < r = y > => y) ))
({a = ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] false )) in (((\x: Rec X. X .\y: Bool .y) false ) 0)) , b = (let u = ({a = true , b = 1 }.b) in u) }.b) , b = (let u = (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in 1) )) ) (case <l = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) in u) }.b)
({a = (let u = ({a = (pred 1) , b = (unfold [ Unit ] (fold [ Unit ] 0 )) }.b) in u) , b = (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f (pred (let u = 1 in u)) ) (let u = (let u = 1 in u) in u) ) ) (\a: Rec X. X .\b: Nat .a)) )) }.b)
({a = (if ({a = ({a = 0 , b = false , c =  0 }.b) , b = ({a = 0 , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) }.a) then (let u = (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) in u) else (let u = (let u = false in 1) in (case <r = (unfold [ Unit ] (fold [ Unit ] true )) > as Bool of < l = x > => x | < r = y > => y))) , b = (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Bool .y) (if (( \f: Rec X. X .((f (iszero 0) ) false ) ) (\a: Bool .\b: Bool .a)) then (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) else (((\x: Rec X. X .\y: Nat .x) (let u = 1 in true) ) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .b)))) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) (pred (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)))) }.a)
(let u = (((\x: Rec X. X .\y: Nat .x) (let u = false in ({a = false , b = 0 }.b)) ) (( \f: Bool .((f ({a = 1 , b = false }.b) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Rec X. X .b))) in ({a = (unfold [ Rec X. X ] (fold [ Nat ] (if false then true else false) )) , b = ({a = (if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) then (if true then 1 else 1) else (fix (\x: Unit . (pred 1) ))) , b = (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)) )) , c = (succ ({a = 0 , b = false }.a)) }.c) }.b))
(let u = (unfold [ Nat ] (fold [ Unit ] ({a = false , b = 0 }.b) )) in ({a = (succ (let u = 0 in u)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Unit . (if false then false else false) )) )) }.a))
(( \f: Nat .((f (succ (let u = ({a = false , b = 0 }.b) in u)) ) ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (let u = true in false) }.a) , b = (let u = (((\x: Nat .\y: Rec X. X .y) true ) true) in (((\x: Rec X. X .\y: Rec X. X .y) false ) false)) , c = (((\x: Unit .\y: Unit .y) (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) )) ) ({a = 0 , b = true , c = 0 }.c)) }.c) ) ) (\a: Rec X. X .\b: Nat .a))
(( \f: Bool .((f ({a = (if (((\x: Nat .\y: Unit .y) true ) true) then (let u = true in false) else true) , b = ({a = 1 , b = 1 }.b) }.a) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) true ) true) )) )) ) ) (\a: Unit .\b: Bool .b))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = (((\x: Unit .\y: Bool .y) true ) 1) }.a) ) (( \f: Bool .((f true ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Bool .a)) ))
({a = ({a = (pred (if true then 0 else 0)) , b = (((\x: Unit .\y: Bool .y) ({a = (let u = 0 in true) , b = (succ (((\x: Unit .\y: Unit .y) false ) 1)) }.a) ) (((\x: Unit .\y: Nat .x) false ) (unfold [ Nat ] (fold [ Bool ] false )))) , c = (succ (let u = 0 in 1)) }.c) , b = (case <r = (((\x: Bool .\y: Unit .x) (if true then false else false) ) false) > as Unit of < l = x > => x | < r = y > => y) }.a)
({a = (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Bool .y) ({a = 1 , b = true , c =  0 }.b) ) ({a = (succ 1) , b = ({a = 0 , b = true }.b) }.b)) ) ({a = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = true , c = 0 }.c) , b = (let u = false in false) , c =  ({a = 0 , b = true , c = 0 }.c) }.b)) , b = ({a = ({a = (iszero (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) in u) }.a) , b = (unfold [ Bool ] (fold [ Rec X. X ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) }.b) }.b)
(unfold [ Bool ] (fold [ Rec X. X ] (let u = (if (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .y) true ) true) )) in u) then ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (pred 1) )) else (succ (((\x: Bool .\y: Nat .y) false ) 0))) in (((\x: Unit .\y: Bool .x) ({a = (fix (\x: Nat . 1 )) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) ) (((\x: Bool .\y: Rec X. X .x) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Nat .\y: Nat .y) false ) true)))) ))
(fix (\x: Bool . (if ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = (((\x: Unit .\y: Nat .x) true ) true) }.b) then (iszero (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) else (let u = ({a = 1 , b = (unfold [ Bool ] (fold [ Unit ] true )) }.a) in (iszero 1))) ))
(let u = (unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f 1 ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Bool .b)) )) in u)
(unfold [ Unit ] (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = 1 , b = false }.b) }.a) )) ))
(iszero (let u = (((\x: Bool .\y: Unit .x) (pred 1) ) (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) true ) false) ) (iszero 0) ) ) (\a: Bool .\b: Rec X. X .b))) in (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) (pred 0) ) ) (\a: Bool .\b: Bool .a))))
({a = (((\x: Rec X. X .\y: Bool .x) (( \f: Rec X. X .((f false ) (let u = false in false) ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (if (let u = true in false) then true else true) }.b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = (let u = true in u) in (let u = 0 in u)) ) ({a = (let u = true in (((\x: Bool .\y: Bool .y) true ) 0)) , b = (((\x: Bool .\y: Unit .x) true ) true) }.b)) }.a)
(pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = (fix (\x: Rec X. X . false )) }.a) )))
(( \f: Nat .((f (unfold [ Bool ] (fold [ Bool ] (iszero (let u = 1 in u)) )) ) ({a = ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = (((\x: Bool .\y: Nat .x) false ) true) }.b) , b = (pred ({a = 0 , b = false , c = 1 }.c)) }.b) , b = (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = false , c =  0 }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
({a = (case <l = ({a = ({a = 1 , b = 1 }.b) , b = (let u = true in true) , c = ({a = (let u = true in 1) , b = ({a = true , b = (fix (\x: Rec X. X . 0 )) }.a) , c = (succ 1) }.c) }.c) > as Unit of < l = x > => x | < r = y > => y) , b = (iszero (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) (succ 1) ) (if false then true else false)) ) (let u = ({a = 0 , b = (pred 0) }.b) in u) ) ) (\a: Unit .\b: Rec X. X .b))) }.b)
(((\x: Nat .\y: Unit .y) ({a = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in u) )) in u) , b = (( \f: Bool .((f false ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) , c =  (((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a))) }.b) ) ({a = ({a = 0 , b = ({a = 1 , b = true , c = 0 }.c) }.b) , b = ({a = false , b = 1 }.a) }.a))
({a = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) ({a = ({a = false , b = false }.b) , b = 0 }.a) ) (let u = (if true then 0 else 0) in u)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Unit .b)) , b = (let u = (if false then true else ({a = 0 , b = false }.b)) in ({a = ({a = (let u = true in 1) , b = true }.b) , b = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b)) }.b)) , c = (((\x: Nat .\y: Bool .x) (((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .x) 1 ) true) ) ({a = 0 , b = true , c =  1 }.b)) ) (let u = (unfold [ Bool ] (fold [ Bool ] 1 )) in ({a = (((\x: Rec X. X .\y: Nat .y) true ) true) , b = 0 }.a))) }.c)
({a = (unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Unit .\y: Nat .x) 1 ) true) }.b) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) , b = ({a = (fix (\x: Nat . (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) , b = (fix (\x: Bool . (( \f: Rec X. X .((f (( \f: Unit .((f ({a = true , b = 1 }.a) ) false ) ) (\a: Unit .\b: Bool .b)) ) (fix (\x: Bool . false )) ) ) (\a: Bool .\b: Unit .a)) )) , c = ({a = ({a = 0 , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) , c = 0 }.c) , b = (iszero 1) , c = ({a = 0 , b = false }.a) }.c) }.c) }.b)
({a = ({a = (let u = (iszero 0) in (((\x: Bool .\y: Bool .y) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) (if false then 0 else 1))) , b = (((\x: Nat .\y: Bool .y) (iszero ({a = 0 , b = true , c = 0 }.c)) ) (if (fix (\x: Unit . false )) then (((\x: Rec X. X .\y: Bool .x) false ) false) else true)) , c =  (case <l = (((\x: Nat .\y: Bool .y) (let u = true in u) ) 0) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (succ (((\x: Bool .\y: Nat .x) ({a = (( \f: Nat .((f 1 ) (if false then 1 else 0) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = 1 , b = false }.b) }.a) ) (( \f: Nat .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (iszero 0) ) ) (\a: Nat .\b: Nat .b)))) }.b)
(let u = (((\x: Unit .\y: Unit .x) (let u = (let u = false in 1) in ({a = true , b = 0 }.b)) ) (case <r = (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) true ) true) )) > as Bool of < l = x > => x | < r = y > => y)) in u)
(case <l = (if ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = (((\x: Unit .\y: Unit .y) false ) false) }.b) then (( \f: Bool .((f (succ 1) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) else (if ({a = false , b = false }.b) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) else (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Unit ] 1 )) )))) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Bool .((f ({a = ({a = 0 , b = true , c =  (((\x: Rec X. X .\y: Nat .x) 0 ) true) }.b) , b = (pred 1) }.b) ) (( \f: Nat .((f (if (unfold [ Bool ] (fold [ Unit ] true )) then (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = 0 }.b) )) else (let u = 1 in ({a = 1 , b = 1 }.b))) ) (((\x: Nat .\y: Unit .x) (case <l = ({a = 0 , b = false }.a) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (((\x: Unit .\y: Bool .x) true ) false) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.a)) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Rec X. X .b))
(fix (\x: Rec X. X . ({a = ({a = (((\x: Unit .\y: Unit .y) true ) 1) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (((\x: Nat .\y: Rec X. X .y) ({a = (iszero 1) , b = (let u = 0 in u) }.a) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = 0 , b = true , c =  1 }.b) ))) , c = (succ (let u = false in 1)) }.c) ))
(let u = ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = (let u = (let u = false in 0) in false) }.b) in ({a = ({a = ({a = 0 , b = true , c =  0 }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] true )) }.b) , b = ({a = (((\x: Unit .\y: Rec X. X .y) true ) 0) , b = (iszero 0) }.b) }.b))
(unfold [ Unit ] (fold [ Nat ] (let u = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a))) , c = (let u = 1 in 1) }.c) in (((\x: Bool .\y: Nat .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ({a = false , b = 0 }.a))) ))
(((\x: Unit .\y: Nat .y) (let u = (case <l = (fix (\x: Bool . 0 )) > as Bool of < l = x > => x | < r = y > => y) in ({a = (let u = (let u = 1 in u) in (succ 0)) , b = (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = true , b = true }.b) ) (fix (\x: Nat . true )) ) ) (\a: Nat .\b: Rec X. X .a)) )) , c =  (fix (\x: Rec X. X . (succ (((\x: Bool .\y: Bool .x) 1 ) false)) )) }.b)) ) (iszero (unfold [ Unit ] (fold [ Bool ] (pred ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] 1 )) ))) ))))
(((\x: Bool .\y: Nat .y) (fix (\x: Unit . (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Nat .y) true ) false) ) (( \f: Rec X. X .((f (let u = false in false) ) ({a = 0 , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .a))) )) ) ({a = (let u = false in u) , b = (((\x: Unit .\y: Bool .x) (fix (\x: Bool . 1 )) ) ({a = true , b = false }.b)) }.a))
(pred (if ({a = false , b = 0 }.a) then (pred (let u = 0 in u)) else (((\x: Unit .\y: Nat .y) (let u = (fix (\x: Bool . 0 )) in (iszero 0)) ) (((\x: Bool .\y: Unit .y) false ) 1))))
(case <r = (case <r = (((\x: Unit .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ({a = 0 , b = true }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Rec X. X ] (succ (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ))) ))
({a = (let u = (succ (fix (\x: Unit . (((\x: Unit .\y: Unit .x) 1 ) true) ))) in (case <r = (let u = ({a = false , b = true }.b) in u) > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (((\x: Bool .\y: Bool .y) false ) false) , c = (((\x: Nat .\y: Nat .x) 1 ) true) }.c) , b = ({a = true , b = (((\x: Rec X. X .\y: Unit .x) true ) false) }.b) , c = (( \f: Nat .((f (((\x: Unit .\y: Unit .x) 0 ) true) ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.c) }.a)
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .x) (let u = true in true) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true ))) )) , b = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Nat .\y: Nat .y) (fix (\x: Nat . true )) ) (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) )) , b = (let u = (let u = 0 in u) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) , c = (( \f: Unit .((f (case <l = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .y) true ) (if true then 0 else 0)) ) ) (\a: Unit .\b: Rec X. X .b)) }.c) }.a)
(case <l = ({a = (if ({a = 1 , b = true , c =  0 }.b) then (fix (\x: Unit . 1 )) else (((\x: Unit .\y: Rec X. X .x) 1 ) true)) , b = ({a = ({a = false , b = true }.b) , b = ({a = 0 , b = false }.b) }.b) , c = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (let u = true in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false ))) , c = (succ 0) }.c) }.c) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (((\x: Rec X. X .\y: Nat .y) (let u = (fix (\x: Bool . (let u = 1 in 1) )) in (fix (\x: Rec X. X . true ))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f true ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ))) , b = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] (let u = 1 in u) )) ) (let u = false in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Nat .b)) }.b) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = (let u = 0 in u) in ({a = 1 , b = 1 }.b)) )) }.b)
(let u = (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] 1 )) ))) in (case <l = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = (fix (\x: Rec X. X . 1 )) }.b) > as Nat of < l = x > => x | < r = y > => y))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f (let u = (let u = true in 0) in (let u = false in u)) ) (let u = 1 in false) ) ) (\a: Unit .\b: Unit .b)) ))
(let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (pred (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a))) , b = ({a = (iszero ({a = 1 , b = 0 }.b)) , b = (let u = 0 in 1) }.a) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (if false then 1 else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) )) }.c) )) in (let u = (iszero (if true then 0 else 0)) in (( \f: Unit .((f (fix (\x: Nat . true )) ) (((\x: Unit .\y: Unit .x) false ) true) ) ) (\a: Unit .\b: Nat .a))))
(let u = (succ (if (iszero 1) then (let u = false in 1) else (let u = 0 in 0))) in (case <r = (((\x: Bool .\y: Bool .x) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) (fix (\x: Unit . (let u = true in true) ))) > as Unit of < l = x > => x | < r = y > => y))
(unfold [ Bool ] (fold [ Bool ] (let u = (let u = (pred 0) in ({a = 0 , b = 0 }.b)) in (if (if false then true else false) then ({a = 1 , b = ({a = 0 , b = true , c =  0 }.b) }.b) else (let u = true in u))) ))
(case <l = (fix (\x: Unit . ({a = (unfold [ Nat ] (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] 1 )) )) , b = (let u = 1 in false) }.a) )) > as Nat of < l = x > => x | < r = y > => y)
(if (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .b)) )) > as Bool of < l = x > => x | < r = y > => y) then (fix (\x: Unit . (iszero (if true then 1 else 0)) )) else ({a = ({a = (((\x: Bool .\y: Nat .x) (( \f: Bool .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) 1 ) ) (\a: Bool .\b: Bool .b)) ) ({a = (iszero 0) , b = ({a = true , b = 0 }.b) }.a)) , b = (pred (let u = true in 1)) }.b) , b = (case <r = (((\x: Rec X. X .\y: Nat .y) ({a = true , b = true }.b) ) false) > as Nat of < l = x > => x | < r = y > => y) , c =  (pred (fix (\x: Nat . 0 ))) }.b))
({a = ({a = ({a = (( \f: Bool .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (iszero 1) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (((\x: Bool .\y: Nat .y) ({a = 0 , b = false }.b) ) ({a = 1 , b = true }.b)) }.b) , b = ({a = (if true then 0 else ({a = 0 , b = false , c = 0 }.c)) , b = ({a = true , b = false }.b) , c = (((\x: Rec X. X .\y: Nat .y) true ) 1) }.c) }.a) , b = (if (if ({a = (if true then 1 else 0) , b = (let u = 1 in true) , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) then (iszero (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) else ({a = true , b = true }.b)) then (( \f: Nat .((f (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) false ) ) (\a: Rec X. X .\b: Unit .b)) else ({a = ({a = true , b = 0 }.a) , b = (succ 1) }.a)) }.b)
(let u = (let u = ({a = (case <l = ({a = 1 , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (if true then false else true) ) false ) ) (\a: Bool .\b: Unit .a)) , c = (unfold [ Nat ] (fold [ Nat ] (fix (\x: Nat . 1 )) )) }.c) in ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))) in u)
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .y) ({a = (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = false }.a) ) ({a = true , b = 1 }.a)) , b = (let u = (fix (\x: Bool . 1 )) in (((\x: Nat .\y: Bool .x) true ) false)) }.b) ) ({a = ({a = 0 , b = ({a = 0 , b = true , c =  0 }.b) }.a) , b = (if true then true else true) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) ))
(let u = ({a = (let u = ({a = true , b = 0 }.a) in u) , b = ({a = 0 , b = false , c = 0 }.c) }.a) in (fix (\x: Bool . (let u = ({a = false , b = 1 }.a) in (if false then 1 else 1)) )))
(case <l = (if ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .a)) )) )) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = (fix (\x: Nat . 0 )) }.b) )) else (( \f: Rec X. X .((f ({a = (((\x: Rec X. X .\y: Nat .y) true ) false) , b = 1 }.b) ) (if false then 1 else (let u = 1 in u)) ) ) (\a: Unit .\b: Unit .a))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (fix (\x: Rec X. X . (fix (\x: Bool . (let u = false in false) )) )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .x) false ) false) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b))) )))
({a = (((\x: Unit .\y: Bool .y) (unfold [ Nat ] (fold [ Bool ] ({a = ({a = true , b = 1 }.a) , b = false }.b) )) ) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Rec X. X .x) false ) true) }.a)) , b = (( \f: Bool .((f (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = false , b = 1 }.b) )) in (case <r = (let u = 0 in true) > as Unit of < l = x > => x | < r = y > => y)) ) (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Bool .a)) }.b)
(( \f: Unit .((f (let u = (let u = (succ ({a = true , b = 1 }.b)) in (let u = true in (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)))) in (succ ({a = 1 , b = true }.a))) ) ({a = (let u = (((\x: Bool .\y: Rec X. X .y) true ) 0) in (if (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) then true else (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .a)))) , b = (succ ({a = 1 , b = false , c = 1 }.c)) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (let u = (( \f: Bool .((f (((\x: Nat .\y: Bool .y) true ) 0) ) (pred (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a))) ) ) (\a: Rec X. X .\b: Bool .b)) in (if ({a = true , b = 1 }.a) then ({a = 0 , b = 0 }.b) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y))) in ({a = (case <l = (let u = ({a = true , b = 0 }.a) in 1) > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = false }.b) )) , c =  (fix (\x: Nat . ({a = (if true then 0 else 1) , b = 1 }.b) )) }.b))
({a = (let u = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Bool ] true )) ) (fix (\x: Rec X. X . false )) ) ) (\a: Bool .\b: Unit .a)) in (( \f: Bool .((f ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Bool .b))) , b = (((\x: Unit .\y: Bool .y) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = false , c =  (pred 1) }.b) }.a)) }.a)
(( \f: Bool .((f (fix (\x: Nat . ({a = (unfold [ Nat ] (fold [ Rec X. X ] true )) , b = (( \f: Unit .((f ({a = 0 , b = 0 }.b) ) 1 ) ) (\a: Nat .\b: Bool .a)) }.a) )) ) (iszero (( \f: Unit .((f (pred 0) ) ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = false in false) , c = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.c) ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Bool .\b: Rec X. X .a))
({a = (let u = (( \f: Bool .((f ({a = 1 , b = false , c = 0 }.c) ) (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Nat .b)) in u) , b = (let u = (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .x) false ) false) ) (let u = 1 in u)) ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Rec X. X .b)) in ({a = (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = (if (let u = false in false) then ({a = 1 , b = true }.a) else ({a = true , b = ({a = 0 , b = 1 }.b) }.b)) }.a)) }.a)
(( \f: Nat .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = (unfold [ Unit ] (fold [ Rec X. X ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) in ({a = (((\x: Nat .\y: Bool .x) 0 ) false) , b = ({a = 1 , b = true , c = 1 }.c) }.b)) )) ) (let u = ({a = (( \f: Rec X. X .((f (pred 0) ) (((\x: Rec X. X .\y: Unit .y) true ) 1) ) ) (\a: Unit .\b: Unit .a)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.b) in ({a = (( \f: Unit .((f ({a = 0 , b = false }.a) ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (fix (\x: Rec X. X . true )) , c = (let u = (pred 0) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (if false then 1 else 1) ))) }.c)) ) ) (\a: Rec X. X .\b: Nat .a))
(let u = (( \f: Bool .((f (fix (\x: Unit . (((\x: Nat .\y: Rec X. X .y) false ) 1) )) ) ({a = ({a = 0 , b = true , c = 0 }.c) , b = ({a = false , b = 0 }.a) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (case <r = (( \f: Nat .((f false ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y))
({a = (let u = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) }.a) in (fix (\x: Rec X. X . ({a = 1 , b = ({a = true , b = 0 }.b) }.b) ))) , b = (if (((\x: Bool .\y: Rec X. X .y) (let u = true in false) ) (if false then false else true)) then (fix (\x: Bool . ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = true }.b) )) else (let u = (if false then false else false) in u)) , c = ({a = (fix (\x: Nat . (((\x: Nat .\y: Unit .y) true ) 0) )) , b = ({a = ({a = 1 , b = true , c =  (fix (\x: Bool . 1 )) }.b) , b = (iszero (let u = 1 in u)) }.b) }.a) }.c)
({a = (( \f: Bool .((f (( \f: Rec X. X .((f (iszero 1) ) true ) ) (\a: Nat .\b: Nat .b)) ) (unfold [ Nat ] (fold [ Unit ] (let u = 0 in false) )) ) ) (\a: Unit .\b: Bool .a)) , b = (if (( \f: Bool .((f false ) (if false then false else true) ) ) (\a: Unit .\b: Nat .a)) then (let u = 0 in ({a = 0 , b = false , c = 1 }.c)) else (((\x: Unit .\y: Rec X. X .x) 0 ) false)) }.a)
(unfold [ Bool ] (fold [ Nat ] ({a = (let u = ({a = true , b = 1 }.a) in (succ ({a = 0 , b = 1 }.b))) , b = (unfold [ Bool ] (fold [ Unit ] ({a = false , b = false }.b) )) }.b) ))
({a = (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = false }.b) ) (((\x: Bool .\y: Rec X. X .x) ({a = false , b = 1 }.a) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y))) , b = (let u = (let u = (let u = true in u) in u) in ({a = ({a = (((\x: Rec X. X .\y: Nat .x) true ) true) , b = (((\x: Bool .\y: Bool .y) ({a = true , b = 1 }.a) ) false) }.b) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)) }.a)
(case <l = (( \f: Nat .((f ({a = (( \f: Bool .((f (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = (succ 0) , b = 1 }.b) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = ({a = 0 , b = ({a = 0 , b = true }.b) , c = 1 }.c) in (let u = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .b)) in (pred 0))) }.b) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = (if true then 1 else 1) , b = (let u = false in false) }.a) )) ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = (succ ({a = true , b = 1 }.b)) , b = ({a = (((\x: Bool .\y: Bool .x) 0 ) true) , b = (fix (\x: Rec X. X . false )) }.b) }.a) in (( \f: Rec X. X .((f (let u = (fix (\x: Rec X. X . 1 )) in ({a = (fix (\x: Bool . 1 )) , b = (let u = false in u) , c =  1 }.b)) ) ({a = (if false then 0 else 0) , b = (((\x: Unit .\y: Nat .y) (let u = false in u) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.b) ) ) (\a: Bool .\b: Rec X. X .b)))
(( \f: Unit .((f (((\x: Nat .\y: Unit .y) (iszero (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a))) ) ({a = true , b = (let u = false in true) }.b)) ) (((\x: Rec X. X .\y: Unit .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) )) )) ) (iszero (let u = true in 0))) ) ) (\a: Unit .\b: Nat .b))
(( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] ({a = (let u = ({a = 1 , b = 0 }.b) in u) , b = (unfold [ Bool ] (fold [ Unit ] (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) else true) )) }.b) )) ) (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) (iszero 0) ) (let u = false in true)) ) ({a = (if ({a = 0 , b = true , c =  0 }.b) then 1 else (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b))) , b = (iszero (if false then 1 else 0)) }.b)) ) ) (\a: Unit .\b: Unit .b))
(let u = (pred (unfold [ Bool ] (fold [ Nat ] ({a = true , b = 0 }.b) ))) in (((\x: Nat .\y: Rec X. X .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = ({a = (pred 1) , b = (let u = true in false) }.b) }.b) )) ) (if (let u = ({a = 0 , b = false }.b) in u) then (case <r = ({a = false , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) else (case <r = (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) false) > as Bool of < l = x > => x | < r = y > => y))))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (( \f: Unit .((f (let u = (let u = false in u) in u) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Nat .\y: Unit .y) (iszero ({a = false , b = 1 }.b)) ) (fix (\x: Nat . 1 ))) }.b) ))
(((\x: Rec X. X .\y: Nat .y) ({a = ({a = (((\x: Unit .\y: Unit .y) true ) 1) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) , b = (if (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .b)) then (((\x: Unit .\y: Nat .y) false ) true) else (iszero 0)) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) (let u = (( \f: Unit .((f (let u = false in u) ) (let u = false in true) ) ) (\a: Nat .\b: Unit .a)) in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .a)) ))))
({a = (case <r = (iszero (((\x: Nat .\y: Unit .y) false ) 1)) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) (iszero 0) ) false) ) ({a = (((\x: Bool .\y: Unit .x) 1 ) false) , b = false , c = (fix (\x: Rec X. X . 1 )) }.c)) in (fix (\x: Nat . (fix (\x: Bool . false )) ))) }.b)
({a = ({a = (let u = (succ 1) in (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b))) , b = ({a = (pred 0) , b = (fix (\x: Nat . 0 )) }.b) }.b) , b = (( \f: Unit .((f (case <r = (let u = 0 in ({a = true , b = 0 }.a)) > as Nat of < l = x > => x | < r = y > => y) ) (case <r = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) }.a)
(fix (\x: Unit . ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) , b = 1 }.a) , b = (fix (\x: Rec X. X . false )) }.b) )) ))
({a = (succ ({a = (succ 1) , b = (( \f: Bool .((f ({a = 0 , b = true }.b) ) true ) ) (\a: Unit .\b: Rec X. X .b)) }.a)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = ({a = 1 , b = true , c = 0 }.c) in (fix (\x: Bool . 0 ))) , b = ({a = (succ 1) , b = ({a = 1 , b = false }.b) }.b) , c = (let u = 1 in u) }.c) )) }.b)
(( \f: Unit .((f (let u = (let u = (let u = ({a = 1 , b = 1 }.b) in (let u = 0 in 1)) in (((\x: Bool .\y: Bool .y) (iszero 0) ) true)) in u) ) ({a = (if (let u = ({a = 0 , b = true , c =  1 }.b) in (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) then ({a = ({a = 1 , b = 1 }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) )) }.a) else (let u = ({a = true , b = 0 }.a) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )))) , b = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) (unfold [ Nat ] (fold [ Nat ] true )) ) true) )) , c =  (unfold [ Nat ] (fold [ Nat ] (pred (pred 0)) )) }.b) ) ) (\a: Bool .\b: Bool .a))
(( \f: Rec X. X .((f (fix (\x: Unit . (iszero (((\x: Unit .\y: Nat .y) true ) 1)) )) ) (let u = (let u = (let u = (unfold [ Bool ] (fold [ Rec X. X ] false )) in false) in u) in u) ) ) (\a: Bool .\b: Nat .a))
(let u = (( \f: Rec X. X .((f (let u = (let u = true in 1) in (let u = ({a = 0 , b = true }.b) in 1)) ) (let u = (((\x: Rec X. X .\y: Bool .x) (succ 1) ) (((\x: Nat .\y: Nat .y) false ) true)) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (succ 1) ))) ) ) (\a: Nat .\b: Nat .a)) in ({a = (case <r = ({a = (let u = true in u) , b = ({a = 0 , b = 1 }.b) }.a) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (if (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .a)) then 0 else ({a = true , b = 1 }.b)) , b = (let u = false in u) , c = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c) }.a))
(fix (\x: Bool . (succ (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y)) ))
(let u = (((\x: Nat .\y: Unit .y) (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Unit .x) true ) true) )) ) ({a = 1 , b = 0 }.b)) in (( \f: Unit .((f ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) true ) true) }.b) ) (fix (\x: Rec X. X . (iszero (succ 1)) )) ) ) (\a: Nat .\b: Unit .b)))
({a = (pred (( \f: Bool .((f ({a = 0 , b = (if true then false else false) , c = 0 }.c) ) (pred 0) ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = ({a = ({a = false , b = (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.b) , b = (fix (\x: Unit . false )) , c = (succ 1) }.c) , b = (fix (\x: Unit . ({a = 1 , b = false }.b) )) , c =  ({a = (unfold [ Unit ] (fold [ Bool ] true )) , b = (let u = (((\x: Rec X. X .\y: Nat .x) 1 ) false) in u) }.b) }.b) , c = ({a = (pred ({a = ({a = true , b = 0 }.b) , b = 1 }.b)) , b = (let u = (unfold [ Nat ] (fold [ Nat ] 1 )) in 1) }.b) }.c)
(let u = (iszero (((\x: Nat .\y: Rec X. X .y) ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)))) in ({a = ({a = true , b = ({a = 1 , b = false , c = 1 }.c) }.b) , b = ({a = 0 , b = (let u = 0 in false) , c =  (unfold [ Bool ] (fold [ Unit ] 1 )) }.b) , c =  (((\x: Nat .\y: Bool .y) (let u = true in u) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b))) }.b))
(let u = (fix (\x: Bool . ({a = (iszero 1) , b = 0 }.b) )) in (( \f: Rec X. X .((f ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) in u) , b = ({a = false , b = 0 }.a) , c = (fix (\x: Bool . 1 )) }.c) ) (if (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) then (fix (\x: Nat . 1 )) else 0) ) ) (\a: Unit .\b: Rec X. X .a)))
(((\x: Unit .\y: Nat .y) ({a = (unfold [ Nat ] (fold [ Bool ] ({a = 1 , b = false }.b) )) , b = (fix (\x: Bool . (fix (\x: Nat . 1 )) )) }.a) ) (if (unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) false ) true) )) then ({a = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in u) }.a) , b = (((\x: Nat .\y: Rec X. X .x) false ) true) }.b) else (let u = (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) (let u = true in u) ) ({a = false , b = 1 }.a)) ) ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = 0 }.a)) in (let u = (if (fix (\x: Unit . false )) then ({a = true , b = 0 }.a) else ({a = 0 , b = true , c =  1 }.b)) in (let u = false in u)))))
(case <l = ({a = (if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) then (let u = (let u = 0 in 1) in 1) else (let u = 1 in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )))) , b = (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .y) true ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) (unfold [ Unit ] (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Bool .a)) , c = (let u = (let u = true in ({a = 0 , b = true }.a)) in u) }.c) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (case <l = (let u = (((\x: Rec X. X .\y: Rec X. X .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 0)) in u) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in u) , c =  (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ))) }.b)
(fix (\x: Bool . (( \f: Nat .((f (( \f: Nat .((f (let u = (let u = false in 1) in false) ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .a)) ) (if ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = true }.b) then ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = false , c =  (((\x: Unit .\y: Unit .y) false ) 0) }.b) else ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) , c =  (pred 1) }.b)) ) ) (\a: Nat .\b: Unit .a)) ))
({a = (( \f: Bool .((f ({a = (iszero 1) , b = 0 }.a) ) ({a = (fix (\x: Rec X. X . true )) , b = ({a = false , b = false }.b) }.b) ) ) (\a: Nat .\b: Bool .a)) , b = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Bool . true )) ) true) }.a) }.b)
(( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (( \f: Nat .((f (let u = 0 in u) ) (( \f: Unit .((f 0 ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .a)) )) ) ({a = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) then (fix (\x: Unit . 1 )) else (let u = false in 0)) , b = (( \f: Unit .((f false ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Nat .b)) , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 1 , b = 1 }.b) )) }.c) ) ) (\a: Bool .\b: Bool .a))
(unfold [ Rec X. X ] (fold [ Bool ] (if (( \f: Unit .((f ({a = true , b = false }.b) ) (let u = (let u = true in true) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (( \f: Nat .((f ({a = 0 , b = false }.a) ) (unfold [ Unit ] (fold [ Bool ] 1 )) ) ) (\a: Rec X. X .\b: Bool .b)) else ({a = (fix (\x: Bool . (if true then 0 else 0) )) , b = (( \f: Rec X. X .((f ({a = 0 , b = false , c =  1 }.b) ) false ) ) (\a: Bool .\b: Rec X. X .b)) , c = (if (iszero 1) then (let u = 0 in u) else (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.c)) ))
(case <r = (( \f: Nat .((f (unfold [ Bool ] (fold [ Bool ] ({a = ({a = 0 , b = true }.b) , b = (((\x: Nat .\y: Rec X. X .y) false ) false) }.b) )) ) ({a = ({a = 0 , b = false , c = 0 }.c) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y)
(pred (let u = (((\x: Unit .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Nat ] false )) ) (case <l = (((\x: Bool .\y: Unit .y) true ) 1) > as Bool of < l = x > => x | < r = y > => y)) in ({a = (( \f: Unit .((f ({a = true , b = 0 }.b) ) (fix (\x: Nat . 0 )) ) ) (\a: Nat .\b: Unit .b)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (let u = true in 0) )) }.b)))
({a = (fix (\x: Nat . (fix (\x: Nat . (succ 1) )) )) , b = (unfold [ Rec X. X ] (fold [ Unit ] (if (((\x: Unit .\y: Unit .y) true ) true) then (let u = 0 in false) else (fix (\x: Unit . false ))) )) }.a)
({a = (let u = ({a = (((\x: Bool .\y: Rec X. X .y) ({a = true , b = false }.b) ) false) , b = ({a = 1 , b = false }.a) }.a) in u) , b = (succ (fix (\x: Rec X. X . 1 ))) }.b)
(if (fix (\x: Unit . ({a = (if false then 0 else 0) , b = (fix (\x: Bool . true )) }.b) )) then (let u = (( \f: Nat .((f true ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Nat .\b: Unit .b)) in (case <r = (let u = 1 in true) > as Bool of < l = x > => x | < r = y > => y)) else (fix (\x: Unit . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) )) )))
(((\x: Unit .\y: Unit .y) (( \f: Bool .((f ({a = (iszero 0) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) }.a) ) (case <r = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) ) (pred (fix (\x: Bool . (unfold [ Bool ] (fold [ Nat ] (( \f: Bool .((f 0 ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .b)) )) ))))
(( \f: Bool .((f ({a = (let u = (let u = false in u) in (unfold [ Unit ] (fold [ Bool ] 1 ))) , b = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (fix (\x: Bool . 1 )) else (if false then 0 else 0)) }.b) ) ({a = (((\x: Bool .\y: Nat .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) (unfold [ Nat ] (fold [ Nat ] (let u = 0 in 1) ))) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = (if false then true else true) , c =  (let u = 0 in u) }.b) , c = (fix (\x: Nat . (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) )) }.c) ) ) (\a: Nat .\b: Nat .a))
(let u = (let u = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Nat .x) (let u = 1 in u) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a))) )) in u) in (fix (\x: Bool . (if (let u = ({a = 1 , b = true }.a) in ({a = ({a = true , b = 0 }.b) , b = (let u = 0 in false) }.b)) then (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) else ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (let u = (unfold [ Bool ] (fold [ Bool ] 1 )) in 1) }.b)) )))
(((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Rec X. X .x) (if (if false then true else false) then ({a = 1 , b = false , c =  (fix (\x: Unit . 1 )) }.b) else (unfold [ Rec X. X ] (fold [ Unit ] true ))) ) (let u = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then false else true) in (unfold [ Unit ] (fold [ Bool ] (fix (\x: Rec X. X . false )) )))) ) (succ (pred (let u = (if (if true then true else true) then true else true) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 ))))))
(let u = (((\x: Bool .\y: Rec X. X .y) (iszero (let u = (let u = 0 in u) in 0)) ) ({a = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (if false then 1 else 0) else 0) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b)) in ({a = (let u = (succ 0) in ({a = (((\x: Nat .\y: Bool .y) true ) 1) , b = true , c =  1 }.b)) , b = (let u = true in 1) }.b))
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Rec X. X . (((\x: Unit .\y: Bool .y) (let u = false in false) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) )) ))
({a = (let u = ({a = (let u = 1 in u) , b = (let u = (let u = false in 0) in (fix (\x: Bool . false ))) , c = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = false }.a) }.c) in ({a = ({a = 0 , b = (iszero 1) , c =  (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = 1 in u) )) }.b)) , b = (((\x: Bool .\y: Unit .x) (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .x) false ) true) ) (unfold [ Nat ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = true }.b)) , c = (succ (((\x: Bool .\y: Nat .y) (case <r = (let u = 1 in false) > as Bool of < l = x > => x | < r = y > => y) ) ({a = 1 , b = 1 }.b))) }.c)
(((\x: Unit .\y: Nat .y) (if (let u = (unfold [ Nat ] (fold [ Rec X. X ] false )) in u) then ({a = (iszero 0) , b = (let u = 0 in true) }.b) else (let u = (let u = true in true) in u)) ) (let u = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) in false) , c =  ({a = 0 , b = true , c = 1 }.c) }.b) in (( \f: Bool .((f ({a = 0 , b = true }.b) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Rec X. X .\b: Bool .b))))
(if (iszero ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (let u = 1 in u) ))) then (let u = (let u = (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 0) > as Bool of < l = x > => x | < r = y > => y) in u) in ({a = (let u = (((\x: Rec X. X .\y: Bool .y) true ) 1) in u) , b = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 1 in u) }.b) }.b)) else (((\x: Bool .\y: Unit .x) ({a = ({a = ({a = 0 , b = true }.a) , b = 1 }.b) , b = (( \f: Rec X. X .((f (iszero 0) ) (let u = true in u) ) ) (\a: Rec X. X .\b: Bool .a)) }.a) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = false in false) )) in u)))
(let u = (let u = ({a = (case <l = ({a = false , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (let u = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in true) , b = (if false then 1 else 1) }.a) }.b) in u) in u)
(fix (\x: Bool . ({a = ({a = (succ (((\x: Rec X. X .\y: Bool .x) 0 ) false)) , b = (let u = true in u) , c = ({a = 1 , b = 0 }.b) }.c) , b = ({a = (pred 0) , b = (let u = true in u) }.a) }.b) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .y) ({a = (unfold [ Nat ] (fold [ Bool ] true )) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) }.a) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) in true)) ))
({a = (( \f: Rec X. X .((f ({a = ({a = 0 , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) }.b) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.a) ) ({a = (iszero (pred 1)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = true , b = 1 }.b) )) }.b) ) ) (\a: Unit .\b: Unit .a)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (iszero 1) )) }.a)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = (let u = (fix (\x: Nat . false )) in (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .x) 1 ) true) ))) , b = (((\x: Rec X. X .\y: Unit .x) true ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) , c =  (let u = (pred 0) in (if true then ({a = 1 , b = true , c = 1 }.c) else 0)) }.b) , b = (pred (let u = 0 in 1)) }.a) ))
(( \f: Rec X. X .((f ({a = ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) false ) false) }.a) , b = (( \f: Nat .((f ({a = false , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) ) (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .x) ({a = ({a = false , b = 0 }.b) , b = (let u = true in false) }.a) ) ({a = 0 , b = false , c =  0 }.b)) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) ) (let u = (let u = true in true) in u)) ) ) (\a: Bool .\b: Nat .a))
(((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Unit .y) (if (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b)) then (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) else ({a = true , b = false }.b)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Bool .\b: Unit .b)) ))) ) (( \f: Bool .((f ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in 0) }.a) ) (( \f: Bool .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
({a = (let u = (let u = (if false then true else false) in u) in (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Bool .x) (if false then false else false) ) true) ) (unfold [ Rec X. X ] (fold [ Bool ] 0 )))) , b = (( \f: Bool .((f (fix (\x: Nat . ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = (unfold [ Bool ] (fold [ Unit ] false )) }.b) )) ) (((\x: Nat .\y: Bool .x) (iszero 0) ) (let u = false in u)) ) ) (\a: Nat .\b: Unit .b)) , c = (if (( \f: Unit .((f ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .a)) }.b) ) ({a = 1 , b = false }.b) ) ) (\a: Bool .\b: Bool .a)) then ({a = (succ (pred 0)) , b = (((\x: Bool .\y: Nat .x) ({a = (if false then false else true) , b = 1 }.a) ) (fix (\x: Rec X. X . (iszero 0) ))) , c = (((\x: Rec X. X .\y: Bool .x) (succ 1) ) ({a = 0 , b = false }.b)) }.c) else (let u = (succ ({a = 0 , b = true , c = 1 }.c)) in ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = (let u = false in 0) }.b))) }.c)
(unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f ({a = false , b = 0 }.a) ) (if true then true else (if true then true else true)) ) ) (\a: Nat .\b: Nat .b)) ))
(let u = (( \f: Bool .((f ({a = (let u = (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Unit .a)) in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) , b = (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .x) true ) true) ) (case <r = ({a = 1 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) , c =  (let u = ({a = ({a = false , b = 0 }.b) , b = 1 }.b) in u) }.b) ) ({a = (fix (\x: Nat . 1 )) , b = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = false , c =  (succ 0) }.b) }.b) ) ) (\a: Unit .\b: Unit .a)) in (let u = (let u = (fix (\x: Rec X. X . 0 )) in (((\x: Rec X. X .\y: Nat .y) true ) false)) in (((\x: Bool .\y: Rec X. X .y) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Nat .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) (unfold [ Bool ] (fold [ Nat ] true ))) }.b) ) (let u = (let u = 1 in true) in u))))
(((\x: Bool .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Nat ] (case <r = (let u = 0 in (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b))) > as Nat of < l = x > => x | < r = y > => y) )) ) (if (case <r = (fix (\x: Unit . false )) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = (unfold [ Nat ] (fold [ Bool ] (if false then (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) else (let u = false in 0)) )) in ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = true in u) , c =  ({a = 1 , b = false }.a) }.b)) else (((\x: Unit .\y: Nat .x) (if false then true else (let u = true in true)) ) ({a = (( \f: Unit .((f (let u = true in false) ) false ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Unit .\y: Bool .y) (let u = true in u) ) true) }.b))))
(case <l = (pred (if (if false then true else false) then (((\x: Nat .\y: Unit .y) false ) 0) else (let u = false in 1))) > as Unit of < l = x > => x | < r = y > => y)
(let u = (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f ({a = true , b = 0 }.b) ) (( \f: Rec X. X .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Unit .b)) ) (( \f: Rec X. X .((f false ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Unit .b))) in (unfold [ Unit ] (fold [ Nat ] (let u = true in (((\x: Nat .\y: Bool .x) 0 ) false)) )))
(iszero (pred (((\x: Rec X. X .\y: Unit .x) (succ (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) ({a = false , b = false }.b))))
(((\x: Bool .\y: Bool .y) (((\x: Unit .\y: Nat .y) ({a = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) , b = ({a = 0 , b = 1 }.b) }.b) , b = (let u = (( \f: Nat .((f (let u = 0 in u) ) ({a = 1 , b = true }.a) ) ) (\a: Nat .\b: Unit .a)) in (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a))) }.b) ) (((\x: Bool .\y: Rec X. X .x) ({a = (((\x: Bool .\y: Nat .y) false ) true) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) }.a) ) (unfold [ Nat ] (fold [ Unit ] true )))) ) (((\x: Bool .\y: Unit .x) (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .x) 0 ) (if true then false else false)) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Bool .\b: Nat .b)) ) (((\x: Rec X. X .\y: Bool .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) ) ({a = true , b = (unfold [ Bool ] (fold [ Unit ] false )) }.b))))
(pred ({a = (let u = (pred (let u = 1 in u)) in u) , b = (((\x: Nat .\y: Bool .x) (let u = (if false then false else false) in true) ) (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Bool .x) false ) false) ) ({a = 1 , b = true , c =  1 }.b))) , c = (((\x: Unit .\y: Bool .x) (((\x: Nat .\y: Nat .y) true ) 1) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true ))) }.c))
(((\x: Rec X. X .\y: Nat .y) (let u = ({a = (fix (\x: Bool . 0 )) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in (let u = 1 in false)) ) ({a = (fix (\x: Rec X. X . (let u = (unfold [ Bool ] (fold [ Bool ] 0 )) in u) )) , b = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (iszero 1) else (( \f: Unit .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .b)) ) (let u = true in false) ) ) (\a: Unit .\b: Nat .b))) }.a))
(fix (\x: Unit . (((\x: Unit .\y: Bool .x) ({a = ({a = (let u = true in 1) , b = 1 }.b) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = true , b = (if false then 1 else 1) }.b) }.b) ) (iszero 1)) ))
(let u = (fix (\x: Nat . ({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = true }.b) , b = (((\x: Unit .\y: Nat .y) false ) 0) }.b) )) in (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = 0 , b = true }.b) )) in (iszero (if ({a = true , b = true }.b) then 0 else ({a = 1 , b = true }.a)))))
(((\x: Unit .\y: Nat .x) ({a = ({a = false , b = (let u = 1 in 0) }.b) , b = (let u = 0 in false) }.a) ) (iszero (pred (fix (\x: Rec X. X . 1 )))))
(let u = (((\x: Nat .\y: Rec X. X .x) (if (let u = true in true) then ({a = (let u = 0 in 0) , b = true , c =  0 }.b) else (let u = ({a = false , b = 1 }.a) in u)) ) ({a = 0 , b = ({a = true , b = 1 }.a) , c =  1 }.b)) in u)
(unfold [ Rec X. X ] (fold [ Nat ] (succ (((\x: Rec X. X .\y: Unit .x) ({a = (fix (\x: Rec X. X . true )) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f ({a = 1 , b = false }.b) ) (iszero 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)))) ))
({a = (fix (\x: Nat . ({a = ({a = false , b = 0 }.b) , b = (let u = 0 in true) , c = 1 }.c) )) , b = (((\x: Bool .\y: Unit .y) (if ({a = 1 , b = true }.b) then (if false then (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) else false) else ({a = 0 , b = true , c =  1 }.b)) ) ({a = (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Nat .x) false ) false) )) , b = (( \f: Unit .((f ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = false , b = 1 }.a) , c =  (let u = 0 in 1) }.b) ) ({a = ({a = 0 , b = 1 }.b) , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) }.b)) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] (succ (let u = 1 in u)) ))
(let u = (if ({a = (let u = (succ 0) in 0) , b = ({a = (if false then 1 else 0) , b = ({a = 0 , b = false }.b) , c =  0 }.b) }.b) then (( \f: Rec X. X .((f (let u = 0 in false) ) (let u = false in false) ) ) (\a: Bool .\b: Rec X. X .b)) else ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] ({a = true , b = 0 }.a) )) ))) in u)
({a = ({a = (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = true }.a) )) , b = (fix (\x: Rec X. X . false )) }.a) , b = (let u = ({a = (fix (\x: Rec X. X . false )) , b = 1 }.a) in (if ({a = 1 , b = (let u = true in false) }.b) then (iszero 1) else (( \f: Unit .((f false ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .a)))) , c = (pred (((\x: Nat .\y: Bool .x) (case <l = (fix (\x: Unit . 0 )) > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . true )))) }.c)
(if ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = 1 , b = true , c = 1 }.c) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) , c =  ({a = 1 , b = true }.a) }.b) )) )) then ({a = (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = false in u) }.b) else (( \f: Nat .((f ({a = ({a = 1 , b = true }.b) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = false }.b) )) ) ) (\a: Bool .\b: Bool .a)))
(fix (\x: Unit . (unfold [ Unit ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) ) (case <r = (((\x: Bool .\y: Bool .x) false ) false) > as Bool of < l = x > => x | < r = y > => y)) )) ))
(case <r = (let u = (case <r = (fix (\x: Unit . ({a = 1 , b = false }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Unit .x) (let u = true in u) ) (((\x: Nat .\y: Rec X. X .x) false ) true))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (( \f: Bool .((f (let u = (succ ({a = 1 , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) }.b)) in ({a = (((\x: Unit .\y: Nat .y) false ) 0) , b = (iszero 0) }.b)) ) (fix (\x: Unit . ({a = 1 , b = false }.b) )) ) ) (\a: Unit .\b: Unit .a)) in (let u = (let u = ({a = 0 , b = false , c = (let u = true in 0) }.c) in (let u = (((\x: Unit .\y: Bool .y) false ) true) in (unfold [ Rec X. X ] (fold [ Unit ] 1 )))) in (if (if true then true else (fix (\x: Nat . true ))) then (((\x: Rec X. X .\y: Rec X. X .y) false ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 ))) else (fix (\x: Unit . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )))))
((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .x) false ) true) )) in (let u = (( \f: Bool .((f ({a = true , b = 0 }.a) ) false ) ) (\a: Unit .\b: Bool .a)) in u)) ))
(let u = ({a = (iszero (( \f: Nat .((f (((\x: Unit .\y: Nat .x) 0 ) false) ) (if false then 0 else 0) ) ) (\a: Rec X. X .\b: Nat .b))) , b = (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) ) (\a: Bool .\b: Bool .a)) }.a) in u)
({a = (((\x: Nat .\y: Rec X. X .x) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] true )) )) ) (((\x: Rec X. X .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) true) ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f (fix (\x: Nat . ({a = 1 , b = true , c =  1 }.b) )) ) (let u = 1 in false) ) ) (\a: Bool .\b: Nat .b))) , b = ({a = ({a = (((\x: Unit .\y: Bool .x) true ) true) , b = (( \f: Bool .((f 1 ) (fix (\x: Bool . 1 )) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) , b = (let u = (((\x: Rec X. X .\y: Nat .y) true ) true) in u) , c =  ({a = true , b = ({a = false , b = 0 }.b) }.b) }.b) }.b)
({a = (case <r = (let u = false in (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .b))) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (pred (( \f: Bool .((f ({a = true , b = 0 }.b) ) 0 ) ) (\a: Bool .\b: Nat .b))) , b = (((\x: Unit .\y: Unit .y) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = ({a = false , b = true }.b) in u)) , c =  (( \f: Unit .((f (pred 0) ) (fix (\x: Nat . 1 )) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) }.b)
({a = ({a = (let u = false in 1) , b = (((\x: Nat .\y: Rec X. X .x) true ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.b) , b = ({a = (let u = (let u = true in 0) in (unfold [ Bool ] (fold [ Bool ] false ))) , b = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Unit .\y: Nat .y) false ) true) in (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) }.b) }.b) }.a)
(((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true }.b) )) ) (unfold [ Rec X. X ] (fold [ Bool ] (if true then true else false) ))) ) (( \f: Unit .((f (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (let u = true in true) , c =  ({a = false , b = 1 }.b) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) ) (unfold [ Nat ] (fold [ Rec X. X ] (let u = false in u) )) ) ) (\a: Rec X. X .\b: Nat .b)))
(let u = (fix (\x: Unit . (fix (\x: Bool . (((\x: Bool .\y: Nat .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true ))) )) )) in (fix (\x: Bool . (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in u) )))
(case <r = ({a = (( \f: Unit .((f (pred ({a = 1 , b = false }.a)) ) (( \f: Nat .((f (let u = 1 in 0) ) ({a = 0 , b = 1 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Bool .y) false ) 0) }.a) }.b) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] 1 )) ) (succ (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a))) ) ) (\a: Nat .\b: Nat .b)) , b = (iszero (fix (\x: Rec X. X . (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) ))) , c = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (succ 0) )) }.c) in (if (( \f: Bool .((f (let u = false in false) ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Rec X. X .b)) then (((\x: Rec X. X .\y: Nat .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (let u = false in 1)) else (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Bool .y) true ) 0) ))))
(succ (fix (\x: Rec X. X . (succ ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 ))) )))
(let u = ({a = (let u = (((\x: Bool .\y: Nat .y) true ) 0) in u) , b = (( \f: Rec X. X .((f (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) false ) true) ) (let u = true in u) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = true }.b) ) true) ) ) (\a: Bool .\b: Rec X. X .b)) , c = (let u = (( \f: Unit .((f (let u = false in u) ) (iszero 1) ) ) (\a: Rec X. X .\b: Bool .b)) in (let u = 0 in (((\x: Unit .\y: Unit .y) false ) 1))) }.c) in u)
(pred (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = true in 0) )) )))
(( \f: Nat .((f (((\x: Bool .\y: Nat .x) (let u = (if true then false else true) in 0) ) (iszero 1)) ) (( \f: Nat .((f (let u = (((\x: Unit .\y: Nat .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) 1) in u) ) (((\x: Unit .\y: Bool .x) (case <l = (if true then 0 else 0) > as Bool of < l = x > => x | < r = y > => y) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a))
(fix (\x: Rec X. X . (iszero (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f (let u = 0 in 0) ) (((\x: Nat .\y: Unit .x) 0 ) true) ) ) (\a: Unit .\b: Nat .a)) ))) ))
(unfold [ Bool ] (fold [ Unit ] (fix (\x: Rec X. X . (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) false) ) (let u = (unfold [ Rec X. X ] (fold [ Bool ] false )) in u) ) ) (\a: Bool .\b: Unit .b)) )) ))
({a = (if (if true then false else true) then (if (unfold [ Bool ] (fold [ Unit ] false )) then 1 else (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) else (((\x: Unit .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (pred 0) )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )))) , b = (let u = (let u = (if ({a = 0 , b = true }.b) then (let u = 0 in u) else (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) in u) in (( \f: Nat .((f ({a = true , b = (((\x: Nat .\y: Unit .x) 1 ) false) }.a) ) (let u = 0 in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .b))) }.a)
(((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Nat .x) ({a = (fix (\x: Nat . false )) , b = ({a = ({a = 0 , b = 1 }.b) , b = false }.a) }.a) ) (if ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = ({a = 1 , b = true }.b) , c =  (pred 1) }.b) then (unfold [ Nat ] (fold [ Nat ] false )) else ({a = 1 , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) }.b))) ) (let u = ({a = ({a = 0 , b = 0 }.b) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) }.a) in (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) ({a = ({a = 1 , b = true , c =  0 }.b) , b = ({a = (fix (\x: Bool . 1 )) , b = false , c = 0 }.c) }.b) ) ) (\a: Rec X. X .\b: Nat .a))))
(( \f: Nat .((f (let u = (((\x: Unit .\y: Nat .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.b)) in u) ) (let u = (( \f: Rec X. X .((f true ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) in (((\x: Bool .\y: Rec X. X .y) false ) false)) ) ) (\a: Nat .\b: Unit .b))
({a = (( \f: Bool .((f (fix (\x: Unit . ({a = false , b = 0 }.b) )) ) (succ 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (iszero ({a = ({a = false , b = 1 }.b) , b = (let u = ({a = false , b = 1 }.b) in u) }.b)) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = (fix (\x: Nat . ({a = ({a = 1 , b = true }.a) , b = (iszero 1) , c =  ({a = 0 , b = true }.a) }.b) )) , b = (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in ({a = 1 , b = false , c = 1 }.c)) }.b) ))
(pred (fix (\x: Rec X. X . (pred (fix (\x: Bool . (let u = 0 in u) ))) )))
(unfold [ Bool ] (fold [ Unit ] (let u = ({a = (let u = (((\x: Nat .\y: Nat .y) true ) 0) in (let u = true in false)) , b = (if (let u = false in true) then (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) else ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = 1 in 1) ))) }.a) in (((\x: Unit .\y: Unit .x) (let u = false in u) ) (fix (\x: Rec X. X . (iszero 0) )))) ))
(let u = ({a = (fix (\x: Bool . (((\x: Bool .\y: Nat .x) true ) true) )) , b = (((\x: Nat .\y: Rec X. X .y) (if (let u = 1 in true) then (case <r = ({a = 1 , b = true , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) else (fix (\x: Rec X. X . ({a = 1 , b = false , c =  0 }.b) ))) ) (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) in u)) }.a) in u)
(( \f: Unit .((f (((\x: Nat .\y: Rec X. X .y) (let u = (fix (\x: Rec X. X . 0 )) in (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)))) ) (let u = ({a = (let u = true in 0) , b = ({a = false , b = true }.b) }.a) in u)) ) (((\x: Bool .\y: Bool .y) (iszero 0) ) (fix (\x: Nat . 0 ))) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = ({a = (if (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , b = (let u = 1 in true) }.b) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) then (pred ({a = 1 , b = false , c = 1 }.c)) else (unfold [ Bool ] (fold [ Bool ] 1 ))) , b = (let u = (let u = (pred 0) in 1) in u) }.b) , b = (iszero (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) , c =  (if ({a = (fix (\x: Nat . (((\x: Unit .\y: Rec X. X .x) false ) false) )) , b = (let u = 1 in false) }.b) then (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)) else (fix (\x: Unit . ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) , b = 1 }.b) ))) }.b)
(( \f: Nat .((f ({a = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (fix (\x: Rec X. X . ({a = true , b = false }.b) )) }.b) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) false ) true) ) ({a = (((\x: Nat .\y: Rec X. X .x) false ) true) , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (( \f: Nat .((f 0 ) (unfold [ Bool ] (fold [ Bool ] 1 )) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (unfold [ Nat ] (fold [ Bool ] (let u = true in u) )) }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = ({a = (if (((\x: Unit .\y: Nat .x) false ) false) then (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) (((\x: Nat .\y: Rec X. X .y) true ) 0) ) ) (\a: Rec X. X .\b: Unit .a)) else (unfold [ Bool ] (fold [ Unit ] 0 ))) , b = ({a = (( \f: Rec X. X .((f (let u = false in u) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = false , b = 0 }.b) }.a) }.a) , b = (if (case <r = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Bool .y) (((\x: Bool .\y: Bool .x) false ) true) ) (fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] 1 )) ))) else (succ 0)) }.b)
({a = ({a = (let u = (let u = 1 in 0) in (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .a))) , b = (((\x: Bool .\y: Bool .y) true ) 1) }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in (fix (\x: Nat . ({a = 0 , b = false }.b) ))) , b = (fix (\x: Nat . (unfold [ Nat ] (fold [ Unit ] 0 )) )) }.b) )) }.b)
(((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Nat .x) (case <r = ({a = true , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) (if ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = false , c =  0 }.b) }.b) then (( \f: Nat .((f 1 ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .b)) else ({a = (let u = 1 in true) , b = (( \f: Unit .((f (((\x: Unit .\y: Nat .y) true ) 0) ) (pred 1) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)))
(pred (pred (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = 1 }.b) ))))
(let u = ({a = (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Rec X. X .y) false ) true) ) ({a = (if false then 1 else 0) , b = ({a = false , b = (iszero 0) }.b) , c =  (fix (\x: Nat . 1 )) }.b)) , b = (iszero (let u = false in (succ 1))) }.b) in (case <l = (let u = (( \f: Bool .((f (iszero (((\x: Bool .\y: Nat .y) true ) 0)) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Unit .b)) in (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (let u = 1 in u) else ({a = true , b = 1 }.b))) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Nat .y) ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = (pred (if true then 1 else 1)) }.a) ) ({a = ({a = (( \f: Bool .((f (if true then 0 else 1) ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Bool .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . false )) ) ) (\a: Rec X. X .\b: Unit .a)) }.a) , b = ({a = (pred 1) , b = (((\x: Unit .\y: Unit .x) false ) true) }.b) }.a))
(((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Nat ] ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = ({a = (fix (\x: Bool . 1 )) , b = (let u = false in false) }.b) , c =  ({a = 0 , b = true }.a) }.b) )) ) (unfold [ Unit ] (fold [ Rec X. X ] ({a = (succ (let u = 1 in 0)) , b = (iszero (( \f: Rec X. X .((f 0 ) (((\x: Rec X. X .\y: Unit .y) false ) 1) ) ) (\a: Bool .\b: Bool .b))) , c =  (((\x: Unit .\y: Nat .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .b))) }.b) )))
(if (( \f: Unit .((f (iszero 0) ) ({a = (let u = (let u = true in false) in u) , b = (unfold [ Nat ] (fold [ Unit ] false )) }.b) ) ) (\a: Nat .\b: Nat .b)) then (( \f: Bool .((f (let u = (((\x: Nat .\y: Rec X. X .x) 1 ) false) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Nat .b)) else (let u = (if true then ({a = true , b = 0 }.a) else (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (succ 1) ))))
(((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Bool .x) (if ({a = 0 , b = false }.b) then 0 else (((\x: Bool .\y: Unit .y) false ) 0)) ) (((\x: Rec X. X .\y: Nat .y) (let u = true in u) ) false)) ) (let u = (unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = false , b = 0 }.b) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) )) in u))
(let u = (if (if ({a = true , b = 0 }.a) then (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) else ({a = 1 , b = false }.b)) then (let u = ({a = false , b = 1 }.b) in u) else ({a = (let u = false in 0) , b = (let u = true in (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b))) }.a)) in u)
(case <r = (let u = (( \f: Bool .((f (iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) ) (if (case <r = (((\x: Unit .\y: Bool .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) then (let u = 1 in true) else (iszero 0)) ) ) (\a: Rec X. X .\b: Unit .a)) in u) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = ({a = (let u = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = false }.b) in (fix (\x: Unit . (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) ))) , b = (let u = ({a = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (((\x: Bool .\y: Unit .x) false ) true) }.a) , b = ({a = false , b = 0 }.b) }.b) in ({a = (pred 0) , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .a)) }.b)) , c =  ({a = ({a = (fix (\x: Rec X. X . true )) , b = true }.b) , b = (pred 0) }.b) }.b) , b = (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) in ({a = 0 , b = false }.a)) )) )) }.a)
({a = (let u = (if (unfold [ Bool ] (fold [ Nat ] false )) then ({a = 0 , b = false , c = 0 }.c) else ({a = (if true then 1 else 1) , b = 0 }.b)) in (pred (pred 0))) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f (((\x: Unit .\y: Bool .x) false ) ({a = 1 , b = false }.b)) ) (let u = ({a = false , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) }.a) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) , c =  (case <l = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) in u) > as Bool of < l = x > => x | < r = y > => y) }.b)
(succ (let u = ({a = (let u = (let u = false in false) in 0) , b = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .b)) , c = (unfold [ Nat ] (fold [ Bool ] 0 )) }.c) in (let u = (((\x: Rec X. X .\y: Unit .y) true ) 1) in u)))
(iszero (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Bool ] ({a = false , b = true }.b) )) ) (fix (\x: Rec X. X . (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .a)) ))) ) ({a = (let u = 0 in true) , b = ({a = 0 , b = true , c = 0 }.c) }.b)))
({a = ({a = (case <l = (((\x: Bool .\y: Rec X. X .x) 1 ) true) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero (((\x: Nat .\y: Rec X. X .y) (let u = false in u) ) (let u = 1 in 1))) }.b) , b = (if (case <r = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) in (fix (\x: Nat . false ))) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Bool .y) ({a = ({a = 0 , b = false , c = 0 }.c) , b = true }.b) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a))) else (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = 1 , b = 0 }.b) else (fix (\x: Rec X. X . 0 )))) }.b)
(fix (\x: Rec X. X . ({a = (pred ({a = 0 , b = 0 }.b)) , b = (((\x: Unit .\y: Bool .y) false ) false) , c = (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Rec X. X .y) false ) 0)) }.c) ))
(((\x: Unit .\y: Rec X. X .x) (if ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) false ) false) )) then (case <r = ({a = false , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = 1 }.a) in (case <r = (let u = 0 in false) > as Rec X. X of < l = x > => x | < r = y > => y))) ) (unfold [ Bool ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f (fix (\x: Unit . true )) ) (unfold [ Nat ] (fold [ Unit ] false )) ) ) (\a: Bool .\b: Nat .b)) ) (( \f: Bool .((f true ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Bool .\b: Unit .b))) )))
({a = (fix (\x: Rec X. X . (((\x: Bool .\y: Unit .y) (case <r = (( \f: Bool .((f (let u = false in u) ) (iszero 1) ) ) (\a: Unit .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . true ))) )) , b = (case <r = (case <r = (iszero ({a = 1 , b = false }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) }.b)
(fix (\x: Nat . ({a = (unfold [ Nat ] (fold [ Nat ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) )) , b = (((\x: Rec X. X .\y: Unit .x) false ) (iszero 1)) }.a) ))
(case <l = (let u = (((\x: Unit .\y: Bool .x) (succ 1) ) (let u = true in u)) in (let u = (( \f: Unit .((f (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ({a = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) , b = false , c = (let u = 1 in u) }.c))) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Nat .x) (( \f: Unit .((f (succ (let u = true in 1)) ) (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in u) ) ) (\a: Bool .\b: Nat .b)) ) (case <r = (((\x: Nat .\y: Rec X. X .y) (iszero 0) ) (let u = 0 in false)) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) ({a = (iszero (let u = 1 in u)) , b = (if true then false else false) }.b) ) (case <r = (fix (\x: Rec X. X . false )) > as Unit of < l = x > => x | < r = y > => y)) ) (let u = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) ) (((\x: Bool .\y: Unit .y) true ) false) ) ) (\a: Nat .\b: Rec X. X .a)) in (if (((\x: Bool .\y: Rec X. X .y) (((\x: Bool .\y: Nat .x) true ) true) ) (fix (\x: Nat . false ))) then (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .b)) else (let u = false in u))) ) ) (\a: Unit .\b: Rec X. X .a))
(unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) ({a = (iszero (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) }.b) }.b) ) ({a = (let u = true in 0) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Bool ] true )) )) }.b)) ))
(( \f: Nat .((f (pred ({a = ({a = false , b = 1 }.b) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.b)) ) (succ (( \f: Nat .((f (((\x: Bool .\y: Unit .x) 0 ) false) ) (pred (succ 1)) ) ) (\a: Unit .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Nat .b))
(let u = ({a = (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = false , c = 1 }.c) ) (let u = true in true)) , b = ({a = (let u = ({a = 1 , b = 0 }.b) in true) , b = (((\x: Nat .\y: Rec X. X .x) true ) false) }.b) , c =  (succ ({a = 1 , b = 0 }.b)) }.b) in (case <r = ({a = ({a = 1 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = 0 }.c) , b = (let u = true in u) , c =  ({a = (((\x: Unit .\y: Nat .x) false ) false) , b = 1 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
({a = (( \f: Bool .((f (let u = (((\x: Unit .\y: Unit .x) true ) false) in 0) ) ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .b)) , b = ({a = (((\x: Nat .\y: Bool .x) 0 ) false) , b = true , c = (succ 1) }.c) }.b) ) ) (\a: Bool .\b: Bool .a)) , b = (( \f: Bool .((f (let u = ({a = true , b = 1 }.b) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ))) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) false ) 1) ) (( \f: Unit .((f (if true then 1 else 1) ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)
(let u = (let u = (( \f: Bool .((f (((\x: Bool .\y: Unit .x) false ) true) ) ({a = (if true then 0 else 1) , b = (let u = 1 in true) }.b) ) ) (\a: Unit .\b: Unit .a)) in u) in (if (let u = false in false) then (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) else (let u = false in u)))
(case <l = (let u = (((\x: Bool .\y: Nat .x) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . true )) , c = (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) 0 ) ) (\a: Unit .\b: Nat .b)) }.c) ) ({a = false , b = 0 }.a)) in ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) , b = (if (((\x: Rec X. X .\y: Nat .x) false ) true) then ({a = false , b = 1 }.b) else (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) }.b)) > as Nat of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Rec X. X ] (let u = (let u = (let u = (pred 0) in u) in u) in (let u = (unfold [ Unit ] (fold [ Rec X. X ] true )) in u)) ))
(( \f: Unit .((f ({a = (if ({a = 1 , b = true , c =  1 }.b) then (unfold [ Unit ] (fold [ Unit ] false )) else (let u = false in false)) , b = (case <l = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Rec X. X .y) true ) 0) }.b) > as Nat of < l = x > => x | < r = y > => y) }.a) ) (if ({a = ({a = (pred (((\x: Nat .\y: Bool .y) true ) 0)) , b = ({a = false , b = true }.b) }.a) , b = (if (fix (\x: Bool . (let u = false in true) )) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) else (let u = 0 in false)) }.b) then ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in u) )) , b = (iszero ({a = true , b = 1 }.b)) }.b) else (case <r = (unfold [ Bool ] (fold [ Unit ] false )) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Unit .a))
(if (iszero (((\x: Bool .\y: Bool .y) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = ({a = 1 , b = true , c = 0 }.c) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) , c = 1 }.c))) then (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = (fix (\x: Unit . true )) }.b) )) in (((\x: Rec X. X .\y: Unit .x) ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = true }.b) ) (let u = true in true))) else ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in false) )) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.a))
({a = (( \f: Rec X. X .((f (fix (\x: Rec X. X . (succ 0) )) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = true , b = 0 }.b) )) ) ) (\a: Bool .\b: Unit .a)) , b = ({a = (((\x: Unit .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Unit ] false )) ) (iszero (((\x: Unit .\y: Nat .y) (((\x: Bool .\y: Unit .y) true ) false) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a))))) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] (pred 1) )) in (let u = (fix (\x: Rec X. X . 0 )) in 0)) }.a) , c =  (( \f: Nat .((f (((\x: Bool .\y: Nat .x) ({a = (succ 0) , b = (iszero 1) , c = ({a = 1 , b = false }.a) }.c) ) ({a = ({a = 0 , b = false , c =  0 }.b) , b = 0 }.a)) ) ({a = ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.a) , b = (fix (\x: Unit . 0 )) }.b) ) ) (\a: Bool .\b: Unit .b)) }.b)
(case <r = (( \f: Unit .((f (iszero (succ 0)) ) (let u = (pred (unfold [ Bool ] (fold [ Bool ] 1 ))) in (( \f: Unit .((f false ) (let u = false in u) ) ) (\a: Nat .\b: Nat .b))) ) ) (\a: Unit .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(pred (succ (pred 1)))
(let u = ({a = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in u) , b = (fix (\x: Bool . true )) , c = (let u = (let u = ({a = false , b = false }.b) in 1) in (unfold [ Bool ] (fold [ Unit ] 0 ))) }.c) in u)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Unit .x) (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in u) ) (case <r = ({a = 1 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y)) )) ))
(pred (case <l = (fix (\x: Rec X. X . 0 )) > as Rec X. X of < l = x > => x | < r = y > => y))
(pred (( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .x) 1 ) true) )) ) (let u = ({a = ({a = true , b = 0 }.b) , b = false , c =  (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b) in ({a = (let u = false in true) , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Unit .b)))
(( \f: Unit .((f ({a = (let u = ({a = 1 , b = false , c =  1 }.b) in (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a))) , b = (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Nat .x) true ) true) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .b))) }.b) ) ({a = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = false }.b) , b = ({a = 1 , b = (let u = false in 1) }.b) }.a) ) ) (\a: Nat .\b: Bool .b))
(unfold [ Rec X. X ] (fold [ Unit ] (pred ({a = ({a = true , b = true }.b) , b = (fix (\x: Bool . 1 )) }.b)) ))
(unfold [ Rec X. X ] (fold [ Nat ] (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) false ) true) )) ) (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Nat .b)) ))
(fix (\x: Nat . (((\x: Nat .\y: Rec X. X .x) (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) (case <l = ({a = 1 , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Nat .x) true ) false)) , b = ({a = (( \f: Rec X. X .((f (if false then false else true) ) false ) ) (\a: Unit .\b: Bool .b)) , b = ({a = ({a = 1 , b = true }.b) , b = true }.b) }.b) }.b)) ))
(unfold [ Rec X. X ] (fold [ Bool ] (let u = (fix (\x: Rec X. X . (let u = ({a = 0 , b = false }.b) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) )) in u) ))
(case <l = (succ (fix (\x: Bool . ({a = 1 , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ))) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = ({a = (((\x: Nat .\y: Rec X. X .y) true ) true) , b = (let u = (if true then 0 else 0) in u) }.a) , b = ({a = (succ ({a = 0 , b = true , c = 1 }.c)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.a) }.b) in u)
(let u = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (let u = true in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.b) in (fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .x) true ) false) )))
(let u = ({a = (fix (\x: Nat . (case <r = ({a = 1 , b = false , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (if (unfold [ Bool ] (fold [ Rec X. X ] true )) then (((\x: Nat .\y: Nat .y) false ) 0) else ({a = 0 , b = 1 }.b)) }.b) in u)
((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f (let u = (let u = false in 0) in u) ) (let u = (pred (((\x: Bool .\y: Nat .x) 1 ) false)) in (( \f: Unit .((f (pred (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Unit .\b: Unit .a))) ) ) (\a: Nat .\b: Unit .a)) ))
({a = ({a = (case <l = (fix (\x: Rec X. X . 1 )) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Bool .((f 1 ) (if false then 1 else 1) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = 0 , b = (let u = 0 in false) }.b) , c =  (fix (\x: Nat . (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) )) }.b) , c = (( \f: Bool .((f 1 ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Unit .b)) }.c) , b = (((\x: Nat .\y: Unit .x) (let u = true in u) ) (iszero ({a = 1 , b = false , c = 1 }.c))) , c = ({a = (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) ) ({a = false , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) }.c)
(if (unfold [ Bool ] (fold [ Rec X. X ] (let u = ({a = ({a = false , b = 1 }.b) , b = false , c =  1 }.b) in u) )) then (( \f: Unit .((f (fix (\x: Unit . ({a = 0 , b = 0 }.b) )) ) ({a = ({a = 0 , b = false }.a) , b = ({a = false , b = 0 }.b) }.b) ) ) (\a: Unit .\b: Unit .b)) else (let u = (iszero (fix (\x: Nat . 0 ))) in (succ (if (unfold [ Unit ] (fold [ Nat ] false )) then (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) else (fix (\x: Bool . 0 ))))))
(((\x: Unit .\y: Nat .x) ({a = (let u = ({a = 0 , b = 0 }.b) in u) , b = ({a = false , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.a) , c = (if (let u = (iszero 0) in u) then (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) else (succ 1)) }.c) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = true in u) , b = (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = true , c =  0 }.b) )) }.b) )))
(( \f: Unit .((f (iszero ({a = (let u = 1 in 0) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) }.a)) ) (((\x: Bool .\y: Bool .x) ({a = ({a = false , b = 0 }.a) , b = (succ 1) }.a) ) ({a = (let u = 0 in 0) , b = (let u = 0 in false) , c =  (fix (\x: Unit . 0 )) }.b)) ) ) (\a: Unit .\b: Rec X. X .b))
(( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) (((\x: Bool .\y: Bool .x) (fix (\x: Rec X. X . false )) ) (let u = true in u)) ) (((\x: Nat .\y: Rec X. X .x) false ) ({a = 0 , b = true }.b))) ) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) , b = ({a = (( \f: Unit .((f (succ 1) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Nat .b)) , b = (fix (\x: Bool . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) }.b) }.b) ) ) (\a: Nat .\b: Unit .b))
(let u = (((\x: Rec X. X .\y: Nat .x) (if false then false else (let u = false in false)) ) (let u = ({a = 0 , b = ({a = 1 , b = false , c =  1 }.b) , c =  1 }.b) in (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Bool .b)))) in (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) in u))
({a = ({a = ({a = ({a = false , b = 1 }.b) , b = (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = false , c = 0 }.c) )) }.b) , b = ({a = (succ 0) , b = (case <r = (((\x: Unit .\y: Unit .x) false ) true) > as Unit of < l = x > => x | < r = y > => y) }.b) }.b) , b = ({a = (let u = (pred 1) in u) , b = (((\x: Bool .\y: Nat .x) (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = false }.b) )) ) (((\x: Unit .\y: Bool .y) ({a = 1 , b = true , c =  1 }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = 1 in false) )))) }.a) }.b)
(if (((\x: Rec X. X .\y: Nat .x) (let u = ({a = 0 , b = true }.b) in (case <r = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y)) ) ({a = (( \f: Unit .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .a)) ) (fix (\x: Rec X. X . false )) ) ) (\a: Nat .\b: Nat .b)) }.b)) then (fix (\x: Bool . ({a = (((\x: Unit .\y: Bool .x) true ) false) , b = (((\x: Bool .\y: Bool .x) 0 ) false) }.a) )) else (case <r = (let u = (unfold [ Unit ] (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] false )) )) in u) > as Bool of < l = x > => x | < r = y > => y))
({a = (fix (\x: Nat . (succ (unfold [ Nat ] (fold [ Nat ] 0 ))) )) , b = (let u = (let u = (succ 1) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a))) in ({a = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Nat .\y: Bool .x) 0 ) false) }.a)) }.a)
({a = (let u = (if ({a = 0 , b = false , c =  (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b) then ({a = false , b = 1 }.b) else ({a = 0 , b = false , c = 0 }.c)) in u) , b = (( \f: Nat .((f (iszero (fix (\x: Nat . 0 ))) ) (( \f: Unit .((f (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) )) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .b)) }.b)
(( \f: Bool .((f (pred ({a = 1 , b = ({a = 1 , b = true }.a) }.b)) ) (succ (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .a))
(pred (fix (\x: Nat . (unfold [ Unit ] (fold [ Nat ] (( \f: Rec X. X .((f (fix (\x: Rec X. X . 0 )) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) )) )))
(unfold [ Bool ] (fold [ Unit ] ({a = (case <l = (((\x: Rec X. X .\y: Nat .y) (((\x: Unit .\y: Rec X. X .y) true ) false) ) 0) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Rec X. X .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = true , b = 1 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (succ 0) , b = (let u = true in u) }.b) )) }.b) }.b) ))
({a = (let u = (pred (unfold [ Unit ] (fold [ Nat ] 0 ))) in ({a = (if false then true else false) , b = (fix (\x: Nat . 1 )) }.b)) , b = (if (fix (\x: Rec X. X . ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = (((\x: Nat .\y: Nat .x) false ) true) }.b) )) then (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (let u = 1 in false)) else ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = 1 in true) ))) , c =  (((\x: Unit .\y: Rec X. X .x) (((\x: Unit .\y: Rec X. X .y) (let u = true in (let u = true in u)) ) (fix (\x: Bool . 0 ))) ) (((\x: Bool .\y: Bool .y) (let u = (fix (\x: Bool . true )) in ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) ) (fix (\x: Unit . ({a = true , b = false }.b) )))) }.b)
(fix (\x: Unit . (((\x: Rec X. X .\y: Bool .x) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (((\x: Bool .\y: Rec X. X .x) (if false then 0 else 1) ) ({a = 1 , b = true }.b)) }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ))
(let u = (case <l = (succ 0) > as Nat of < l = x > => x | < r = y > => y) in (case <l = (fix (\x: Rec X. X . (case <l = ({a = true , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Bool .x) ({a = (fix (\x: Nat . (((\x: Nat .\y: Nat .x) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) false) )) , b = (case <l = (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f ({a = true , b = true }.b) ) (iszero 1) ) ) (\a: Unit .\b: Nat .a)) ) (fix (\x: Nat . 0 ))) > as Unit of < l = x > => x | < r = y > => y) }.a) ) (case <r = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = 1 , b = false }.b) in u) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(case <l = ({a = (let u = (let u = 1 in 0) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false ))) , b = (((\x: Unit .\y: Nat .y) (if (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (let u = false in u) else (((\x: Nat .\y: Nat .y) false ) false)) ) (let u = true in 1)) }.b) > as Unit of < l = x > => x | < r = y > => y)
(case <r = (iszero (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) (let u = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = 1 }.b) in u) ) ) (\a: Bool .\b: Unit .b))) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Bool .((f ({a = (let u = (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) in ({a = (pred ({a = 1 , b = true }.a)) , b = (fix (\x: Unit . 0 )) }.b)) , b = (iszero ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = false }.a)) }.b) ) (let u = ({a = (((\x: Bool .\y: Rec X. X .x) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b)) ) true) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) }.a) in (( \f: Unit .((f (iszero ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 ))) ) (( \f: Unit .((f (let u = 0 in true) ) ({a = false , b = false }.b) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Bool .a))) ) ) (\a: Unit .\b: Nat .b))
({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (if false then 1 else 0) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) )) }.b) , b = (let u = (((\x: Unit .\y: Unit .y) true ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) in u) , c =  (let u = (let u = (fix (\x: Nat . (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) )) in (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = false }.a) ))) in (let u = (unfold [ Bool ] (fold [ Rec X. X ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) in u)) }.b)
({a = (unfold [ Rec X. X ] (fold [ Bool ] ({a = (if false then (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .b)) else false) , b = (((\x: Rec X. X .\y: Bool .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = false , b = 1 }.b)) }.b) )) , b = (( \f: Rec X. X .((f (if ({a = (let u = ({a = 0 , b = true }.a) in false) , b = (case <l = (((\x: Bool .\y: Bool .y) true ) 1) > as Nat of < l = x > => x | < r = y > => y) }.a) then ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = (((\x: Unit .\y: Nat .y) (let u = false in true) ) 0) }.b) else (let u = (succ 0) in 1)) ) (( \f: Nat .((f ({a = 0 , b = true }.a) ) (succ 1) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .a)) }.b)
(unfold [ Unit ] (fold [ Bool ] (fix (\x: Nat . ({a = (( \f: Unit .((f ({a = 0 , b = false }.a) ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = 0 , b = false }.b) }.b) )) ))
({a = ({a = (( \f: Rec X. X .((f (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = (((\x: Bool .\y: Unit .x) true ) false) in u) ) ) (\a: Unit .\b: Nat .b)) , b = (case <r = (( \f: Rec X. X .((f true ) ({a = 1 , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (((\x: Nat .\y: Unit .y) (let u = (let u = ({a = false , b = 0 }.b) in true) in (((\x: Bool .\y: Bool .y) false ) false)) ) (let u = (case <r = ({a = false , b = 0 }.a) > as Unit of < l = x > => x | < r = y > => y) in ({a = (let u = 1 in 1) , b = (if (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .b)) then 1 else 0) }.b))) }.b)
({a = (case <r = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) , b = ({a = true , b = 0 }.a) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Rec X. X .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) }.b)
(((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) )) ) (((\x: Unit .\y: Bool .x) true ) false)) ) (case <r = ({a = (let u = 1 in u) , b = ({a = true , b = 0 }.a) }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Nat .\y: Rec X. X .y) true ) true) , c =  (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) in (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Rec X. X . false )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y))))
(unfold [ Unit ] (fold [ Bool ] ({a = (let u = (((\x: Rec X. X .\y: Bool .x) (let u = 1 in true) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in u) ))) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = false in u) )) }.b) ))
(let u = (unfold [ Nat ] (fold [ Nat ] (if (if false then true else true) then ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) else ({a = 0 , b = true , c =  0 }.b)) )) in (((\x: Bool .\y: Unit .y) ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = ({a = false , b = 1 }.b) }.a) ) (( \f: Bool .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Unit ] 0 )) ) ) (\a: Nat .\b: Nat .a))))
(( \f: Nat .((f ({a = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c = (let u = true in 1) }.c) , b = (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) }.a) ) (((\x: Nat .\y: Rec X. X .y) (((\x: Bool .\y: Unit .y) (iszero (( \f: Bool .((f 1 ) (unfold [ Bool ] (fold [ Unit ] 1 )) ) ) (\a: Unit .\b: Unit .a))) ) ({a = (unfold [ Rec X. X ] (fold [ Nat ] false )) , b = (let u = true in 0) }.a)) ) (pred (unfold [ Rec X. X ] (fold [ Bool ] 0 )))) ) ) (\a: Bool .\b: Nat .a))
(( \f: Rec X. X .((f (let u = ({a = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Bool .\y: Nat .x) 1 ) (iszero 0)) }.b) in (let u = (if (((\x: Rec X. X .\y: Unit .x) true ) true) then true else (let u = 0 in true)) in (let u = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) in 1))) ) (let u = ({a = (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) in u) ) ) (\a: Nat .\b: Unit .a))
(if (case <r = (if ({a = (fix (\x: Unit . true )) , b = (if true then false else false) }.b) then (fix (\x: Rec X. X . (if true then false else true) )) else (let u = ({a = 0 , b = true , c =  1 }.b) in u)) > as Rec X. X of < l = x > => x | < r = y > => y) then (pred (let u = (let u = (pred 1) in u) in u)) else ({a = (let u = (if (let u = false in false) then (succ 0) else (let u = 0 in 0)) in u) , b = (pred (((\x: Nat .\y: Rec X. X .x) 0 ) false)) }.b))
(fix (\x: Unit . (if (fix (\x: Bool . ({a = false , b = 1 }.a) )) then (((\x: Unit .\y: Nat .x) 0 ) ({a = false , b = true }.b)) else (fix (\x: Bool . (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) ))) ))
(((\x: Bool .\y: Nat .x) ({a = ({a = (fix (\x: Rec X. X . 0 )) , b = (succ (((\x: Unit .\y: Unit .y) true ) 0)) }.b) , b = (fix (\x: Nat . (if false then true else false) )) , c =  ({a = (let u = false in 1) , b = 0 }.b) }.b) ) ({a = ({a = (fix (\x: Rec X. X . (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = ({a = true , b = 0 }.a) , c = (((\x: Rec X. X .\y: Unit .x) 1 ) true) }.c) )) }.b) , b = ({a = (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Rec X. X .y) true ) false) ) ({a = false , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.a)) , b = (if (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) then true else (((\x: Rec X. X .\y: Nat .y) false ) true)) }.b) , c =  (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Unit .x) 1 ) true) )) )) }.b))
(case <r = ({a = (( \f: Unit .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) (case <l = ({a = 1 , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) , b = ({a = true , b = (pred 1) }.a) , c =  ({a = (let u = true in 1) , b = (if true then 0 else 0) }.b) }.b) > as Nat of < l = x > => x | < r = y > => y)
({a = (fix (\x: Rec X. X . ({a = (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Bool .x) false ) false) ) ({a = 0 , b = true }.b)) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) )) , b = ({a = ({a = ({a = (((\x: Nat .\y: Unit .y) false ) true) , b = ({a = 0 , b = 0 }.b) }.b) , b = (let u = (unfold [ Rec X. X ] (fold [ Unit ] true )) in true) , c = (((\x: Nat .\y: Rec X. X .x) (let u = false in 1) ) ({a = false , b = 1 }.a)) }.c) , b = (((\x: Unit .\y: Bool .y) (( \f: Bool .((f true ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .a)) ) (((\x: Nat .\y: Nat .x) (let u = false in u) ) ({a = true , b = 0 }.a))) , c =  (succ (fix (\x: Bool . ({a = 1 , b = (iszero 1) , c = 0 }.c) ))) }.b) }.b)
(case <l = (case <l = (pred (fix (\x: Rec X. X . 1 ))) > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Unit . (let u = (((\x: Unit .\y: Rec X. X .y) (iszero ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) ) ({a = 1 , b = false }.b)) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Bool . (((\x: Bool .\y: Bool .y) false ) 1) )) ))) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Nat .y) true ) 0) in u) )) ))
(succ (((\x: Rec X. X .\y: Nat .x) (let u = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) in (((\x: Nat .\y: Bool .x) 1 ) ({a = 0 , b = false , c =  0 }.b))) ) (((\x: Bool .\y: Nat .y) (( \f: Unit .((f ({a = 0 , b = true }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .b)) ) ({a = 1 , b = false , c =  1 }.b))))
({a = (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .x) ({a = (((\x: Nat .\y: Unit .x) true ) true) , b = 0 }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Nat .\b: Nat .a)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f true ) (let u = true in u) ) ) (\a: Unit .\b: Rec X. X .b)) )) }.b)
(( \f: Nat .((f (((\x: Bool .\y: Nat .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in (((\x: Rec X. X .\y: Nat .y) false ) false)) )) ) (fix (\x: Rec X. X . (let u = 1 in u) ))) ) (( \f: Bool .((f (fix (\x: Nat . (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] 0 )) )) )) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = 0 , b = false }.a) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Nat .\b: Rec X. X .a)) ) (( \f: Rec X. X .((f ({a = 0 , b = 0 }.b) ) (succ (succ 0)) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .a))
(if ({a = ({a = (let u = 0 in u) , b = (if false then ({a = true , b = 1 }.a) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) }.b) , b = (( \f: Nat .((f (((\x: Bool .\y: Nat .x) (fix (\x: Nat . ({a = 0 , b = true , c =  1 }.b) )) ) ({a = true , b = true }.b)) ) ({a = true , b = ({a = 0 , b = true }.a) }.a) ) ) (\a: Unit .\b: Unit .b)) }.b) then ({a = (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) ) (((\x: Nat .\y: Rec X. X .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) true) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (let u = true in 0) , b = (if false then false else false) }.b) }.b) else ({a = (fix (\x: Rec X. X . (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (iszero ({a = 0 , b = true }.a)) }.b) }.b))
(((\x: Rec X. X .\y: Unit .y) ({a = (succ (succ (let u = true in 1))) , b = (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Rec X. X . false )) )) }.b) ) (unfold [ Unit ] (fold [ Rec X. X ] (let u = ({a = (let u = 0 in u) , b = (((\x: Unit .\y: Nat .x) true ) false) }.b) in (let u = (if false then 1 else 0) in 1)) )))
(let u = (let u = ({a = (fix (\x: Rec X. X . 1 )) , b = true }.b) in (((\x: Rec X. X .\y: Unit .x) false ) true)) in ({a = ({a = (((\x: Rec X. X .\y: Bool .x) 1 ) true) , b = ({a = 0 , b = false }.a) }.b) , b = (let u = ({a = 1 , b = false }.a) in ({a = 0 , b = false , c =  0 }.b)) }.b))
({a = (case <r = (( \f: Nat .((f true ) (let u = false in u) ) ) (\a: Unit .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Bool ] (let u = (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .b)) ) 0) in u) )) }.b)
({a = ({a = (((\x: Nat .\y: Bool .y) (let u = true in false) ) false) , b = (succ 1) }.b) , b = ({a = ({a = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (if true then 1 else 0)) , b = ({a = (((\x: Nat .\y: Bool .x) false ) true) , b = (iszero 1) }.b) , c = ({a = 1 , b = 0 }.b) }.c) , b = ({a = (case <l = (((\x: Rec X. X .\y: Bool .y) false ) 1) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Bool ] (fold [ Nat ] false )) in (let u = true in true)) }.b) }.b) , c = (( \f: Nat .((f (( \f: Nat .((f ({a = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) , c = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.c) ) (let u = ({a = 0 , b = false }.b) in (succ 1)) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = ({a = (let u = false in false) , b = 1 }.b) , b = (((\x: Nat .\y: Bool .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) false) , c = (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) }.c) ) ) (\a: Nat .\b: Nat .b)) }.c)
(unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Nat ] true )) )) ))
(((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true , c =  0 }.b) )) ) (((\x: Rec X. X .\y: Nat .x) ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (((\x: Unit .\y: Bool .x) 0 ) ({a = false , b = true }.b)) }.b) ) (((\x: Unit .\y: Nat .x) (fix (\x: Bool . false )) ) (((\x: Unit .\y: Unit .x) true ) true))))
(if ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) (fix (\x: Unit . true ))) , b = (((\x: Unit .\y: Rec X. X .y) true ) (let u = 0 in false)) , c =  ({a = 1 , b = false , c = ({a = 1 , b = 0 }.b) }.c) }.b) then (( \f: Nat .((f (( \f: Nat .((f (iszero 1) ) ({a = true , b = 0 }.a) ) ) (\a: Nat .\b: Nat .b)) ) ({a = ({a = 0 , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Rec X. X .y) false ) false) ) (iszero 0)) }.b) ) ) (\a: Unit .\b: Unit .b)) else (( \f: Rec X. X .((f (let u = ({a = 0 , b = false , c =  1 }.b) in (let u = true in u)) ) (( \f: Unit .((f (((\x: Bool .\y: Nat .y) (unfold [ Unit ] (fold [ Unit ] false )) ) (let u = false in u)) ) (((\x: Rec X. X .\y: Nat .x) ({a = false , b = (succ 0) }.a) ) (fix (\x: Rec X. X . false ))) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Nat .\b: Bool .a)))
(( \f: Bool .((f (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] 0 )) )) in (let u = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Nat .a)) in u)) ) (case <r = (iszero (pred ({a = 1 , b = true , c = 0 }.c))) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a))
(iszero (let u = ({a = (let u = false in u) , b = ({a = 1 , b = true , c = 1 }.c) }.a) in (((\x: Rec X. X .\y: Unit .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (iszero 1))))
({a = ({a = (( \f: Bool .((f ({a = 0 , b = true , c =  1 }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = true , b = (let u = 1 in u) }.a) )) }.b) , b = (if (let u = (((\x: Unit .\y: Bool .x) false ) true) in u) then (unfold [ Nat ] (fold [ Bool ] (let u = 1 in 1) )) else (unfold [ Unit ] (fold [ Unit ] 1 ))) }.a)
(case <l = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (pred (let u = (succ 0) in u)) ) (let u = ({a = (iszero 1) , b = ({a = false , b = 0 }.b) }.a) in (succ 0)) ) ) (\a: Rec X. X .\b: Bool .a))
(( \f: Rec X. X .((f ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false , c =  0 }.b) }.b) ) (( \f: Bool .((f ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) , b = ({a = 1 , b = true }.b) }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = 1 , b = false , c =  1 }.b) in u) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(let u = ({a = (if (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) then ({a = 1 , b = false }.a) else (unfold [ Unit ] (fold [ Nat ] 1 ))) , b = (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . false )) )) , c = (fix (\x: Unit . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) )) }.c) in u)
({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (case <l = ({a = 1 , b = false }.a) > as Nat of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f (if (unfold [ Unit ] (fold [ Bool ] ({a = false , b = ({a = false , b = 0 }.b) }.a) )) then ({a = false , b = (if true then false else true) }.b) else (let u = (unfold [ Nat ] (fold [ Rec X. X ] false )) in (unfold [ Rec X. X ] (fold [ Bool ] false )))) ) (unfold [ Unit ] (fold [ Bool ] (let u = false in ({a = 0 , b = false , c =  1 }.b)) )) ) ) (\a: Bool .\b: Bool .a)) }.a)
(if (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Rec X. X .((f (let u = 1 in false) ) (((\x: Bool .\y: Nat .x) false ) false) ) ) (\a: Bool .\b: Unit .b)) ) ({a = 0 , b = false , c =  ({a = true , b = 0 }.b) }.b)) ) (case <r = (fix (\x: Bool . false )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) then (succ (if (unfold [ Nat ] (fold [ Unit ] false )) then (((\x: Bool .\y: Rec X. X .x) 1 ) (let u = false in false)) else (if false then 1 else 1))) else (if (( \f: Nat .((f ({a = 1 , b = false }.b) ) true ) ) (\a: Unit .\b: Nat .a)) then (let u = false in 1) else (let u = ({a = 0 , b = 1 }.b) in ({a = ({a = false , b = 1 }.b) , b = 1 }.b))))
(((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Bool .y) ({a = ({a = 0 , b = true }.a) , b = ({a = true , b = false }.b) , c =  ({a = 1 , b = 1 }.b) }.b) ) (fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) ))) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (succ 1) )) , b = ({a = (iszero 1) , b = ({a = 1 , b = (let u = true in true) , c =  (pred 1) }.b) }.b) , c =  (if (case <r = ({a = false , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) then (let u = 0 in u) else ({a = 0 , b = 1 }.b)) }.b))
(iszero ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = ({a = false , b = 0 }.a) in 1) )))
(if ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (( \f: Nat .((f (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) then (let u = ({a = (fix (\x: Nat . (fix (\x: Nat . 1 )) )) , b = (if (let u = false in u) then 0 else (pred 0)) }.b) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .x) (let u = 0 in false) ) (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Bool .y) false ) true) ) ({a = 1 , b = true , c =  0 }.b))) ))) else (fix (\x: Bool . ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = false , b = 0 }.a) )) , b = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) }.b) )))
(let u = (( \f: Rec X. X .((f (let u = (fix (\x: Unit . 0 )) in u) ) (fix (\x: Bool . (pred 0) )) ) ) (\a: Bool .\b: Bool .b)) in u)
(unfold [ Unit ] (fold [ Rec X. X ] (if (((\x: Unit .\y: Rec X. X .x) (let u = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) ({a = 0 , b = true , c =  1 }.b)) in u) ) (let u = ({a = 1 , b = false , c =  1 }.b) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )))) then (iszero ({a = 1 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) else (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .b)) ) (iszero 0)) ) (fix (\x: Bool . ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = false in u) )) )) ) ) (\a: Unit .\b: Rec X. X .b))) ))
({a = (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = true , c =  1 }.b) )) )) )) , b = (unfold [ Bool ] (fold [ Bool ] ({a = true , b = 1 }.b) )) }.a)
(pred ({a = (( \f: Nat .((f (((\x: Nat .\y: Unit .x) 0 ) true) ) (succ (let u = 1 in 1)) ) ) (\a: Nat .\b: Nat .a)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) 0 ) true) )) }.b))
((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Bool . ({a = (if true then ({a = 0 , b = false , c =  1 }.b) else (iszero 1)) , b = ({a = 0 , b = 1 }.b) }.a) )) ))
(if (let u = (if (if false then false else true) then ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) else 1) in (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) ({a = false , b = 1 }.a) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ))) then (succ (pred (((\x: Nat .\y: Bool .x) 1 ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)))) else (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) (if false then 1 else 0) ) (unfold [ Bool ] (fold [ Bool ] false ))) )) ) (let u = (((\x: Unit .\y: Bool .x) false ) false) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) false ) 1) ))) ) ) (\a: Bool .\b: Unit .b)))
(let u = (iszero (if ({a = (let u = 1 in u) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) }.b) then (((\x: Nat .\y: Bool .x) 1 ) true) else (((\x: Unit .\y: Bool .x) (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)))) in (let u = (case <r = ({a = (iszero (succ 0)) , b = (( \f: Nat .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) (((\x: Nat .\y: Nat .x) 0 ) false) ) ) (\a: Bool .\b: Rec X. X .b)) }.a) > as Bool of < l = x > => x | < r = y > => y) in (let u = (pred (((\x: Unit .\y: Bool .x) 0 ) false)) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y))))
(case <r = (unfold [ Bool ] (fold [ Bool ] (case <r = (unfold [ Bool ] (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y)
({a = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (let u = false in 1) ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (fix (\x: Nat . (( \f: Unit .((f ({a = false , b = 0 }.a) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .a)) )) , c = (((\x: Bool .\y: Unit .y) (( \f: Unit .((f false ) (unfold [ Bool ] (fold [ Rec X. X ] true )) ) ) (\a: Nat .\b: Nat .a)) ) (case <l = (unfold [ Bool ] (fold [ Nat ] 0 )) > as Bool of < l = x > => x | < r = y > => y)) }.c)
(let u = (let u = (let u = false in (let u = 0 in u)) in u) in ({a = (succ (let u = 1 in u)) , b = (let u = ({a = (fix (\x: Nat . false )) , b = false }.b) in (((\x: Bool .\y: Rec X. X .x) false ) false)) , c = (fix (\x: Rec X. X . (succ 1) )) }.c))
((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) true ) false) )) ))
(succ (let u = ({a = ({a = 1 , b = 1 }.b) , b = false , c = 1 }.c) in (( \f: Unit .((f (let u = ({a = 0 , b = false }.b) in 1) ) ({a = (let u = true in 0) , b = (fix (\x: Rec X. X . true )) }.a) ) ) (\a: Nat .\b: Rec X. X .a))))
(let u = (((\x: Nat .\y: Unit .x) (let u = ({a = false , b = false }.b) in ({a = 1 , b = true }.b)) ) ({a = ({a = true , b = 1 }.a) , b = true }.b)) in ({a = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) in ({a = (succ 1) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) }.a)) , b = (((\x: Nat .\y: Bool .x) (case <r = (unfold [ Bool ] (fold [ Unit ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 1)) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Bool . (let u = 0 in (let u = 0 in u)) )) )) }.b))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (( \f: Bool .((f (let u = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = false }.b) in u) ) (let u = ({a = 1 , b = 0 }.b) in true) ) ) (\a: Nat .\b: Nat .b)) ))
(succ (((\x: Unit .\y: Rec X. X .y) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) ) (((\x: Rec X. X .\y: Nat .y) false ) true) ) ) (\a: Unit .\b: Bool .a)) ) (fix (\x: Unit . (case <l = ({a = 0 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) ))))
(let u = (case <l = (((\x: Unit .\y: Bool .x) ({a = true , b = 1 }.b) ) (let u = true in u)) > as Bool of < l = x > => x | < r = y > => y) in ({a = (let u = ({a = true , b = 0 }.a) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) , b = ({a = (( \f: Nat .((f ({a = 0 , b = true }.a) ) (let u = false in 1) ) ) (\a: Unit .\b: Bool .b)) , b = (case <r = (iszero 0) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.a))
(pred (let u = (succ (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) (if true then 1 else 1) ) ) (\a: Bool .\b: Unit .b)) ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Unit .a))) in u))
(((\x: Bool .\y: Rec X. X .x) (let u = (( \f: Nat .((f (let u = (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) false ) 1) ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) in (succ 0)) ) (( \f: Bool .((f ({a = true , b = 0 }.b) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .b)) in (pred ({a = (((\x: Unit .\y: Bool .x) ({a = false , b = 1 }.a) ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .a))) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.b))) ) (((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .x) (fix (\x: Rec X. X . true )) ) true) ) (((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Unit .y) false ) true) ) (((\x: Nat .\y: Bool .y) false ) true))))
(((\x: Bool .\y: Rec X. X .x) ({a = ({a = ({a = false , b = (((\x: Unit .\y: Rec X. X .y) false ) 0) }.b) , b = (unfold [ Nat ] (fold [ Nat ] true )) }.a) , b = (unfold [ Nat ] (fold [ Bool ] ({a = ({a = true , b = 1 }.a) , b = false }.b) )) , c =  (fix (\x: Rec X. X . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) }.b) ) (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = false , b = 0 }.a) ))))
(let u = (case <r = ({a = true , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) (let u = false in false) ) ({a = 1 , b = true }.b)) )) , b = (pred ({a = (pred 0) , b = true , c = ({a = 1 , b = true }.a) }.c)) }.a)
(pred (let u = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) (let u = 0 in (unfold [ Unit ] (fold [ Bool ] true )))) in (( \f: Nat .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 )) ) ) (\a: Nat .\b: Rec X. X .a))))
(pred (let u = (((\x: Bool .\y: Bool .x) (let u = 0 in 0) ) (((\x: Nat .\y: Unit .y) false ) ({a = false , b = 0 }.a))) in u))
(( \f: Nat .((f (((\x: Nat .\y: Nat .x) (pred (let u = true in (unfold [ Bool ] (fold [ Nat ] 1 )))) ) (((\x: Bool .\y: Rec X. X .y) (let u = 1 in false) ) (fix (\x: Rec X. X . true )))) ) (if (let u = (let u = 1 in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in u) then ({a = (iszero 0) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) else (case <l = ({a = 0 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(let u = (let u = (( \f: Rec X. X .((f (let u = 1 in u) ) (fix (\x: Nat . 1 )) ) ) (\a: Nat .\b: Bool .b)) in (pred (let u = false in 0))) in (let u = (if (((\x: Bool .\y: Unit .y) ({a = false , b = false }.b) ) true) then (( \f: Rec X. X .((f (let u = ({a = 1 , b = 0 }.b) in u) ) (((\x: Nat .\y: Bool .y) true ) 1) ) ) (\a: Unit .\b: Bool .a)) else (( \f: Rec X. X .((f (let u = (if true then true else false) in 1) ) (pred 0) ) ) (\a: Bool .\b: Nat .a))) in u))
(let u = ({a = (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Bool .y) false ) true) ) (let u = 1 in false)) , b = (case <l = (let u = 0 in (if false then 1 else 0)) > as Unit of < l = x > => x | < r = y > => y) }.a) in ({a = (((\x: Nat .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Unit ] ({a = false , b = 1 }.a) )) ) (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] true )) ))) , b = (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = false , c =  1 }.b) ) (iszero 0)) }.b))
(case <r = (let u = ({a = ({a = (((\x: Nat .\y: Rec X. X .y) true ) 1) , b = (if true then true else false) }.b) , b = (let u = false in u) }.b) in u) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (((\x: Bool .\y: Rec X. X .x) (let u = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) in u) ) (unfold [ Nat ] (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) ))) , b = (if (unfold [ Bool ] (fold [ Rec X. X ] (if false then false else true) )) then (let u = true in (((\x: Rec X. X .\y: Nat .y) false ) true)) else ({a = true , b = 1 }.a)) }.b) , b = (let u = (( \f: Unit .((f (fix (\x: Nat . true )) ) (fix (\x: Bool . false )) ) ) (\a: Bool .\b: Bool .b)) in u) }.b)
(( \f: Rec X. X .((f (if ({a = (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b))) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c =  (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) in 0) }.b) then ({a = (fix (\x: Unit . 1 )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.b) else (let u = ({a = 1 , b = false , c = 1 }.c) in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) ) ({a = ({a = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = false }.a) , b = ({a = 0 , b = false , c = 1 }.c) }.b) , b = (if (let u = 0 in true) then (fix (\x: Bool . false )) else (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .b))) , c = (((\x: Nat .\y: Rec X. X .y) (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .y) true ) true) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) (( \f: Unit .((f (((\x: Nat .\y: Nat .x) 0 ) false) ) (if true then 0 else 0) ) ) (\a: Nat .\b: Rec X. X .a))) }.c) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (succ (( \f: Rec X. X .((f (let u = true in 1) ) (unfold [ Unit ] (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Rec X. X .a))) , b = ({a = (((\x: Unit .\y: Unit .y) (let u = true in false) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (((\x: Unit .\y: Bool .y) true ) (fix (\x: Nat . false ))) , c = (if (let u = false in true) then (((\x: Nat .\y: Unit .y) false ) 0) else 1) }.c) }.b)
(((\x: Bool .\y: Bool .y) (( \f: Nat .((f (let u = 1 in (if false then false else false)) ) (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Nat ] (let u = false in u) )) )) ) ) (\a: Rec X. X .\b: Bool .a)) ) (((\x: Rec X. X .\y: Unit .x) (let u = (((\x: Rec X. X .\y: Bool .y) (if true then false else false) ) (let u = 1 in 1)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) ) ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = (let u = false in true) }.b)))
(if ({a = (( \f: Bool .((f (((\x: Nat .\y: Bool .y) false ) true) ) (let u = true in true) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = false , b = (let u = true in 0) }.a) }.b) then (fix (\x: Rec X. X . ({a = (let u = 0 in u) , b = ({a = 1 , b = true }.b) }.a) )) else (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] false )) ) (unfold [ Nat ] (fold [ Rec X. X ] (if false then 1 else 0) )))))
(((\x: Nat .\y: Nat .y) (fix (\x: Bool . (let u = (((\x: Unit .\y: Unit .y) false ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) in u) )) ) (succ (let u = (((\x: Bool .\y: Rec X. X .x) 1 ) false) in u)))
(let u = (( \f: Bool .((f (unfold [ Bool ] (fold [ Unit ] (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ({a = ({a = false , b = false }.b) , b = (let u = 1 in true) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) in (let u = (( \f: Nat .((f ({a = 1 , b = false , c =  0 }.b) ) (if (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .b)) then ({a = true , b = true }.b) else false) ) ) (\a: Unit .\b: Bool .a)) in ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (pred 1) ))))
(let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f (pred 0) ) (((\x: Unit .\y: Unit .x) 0 ) true) ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = false , b = 1 }.b) }.b) )) in u)
(let u = (let u = ({a = (unfold [ Unit ] (fold [ Nat ] true )) , b = (((\x: Bool .\y: Nat .x) false ) (((\x: Bool .\y: Nat .x) true ) false)) }.b) in (case <l = (let u = false in 0) > as Unit of < l = x > => x | < r = y > => y)) in u)
(( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = ({a = true , b = 0 }.a) }.b) )) ) (unfold [ Nat ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (if false then false else true)) )) ) ) (\a: Nat .\b: Bool .a))
(iszero (let u = (( \f: Bool .((f (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .a)) in ({a = (if true then 0 else 0) , b = ({a = ({a = true , b = 0 }.a) , b = (((\x: Nat .\y: Rec X. X .x) false ) false) }.b) , c = ({a = 1 , b = true }.a) }.c)))
(let u = (((\x: Unit .\y: Rec X. X .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) in ({a = true , b = 0 }.a)) )) ) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = ({a = true , b = 0 }.a) , b = 1 }.a) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b)) in (( \f: Bool .((f (succ 0) ) (fix (\x: Bool . ({a = false , b = 0 }.b) )) ) ) (\a: Rec X. X .\b: Nat .a)))
(((\x: Bool .\y: Nat .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f ({a = (let u = true in true) , b = ({a = 1 , b = 1 }.b) }.a) ) (((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Unit .b)) )) ) (unfold [ Nat ] (fold [ Unit ] (fix (\x: Rec X. X . (fix (\x: Bool . 0 )) )) )))
(fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Unit .y) (let u = (let u = 0 in false) in u) ) (let u = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = 1 }.b) in ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (((\x: Rec X. X .\y: Nat .x) true ) true) }.b))) ) (unfold [ Nat ] (fold [ Nat ] (let u = ({a = ({a = 0 , b = true }.a) , b = true }.a) in ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) , b = false }.b)) ))) ))
({a = (pred (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) false ) true) ) (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .a)) ) (if (unfold [ Unit ] (fold [ Bool ] false )) then (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u) else (let u = (succ 1) in u)))) , b = ({a = ({a = false , b = (((\x: Bool .\y: Unit .x) false ) true) }.b) , b = ({a = (pred 1) , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .b)) , c =  (pred 1) }.b) }.b) }.b)
(((\x: Rec X. X .\y: Unit .x) (iszero (( \f: Unit .((f ({a = true , b = 0 }.b) ) (((\x: Nat .\y: Rec X. X .x) 0 ) false) ) ) (\a: Bool .\b: Nat .a))) ) (let u = (unfold [ Bool ] (fold [ Nat ] ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = 1 }.a) )) in (if (((\x: Rec X. X .\y: Unit .x) false ) true) then (if false then false else true) else ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )))))
({a = (((\x: Bool .\y: Nat .x) ({a = (if (if true then (let u = false in false) else false) then ({a = ({a = 0 , b = false }.a) , b = false }.a) else (unfold [ Unit ] (fold [ Nat ] 1 ))) , b = (iszero (((\x: Unit .\y: Bool .x) 0 ) false)) }.b) ) (((\x: Unit .\y: Unit .x) (let u = ({a = 0 , b = false }.b) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] false )) ))) ) (((\x: Nat .\y: Rec X. X .y) ({a = false , b = true }.b) ) ({a = 0 , b = false }.b)))) , b = (pred (( \f: Unit .((f (let u = 1 in (((\x: Unit .\y: Bool .x) 1 ) true)) ) (((\x: Unit .\y: Bool .x) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) (((\x: Unit .\y: Bool .x) false ) false)) ) ) (\a: Unit .\b: Bool .a))) }.a)
({a = (iszero (( \f: Unit .((f ({a = 1 , b = false , c = 0 }.c) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) ) ) (\a: Bool .\b: Rec X. X .a))) , b = (((\x: Unit .\y: Bool .x) (((\x: Unit .\y: Unit .x) (succ (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) ) (fix (\x: Nat . false ))) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = false , b = true }.b) ))) }.a)
(unfold [ Unit ] (fold [ Rec X. X ] (if (let u = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) in (((\x: Rec X. X .\y: Unit .x) true ) false)) then (if ({a = 0 , b = true }.b) then (if true then true else true) else ({a = false , b = 1 }.a)) else (iszero (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .y) false ) 1) )))) ))
({a = (let u = ({a = 0 , b = false , c = 1 }.c) in (unfold [ Nat ] (fold [ Bool ] 0 ))) , b = (( \f: Rec X. X .((f ({a = (if true then false else true) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .y) false ) false) )) }.b) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) in (((\x: Unit .\y: Nat .y) true ) (let u = 0 in true))) ) ) (\a: Rec X. X .\b: Unit .a)) , c =  ({a = (let u = (let u = 0 in u) in ({a = ({a = false , b = 0 }.a) , b = (( \f: Rec X. X .((f (let u = 1 in u) ) 1 ) ) (\a: Nat .\b: Nat .a)) }.b)) , b = ({a = ({a = (iszero 0) , b = ({a = 0 , b = false , c = 1 }.c) }.a) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.a) }.a) }.b)
(let u = ({a = (case <l = (succ ({a = 0 , b = false }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ({a = (let u = true in 0) , b = false }.a) , b = (iszero ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 ))) }.a) }.b) in (let u = ({a = (succ 0) , b = ({a = 0 , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.b) }.a) in u))
(fix (\x: Unit . (if ({a = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) in (succ 0)) , b = (( \f: Bool .((f ({a = false , b = (iszero 1) }.b) ) (unfold [ Rec X. X ] (fold [ Unit ] (let u = true in false) )) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  (unfold [ Bool ] (fold [ Unit ] 0 )) }.b) then ({a = (fix (\x: Nat . ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) )) , b = ({a = (iszero 1) , b = false }.b) }.b) else (unfold [ Nat ] (fold [ Bool ] (iszero ({a = ({a = 1 , b = true }.a) , b = true }.a)) ))) ))
(let u = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (let u = 1 in u) , b = (( \f: Bool .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Bool .a)) ) true ) ) (\a: Unit .\b: Unit .b)) , c = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.c) }.a) in (((\x: Unit .\y: Bool .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .x) false ) false) )) ) (((\x: Nat .\y: Bool .y) (let u = false in (let u = 0 in false)) ) ({a = 0 , b = false }.b))))
({a = ({a = ({a = false , b = 0 }.b) , b = ({a = ({a = 1 , b = 1 }.b) , b = (if ({a = 1 , b = false }.b) then true else true) , c =  (let u = 1 in 1) }.b) , c =  (let u = true in (let u = 1 in 1)) }.b) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) , b = (let u = ({a = 0 , b = false }.b) in (((\x: Bool .\y: Unit .y) false ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)))) , c =  (unfold [ Rec X. X ] (fold [ Nat ] (let u = true in 0) )) }.b) }.b)
({a = (((\x: Nat .\y: Nat .y) ({a = ({a = true , b = 0 }.b) , b = (let u = true in u) , c =  (if (((\x: Rec X. X .\y: Bool .x) true ) false) then 1 else 0) }.b) ) (let u = (let u = ({a = false , b = false }.b) in false) in u)) , b = (( \f: Rec X. X .((f (let u = ({a = (let u = 1 in u) , b = 0 }.b) in u) ) ({a = (let u = 0 in false) , b = ({a = (let u = 0 in false) , b = 1 }.b) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.b)
(fix (\x: Rec X. X . (( \f: Bool .((f (let u = ({a = (let u = 1 in u) , b = true , c = 1 }.c) in (case <r = ({a = false , b = false }.b) > as Bool of < l = x > => x | < r = y > => y)) ) (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) ) ) (\a: Bool .\b: Bool .a)) ))
(( \f: Unit .((f (( \f: Unit .((f (let u = (let u = false in true) in (let u = 1 in true)) ) (((\x: Bool .\y: Bool .y) false ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true ))) ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = ({a = (let u = true in false) , b = (let u = true in 1) }.a) in (( \f: Rec X. X .((f (( \f: Nat .((f ({a = false , b = (fix (\x: Rec X. X . false )) }.b) ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Bool .\b: Unit .b)) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Nat .\b: Nat .a))
(((\x: Bool .\y: Unit .x) (let u = (unfold [ Unit ] (fold [ Bool ] 0 )) in ({a = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = true }.a) , b = ({a = 0 , b = true }.b) , c =  (unfold [ Bool ] (fold [ Unit ] 1 )) }.b)) ) (case <r = (case <r = (fix (\x: Unit . false )) > as Nat of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y))
(let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) )) , b = (succ (((\x: Bool .\y: Unit .x) 0 ) false)) }.b) in (( \f: Bool .((f (pred 0) ) (( \f: Bool .((f (((\x: Unit .\y: Nat .x) 1 ) true) ) ({a = false , b = 1 }.b) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(unfold [ Rec X. X ] (fold [ Bool ] (succ (( \f: Nat .((f (pred 0) ) 1 ) ) (\a: Bool .\b: Nat .a))) ))
(let u = (( \f: Bool .((f ({a = (succ 0) , b = (if true then false else false) }.a) ) ({a = (if (let u = true in true) then (((\x: Bool .\y: Nat .y) false ) 1) else 1) , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .a)) , c = ({a = (fix (\x: Rec X. X . 0 )) , b = false , c = ({a = true , b = 0 }.b) }.c) }.c) ) ) (\a: Bool .\b: Bool .b)) in (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) , b = 0 }.a)))
(fix (\x: Rec X. X . (let u = (succ (if false then 0 else 0)) in u) ))
({a = ({a = (((\x: Nat .\y: Unit .x) (let u = (let u = false in 1) in 0) ) ({a = false , b = 1 }.a)) , b = (if (((\x: Rec X. X .\y: Nat .y) false ) (iszero 1)) then ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = false in true) )) else ({a = true , b = 0 }.a)) , c =  ({a = (((\x: Bool .\y: Bool .y) false ) 0) , b = (pred 0) }.b) }.b) , b = (succ (let u = 1 in 1)) }.a)
(pred (if (((\x: Bool .\y: Rec X. X .y) (let u = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) in true) ) (fix (\x: Unit . (case <r = (let u = false in u) > as Nat of < l = x > => x | < r = y > => y) ))) then ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) )) else (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Bool .x) false ) false) ) (let u = false in u)) ) (((\x: Bool .\y: Rec X. X .x) 0 ) false))))
(unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = ({a = ({a = true , b = 0 }.b) , b = false }.a) , b = (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) (unfold [ Rec X. X ] (fold [ Unit ] true )) ) ) (\a: Bool .\b: Nat .a)) , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.c) in (let u = (( \f: Unit .((f (let u = true in 0) ) (unfold [ Unit ] (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Nat .b)) in u)) ))
(if ({a = ({a = ({a = ({a = true , b = 1 }.a) , b = (( \f: Unit .((f true ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Unit .\b: Bool .a)) }.b) , b = (let u = (let u = ({a = 0 , b = true , c =  1 }.b) in (((\x: Rec X. X .\y: Unit .x) true ) true)) in (let u = (let u = 0 in 1) in u)) }.a) , b = (let u = (( \f: Bool .((f 1 ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) ) ) (\a: Nat .\b: Rec X. X .a)) in (( \f: Bool .((f true ) (let u = true in u) ) ) (\a: Bool .\b: Rec X. X .a))) }.b) then (( \f: Bool .((f ({a = 0 , b = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  0 }.b) ) (( \f: Rec X. X .((f false ) (unfold [ Bool ] (fold [ Unit ] true )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .b)) else (fix (\x: Nat . (let u = (if true then true else true) in u) )))
(((\x: Nat .\y: Nat .y) (( \f: Bool .((f ({a = ({a = 1 , b = false , c =  1 }.b) , b = false }.b) ) (case <r = ({a = false , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.a) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .b)) ) 0) )))
(let u = ({a = (( \f: Unit .((f (( \f: Rec X. X .((f (pred 0) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Bool .\b: Nat .b)) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .b)) , b = (((\x: Unit .\y: Unit .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = true in 1) )) ) (((\x: Unit .\y: Rec X. X .y) (let u = 1 in true) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )))) }.b) in u)
({a = (( \f: Bool .((f (( \f: Rec X. X .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (if (((\x: Unit .\y: Unit .x) false ) false) then false else false) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] true )) )) in (fix (\x: Nat . (if (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .b)) then ({a = 1 , b = false , c = 1 }.c) else (succ 0)) ))) }.b)
(((\x: Nat .\y: Rec X. X .y) ({a = (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) )) , b = (((\x: Rec X. X .\y: Nat .x) ({a = (((\x: Nat .\y: Bool .y) true ) false) , b = false }.b) ) ({a = false , b = true }.b)) }.b) ) ({a = (( \f: Bool .((f (succ 1) ) (if ({a = true , b = 0 }.a) then ({a = 0 , b = false , c = 1 }.c) else ({a = 1 , b = 0 }.b)) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = (fix (\x: Bool . true )) , b = (((\x: Nat .\y: Bool .x) 1 ) false) }.a) }.b))
(iszero (((\x: Bool .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Unit ] (let u = ({a = 1 , b = false , c =  1 }.b) in (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a))) )) ) (unfold [ Nat ] (fold [ Rec X. X ] (pred (((\x: Unit .\y: Bool .y) true ) 1)) ))))
(((\x: Nat .\y: Rec X. X .x) ({a = (if (case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) > as Nat of < l = x > => x | < r = y > => y) then (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) in ({a = (let u = 0 in false) , b = ({a = true , b = 0 }.b) }.b)) else (let u = true in ({a = 0 , b = false , c = 0 }.c))) , b = (iszero ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Rec X. X . 1 )) ))) }.b) ) ({a = (unfold [ Unit ] (fold [ Unit ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Bool ] false )) )) )) )) , b = ({a = (((\x: Unit .\y: Unit .x) false ) (unfold [ Unit ] (fold [ Bool ] false ))) , b = (((\x: Rec X. X .\y: Unit .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) false) }.b) }.b))
(unfold [ Bool ] (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) (let u = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a)) in u) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) )) ))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f ({a = ({a = 0 , b = 1 }.b) , b = true }.a) ) (((\x: Bool .\y: Bool .x) 0 ) true) ) ) (\a: Unit .\b: Rec X. X .a)) )) in u)
({a = (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (iszero (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) )) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .x) 0 ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true ))) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = ({a = true , b = 0 }.a) , b = (( \f: Nat .((f ({a = 0 , b = false , c = 1 }.c) ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Nat .a)) }.a) , c = (pred ({a = 0 , b = true }.a)) }.c) }.a)
(unfold [ Unit ] (fold [ Rec X. X ] (succ (((\x: Nat .\y: Nat .y) ({a = (((\x: Unit .\y: Unit .y) true ) 0) , b = (iszero 0) , c =  (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) }.b) ) (( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) (let u = 0 in 0) ) ) (\a: Rec X. X .\b: Unit .a)))) ))
({a = (fix (\x: Nat . ({a = (((\x: Unit .\y: Nat .x) 0 ) true) , b = (case <r = (fix (\x: Nat . true )) > as Unit of < l = x > => x | < r = y > => y) , c =  (case <l = (((\x: Rec X. X .\y: Bool .y) true ) 1) > as Unit of < l = x > => x | < r = y > => y) }.b) )) , b = (fix (\x: Bool . (unfold [ Bool ] (fold [ Rec X. X ] (let u = 1 in (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) )) )) }.a)
(iszero ({a = (let u = ({a = false , b = 1 }.b) in u) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) in u) )) }.b))
(succ (fix (\x: Nat . ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) }.b) )))
(let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = (( \f: Unit .((f ({a = 1 , b = false }.b) ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = 1 }.b) )) }.a) )) in u)
(fix (\x: Unit . ({a = (fix (\x: Nat . (pred 1) )) , b = (( \f: Rec X. X .((f (if true then true else true) ) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Rec X. X .y) true ) false) , c =  (pred 1) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = ({a = false , b = 0 }.a) , c = (fix (\x: Bool . 1 )) }.c)) }.b) ))
(case <l = (fix (\x: Nat . (if (let u = (if false then 1 else 1) in (fix (\x: Rec X. X . false ))) then (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) else (((\x: Bool .\y: Rec X. X .y) false ) 0)) )) > as Unit of < l = x > => x | < r = y > => y)
(iszero (pred (( \f: Nat .((f ({a = (((\x: Nat .\y: Rec X. X .x) true ) true) , b = 1 }.b) ) (( \f: Bool .((f 0 ) (if false then 1 else 1) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .a))))
(case <r = ({a = (fix (\x: Nat . (((\x: Unit .\y: Nat .x) (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) (let u = (iszero 0) in u)) )) , b = (let u = (iszero 1) in (((\x: Unit .\y: Rec X. X .y) true ) true)) , c =  (unfold [ Rec X. X ] (fold [ Unit ] (if true then 0 else 0) )) }.b) > as Bool of < l = x > => x | < r = y > => y)
({a = (((\x: Bool .\y: Unit .y) (unfold [ Unit ] (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) )) ) (unfold [ Unit ] (fold [ Rec X. X ] false ))) , b = (if ({a = ({a = (((\x: Rec X. X .\y: Bool .x) 1 ) false) , b = 1 }.b) , b = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) }.b) then (unfold [ Rec X. X ] (fold [ Unit ] (if (let u = 1 in true) then ({a = true , b = 0 }.b) else 1) )) else (pred 0)) }.a)
(if (( \f: Unit .((f (iszero (( \f: Nat .((f ({a = 0 , b = false , c = 0 }.c) ) (fix (\x: Nat . 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (iszero 0) ) ) (\a: Rec X. X .\b: Unit .b)) then ({a = ({a = (let u = 0 in u) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c = ({a = 1 , b = true }.a) }.c) , b = ({a = (((\x: Unit .\y: Unit .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) (((\x: Bool .\y: Unit .x) false ) false)) , b = (( \f: Nat .((f 0 ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) , c =  (if ({a = 0 , b = true }.b) then ({a = 1 , b = true }.a) else ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = 0 }.b)) }.b) else (((\x: Unit .\y: Nat .x) (case <r = (((\x: Rec X. X .\y: Rec X. X .x) true ) (let u = true in u)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = ({a = false , b = 1 }.a) in (if false then true else true))))
({a = (( \f: Nat .((f (let u = (pred (let u = 1 in 0)) in (let u = ({a = 0 , b = false }.b) in u)) ) (if (iszero 0) then ({a = 1 , b = false , c =  1 }.b) else (let u = false in true)) ) ) (\a: Nat .\b: Unit .a)) , b = ({a = (let u = (if true then 0 else (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a))) in (if (((\x: Nat .\y: Nat .y) false ) false) then (unfold [ Unit ] (fold [ Nat ] 1 )) else (pred 1))) , b = (( \f: Nat .((f (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) > as Bool of < l = x > => x | < r = y > => y) ) (if (let u = 1 in false) then (((\x: Unit .\y: Nat .y) ({a = false , b = false }.b) ) (if false then false else false)) else (let u = true in false)) ) ) (\a: Bool .\b: Bool .b)) , c =  (( \f: Bool .((f (( \f: Nat .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) (unfold [ Unit ] (fold [ Nat ] (unfold [ Bool ] (fold [ Bool ] 0 )) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) }.b)
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = ({a = ({a = 0 , b = 0 }.b) , b = ({a = false , b = (let u = 1 in u) }.a) , c =  (succ 0) }.b) , b = (let u = (pred 0) in ({a = 0 , b = false , c = 1 }.c)) }.b) ))
(unfold [ Bool ] (fold [ Bool ] ({a = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (iszero 0) }.a) , b = (let u = (let u = true in true) in u) }.a) ))
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) ({a = true , b = 1 }.b)) )) ))
({a = (let u = (iszero (((\x: Bool .\y: Nat .x) 0 ) true)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y) ))) , b = ({a = (succ ({a = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .b)) , b = 1 }.b)) , b = (iszero ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) ))) , c =  (((\x: Nat .\y: Bool .y) (unfold [ Nat ] (fold [ Nat ] (if false then false else true) )) ) (((\x: Unit .\y: Bool .y) false ) 0)) }.b) }.b)
(((\x: Unit .\y: Unit .x) (( \f: Nat .((f (unfold [ Bool ] (fold [ Bool ] ({a = ({a = true , b = (unfold [ Bool ] (fold [ Unit ] 1 )) }.b) , b = (((\x: Rec X. X .\y: Unit .y) ({a = true , b = 0 }.a) ) 1) }.b) )) ) (pred (((\x: Rec X. X .\y: Bool .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)))) ) ) (\a: Nat .\b: Nat .a)) ) ({a = (if (iszero 1) then (fix (\x: Unit . true )) else (if false then true else false)) , b = (((\x: Nat .\y: Rec X. X .y) (iszero 0) ) (let u = 0 in false)) }.b))
(fix (\x: Rec X. X . (fix (\x: Nat . (case <l = (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (((\x: Bool .\y: Unit .y) false ) (let u = false in 0)) ) ) (\a: Nat .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) )) ))
(iszero (((\x: Unit .\y: Unit .y) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .x) false ) false) )) in ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) ) ({a = (fix (\x: Rec X. X . false )) , b = (pred 1) }.b)))
(fix (\x: Unit . ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 1 in true) )) , b = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) 1 ) ) (\a: Bool .\b: Nat .b)) }.a) ))
(if (if (if ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) then ({a = 1 , b = true }.b) else (if false then false else false)) then (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Unit ] false )) )) else (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a))) then (((\x: Nat .\y: Rec X. X .y) (let u = (((\x: Unit .\y: Bool .y) false ) 0) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] false ))) ) (let u = true in 1)) else ({a = (let u = (unfold [ Bool ] (fold [ Unit ] false )) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) , b = ({a = (let u = true in u) , b = (let u = 0 in ({a = true , b = false }.b)) }.b) }.a))
(let u = (if ({a = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) , b = (unfold [ Unit ] (fold [ Bool ] false )) , c =  ({a = (fix (\x: Unit . 1 )) , b = false , c = 0 }.c) }.b) then (if (if true then true else false) then ({a = 0 , b = true }.b) else true) else (let u = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .b)) in u)) in (unfold [ Bool ] (fold [ Nat ] ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) )))
(case <r = ({a = (( \f: Nat .((f ({a = (succ 0) , b = false }.b) ) ({a = true , b = 0 }.a) ) ) (\a: Nat .\b: Bool .b)) , b = ({a = ({a = 1 , b = (((\x: Bool .\y: Unit .x) false ) false) }.a) , b = (let u = true in u) }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .x) true ) false) )) ) (( \f: Rec X. X .((f (fix (\x: Nat . ({a = 0 , b = false , c =  0 }.b) )) ) ({a = true , b = true }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Nat .b)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .y) true ) (let u = 0 in u)) )))
(case <r = ({a = (( \f: Nat .((f (case <r = (let u = 1 in false) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (let u = true in u)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (if (let u = true in u) then (((\x: Nat .\y: Nat .y) true ) 1) else 0) }.a) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Unit .y) (let u = (( \f: Nat .((f ({a = ({a = true , b = true }.b) , b = 1 }.a) ) (iszero 0) ) ) (\a: Bool .\b: Unit .a)) in (((\x: Nat .\y: Nat .y) (( \f: Nat .((f (( \f: Nat .((f false ) (((\x: Nat .\y: Nat .x) false ) false) ) ) (\a: Bool .\b: Unit .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (iszero 1) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = ({a = (let u = true in 1) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) , c =  0 }.b) , b = (( \f: Bool .((f (succ 0) ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Bool .a)) }.a))) ) (pred (((\x: Nat .\y: Rec X. X .x) 0 ) (let u = true in u))))
({a = (if (if ({a = 0 , b = false }.b) then true else (iszero 1)) then (pred (fix (\x: Nat . 0 ))) else ({a = (((\x: Rec X. X .\y: Bool .y) true ) 0) , b = 0 }.b)) , b = (iszero ({a = ({a = (succ 1) , b = true , c =  0 }.b) , b = (pred 1) }.b)) , c = (( \f: Rec X. X .((f ({a = (((\x: Unit .\y: Nat .x) false ) ({a = 0 , b = true , c =  1 }.b)) , b = (pred 0) }.b) ) (case <l = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .b)) , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) }.c)
(let u = (let u = (if (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) then ({a = 0 , b = true , c = 1 }.c) else ({a = 1 , b = true , c = 1 }.c)) in ({a = (let u = (unfold [ Unit ] (fold [ Nat ] false )) in (let u = 1 in u)) , b = (( \f: Unit .((f (let u = false in 1) ) 1 ) ) (\a: Bool .\b: Unit .b)) }.b)) in (((\x: Bool .\y: Nat .x) ({a = 0 , b = false }.b) ) (let u = (( \f: Bool .((f true ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Rec X. X .a)) in ({a = ({a = false , b = true }.b) , b = true }.b))))
(succ (let u = ({a = 1 , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) }.a) in u))
(((\x: Rec X. X .\y: Rec X. X .y) (if ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Unit .x) false ) true) , c =  (let u = 1 in 0) }.b) then ({a = ({a = 0 , b = true }.a) , b = (fix (\x: Unit . ({a = 1 , b = true }.b) )) }.b) else (unfold [ Rec X. X ] (fold [ Nat ] (let u = ({a = 0 , b = 0 }.b) in false) ))) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) 0 ) (iszero 1)) ) (if false then 0 else 1) ) ) (\a: Unit .\b: Unit .a)) )))
(case <r = (((\x: Bool .\y: Bool .x) ({a = (iszero 0) , b = (let u = ({a = 0 , b = 0 }.b) in u) }.a) ) (if (((\x: Unit .\y: Rec X. X .x) false ) false) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) true ) false) )))) > as Nat of < l = x > => x | < r = y > => y)
(let u = ({a = (( \f: Nat .((f ({a = 1 , b = false , c =  0 }.b) ) (let u = (succ 1) in (iszero 0)) ) ) (\a: Nat .\b: Bool .a)) , b = (case <l = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in u)
(let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (pred ({a = 1 , b = false , c = 0 }.c)) )) in (let u = (iszero (((\x: Unit .\y: Unit .y) false ) 0)) in u))
(((\x: Rec X. X .\y: Unit .y) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in true) )) in (let u = (let u = 0 in u) in (((\x: Unit .\y: Rec X. X .y) true ) false))) ) (((\x: Rec X. X .\y: Nat .x) ({a = (unfold [ Nat ] (fold [ Nat ] (unfold [ Nat ] (fold [ Bool ] true )) )) , b = (let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = true }.b) )) in (let u = false in 0)) }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = (if true then false else false) > as Unit of < l = x > => x | < r = y > => y) ))))
(((\x: Nat .\y: Bool .x) ({a = ({a = 0 , b = true , c =  ({a = false , b = 1 }.b) }.b) , b = ({a = (((\x: Unit .\y: Rec X. X .y) true ) false) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) }.b) }.b) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = 1 in false) }.b))
({a = (fix (\x: Nat . ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (let u = 0 in false) }.b) )) , b = (unfold [ Unit ] (fold [ Bool ] (case <r = (let u = 0 in false) > as Unit of < l = x > => x | < r = y > => y) )) }.b)
(if (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = true , b = 1 }.a) in u) )) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = 0 }.b) )) ) ({a = ({a = ({a = false , b = 1 }.b) , b = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) true ) false) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) ) (\a: Nat .\b: Rec X. X .a)) , c =  (let u = 0 in ({a = false , b = 1 }.b)) }.b) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) true ) ({a = false , b = 1 }.a)) , b = ({a = 1 , b = false }.a) }.b) }.b) ) ) (\a: Unit .\b: Unit .b)) else (succ (let u = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .y) false ) true) )) , b = ({a = true , b = 0 }.a) }.b) in (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) in (let u = ({a = false , b = 1 }.b) in u)))))
(let u = (((\x: Nat .\y: Unit .y) (let u = (( \f: Unit .((f (( \f: Nat .((f (iszero 0) ) false ) ) (\a: Unit .\b: Nat .a)) ) (fix (\x: Bool . false )) ) ) (\a: Nat .\b: Nat .b)) in (((\x: Rec X. X .\y: Nat .y) (let u = true in (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) ) (( \f: Bool .((f ({a = true , b = false }.b) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .a)))) ) (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ))) in u)
(unfold [ Bool ] (fold [ Unit ] (succ ({a = (fix (\x: Nat . 0 )) , b = (let u = true in false) , c = ({a = false , b = (fix (\x: Bool . 1 )) }.b) }.c)) ))
(iszero (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) ({a = 1 , b = false , c = 1 }.c) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false }.b) , c = (((\x: Nat .\y: Rec X. X .y) false ) 1) }.c) ) ) (\a: Nat .\b: Rec X. X .b)))
(let u = (((\x: Unit .\y: Bool .x) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = true , b = 0 }.b) )) , b = (case <r = ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = false , c =  1 }.b) > as Bool of < l = x > => x | < r = y > => y) , c = (case <l = (((\x: Rec X. X .\y: Bool .x) 0 ) false) > as Bool of < l = x > => x | < r = y > => y) }.c) ) (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) in (iszero 1))) in (if (((\x: Rec X. X .\y: Rec X. X .y) true ) (((\x: Bool .\y: Rec X. X .y) false ) true)) then ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (succ 0) )) else (if true then 0 else ({a = 1 , b = false , c = 0 }.c))))
(iszero (((\x: Unit .\y: Bool .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (if true then 0 else 0)) )) ) (( \f: Rec X. X .((f (let u = (fix (\x: Rec X. X . false )) in (unfold [ Nat ] (fold [ Unit ] true ))) ) (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) ) ) (\a: Rec X. X .\b: Nat .a))))
(((\x: Unit .\y: Bool .x) ({a = ({a = (fix (\x: Nat . (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 ))) )) , b = (( \f: Rec X. X .((f ({a = ({a = false , b = 0 }.b) , b = ({a = true , b = true }.b) , c =  0 }.b) ) (let u = true in false) ) ) (\a: Bool .\b: Unit .a)) }.a) , b = ({a = (( \f: Nat .((f (((\x: Unit .\y: Unit .y) true ) true) ) true ) ) (\a: Nat .\b: Unit .a)) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.b) }.a) ) (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) (unfold [ Unit ] (fold [ Unit ] ({a = true , b = 1 }.a) )) ) ) (\a: Nat .\b: Nat .a)) )))
({a = (iszero (let u = (fix (\x: Bool . (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) )) in (let u = 0 in 1))) , b = (( \f: Unit .((f ({a = ({a = true , b = 1 }.b) , b = (let u = ({a = 1 , b = false , c = 0 }.c) in u) }.b) ) (let u = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = 1 , b = false }.a)) ) ) (\a: Nat .\b: Nat .a)) }.a)
(case <l = (case <l = ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) false) , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (succ (fix (\x: Unit . (let u = 0 in u) ))) ) (pred ({a = 1 , b = false }.a)) ) ) (\a: Rec X. X .\b: Nat .a))
(unfold [ Nat ] (fold [ Bool ] (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b)) )) > as Nat of < l = x > => x | < r = y > => y) ))
(((\x: Bool .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (if (if true then true else true) then (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .a)) else (let u = 1 in (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .b)))) )) ) (iszero ({a = (succ 1) , b = (let u = 0 in 0) }.b)))
({a = ({a = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) , c = 1 }.c) , b = (case <r = (let u = (((\x: Rec X. X .\y: Nat .x) 1 ) false) in true) > as Unit of < l = x > => x | < r = y > => y) }.a) , b = (if (iszero (let u = 0 in u)) then (if ({a = false , b = true }.b) then ({a = true , b = 0 }.a) else ({a = true , b = false }.b)) else ({a = (let u = true in false) , b = (fix (\x: Unit . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) }.b)) }.a)
(pred (if (( \f: Nat .((f (let u = true in u) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) true ) false) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Bool .b)) then (fix (\x: Rec X. X . 1 )) else (pred (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))))
(fix (\x: Unit . (let u = ({a = (succ ({a = 1 , b = false }.a)) , b = (let u = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) in (let u = false in true)) }.b) in u) ))
({a = (unfold [ Nat ] (fold [ Bool ] ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (if false then true else true) )) )) , b = (( \f: Bool .((f ({a = (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = true }.a) )) , b = (case <r = ({a = (let u = 0 in u) , b = (let u = 0 in true) , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) ) ({a = ({a = (unfold [ Rec X. X ] (fold [ Unit ] true )) , b = (if false then 0 else 0) }.b) , b = (let u = false in ({a = 1 , b = false }.b)) }.b) ) ) (\a: Unit .\b: Nat .b)) }.b)
({a = ({a = ({a = (pred 1) , b = (let u = 0 in 0) }.b) , b = ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , b = (((\x: Unit .\y: Nat .x) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) false) }.b) }.b) , b = (((\x: Rec X. X .\y: Unit .x) (( \f: Unit .((f (let u = false in u) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) )) ) ) (\a: Bool .\b: Nat .a)) ) ({a = (fix (\x: Unit . ({a = 0 , b = false , c = 0 }.c) )) , b = (((\x: Nat .\y: Bool .x) true ) false) , c =  ({a = 0 , b = false , c = 0 }.c) }.b)) }.b)
(( \f: Nat .((f (let u = (let u = ({a = 1 , b = true , c = 0 }.c) in (succ 0)) in ({a = (let u = 1 in u) , b = (fix (\x: Unit . 1 )) }.b)) ) (let u = (fix (\x: Bool . 0 )) in (( \f: Bool .((f (if false then 0 else 1) ) ({a = true , b = 1 }.b) ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Unit .\b: Rec X. X .a))
(let u = (( \f: Rec X. X .((f ({a = (if (((\x: Unit .\y: Bool .x) true ) true) then ({a = (let u = 0 in 0) , b = 1 }.b) else ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = 0 }.b) ))) , b = (let u = true in u) }.a) ) ({a = (( \f: Bool .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = (let u = true in true) , c = ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , c = 0 }.c) }.c) ) ) (\a: Bool .\b: Bool .a)) in u)
(( \f: Bool .((f (let u = (((\x: Nat .\y: Bool .y) ({a = true , b = 0 }.a) ) (fix (\x: Unit . ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 )) ))) in ({a = (succ 0) , b = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) , b = (((\x: Rec X. X .\y: Unit .x) true ) false) }.b) , c =  ({a = 0 , b = 0 }.b) }.b)) ) (((\x: Rec X. X .\y: Nat .x) ({a = (((\x: Unit .\y: Bool .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) true) , b = (let u = 0 in false) }.b) ) (( \f: Nat .((f ({a = (((\x: Nat .\y: Bool .x) 1 ) false) , b = ({a = false , b = true }.b) }.b) ) ({a = false , b = false }.b) ) ) (\a: Bool .\b: Unit .a))) ) ) (\a: Unit .\b: Nat .a))
(((\x: Nat .\y: Bool .y) (let u = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = true , c =  1 }.b) in (let u = ({a = true , b = 0 }.a) in u)) ) ({a = (fix (\x: Nat . (let u = 1 in u) )) , b = ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .a)) , b = true }.b) , c =  (succ ({a = ({a = 1 , b = 1 }.b) , b = (let u = 0 in u) }.b)) }.b))
({a = ({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) in (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .a))) , b = (succ (pred 1)) }.b) , b = ({a = (let u = (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) in (let u = true in 0)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) }.b) , c = (unfold [ Bool ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = false }.b) ) 1) ) (let u = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) in ({a = 0 , b = true }.b))) )) }.c)
(iszero (pred (let u = ({a = 0 , b = 0 }.b) in u)))
(((\x: Bool .\y: Bool .x) (( \f: Unit .((f (let u = ({a = 0 , b = 1 }.b) in u) ) ({a = 1 , b = (let u = 1 in true) }.a) ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = ({a = ({a = 1 , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) }.b) , b = (let u = ({a = 1 , b = true }.b) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b))) }.a) , b = ({a = (let u = (( \f: Rec X. X .((f 1 ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Bool .b)) in (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) , b = (((\x: Rec X. X .\y: Bool .y) (case <r = ({a = false , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 0 , b = true , c =  1 }.b)) , c =  (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = 1 }.b) )) }.b) }.b))
(((\x: Rec X. X .\y: Unit .x) (succ ({a = (succ 0) , b = (pred 1) }.b)) ) (let u = ({a = (( \f: Bool .((f 1 ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Bool .b)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b) in ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) , b = (((\x: Unit .\y: Rec X. X .x) false ) true) }.b)))
(case <l = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] (let u = (succ (fix (\x: Rec X. X . 1 ))) in u) )) )) > as Bool of < l = x > => x | < r = y > => y)
(if (iszero (fix (\x: Unit . 0 ))) then (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Bool .x) (succ 1) ) ({a = ({a = 1 , b = true }.b) , b = (((\x: Nat .\y: Rec X. X .y) true ) 0) }.a)) )) else (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (let u = (if true then 1 else 1) in (fix (\x: Nat . 1 ))) in ({a = (let u = 0 in false) , b = (((\x: Unit .\y: Bool .x) ({a = 1 , b = true }.a) ) (let u = false in true)) }.b)) )))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (if (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = 0 in true) )) in u) then (((\x: Nat .\y: Unit .x) (case <l = (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) then 0 else 1) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)))) else ({a = ({a = 0 , b = false , c = ({a = false , b = 1 }.b) }.c) , b = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Unit ] false )) , c =  (let u = true in 0) }.b) , c = (((\x: Nat .\y: Rec X. X .x) 0 ) (let u = true in true)) }.c)) ))
(let u = (let u = (unfold [ Bool ] (fold [ Unit ] (( \f: Bool .((f (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Bool .b)) ) (let u = (let u = 0 in 1) in false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) in u) in (fix (\x: Rec X. X . (case <r = true > as Bool of < l = x > => x | < r = y > => y) )))
(((\x: Bool .\y: Nat .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (iszero (unfold [ Bool ] (fold [ Unit ] 0 ))) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.b) )) ) (unfold [ Nat ] (fold [ Bool ] (iszero (unfold [ Nat ] (fold [ Bool ] 0 ))) )))
(((\x: Unit .\y: Unit .y) (((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Bool .y) ({a = true , b = true }.b) ) (let u = 0 in true)) ) ({a = ({a = 1 , b = ({a = 0 , b = true , c = 1 }.c) }.b) , b = (((\x: Nat .\y: Unit .y) true ) false) , c =  (((\x: Unit .\y: Bool .x) (fix (\x: Unit . 0 )) ) (let u = false in u)) }.b)) ) ({a = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = false in false)) , b = (pred (fix (\x: Rec X. X . 1 ))) }.a))
(fix (\x: Nat . (((\x: Rec X. X .\y: Bool .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . 0 ))) ))
(unfold [ Rec X. X ] (fold [ Nat ] ({a = (fix (\x: Rec X. X . (let u = (let u = 0 in 0) in u) )) , b = ({a = ({a = (let u = 1 in u) , b = (iszero 0) }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.a) , c =  (succ (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) }.b) ))
(let u = (iszero ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) ))) in u)
({a = (((\x: Rec X. X .\y: Nat .y) (case <r = (( \f: Nat .((f false ) (((\x: Nat .\y: Nat .x) true ) true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (( \f: Bool .((f (let u = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) in (unfold [ Unit ] (fold [ Rec X. X ] false ))) ) (let u = (succ 0) in (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .x) false ) false) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Unit .a)) , c = (if (( \f: Unit .((f (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) true ) false) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Bool .\y: Rec X. X .y) true ) (let u = false in true)) ) ) (\a: Bool .\b: Rec X. X .a)) then (let u = ({a = 1 , b = false }.a) in u) else (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) 0 ) true) ) (let u = true in 0) ) ) (\a: Nat .\b: Rec X. X .b)) in u)) }.c)
(let u = (iszero (pred (unfold [ Unit ] (fold [ Bool ] 0 )))) in ({a = (( \f: Bool .((f (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (pred 0)) ) (unfold [ Bool ] (fold [ Unit ] 1 )) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (fix (\x: Rec X. X . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) }.b))
(let u = ({a = (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Nat . 1 )) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) }.a) in (let u = ({a = (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Rec X. X .y) true ) false) ) (let u = true in u)) , b = (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in (pred 0)) }.a) in u))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f ({a = (let u = false in 0) , b = ({a = ({a = false , b = 0 }.a) , b = ({a = true , b = 0 }.b) }.a) , c = ({a = 1 , b = true , c = 0 }.c) }.c) ) ({a = (iszero 0) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.b) ) ) (\a: Unit .\b: Bool .b)) ))
({a = ({a = ({a = (((\x: Nat .\y: Nat .x) 0 ) (iszero 0)) , b = ({a = 1 , b = false }.b) }.b) , b = (iszero (let u = ({a = false , b = 0 }.a) in 0)) }.b) , b = (let u = ({a = ({a = 0 , b = false , c = 1 }.c) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.b) in (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ))) }.a)
(fix (\x: Rec X. X . (if (iszero (succ 0)) then ({a = (( \f: Rec X. X .((f true ) (let u = 1 in false) ) ) (\a: Bool .\b: Nat .b)) , b = ({a = (if true then true else true) , b = (if false then 1 else 1) }.a) }.b) else (((\x: Bool .\y: Bool .x) ({a = 0 , b = false }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true )))) ))
(unfold [ Nat ] (fold [ Unit ] (succ (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) ))
({a = ({a = (iszero (let u = (fix (\x: Nat . false )) in (pred 0))) , b = (let u = ({a = (iszero 0) , b = (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) > as Nat of < l = x > => x | < r = y > => y) }.b) in (((\x: Unit .\y: Unit .y) (fix (\x: Rec X. X . true )) ) ({a = (let u = 1 in 0) , b = true }.b))) }.b) , b = ({a = (( \f: Unit .((f (let u = 0 in 0) ) (((\x: Nat .\y: Nat .x) (succ 1) ) ({a = true , b = 0 }.a)) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (fix (\x: Bool . (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (let u = false in u)) )) , c = (fix (\x: Rec X. X . ({a = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a))) , b = (iszero (succ 1)) }.a) )) }.c) }.b)
(case <r = (case <r = (let u = ({a = (((\x: Nat .\y: Bool .x) false ) true) , b = 0 }.b) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) ({a = 0 , b = false }.a)) ) (if (iszero 0) then (let u = true in 1) else (((\x: Nat .\y: Bool .x) 1 ) true)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) ) (succ (case <l = ({a = 0 , b = false , c = 0 }.c) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Nat .b))
(fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Rec X. X . (let u = false in u) )) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = (((\x: Nat .\y: Rec X. X .y) true ) true) , b = 0 }.a) ))) ))
(if (if (let u = ({a = 0 , b = false , c =  1 }.b) in (let u = false in u)) then (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) ) (((\x: Nat .\y: Bool .x) false ) true)) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) else (((\x: Rec X. X .\y: Nat .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) ({a = (let u = 0 in 0) , b = true }.b))) then ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Bool .y) (let u = 0 in false) ) (((\x: Rec X. X .\y: Nat .y) false ) false)) )) else (case <r = (((\x: Nat .\y: Nat .y) (iszero (pred 1)) ) (let u = 1 in false)) > as Unit of < l = x > => x | < r = y > => y))
({a = (( \f: Nat .((f (let u = (if ({a = 0 , b = true }.b) then (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) else true) in u) ) (if (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .a)) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) else (unfold [ Bool ] (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) true ) true) ))) ) ) (\a: Nat .\b: Nat .b)) , b = (let u = (let u = ({a = true , b = false }.b) in 0) in u) }.b)
(let u = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (case <r = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) in (let u = (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) > as Unit of < l = x > => x | < r = y > => y) in u))
(fix (\x: Rec X. X . (succ ({a = (let u = 0 in 1) , b = (let u = false in false) , c = (fix (\x: Nat . 0 )) }.c)) ))
(( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] (( \f: Nat .((f (iszero 1) ) true ) ) (\a: Bool .\b: Nat .b)) )) ) (((\x: Bool .\y: Bool .y) ({a = (unfold [ Bool ] (fold [ Bool ] 0 )) , b = ({a = true , b = true }.b) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.b) ) (let u = (fix (\x: Unit . ({a = true , b = false }.b) )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )))) ) ) (\a: Unit .\b: Nat .a))
(if (if ({a = (fix (\x: Rec X. X . 1 )) , b = (let u = true in u) , c =  0 }.b) then (unfold [ Unit ] (fold [ Rec X. X ] (let u = true in false) )) else ({a = 0 , b = false , c =  (((\x: Unit .\y: Rec X. X .y) true ) 0) }.b)) then ({a = (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) ) (((\x: Nat .\y: Nat .x) true ) true)) , b = (unfold [ Nat ] (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] ({a = false , b = 1 }.a) )) )) }.b) else (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Unit .x) ({a = ({a = false , b = true }.b) , b = false }.b) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ({a = (( \f: Nat .((f (((\x: Bool .\y: Unit .x) 1 ) false) ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = (( \f: Unit .((f (let u = true in false) ) true ) ) (\a: Bool .\b: Rec X. X .a)) , c =  (let u = ({a = 0 , b = true , c = 0 }.c) in 1) }.b)))
(let u = ({a = ({a = (unfold [ Bool ] (fold [ Bool ] (let u = true in true) )) , b = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (fix (\x: Unit . false )) else ({a = true , b = 0 }.a)) }.b) , b = (case <r = (if false then false else false) > as Bool of < l = x > => x | < r = y > => y) }.b) in u)
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Rec X. X ] true )) )) ) (iszero (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Unit .a)) )) , b = (pred ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = (succ 0) }.b)) }.a)
(case <r = (unfold [ Unit ] (fold [ Nat ] ({a = ({a = 1 , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (let u = (let u = false in true) in u) , c =  (fix (\x: Nat . (let u = true in 0) )) }.b) )) > as Unit of < l = x > => x | < r = y > => y)
(if ({a = (( \f: Bool .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) ) (if false then 1 else 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (fix (\x: Rec X. X . ({a = true , b = 1 }.a) )) }.b) then ({a = (((\x: Rec X. X .\y: Unit .y) (unfold [ Unit ] (fold [ Rec X. X ] ({a = 1 , b = false }.b) )) ) ({a = 1 , b = 0 }.b)) , b = (if (if true then true else true) then (((\x: Bool .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) true) else (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .a))) , c = (((\x: Rec X. X .\y: Unit .y) false ) ({a = false , b = 1 }.b)) }.c) else (( \f: Nat .((f (let u = (iszero (let u = 0 in 1)) in (let u = (( \f: Nat .((f (pred 1) ) (pred 1) ) ) (\a: Unit .\b: Nat .a)) in u)) ) (let u = (succ 1) in u) ) ) (\a: Bool .\b: Bool .a)))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) in u) , b = (case <r = (fix (\x: Unit . (let u = false in false) )) > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (succ 0) )) , b = (case <r = (fix (\x: Bool . true )) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (if true then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 ))) }.c) }.b) ))
({a = (iszero (let u = 1 in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y))) , b = (( \f: Nat .((f ({a = (fix (\x: Unit . 0 )) , b = true }.a) ) (pred (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(((\x: Rec X. X .\y: Rec X. X .x) (let u = (((\x: Nat .\y: Bool .y) ({a = ({a = (succ 0) , b = false }.b) , b = ({a = (let u = 1 in false) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) }.b) ) ({a = ({a = 1 , b = false , c =  0 }.b) , b = ({a = false , b = 0 }.a) }.b)) in u) ) (iszero (( \f: Bool .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in u) ) ) (\a: Nat .\b: Rec X. X .a))))
(case <l = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in 0) )) , b = (case <r = (( \f: Unit .((f (((\x: Bool .\y: Unit .x) false ) false) ) false ) ) (\a: Bool .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y) , c = ({a = 0 , b = 1 }.b) }.c) > as Nat of < l = x > => x | < r = y > => y)
(case <l = (( \f: Unit .((f (pred ({a = 1 , b = false }.a)) ) (let u = ({a = true , b = 1 }.a) in (pred 0)) ) ) (\a: Nat .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Bool .y) (let u = ({a = ({a = false , b = false }.b) , b = (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) }.a) in (( \f: Nat .((f (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (let u = false in false) ) ) (\a: Rec X. X .\b: Nat .a)) ) (fix (\x: Bool . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Nat .b))) ) (( \f: Bool .((f (let u = (let u = (let u = true in 0) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) in (fix (\x: Unit . false ))) ) (iszero (unfold [ Nat ] (fold [ Nat ] 0 ))) ) ) (\a: Rec X. X .\b: Nat .b)))
(let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = (iszero 1) }.b) )) )) in (let u = (( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Unit .\b: Nat .b)) in (iszero ({a = 1 , b = true , c = 1 }.c))))
(let u = (( \f: Rec X. X .((f (let u = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) in u) ) (if (fix (\x: Unit . false )) then (let u = 1 in u) else (pred ({a = 1 , b = true }.a))) ) ) (\a: Nat .\b: Rec X. X .b)) in (iszero (( \f: Nat .((f (fix (\x: Nat . 0 )) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))))
({a = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in 0) )) , b = (fix (\x: Unit . (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b)) )) }.a) , b = (case <r = ({a = (let u = 0 in 1) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , c =  ({a = 0 , b = true }.a) }.b) > as Unit of < l = x > => x | < r = y > => y) }.b)
({a = (if (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (( \f: Bool .((f (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) (iszero 1) ) ) (\a: Unit .\b: Bool .b)) )) )) then ({a = ({a = true , b = (let u = 1 in false) }.b) , b = (let u = ({a = 1 , b = false }.a) in 0) }.b) else (unfold [ Nat ] (fold [ Unit ] (let u = ({a = 0 , b = 0 }.b) in 1) ))) , b = ({a = (((\x: Nat .\y: Bool .x) (((\x: Nat .\y: Unit .x) 1 ) false) ) (((\x: Unit .\y: Rec X. X .x) false ) false)) , b = ({a = ({a = true , b = 1 }.a) , b = false }.b) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in 0) )) }.b) , c =  (( \f: Rec X. X .((f (fix (\x: Rec X. X . ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) )) ) (( \f: Nat .((f ({a = 0 , b = false , c = 0 }.c) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .b)) }.b)
(unfold [ Unit ] (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) (if false then true else true) ) (let u = 0 in (let u = false in 0))) ))
(if (iszero (fix (\x: Rec X. X . 1 ))) then ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (let u = 0 in true) in (if true then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else true)) )) else ({a = ({a = ({a = 0 , b = true , c = 1 }.c) , b = true , c = ({a = 1 , b = true }.a) }.c) , b = (case <r = (let u = true in false) > as Bool of < l = x > => x | < r = y > => y) , c =  (if false then 1 else (unfold [ Unit ] (fold [ Bool ] 1 ))) }.b))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (succ (fix (\x: Nat . (case <l = (((\x: Bool .\y: Nat .x) 0 ) false) > as Unit of < l = x > => x | < r = y > => y) ))) ))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (fix (\x: Bool . (let u = (iszero 1) in u) )) , b = (((\x: Nat .\y: Unit .y) (let u = false in u) ) (let u = (succ 0) in ({a = false , b = 0 }.a))) }.b) ))
(unfold [ Rec X. X ] (fold [ Nat ] (((\x: Rec X. X .\y: Bool .x) ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (unfold [ Bool ] (fold [ Bool ] 1 )) }.b) ) ({a = (( \f: Unit .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) ) ) (\a: Bool .\b: Unit .a)) , c =  (((\x: Nat .\y: Nat .x) 1 ) (iszero 0)) }.b)) ))
(fix (\x: Bool . (pred (succ 1)) ))
({a = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (((\x: Bool .\y: Unit .y) ({a = 1 , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .a)) }.b) ) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b))) , c = (let u = 0 in 0) }.c) , b = ({a = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Nat .x) 1 ) false) }.a) , b = ({a = (let u = 0 in 0) , b = (((\x: Bool .\y: Unit .y) ({a = true , b = true }.b) ) (let u = 0 in false)) , c = (if (((\x: Bool .\y: Rec X. X .x) true ) true) then (pred 1) else 1) }.c) }.b) }.b)
(((\x: Unit .\y: Nat .y) (case <r = (case <r = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .x) ({a = (unfold [ Bool ] (fold [ Rec X. X ] true )) , b = ({a = (pred 0) , b = (iszero 1) }.a) }.b) ) (((\x: Unit .\y: Rec X. X .x) (let u = 0 in false) ) (case <r = (((\x: Nat .\y: Unit .x) true ) true) > as Unit of < l = x > => x | < r = y > => y))))
({a = (succ (case <l = (if true then 1 else 1) > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = ({a = (fix (\x: Bool . 0 )) , b = (let u = (if true then true else false) in u) }.a) , b = (((\x: Bool .\y: Bool .y) ({a = 1 , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) }.b) ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a))) , c =  ({a = (((\x: Nat .\y: Nat .y) true ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a))) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .a)) }.a) }.b) }.b)
(iszero (((\x: Nat .\y: Unit .y) (let u = ({a = true , b = 1 }.b) in ({a = 0 , b = false , c =  1 }.b)) ) (succ ({a = 1 , b = 0 }.b))))
({a = ({a = ({a = 0 , b = 1 }.b) , b = (unfold [ Unit ] (fold [ Bool ] ({a = false , b = true }.b) )) }.a) , b = (fix (\x: Unit . (let u = (( \f: Nat .((f (((\x: Unit .\y: Nat .x) true ) true) ) false ) ) (\a: Nat .\b: Nat .a)) in ({a = ({a = 0 , b = false }.a) , b = true , c =  (pred 0) }.b)) )) }.b)
(if (let u = (((\x: Rec X. X .\y: Unit .x) (succ 1) ) (fix (\x: Nat . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ))) in (let u = ({a = false , b = false }.b) in u)) then ({a = ({a = ({a = 1 , b = true }.a) , b = false , c =  0 }.b) , b = (((\x: Unit .\y: Nat .x) ({a = false , b = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) }.b) ) ({a = (let u = 0 in false) , b = 1 }.a)) }.b) else ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (case <l = (( \f: Bool .((f 1 ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) )))
({a = ({a = (( \f: Unit .((f 1 ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)) , b = ({a = ({a = (if false then 0 else 1) , b = true }.a) , b = ({a = false , b = 0 }.a) , c =  (((\x: Bool .\y: Rec X. X .x) 1 ) true) }.b) , c = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.c) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = (let u = 0 in true) > as Bool of < l = x > => x | < r = y > => y) )) }.a)
(let u = (pred (( \f: Nat .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = (let u = false in 1) , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a))) in (case <r = (iszero ({a = (fix (\x: Rec X. X . 1 )) , b = true , c = 0 }.c)) > as Nat of < l = x > => x | < r = y > => y))
(((\x: Rec X. X .\y: Nat .x) ({a = ({a = (succ (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = ({a = (unfold [ Unit ] (fold [ Rec X. X ] false )) , b = 0 }.b) }.b) , b = (unfold [ Nat ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) }.b) ) ({a = (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) , b = (iszero (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b))) , c =  ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (let u = false in u) }.a) }.b))
(case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (if true then true else false) )) )) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (( \f: Bool .((f (case <l = (( \f: Unit .((f (pred 1) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) (iszero 0) ) 0) ) ({a = false , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (((\x: Nat .\y: Bool .y) (( \f: Nat .((f (let u = true in u) ) (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) ) (if (((\x: Rec X. X .\y: Unit .y) false ) true) then ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) else ({a = 0 , b = true }.b))) , c = (let u = (((\x: Bool .\y: Bool .y) (let u = false in false) ) (((\x: Rec X. X .\y: Bool .y) (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) (succ 1))) in (unfold [ Nat ] (fold [ Bool ] ({a = (((\x: Nat .\y: Unit .y) false ) false) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ))) }.c)
(unfold [ Nat ] (fold [ Unit ] (let u = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = true , b = 0 }.a) }.b) in u) ))
({a = (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) true ) true) )) )) , b = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = false }.b) )) in u) }.b)
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Bool .\y: Bool .x) 0 ) (let u = false in u)) )) )) , b = ({a = (( \f: Nat .((f (((\x: Nat .\y: Unit .x) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in true) ) (((\x: Nat .\y: Nat .x) true ) (let u = true in false))) ) (iszero (pred 1)) ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Unit .\y: Unit .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) }.a) , c = (( \f: Unit .((f (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (let u = false in 1) , b = (let u = 0 in true) , c = (unfold [ Bool ] (fold [ Bool ] 1 )) }.c) ) ) (\a: Bool .\b: Bool .a)) }.c)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .y) (case <r = (let u = 0 in false) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . (let u = 1 in u) ))) ))
(let u = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Bool . (let u = (let u = false in 0) in (let u = (((\x: Nat .\y: Nat .y) true ) false) in u)) )) )) in ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) true) , b = (( \f: Nat .((f false ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Nat .b)) , c =  (pred 0) }.b))
(let u = (unfold [ Unit ] (fold [ Unit ] (fix (\x: Nat . 1 )) )) in (( \f: Bool .((f ({a = true , b = (let u = false in u) }.b) ) (((\x: Unit .\y: Rec X. X .y) ({a = 1 , b = false , c =  0 }.b) ) ({a = 1 , b = false , c =  0 }.b)) ) ) (\a: Bool .\b: Nat .b)))
({a = (let u = (let u = (((\x: Nat .\y: Nat .y) false ) true) in u) in (succ (( \f: Rec X. X .((f 0 ) (let u = 1 in 0) ) ) (\a: Bool .\b: Bool .a)))) , b = (iszero (( \f: Nat .((f (if true then 1 else 0) ) ({a = true , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .a))) }.a)
(fix (\x: Nat . ({a = (( \f: Nat .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = (((\x: Rec X. X .\y: Unit .x) (if false then false else true) ) ({a = true , b = false }.b)) }.b) ))
(case <l = ({a = ({a = ({a = false , b = 1 }.b) , b = ({a = false , b = true }.b) }.a) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) }.a) > as Bool of < l = x > => x | < r = y > => y)
(let u = (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) true ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (( \f: Bool .((f 0 ) (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = (if false then false else false) in (( \f: Nat .((f false ) ({a = true , b = 1 }.a) ) ) (\a: Nat .\b: Unit .a))) , c = (pred (let u = 0 in 0)) }.c) ))
(fix (\x: Unit . ({a = (((\x: Nat .\y: Nat .y) true ) (unfold [ Unit ] (fold [ Nat ] 0 ))) , b = (((\x: Unit .\y: Unit .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a))) }.b) ))
(((\x: Nat .\y: Unit .x) (let u = ({a = ({a = 0 , b = 0 }.b) , b = (let u = 0 in 0) }.b) in ({a = true , b = (let u = true in u) }.b)) ) ({a = (unfold [ Nat ] (fold [ Rec X. X ] (pred 0) )) , b = (if ({a = ({a = true , b = 0 }.a) , b = true }.b) then ({a = 0 , b = true , c =  1 }.b) else (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.b))
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Nat . (succ 1) )) )) , b = (( \f: Unit .((f (fix (\x: Bool . (succ 1) )) ) (let u = (((\x: Nat .\y: Unit .x) 0 ) true) in u) ) ) (\a: Unit .\b: Nat .a)) }.b)
({a = ({a = (fix (\x: Rec X. X . ({a = (let u = false in true) , b = false }.b) )) , b = ({a = ({a = 1 , b = true }.b) , b = (((\x: Nat .\y: Nat .x) (( \f: Unit .((f (let u = 1 in 0) ) 0 ) ) (\a: Unit .\b: Bool .a)) ) ({a = false , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) }.b)) }.b) }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Rec X. X .y) true ) false) )) }.a)
(unfold [ Unit ] (fold [ Rec X. X ] ({a = (pred ({a = true , b = 1 }.b)) , b = (unfold [ Bool ] (fold [ Bool ] (if false then true else false) )) }.a) ))
(unfold [ Nat ] (fold [ Bool ] ({a = (( \f: Unit .((f (pred (succ 0)) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = ({a = true , b = 1 }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) }.b) }.a) ))
(case <r = (( \f: Rec X. X .((f ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = false }.b) ) (let u = 0 in true) ) ) (\a: Bool .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (if (( \f: Bool .((f (let u = true in u) ) (if true then (iszero 1) else true) ) ) (\a: Bool .\b: Rec X. X .b)) then (case <l = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y) else ({a = (let u = 1 in u) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.b)) ) (pred (( \f: Bool .((f (if ({a = false , b = 0 }.a) then (pred 0) else 0) ) (if (fix (\x: Nat . true )) then (let u = 1 in u) else 1) ) ) (\a: Bool .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Rec X. X .a))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) )) , b = (fix (\x: Rec X. X . (let u = 0 in false) )) }.b) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (((\x: Unit .\y: Bool .x) (unfold [ Bool ] (fold [ Unit ] ({a = ({a = ({a = 0 , b = 1 }.b) , b = true }.a) , b = (if true then true else true) , c = (fix (\x: Unit . 1 )) }.c) )) ) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in 1) )) , b = ({a = true , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) }.b)) ))
(( \f: Nat .((f (let u = (let u = (let u = ({a = (((\x: Unit .\y: Unit .x) true ) false) , b = 0 }.a) in (if false then (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) else 0)) in u) in u) ) (let u = (unfold [ Nat ] (fold [ Rec X. X ] ({a = true , b = 1 }.b) )) in (succ (let u = 0 in 1))) ) ) (\a: Bool .\b: Unit .b))
(case <l = (succ (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Nat .x) (let u = true in u) ) (((\x: Bool .\y: Rec X. X .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) ) (let u = false in u))) ) ({a = (pred 1) , b = (let u = 1 in false) }.a))) > as Bool of < l = x > => x | < r = y > => y)
({a = (if ({a = (iszero 1) , b = (let u = false in false) }.b) then ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) in (pred 1)) , b = (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in false) }.b) else ({a = (let u = ({a = 1 , b = true }.a) in u) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b)) , b = (((\x: Bool .\y: Bool .x) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = (succ (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) }.c) ) (let u = (if (unfold [ Bool ] (fold [ Rec X. X ] true )) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a))) in ({a = ({a = false , b = 1 }.b) , b = true }.b))) }.b)
(let u = ({a = ({a = ({a = (((\x: Unit .\y: Unit .x) 1 ) true) , b = (let u = 1 in u) }.b) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) }.b) , b = (case <r = (( \f: Nat .((f false ) (iszero 1) ) ) (\a: Unit .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) }.a) in u)
({a = (let u = (if ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) , b = 0 }.a) then (unfold [ Nat ] (fold [ Bool ] 1 )) else (let u = 1 in 1)) in u) , b = (if ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (iszero (unfold [ Nat ] (fold [ Nat ] 1 ))) )) then (fix (\x: Nat . ({a = 0 , b = true , c =  0 }.b) )) else (iszero (pred (let u = 1 in 1)))) , c = (((\x: Rec X. X .\y: Unit .y) ({a = (let u = false in false) , b = false }.b) ) ({a = (let u = 1 in u) , b = false }.a)) }.c)
((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] (( \f: Rec X. X .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) (let u = true in false) ) ) (\a: Rec X. X .\b: Bool .b)) )) ))
({a = ({a = (let u = (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Rec X. X .\b: Unit .a)) in (((\x: Unit .\y: Unit .y) true ) 1)) , b = (( \f: Rec X. X .((f true ) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Unit .b)) , c = (pred (if false then 1 else 1)) }.c) , b = (if (let u = 1 in (unfold [ Bool ] (fold [ Nat ] false ))) then (let u = true in u) else (fix (\x: Unit . (if false then true else true) ))) }.a)
(let u = ({a = (pred (((\x: Unit .\y: Unit .x) 0 ) true)) , b = (let u = 0 in false) , c = (unfold [ Nat ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) false ) (let u = 0 in u)) )) }.c) in u)
(( \f: Bool .((f (let u = (let u = ({a = 1 , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) in u) in (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = (let u = 0 in u) , b = ({a = 1 , b = false }.b) , c = 1 }.c))) ) (let u = ({a = (((\x: Bool .\y: Unit .x) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) true) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.a) in ({a = (let u = true in u) , b = (((\x: Nat .\y: Unit .y) true ) 1) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(let u = ({a = (let u = (((\x: Nat .\y: Bool .y) false ) false) in ({a = 0 , b = false }.a)) , b = (let u = ({a = false , b = 1 }.b) in (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) }.b) in ({a = (pred (( \f: Unit .((f ({a = 0 , b = false , c = 1 }.c) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Nat .\b: Unit .b))) , b = (((\x: Bool .\y: Unit .x) (if ({a = 0 , b = false , c =  1 }.b) then (((\x: Bool .\y: Nat .x) true ) true) else false) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) , c =  ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . 1 )) }.b) }.b))
(fix (\x: Unit . (if (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .y) false ) true) )) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b))) then (((\x: Rec X. X .\y: Bool .y) (iszero (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ))) else (if (let u = ({a = true , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.a) in (iszero ({a = 1 , b = true , c = 1 }.c))) then (( \f: Unit .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) (case <r = (if false then true else true) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) else (fix (\x: Unit . ({a = true , b = 0 }.a) )))) ))
(let u = (if (iszero (if true then 0 else 0)) then ({a = ({a = false , b = true }.b) , b = false }.b) else (fix (\x: Nat . true ))) in (unfold [ Nat ] (fold [ Bool ] (fix (\x: Unit . 1 )) )))
(let u = (((\x: Bool .\y: Unit .x) (let u = ({a = (let u = false in u) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a)) }.b) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) ) ({a = ({a = true , b = (((\x: Rec X. X .\y: Unit .y) true ) 1) }.a) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) )) }.a)) in u)
({a = (((\x: Unit .\y: Bool .x) ({a = (unfold [ Unit ] (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] (pred 0) )) )) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) }.b) ) (let u = ({a = 1 , b = false , c =  0 }.b) in (( \f: Unit .((f true ) (let u = 1 in true) ) ) (\a: Nat .\b: Bool .b)))) , b = (if (if (( \f: Rec X. X .((f false ) (((\x: Nat .\y: Rec X. X .y) false ) true) ) ) (\a: Unit .\b: Bool .a)) then ({a = false , b = false }.b) else ({a = false , b = 0 }.a)) then (let u = (let u = (let u = true in 1) in false) in (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) else (if ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) false ) false) )) then ({a = (fix (\x: Nat . 1 )) , b = (fix (\x: Rec X. X . true )) , c =  ({a = 1 , b = false , c = 1 }.c) }.b) else (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) false ) true) ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Unit .a)))) }.b)
(( \f: Nat .((f (iszero ({a = (((\x: Nat .\y: Rec X. X .x) (let u = (let u = 0 in true) in ({a = 0 , b = false }.a)) ) (let u = 1 in (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)))) , b = (( \f: Bool .((f (let u = 0 in false) ) (fix (\x: Rec X. X . false )) ) ) (\a: Rec X. X .\b: Unit .a)) }.a)) ) ({a = (iszero ({a = true , b = 0 }.b)) , b = (case <r = ({a = true , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Unit .a))
({a = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f (let u = false in u) ) (if (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .b)) then ({a = 1 , b = true }.b) else (unfold [ Unit ] (fold [ Unit ] false ))) ) ) (\a: Unit .\b: Nat .b)) ) (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Rec X. X . 1 )) )) in ({a = (let u = 1 in true) , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.a))) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = false in (fix (\x: Nat . 0 ))) ) (if false then (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) else (((\x: Rec X. X .\y: Unit .y) true ) false))) }.b)
({a = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = false , c =  (let u = 0 in u) }.b) in (fix (\x: Unit . 0 ))) )) , b = (case <l = (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (fix (\x: Rec X. X . (if (((\x: Bool .\y: Unit .x) false ) false) then (let u = 0 in u) else 1) )) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Bool . false )) )) ) ({a = (iszero (let u = 0 in u)) , b = ({a = (if true then 1 else 0) , b = true , c = (pred 0) }.c) }.a) ) ) (\a: Rec X. X .\b: Unit .a)) ))
(let u = (let u = ({a = false , b = (let u = 0 in 0) }.a) in (let u = (fix (\x: Bool . 0 )) in u)) in u)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) (if ({a = (if false then 0 else 0) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  1 }.b) then (((\x: Nat .\y: Nat .y) true ) 1) else (succ 1)) ) (((\x: Bool .\y: Rec X. X .x) (let u = false in true) ) (let u = true in u))) ))
(let u = (( \f: Unit .((f ({a = (fix (\x: Bool . 1 )) , b = true }.a) ) (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] (((\x: Unit .\y: Unit .x) 0 ) true) )) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .a)) in (fix (\x: Bool . (( \f: Bool .((f (fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .y) false ) 0) )) ) (let u = 1 in u) ) ) (\a: Nat .\b: Nat .a)) )))
({a = (succ (case <l = (let u = 0 in 0) > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = (let u = (fix (\x: Unit . 0 )) in ({a = (case <r = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = true , b = 1 }.a) }.b)) , b = ({a = (( \f: Unit .((f 0 ) ({a = 1 , b = false }.a) ) ) (\a: Bool .\b: Bool .b)) , b = (fix (\x: Bool . false )) }.a) }.a) , c = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) )) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) )) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b))) ) ) (\a: Bool .\b: Rec X. X .a)) }.c)
({a = ({a = (case <l = (unfold [ Nat ] (fold [ Bool ] 1 )) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = 0 , b = true , c =  1 }.b) in false) )) }.b) , b = ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = false }.a) , b = (if (unfold [ Unit ] (fold [ Nat ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) then ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) else (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b))) }.b) }.b)
(( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) ({a = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = 0 , b = true }.a) }.a) ) (case <l = ({a = false , b = (((\x: Rec X. X .\y: Bool .y) false ) 1) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (succ (( \f: Rec X. X .((f (let u = 1 in u) ) ({a = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = 1 }.b) ) ) (\a: Nat .\b: Bool .a))) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = (iszero (fix (\x: Unit . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) )) ))) , b = ({a = (let u = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .b)) in (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a))) , b = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in u) }.a) }.b)
(case <r = ({a = (unfold [ Rec X. X ] (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] false )) )) , b = ({a = (iszero 0) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) }.a) > as Bool of < l = x > => x | < r = y > => y)
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Bool .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (let u = true in u)) )) , b = (unfold [ Nat ] (fold [ Unit ] ({a = (let u = false in false) , b = (let u = true in true) }.b) )) }.b)
({a = (succ ({a = (case <l = (((\x: Nat .\y: Bool .x) 0 ) true) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Bool ] 1 )) }.b)) , b = (( \f: Nat .((f ({a = (iszero 0) , b = ({a = true , b = 0 }.a) }.b) ) (( \f: Nat .((f (let u = true in u) ) (((\x: Unit .\y: Nat .x) true ) true) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Unit .a)) , c = (((\x: Bool .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (pred 1) }.c) )) )) ) (let u = (if true then 1 else 1) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) false ) true) )))) }.c)
(( \f: Rec X. X .((f ({a = (let u = (let u = ({a = 1 , b = true }.b) in 0) in (((\x: Unit .\y: Bool .y) false ) 1)) , b = (((\x: Nat .\y: Bool .y) ({a = 1 , b = (if true then true else false) }.b) ) (iszero ({a = 0 , b = 1 }.b))) , c =  (( \f: Nat .((f 0 ) (pred 0) ) ) (\a: Unit .\b: Nat .a)) }.b) ) (if ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) )) )) then (let u = ({a = (let u = 1 in false) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) }.a) in u) else (if (let u = (((\x: Bool .\y: Unit .x) false ) true) in false) then ({a = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) , b = true }.b) else (let u = false in u))) ) ) (\a: Nat .\b: Nat .a))
(unfold [ Nat ] (fold [ Bool ] (let u = (let u = (if false then 1 else 1) in u) in u) ))
(iszero (let u = (let u = (((\x: Rec X. X .\y: Unit .x) ({a = false , b = 1 }.b) ) (let u = 0 in true)) in u) in (pred (let u = false in 1))))
(unfold [ Unit ] (fold [ Bool ] ({a = (case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .y) ({a = 1 , b = true }.b) ) 0) )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in false) ))) }.b) ))
({a = (let u = (let u = 1 in 1) in (fix (\x: Rec X. X . 0 ))) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <l = (if true then 0 else 1) > as Nat of < l = x > => x | < r = y > => y) )) }.b)
(((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero ({a = 0 , b = false , c = 1 }.c)) )) ) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = 0 , b = false , c = 0 }.c) , b = (fix (\x: Nat . ({a = 1 , b = false , c = 0 }.c) )) }.b) )) , b = (let u = (if (fix (\x: Unit . false )) then true else ({a = false , b = false }.b)) in u) }.b))
(if (unfold [ Bool ] (fold [ Rec X. X ] (if (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Nat . false ))) then ({a = 1 , b = true }.b) else (unfold [ Bool ] (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] true )) ))) )) then (let u = (let u = 1 in 0) in ({a = ({a = true , b = 1 }.a) , b = (succ 1) }.b)) else (pred (case <l = (pred 1) > as Unit of < l = x > => x | < r = y > => y)))
(((\x: Nat .\y: Nat .y) (case <r = ({a = (((\x: Rec X. X .\y: Nat .x) false ) true) , b = ({a = false , b = false }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) ) (succ (pred (((\x: Bool .\y: Bool .y) false ) 1))))
(case <r = (let u = ({a = ({a = 1 , b = ({a = 1 , b = 1 }.b) }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = 0 in true)) , c =  (fix (\x: Unit . ({a = false , b = 1 }.b) )) }.b) in (( \f: Bool .((f (let u = ({a = true , b = true }.b) in (((\x: Unit .\y: Nat .y) true ) true)) ) ({a = ({a = true , b = 1 }.b) , b = ({a = 1 , b = false , c =  1 }.b) , c =  1 }.b) ) ) (\a: Nat .\b: Nat .b))) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Unit .((f ({a = (pred 0) , b = ({a = (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 ))) , b = ({a = (let u = 1 in true) , b = 1 }.a) , c =  ({a = 1 , b = true }.a) }.b) }.a) ) ({a = ({a = 1 , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b)) }.a) , b = ({a = false , b = (fix (\x: Nat . 1 )) }.a) }.a) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (let u = ({a = ({a = 1 , b = false }.a) , b = (succ 0) }.b) in u) , b = (case <r = (fix (\x: Nat . true )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = (let u = false in (((\x: Unit .\y: Bool .y) false ) 1)) , b = ({a = true , b = true }.b) }.a) )))
(let u = (let u = (((\x: Bool .\y: Nat .y) true ) false) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .x) 1 ) false) ))) in ({a = (if (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = true , c =  0 }.b) )) then (succ ({a = true , b = 1 }.b)) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = 0 in u) ))) , b = (( \f: Nat .((f ({a = 0 , b = (iszero 0) }.b) ) ({a = ({a = false , b = 1 }.b) , b = ({a = true , b = false }.b) }.b) ) ) (\a: Unit .\b: Nat .b)) }.b))
(((\x: Bool .\y: Bool .x) (( \f: Bool .((f (let u = (let u = false in u) in u) ) (fix (\x: Nat . (iszero 0) )) ) ) (\a: Unit .\b: Unit .a)) ) (unfold [ Unit ] (fold [ Unit ] (let u = (pred 1) in (iszero (((\x: Rec X. X .\y: Bool .x) 0 ) true))) )))
(fix (\x: Nat . (pred (if (let u = ({a = (if true then true else true) , b = 1 }.a) in (let u = true in u)) then (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Bool .y) true ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a))) ) (if true then true else false)) else (((\x: Nat .\y: Rec X. X .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (let u = 0 in u)))) ))
({a = (pred (let u = (let u = true in u) in (let u = 0 in u))) , b = (case <r = (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Bool ] false )) )) > as Nat of < l = x > => x | < r = y > => y) }.a)
({a = (( \f: Rec X. X .((f (let u = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) in ({a = 0 , b = true , c = 0 }.c)) ) (pred (pred 1)) ) ) (\a: Bool .\b: Unit .b)) , b = ({a = (if (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .b)) then (fix (\x: Rec X. X . 0 )) else (fix (\x: Rec X. X . (if true then 1 else 1) ))) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = 1 , b = false , c = 1 }.c) )) }.b) }.b)
(case <l = ({a = ({a = (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) else ({a = true , b = 1 }.b)) , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) }.b) , b = (pred 1) }.b) > as Nat of < l = x > => x | < r = y > => y)
({a = (let u = (fix (\x: Nat . (((\x: Nat .\y: Unit .x) 0 ) false) )) in (let u = true in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)))) , b = (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 )) )) ) ({a = (fix (\x: Nat . 1 )) , b = (( \f: Bool .((f (if ({a = 1 , b = true }.b) then (let u = true in false) else (((\x: Bool .\y: Rec X. X .x) true ) false)) ) (unfold [ Unit ] (fold [ Bool ] false )) ) ) (\a: Bool .\b: Bool .a)) , c = (case <l = (unfold [ Nat ] (fold [ Unit ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Bool .\b: Unit .a)) }.b)
(pred ({a = (if ({a = true , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) }.a) then (let u = true in (fix (\x: Bool . 1 ))) else (case <l = (( \f: Bool .((f (fix (\x: Unit . 1 )) ) ({a = false , b = 0 }.b) ) ) (\a: Nat .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = true , b = 1 }.a) )) , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = true , c = 1 }.c) )) }.c))
(unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] (case <r = (fix (\x: Nat . (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y) )) ))
(unfold [ Unit ] (fold [ Nat ] ({a = (( \f: Unit .((f (fix (\x: Nat . (pred 0) )) ) ({a = (let u = true in 0) , b = 1 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = (if false then 1 else 1) , b = (fix (\x: Nat . true )) }.a) }.b) ))
(succ ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (succ ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 ))) )))
(let u = (unfold [ Nat ] (fold [ Nat ] (pred (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ))) )) in ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = ({a = (succ 1) , b = (((\x: Nat .\y: Unit .x) false ) true) , c =  1 }.b) , c =  ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.b))
(case <r = (((\x: Bool .\y: Nat .x) ({a = (((\x: Rec X. X .\y: Unit .y) true ) true) , b = (((\x: Nat .\y: Bool .y) false ) true) }.b) ) (iszero (let u = 1 in u))) > as Nat of < l = x > => x | < r = y > => y)
(let u = (case <l = (succ ({a = (if (iszero 0) then (fix (\x: Bool . 0 )) else (unfold [ Bool ] (fold [ Unit ] 0 ))) , b = (iszero 0) }.a)) > as Unit of < l = x > => x | < r = y > => y) in (fix (\x: Bool . ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = ({a = 0 , b = true , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) }.b) )))
(let u = ({a = (( \f: Nat .((f (let u = 1 in 1) ) (let u = (if false then 1 else 0) in 1) ) ) (\a: Bool .\b: Unit .b)) , b = ({a = (( \f: Rec X. X .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (let u = 1 in u) ) ) (\a: Bool .\b: Unit .a)) , b = (((\x: Unit .\y: Rec X. X .x) true ) ({a = false , b = 0 }.a)) }.b) , c =  (fix (\x: Rec X. X . ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) )) }.b) in ({a = (if ({a = 1 , b = true , c =  1 }.b) then 0 else (let u = true in 0)) , b = (case <r = (let u = 1 in false) > as Unit of < l = x > => x | < r = y > => y) }.b))
(succ ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 0 in u) )))
({a = (if (if (( \f: Bool .((f true ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) then ({a = 0 , b = false , c =  0 }.b) else (((\x: Nat .\y: Bool .x) false ) true)) then (if true then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else false) else (let u = (((\x: Bool .\y: Bool .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )) ) (if true then true else true)) in ({a = 1 , b = true , c =  0 }.b))) , b = (let u = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (if true then true else false) , b = ({a = 0 , b = 1 }.b) }.b) )) in ({a = (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .b)) in u) , b = (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 ))) }.b)) }.a)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (if true then false else (let u = true in true)) )) in u) ))
(fix (\x: Unit . (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f (let u = 1 in 0) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ({a = (fix (\x: Bool . (iszero 0) )) , b = (((\x: Rec X. X .\y: Unit .y) (let u = false in u) ) 0) }.b) ) ) (\a: Nat .\b: Nat .b)) ))
(fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = 0 , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) in (fix (\x: Nat . false ))) )) ) (iszero (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)))) ))
(fix (\x: Unit . ({a = ({a = ({a = 1 , b = true , c = 1 }.c) , b = true , c = 1 }.c) , b = ({a = (((\x: Nat .\y: Rec X. X .y) false ) true) , b = true }.b) }.b) ))
(( \f: Nat .((f ({a = (let u = ({a = ({a = false , b = false }.b) , b = 1 }.b) in u) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) ({a = 1 , b = false , c = 1 }.c) ) ) (\a: Rec X. X .\b: Unit .b)) )) }.b) ) (unfold [ Nat ] (fold [ Bool ] (if ({a = (let u = false in true) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.b) }.b) then (pred ({a = 1 , b = false , c = 1 }.c)) else (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) )) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (pred (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Bool .y) false ) 0) ))) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) }.b)
(case <l = (( \f: Nat .((f (let u = (pred ({a = 1 , b = 0 }.b)) in (pred (let u = true in 0))) ) (( \f: Bool .((f (if true then 1 else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Rec X. X .y) true ) false) in u) ) ({a = ({a = 1 , b = false }.b) , b = ({a = true , b = (fix (\x: Bool . false )) }.b) }.b)) ) (iszero (unfold [ Nat ] (fold [ Bool ] 0 ))) ) ) (\a: Unit .\b: Nat .b))
(let u = (( \f: Nat .((f (((\x: Unit .\y: Bool .y) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .b)) ) (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) in (let u = 0 in 1))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (succ (let u = 0 in u)) )) ) ) (\a: Unit .\b: Nat .b)) in u)
(if ({a = (pred (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Unit .x) 1 ) ({a = true , b = 0 }.a)) ) (fix (\x: Nat . true )))) , b = (iszero (fix (\x: Bool . 1 ))) , c =  (pred (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) }.b) then (unfold [ Nat ] (fold [ Bool ] (iszero (unfold [ Rec X. X ] (fold [ Unit ] 0 ))) )) else (( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Unit .y) true ) 1) , b = (let u = (fix (\x: Bool . true )) in (fix (\x: Unit . true ))) }.b) ) (let u = 1 in (unfold [ Unit ] (fold [ Bool ] true ))) ) ) (\a: Nat .\b: Nat .b)))
(case <l = (succ (let u = (((\x: Nat .\y: Unit .y) true ) 1) in u)) > as Rec X. X of < l = x > => x | < r = y > => y)
(if (( \f: Rec X. X .((f (if (let u = false in u) then (if (let u = false in false) then (fix (\x: Unit . false )) else (let u = 1 in true)) else (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a))) ) (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Rec X. X .b)) then ({a = (( \f: Nat .((f (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b)) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) false) ) ) (\a: Nat .\b: Nat .a)) , b = (unfold [ Bool ] (fold [ Nat ] 1 )) }.a) else (let u = (((\x: Nat .\y: Rec X. X .y) (( \f: Nat .((f (fix (\x: Rec X. X . false )) ) ({a = true , b = ({a = 0 , b = true , c =  0 }.b) }.b) ) ) (\a: Unit .\b: Unit .b)) ) (let u = 1 in (let u = 0 in true))) in ({a = ({a = ({a = 1 , b = true , c = 1 }.c) , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b)) }.b) , b = ({a = true , b = 0 }.b) }.a)))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Nat . (succ (( \f: Rec X. X .((f 1 ) (fix (\x: Bool . 1 )) ) ) (\a: Rec X. X .\b: Bool .a))) )) ))
(succ (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Rec X. X . (let u = true in false) )) ) (( \f: Rec X. X .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a))))
(let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (pred 0) , b = false , c =  1 }.b) )) in (let u = (let u = ({a = (iszero 0) , b = (fix (\x: Rec X. X . true )) }.b) in (if true then 0 else 0)) in (if (let u = true in true) then (let u = false in (fix (\x: Rec X. X . false ))) else (let u = 0 in true))))
(unfold [ Unit ] (fold [ Unit ] (let u = (let u = ({a = ({a = (iszero 1) , b = (pred 1) }.b) , b = (let u = true in false) , c = (let u = 0 in 1) }.c) in (succ (succ 1))) in ({a = (((\x: Bool .\y: Rec X. X .x) 1 ) false) , b = (iszero 1) , c =  (case <l = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) }.b)) ))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .x) ({a = true , b = true }.b) ) (iszero 0)) )) ))
(pred (( \f: Bool .((f (((\x: Nat .\y: Bool .y) (fix (\x: Bool . true )) ) ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Nat .\y: Unit .x) false ) true) }.a)) ) (( \f: Nat .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) (if (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) then (((\x: Unit .\y: Nat .y) false ) 1) else (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a))) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .b)))
(unfold [ Nat ] (fold [ Rec X. X ] (let u = (let u = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) in u) in (fix (\x: Unit . (unfold [ Unit ] (fold [ Nat ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) )) ))) ))
(unfold [ Bool ] (fold [ Unit ] (if (if (((\x: Bool .\y: Rec X. X .y) (let u = false in true) ) (case <r = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y)) then (let u = (iszero (succ 1)) in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) else (((\x: Rec X. X .\y: Bool .y) (let u = true in true) ) ({a = 0 , b = true }.b))) then (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = 0 }.b) )) else (fix (\x: Rec X. X . ({a = (((\x: Unit .\y: Nat .x) true ) false) , b = ({a = 0 , b = true , c = 1 }.c) }.b) ))) ))
(fix (\x: Nat . (( \f: Unit .((f ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = ({a = 0 , b = true }.b) }.a) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = true , b = false }.b) )) , c = (((\x: Nat .\y: Unit .x) 1 ) false) }.c) ) (let u = 0 in u) ) ) (\a: Nat .\b: Nat .a)) ))
({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (case <l = ({a = 0 , b = true , c = 0 }.c) > as Bool of < l = x > => x | < r = y > => y) )) , b = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = false in (((\x: Bool .\y: Bool .x) 0 ) false)) )) in ({a = ({a = 1 , b = true }.b) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.a)) , c = (case <l = (let u = (unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .b)) )) in (if false then (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) else 0)) > as Nat of < l = x > => x | < r = y > => y) }.c)
(succ (pred (let u = 1 in u)))
(( \f: Unit .((f (( \f: Nat .((f ({a = (iszero (succ 0)) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) (let u = true in 1)) }.b) ) (fix (\x: Unit . (pred (let u = 0 in u)) )) ) ) (\a: Bool .\b: Rec X. X .a)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (( \f: Unit .((f (let u = true in u) ) ({a = true , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (if true then 1 else 0) }.b) )) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) )) )) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) )) )))
(((\x: Unit .\y: Rec X. X .y) (case <r = (( \f: Rec X. X .((f (let u = 0 in true) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Nat .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) ) (pred (pred ({a = (pred 1) , b = (let u = 0 in true) }.a))))
(( \f: Nat .((f (let u = ({a = (((\x: Nat .\y: Bool .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) (unfold [ Unit ] (fold [ Unit ] false ))) , b = ({a = 0 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.a) in u) ) ({a = (( \f: Bool .((f ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) , b = ({a = true , b = true }.b) }.b) ) ({a = (((\x: Nat .\y: Bool .y) true ) 1) , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = (iszero 0) }.a) }.b) ) ) (\a: Unit .\b: Nat .b))
({a = (((\x: Nat .\y: Unit .y) (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (let u = 1 in 1) in u)) , b = (if ({a = (if false then true else false) , b = ({a = 1 , b = true , c = 1 }.c) }.a) then (case <r = ({a = 1 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = (let u = false in true) , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .b)) }.b)) }.a)
(fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .x) (case <l = (((\x: Unit .\y: Rec X. X .x) ({a = 1 , b = 1 }.b) ) (if (iszero 0) then true else (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .a)))) > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . (let u = (unfold [ Unit ] (fold [ Nat ] true )) in true) ))) ))
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Nat . (fix (\x: Bool . true )) )) )) )) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .y) ({a = ({a = true , b = 0 }.b) , b = (let u = (((\x: Unit .\y: Nat .y) false ) 1) in (((\x: Bool .\y: Rec X. X .x) false ) true)) }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = ({a = 0 , b = true }.b) }.b) ))) ))
(((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f (( \f: Nat .((f false ) (((\x: Unit .\y: Bool .y) false ) false) ) ) (\a: Nat .\b: Bool .b)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = false , b = 0 }.a) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (pred (( \f: Bool .((f (let u = 1 in u) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = true in (let u = false in 1)) )) ) ) (\a: Bool .\b: Rec X. X .b))))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (let u = ({a = 0 , b = false }.b) in (let u = (((\x: Unit .\y: Rec X. X .x) 0 ) false) in u)) , b = (((\x: Unit .\y: Bool .y) (iszero (fix (\x: Unit . 1 ))) ) (((\x: Bool .\y: Nat .x) true ) false)) , c = (let u = ({a = 0 , b = true , c = 1 }.c) in (let u = false in 0)) }.c) )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = false , b = true }.b) in (((\x: Unit .\y: Unit .x) 1 ) false)) )) }.b)
({a = (unfold [ Nat ] (fold [ Nat ] (iszero ({a = 0 , b = false , c = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.c)) )) , b = (((\x: Bool .\y: Nat .x) (let u = ({a = 0 , b = false }.b) in ({a = 1 , b = (let u = false in true) , c =  (((\x: Bool .\y: Bool .x) 1 ) true) }.b)) ) ({a = ({a = (if true then 0 else 0) , b = ({a = true , b = 1 }.a) }.b) , b = (( \f: Rec X. X .((f 1 ) (((\x: Bool .\y: Rec X. X .y) false ) 1) ) ) (\a: Bool .\b: Rec X. X .b)) }.a)) }.b)
({a = ({a = (((\x: Bool .\y: Nat .y) (if true then true else (let u = true in true)) ) (succ (if false then 0 else 1))) , b = (let u = (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in true) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .a))) in (succ 1)) }.b) , b = ({a = ({a = ({a = ({a = false , b = 1 }.b) , b = (let u = false in false) , c = (pred 1) }.c) , b = (unfold [ Bool ] (fold [ Bool ] false )) }.b) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 0 , b = (if false then false else true) }.b) ) ({a = ({a = true , b = 1 }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (if true then true else false) )) }.b)) }.b) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .x) ({a = (pred (pred 0)) , b = ({a = 0 , b = false }.b) , c = (let u = (iszero 0) in (let u = 1 in 1)) }.c) ) (fix (\x: Unit . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ))) )) }.b)
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (succ (pred 0)) )) , b = ({a = (case <r = (let u = ({a = 1 , b = (let u = 1 in false) , c = 1 }.c) in ({a = false , b = (((\x: Nat .\y: Nat .y) true ) true) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) ({a = true , b = 1 }.a) ) ) (\a: Nat .\b: Nat .a)) }.b) , c =  (( \f: Bool .((f (succ (unfold [ Bool ] (fold [ Bool ] (let u = true in 1) ))) ) (((\x: Nat .\y: Unit .x) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = false , b = 0 }.a) ))) ) ) (\a: Unit .\b: Rec X. X .a)) }.b)
({a = (((\x: Rec X. X .\y: Unit .y) (if ({a = (let u = true in u) , b = (((\x: Bool .\y: Rec X. X .x) true ) false) }.b) then (((\x: Unit .\y: Nat .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Bool .x) true ) false)) else ({a = ({a = 0 , b = true }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) }.b)) ) (fix (\x: Rec X. X . (( \f: Rec X. X .((f (pred 1) ) 0 ) ) (\a: Unit .\b: Nat .b)) ))) , b = (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Nat .y) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Bool .b)) ) (succ 1)) )) }.b)
(((\x: Unit .\y: Bool .y) (if (let u = (if ({a = true , b = true }.b) then (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .a)) else (if false then false else true)) in u) then ({a = (( \f: Nat .((f (let u = false in u) ) (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = false , c =  1 }.b) ) false) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f (let u = false in 0) ) 1 ) ) (\a: Nat .\b: Unit .a)) }.a) else (fix (\x: Unit . (( \f: Bool .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .a)) ))) ) (pred (fix (\x: Bool . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Bool . 1 )) )) ))))
(case <r = (((\x: Bool .\y: Nat .y) (fix (\x: Unit . (if ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) then true else false) )) ) ({a = (case <l = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = false , c =  0 }.b) , c =  (let u = ({a = 0 , b = 1 }.b) in (pred 1)) }.b)) > as Nat of < l = x > => x | < r = y > => y)
({a = (((\x: Bool .\y: Unit .y) (let u = (( \f: Bool .((f (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .a)) ) (let u = 1 in false) ) ) (\a: Unit .\b: Bool .a)) in (((\x: Bool .\y: Bool .y) false ) (unfold [ Rec X. X ] (fold [ Unit ] true )))) ) ({a = (let u = 1 in u) , b = ({a = ({a = 1 , b = false }.a) , b = false }.b) }.a)) , b = (unfold [ Unit ] (fold [ Nat ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) , c =  (if ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Nat .y) false ) false) )) , c =  (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) then (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .b)) else (unfold [ Bool ] (fold [ Unit ] (let u = 0 in u) ))) }.b)
(( \f: Bool .((f (case <l = (succ (( \f: Nat .((f 0 ) (let u = 0 in u) ) ) (\a: Unit .\b: Unit .a))) > as Unit of < l = x > => x | < r = y > => y) ) (let u = ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = ({a = 1 , b = (iszero 1) , c = (pred 0) }.c) }.b) in u) ) ) (\a: Rec X. X .\b: Nat .b))
(iszero ({a = (((\x: Bool .\y: Unit .x) ({a = 1 , b = false }.a) ) ({a = true , b = false }.b)) , b = ({a = ({a = 0 , b = false , c =  1 }.b) , b = 0 }.a) }.a))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false , c =  ({a = 1 , b = false , c = 0 }.c) }.b) in u) ))
(let u = (iszero ({a = (let u = (let u = 0 in 0) in u) , b = ({a = 0 , b = true }.b) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c)) in u)
(pred (( \f: Rec X. X .((f (let u = (let u = 1 in u) in u) ) (case <l = (pred (let u = 1 in u)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)))
({a = (succ (( \f: Nat .((f ({a = 0 , b = 0 }.b) ) ({a = 1 , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .a)) }.a) ) ) (\a: Rec X. X .\b: Bool .a))) , b = (let u = (succ (((\x: Nat .\y: Rec X. X .y) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Unit .\y: Bool .y) true ) 1))) in ({a = ({a = (succ 0) , b = true , c = ({a = 0 , b = true , c = 0 }.c) }.c) , b = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ({a = false , b = 0 }.a) ) ) (\a: Unit .\b: Unit .b)) , c =  (let u = ({a = false , b = false }.b) in (fix (\x: Bool . 1 ))) }.b)) }.b)
(if (( \f: Unit .((f (fix (\x: Nat . ({a = 1 , b = false }.b) )) ) (iszero (if true then 1 else 0)) ) ) (\a: Unit .\b: Unit .a)) then (if ({a = ({a = (let u = (fix (\x: Rec X. X . 1 )) in u) , b = ({a = (let u = false in u) , b = 1 }.a) }.a) , b = ({a = (fix (\x: Rec X. X . ({a = 0 , b = false , c =  0 }.b) )) , b = (unfold [ Unit ] (fold [ Nat ] 1 )) }.a) }.b) then (((\x: Unit .\y: Bool .y) (case <r = (if true then ({a = false , b = false }.b) else true) > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = true in true) ))) else (unfold [ Unit ] (fold [ Bool ] (iszero (( \f: Bool .((f 0 ) (let u = 1 in 0) ) ) (\a: Unit .\b: Bool .b))) ))) else (if (case <r = (((\x: Unit .\y: Rec X. X .x) (iszero 1) ) false) > as Unit of < l = x > => x | < r = y > => y) then (fix (\x: Bool . (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Nat .y) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) true) ) ({a = 0 , b = (iszero 0) }.b)) )) else (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Bool .x) false ) true) ) (((\x: Rec X. X .\y: Nat .y) false ) false))))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Unit .y) (case <r = (let u = false in u) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) )) , b = (( \f: Nat .((f ({a = 0 , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) , c = 0 }.c) ) (let u = true in 0) ) ) (\a: Bool .\b: Unit .a)) }.a)) ))
(if (((\x: Rec X. X .\y: Bool .x) (((\x: Rec X. X .\y: Rec X. X .x) (iszero 0) ) ({a = (succ 0) , b = true }.b)) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true )) )) , b = (pred (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false)) }.a)) then ({a = (( \f: Nat .((f (let u = 0 in 0) ) (pred 0) ) ) (\a: Nat .\b: Bool .a)) , b = (fix (\x: Unit . (((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Bool .y) true ) false) ) (let u = true in true)) )) }.a) else (case <l = (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y))
(( \f: Bool .((f (succ (case <l = (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = true }.a) ) (let u = true in true)) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (case <l = (case <l = (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) )) > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b))
(((\x: Bool .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Bool ] ({a = (succ 0) , b = (((\x: Nat .\y: Nat .x) false ) true) , c =  (case <l = ({a = 0 , b = false , c = 1 }.c) > as Nat of < l = x > => x | < r = y > => y) }.b) )) ) (((\x: Rec X. X .\y: Rec X. X .x) (if (let u = 0 in false) then ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) else (fix (\x: Nat . true ))) ) ({a = ({a = false , b = ({a = 0 , b = false }.a) }.b) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b)))
(unfold [ Bool ] (fold [ Rec X. X ] ({a = (if (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .y) true ) true) )) then (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) else (fix (\x: Nat . false ))) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = (let u = true in 0) in u) )) }.a) ))
(iszero ({a = (succ ({a = ({a = true , b = 1 }.a) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.b)) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in (pred 0)) }.b))
(let u = (unfold [ Bool ] (fold [ Bool ] (if (((\x: Bool .\y: Unit .x) true ) true) then (let u = false in u) else (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .b))) )) in u)
(fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = false }.b) in (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Bool .x) false ) false) ) false)) )) ))
(((\x: Rec X. X .\y: Nat .y) ({a = (if (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) then (unfold [ Bool ] (fold [ Rec X. X ] 0 )) else ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = ({a = 1 , b = false }.b) }.a)) , b = ({a = (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u) , b = (( \f: Unit .((f (iszero 0) ) false ) ) (\a: Unit .\b: Unit .b)) }.b) , c =  (fix (\x: Nat . (let u = (((\x: Unit .\y: Bool .x) 0 ) true) in u) )) }.b) ) (( \f: Rec X. X .((f (( \f: Unit .((f (((\x: Bool .\y: Bool .y) true ) false) ) (let u = 1 in true) ) ) (\a: Bool .\b: Rec X. X .a)) ) (if (let u = 1 in true) then (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) else (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(let u = (let u = (let u = ({a = true , b = 0 }.b) in u) in u) in (fix (\x: Rec X. X . (( \f: Bool .((f ({a = 0 , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) }.b) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Unit .\b: Bool .a)) )))
(iszero (let u = (((\x: Bool .\y: Bool .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Bool .((f (let u = false in true) ) false ) ) (\a: Nat .\b: Rec X. X .b))) in u))
({a = ({a = (case <l = (if (unfold [ Rec X. X ] (fold [ Bool ] (if true then true else true) )) then ({a = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) }.b) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Bool . 1 )) ))) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Rec X. X ] (let u = 1 in false) )) }.a) , b = (((\x: Unit .\y: Bool .x) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .y) true ) true) , c = (unfold [ Nat ] (fold [ Nat ] 0 )) }.c) ) (( \f: Nat .((f (iszero ({a = true , b = 0 }.b)) ) ({a = (fix (\x: Unit . ({a = true , b = 0 }.a) )) , b = (pred 0) }.a) ) ) (\a: Bool .\b: Nat .a))) }.b)
(((\x: Rec X. X .\y: Rec X. X .x) (let u = (succ ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = ({a = 0 , b = false }.a) }.b)) in (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f (((\x: Unit .\y: Unit .y) true ) true) ) (let u = false in true) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = ({a = (succ 0) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.b) , b = (if ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true )) then (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .b)) else true) , c =  ({a = false , b = 1 }.b) }.b))) ) ({a = (let u = (( \f: Bool .((f (let u = 0 in 0) ) (let u = true in 0) ) ) (\a: Rec X. X .\b: Unit .a)) in u) , b = ({a = (let u = 0 in (unfold [ Bool ] (fold [ Rec X. X ] true ))) , b = (if true then false else false) }.b) , c =  ({a = (if false then 1 else 0) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.a) }.b))
(if (case <r = ({a = ({a = false , b = 1 }.b) , b = ({a = true , b = ({a = true , b = 0 }.a) }.b) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b) > as Unit of < l = x > => x | < r = y > => y) then ({a = (let u = (((\x: Bool .\y: Rec X. X .y) true ) 1) in (((\x: Rec X. X .\y: Rec X. X .x) true ) true)) , b = (((\x: Rec X. X .\y: Unit .x) (let u = false in 0) ) ({a = 0 , b = ({a = 1 , b = true }.b) , c =  1 }.b)) }.b) else (if (let u = (fix (\x: Nat . 1 )) in true) then (pred (((\x: Nat .\y: Nat .y) true ) 1)) else (let u = 0 in u)))
(( \f: Nat .((f (((\x: Unit .\y: Unit .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = true , c =  1 }.b) )) ) (( \f: Nat .((f ({a = (let u = false in 0) , b = false }.b) ) (((\x: Bool .\y: Unit .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = false in u)) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) (let u = (let u = (((\x: Unit .\y: Bool .y) ({a = true , b = 1 }.a) ) (((\x: Nat .\y: Rec X. X .y) true ) 1)) in (let u = ({a = ({a = 1 , b = 1 }.b) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) in u)) in (let u = (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = false , c =  0 }.b) ) false) in u)) ) ) (\a: Rec X. X .\b: Nat .b))
(((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f (case <r = (case <r = (let u = true in true) > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Bool .b)) ) (iszero ({a = (case <r = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (if (if true then (fix (\x: Unit . false )) else true) then (((\x: Unit .\y: Bool .x) 1 ) true) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 ))) }.b)))
({a = (( \f: Bool .((f (((\x: Unit .\y: Unit .y) (( \f: Nat .((f (((\x: Unit .\y: Nat .x) true ) true) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = false , b = (((\x: Bool .\y: Unit .y) true ) false) }.b)) ) (let u = (let u = 1 in (((\x: Rec X. X .\y: Rec X. X .y) false ) false)) in u) ) ) (\a: Bool .\b: Unit .a)) , b = (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Bool .((f (fix (\x: Bool . 0 )) ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Bool .b)) ))) }.a)
({a = (case <l = (( \f: Nat .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) (fix (\x: Unit . 0 )) ) ) (\a: Bool .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Bool .\y: Nat .y) (fix (\x: Nat . (if true then false else true) )) ) (( \f: Nat .((f false ) (let u = 0 in false) ) ) (\a: Unit .\b: Bool .a))) in ({a = ({a = false , b = 1 }.b) , b = (((\x: Nat .\y: Rec X. X .x) true ) false) , c = ({a = 0 , b = 1 }.b) }.c)) }.b)
(((\x: Nat .\y: Nat .y) ({a = ({a = (pred (((\x: Unit .\y: Unit .x) 0 ) false)) , b = (let u = false in true) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.b) , b = (unfold [ Unit ] (fold [ Bool ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) }.a) ) (let u = (((\x: Bool .\y: Rec X. X .x) ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = (((\x: Bool .\y: Nat .y) true ) false) }.a) ) (((\x: Nat .\y: Unit .x) false ) true)) in ({a = (((\x: Rec X. X .\y: Bool .y) true ) 1) , b = ({a = false , b = 0 }.a) , c = (((\x: Rec X. X .\y: Bool .y) false ) 1) }.c)))
(if (( \f: Unit .((f (let u = (let u = (pred 1) in u) in (fix (\x: Bool . (if false then true else true) ))) ) (iszero (((\x: Unit .\y: Nat .y) ({a = false , b = false }.b) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) then ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = false in (fix (\x: Unit . 1 ))) )) , b = (((\x: Nat .\y: Rec X. X .x) (let u = ({a = (pred 0) , b = true }.a) in (iszero 0)) ) (let u = (((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) ({a = 0 , b = false }.a)) in ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = true }.b))) }.a) else ({a = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) )) , b = (let u = (let u = false in u) in u) }.a))
(iszero (let u = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = false , c =  0 }.b) )) then ({a = (((\x: Rec X. X .\y: Nat .y) true ) 0) , b = (((\x: Nat .\y: Unit .y) true ) true) , c = ({a = 1 , b = true }.a) }.c) else (( \f: Nat .((f (let u = 1 in u) ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Rec X. X .b))) in (((\x: Nat .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) )) ) (let u = true in u))))
({a = (let u = (( \f: Nat .((f (((\x: Bool .\y: Bool .y) (let u = false in false) ) ({a = 1 , b = 1 }.b)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . ({a = 0 , b = false }.a) )) )) ) ) (\a: Unit .\b: Bool .b)) in u) , b = (((\x: Unit .\y: Nat .x) (iszero (( \f: Rec X. X .((f (fix (\x: Nat . 0 )) ) (pred 0) ) ) (\a: Rec X. X .\b: Unit .a))) ) (((\x: Nat .\y: Rec X. X .x) (if ({a = false , b = 0 }.a) then (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (succ 1) , b = true , c =  (pred 1) }.b))) }.b)
(let u = (iszero (( \f: Nat .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Unit .\b: Unit .b))) in (( \f: Bool .((f (case <r = ({a = ({a = true , b = 0 }.b) , b = ({a = 1 , b = false }.b) , c =  ({a = (fix (\x: Rec X. X . 1 )) , b = false , c = 0 }.c) }.b) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 0 , b = true }.b) )) ) (( \f: Bool .((f false ) (((\x: Unit .\y: Bool .y) true ) false) ) ) (\a: Bool .\b: Unit .b))) ) ) (\a: Unit .\b: Unit .a)))
(unfold [ Bool ] (fold [ Nat ] ({a = (let u = ({a = 1 , b = false , c =  1 }.b) in (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) in 0)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] 1 )) )) }.b) ))
(pred ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (if false then 0 else 1) )) , b = (unfold [ Unit ] (fold [ Unit ] ({a = (let u = (((\x: Bool .\y: Rec X. X .x) true ) false) in 1) , b = (fix (\x: Bool . false )) , c =  (((\x: Nat .\y: Unit .x) 1 ) false) }.b) )) }.a))
(succ (pred (let u = ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = (((\x: Rec X. X .\y: Bool .x) true ) false) }.b) in (let u = (((\x: Nat .\y: Unit .x) 1 ) false) in (let u = 0 in u)))))
(let u = ({a = ({a = ({a = (if false then false else false) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) }.b) , b = (( \f: Nat .((f true ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .a)) }.b) , b = (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) }.a) in (((\x: Nat .\y: Bool .x) (let u = ({a = true , b = 1 }.a) in ({a = false , b = true }.b)) ) (let u = (iszero 0) in (((\x: Nat .\y: Rec X. X .x) true ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Nat .b))))))
(case <r = (((\x: Nat .\y: Bool .y) ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in false) , c =  (pred ({a = 1 , b = 0 }.b)) }.b) ) ({a = (let u = 0 in true) , b = (succ (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(fix (\x: Nat . ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = true , c = 0 }.c) )) , b = (let u = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) in ({a = ({a = 0 , b = true , c = 1 }.c) , b = ({a = 0 , b = false }.b) }.b)) }.a) ))
(if ({a = (iszero ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = true , c = ({a = 0 , b = true , c = 0 }.c) }.c)) , b = (((\x: Nat .\y: Bool .y) (( \f: Unit .((f ({a = 1 , b = true }.b) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = 0 in u)) }.a) then (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Rec X. X .x) (let u = 1 in u) ) ({a = 1 , b = true }.b)) ) ({a = ({a = true , b = false }.b) , b = (pred (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) }.a)) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (succ (pred 1)) )))
(if ({a = (case <l = (if ({a = 1 , b = true , c =  1 }.b) then ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) else (succ 0)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Nat .y) (let u = true in true) ) ({a = false , b = (unfold [ Unit ] (fold [ Bool ] false )) }.b)) , c =  (let u = (((\x: Nat .\y: Rec X. X .y) true ) true) in ({a = 0 , b = false , c = 0 }.c)) }.b) then (let u = (iszero (succ (if true then 0 else 1))) in ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Bool ] 0 )) )) in ({a = 1 , b = false , c =  0 }.b)) ))) else (((\x: Nat .\y: Unit .x) (( \f: Nat .((f (((\x: Nat .\y: Unit .y) true ) (let u = true in false)) ) (if false then ({a = 0 , b = false }.b) else (let u = true in u)) ) ) (\a: Nat .\b: Nat .a)) ) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = false , b = true }.b) }.b)))
(case <l = (let u = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . false )) }.b) in ({a = (case <l = (let u = 1 in 0) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Unit .x) (let u = false in true) ) (((\x: Unit .\y: Unit .y) true ) true)) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(succ (let u = (pred (((\x: Rec X. X .\y: Unit .y) ({a = 0 , b = true , c =  1 }.b) ) 0)) in u))
({a = (( \f: Bool .((f (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .x) 1 ) false) ) 0 ) ) (\a: Nat .\b: Nat .b)) ) (pred 1) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (case <r = ({a = (fix (\x: Unit . ({a = 0 , b = 0 }.b) )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , c =  (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) > as Unit of < l = x > => x | < r = y > => y) }.b)
(fix (\x: Nat . (fix (\x: Unit . (let u = ({a = ({a = 1 , b = false , c =  1 }.b) , b = ({a = 1 , b = 1 }.b) }.a) in (let u = (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) )) in u)) )) ))
(let u = (((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Nat .y) (let u = 1 in true) ) (let u = 1 in true)) ) (((\x: Bool .\y: Nat .x) (let u = 1 in true) ) (fix (\x: Unit . false )))) in (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) in u) )) in (pred (fix (\x: Bool . (pred 0) )))))
({a = (pred (fix (\x: Rec X. X . ({a = 0 , b = 1 }.b) ))) , b = (unfold [ Nat ] (fold [ Nat ] ({a = (let u = (let u = 1 in 1) in ({a = 0 , b = false , c =  0 }.b)) , b = (if ({a = true , b = false }.b) then false else true) }.b) )) }.b)
(let u = (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Nat ] false )) ) (if true then true else true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = false in true) ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Nat .\y: Unit .x) (let u = 1 in true) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b)) )))) in (fix (\x: Nat . (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) ({a = false , b = true }.b) ) false) )) )))
(let u = (((\x: Rec X. X .\y: Rec X. X .x) (let u = (case <r = (if false then false else false) > as Unit of < l = x > => x | < r = y > => y) in u) ) (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = true }.b) )) ) ) (\a: Bool .\b: Nat .b))) in (let u = (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) in u))
(succ ({a = (if (let u = 1 in false) then (fix (\x: Rec X. X . 0 )) else (unfold [ Unit ] (fold [ Nat ] 1 ))) , b = (unfold [ Bool ] (fold [ Unit ] (let u = false in true) )) }.a))
(((\x: Rec X. X .\y: Nat .x) ({a = (fix (\x: Unit . (if false then 1 else 1) )) , b = (fix (\x: Bool . true )) }.a) ) (((\x: Nat .\y: Nat .x) ({a = (succ 1) , b = (((\x: Rec X. X .\y: Unit .x) true ) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b))) }.b) ) ({a = (pred 1) , b = ({a = 1 , b = (let u = true in u) , c =  (pred 1) }.b) }.b)))
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (if (let u = true in u) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) else 0) )) , b = ({a = (pred (let u = 1 in 1)) , b = ({a = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = true }.a) }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) , c =  (let u = (((\x: Unit .\y: Rec X. X .y) (let u = 1 in true) ) 1) in (pred 1)) }.b) }.b) }.a)
(let u = (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = false }.b) )) > as Unit of < l = x > => x | < r = y > => y) in (if ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) (iszero 1)) in (let u = 1 in false)) , b = (succ ({a = true , b = 1 }.b)) }.a) then (((\x: Rec X. X .\y: Nat .y) ({a = true , b = (let u = false in false) }.b) ) (let u = ({a = 1 , b = 0 }.b) in (((\x: Unit .\y: Bool .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (iszero 1)))) else (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Nat .y) (unfold [ Bool ] (fold [ Bool ] true )) ) 1) ))))
(let u = (let u = (unfold [ Unit ] (fold [ Bool ] 0 )) in u) in (let u = (let u = (((\x: Nat .\y: Rec X. X .x) (let u = true in 1) ) true) in (let u = 1 in false)) in (let u = ({a = 0 , b = true }.b) in (( \f: Nat .((f 0 ) (((\x: Rec X. X .\y: Unit .y) false ) 1) ) ) (\a: Nat .\b: Rec X. X .a)))))
(( \f: Rec X. X .((f ({a = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (unfold [ Unit ] (fold [ Unit ] 0 ))) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) (((\x: Bool .\y: Nat .x) false ) false) ) ) (\a: Bool .\b: Unit .a)) )) }.b) ) (fix (\x: Nat . ({a = true , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .b)) }.b) )) ) ) (\a: Rec X. X .\b: Unit .b))
(((\x: Unit .\y: Rec X. X .x) (fix (\x: Unit . (if (unfold [ Nat ] (fold [ Rec X. X ] false )) then (unfold [ Bool ] (fold [ Rec X. X ] (pred 1) )) else ({a = ({a = 0 , b = true , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) }.c) , b = (let u = ({a = false , b = true }.b) in u) , c = (succ 0) }.c)) )) ) (((\x: Rec X. X .\y: Bool .y) ({a = (((\x: Bool .\y: Bool .y) true ) 0) , b = (let u = (let u = true in false) in (iszero 1)) , c =  (let u = (if true then 1 else 0) in (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a))) }.b) ) (fix (\x: Nat . (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ))))
(if (let u = (((\x: Bool .\y: Rec X. X .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) ) false) in u) then (case <r = (unfold [ Unit ] (fold [ Nat ] (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (let u = 1 in true)) )) > as Unit of < l = x > => x | < r = y > => y) else (if (case <r = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = (let u = 1 in false) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = 1 }.b) )) }.a) else ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ))))
({a = (( \f: Unit .((f ({a = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = true , c =  0 }.b) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .b))) , b = (succ (((\x: Rec X. X .\y: Nat .x) 1 ) true)) }.b) ) (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = 0 }.b) )) ) ) (\a: Nat .\b: Bool .a)) , b = (iszero (((\x: Unit .\y: Unit .x) (succ 0) ) (unfold [ Unit ] (fold [ Bool ] true )))) }.b)
(case <r = (iszero ({a = (let u = true in 0) , b = (if (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b)) then false else (let u = 0 in true)) }.a)) > as Unit of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = ({a = (((\x: Unit .\y: Unit .y) (if true then true else false) ) (let u = 1 in 1)) , b = (( \f: Rec X. X .((f (fix (\x: Unit . false )) ) (((\x: Nat .\y: Rec X. X .y) true ) false) ) ) (\a: Bool .\b: Bool .a)) }.b) , b = (((\x: Nat .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = 0 in false) )) ) (pred 0)) }.b) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = (( \f: Bool .((f (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )) in u) ) ({a = (let u = false in 1) , b = (((\x: Unit .\y: Rec X. X .x) false ) true) , c = 0 }.c) ) ) (\a: Unit .\b: Bool .b)) , b = ({a = (((\x: Unit .\y: Unit .y) true ) true) , b = (succ 1) }.a) , c = (case <l = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.c) ))
({a = ({a = (fix (\x: Rec X. X . ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.b) )) , b = (let u = 0 in true) , c = (let u = (let u = 1 in u) in ({a = 1 , b = false }.a)) }.c) , b = (( \f: Unit .((f (let u = (((\x: Bool .\y: Rec X. X .y) false ) 1) in (((\x: Unit .\y: Rec X. X .x) true ) false)) ) (( \f: Rec X. X .((f ({a = (let u = true in u) , b = 1 }.a) ) ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.b) ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .a)) , c = (case <l = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (pred 0) )) > as Unit of < l = x > => x | < r = y > => y) }.c)
({a = (((\x: Unit .\y: Bool .y) (let u = ({a = 1 , b = false }.b) in u) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ))) , b = (case <r = (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = false , b = true }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (let u = true in u) , b = (let u = 0 in false) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(( \f: Unit .((f (iszero (( \f: Nat .((f ({a = 0 , b = 1 }.b) ) (fix (\x: Nat . ({a = (pred 1) , b = true , c = ({a = 1 , b = true , c = 0 }.c) }.c) )) ) ) (\a: Rec X. X .\b: Bool .b))) ) (((\x: Bool .\y: Rec X. X .x) ({a = (let u = 1 in u) , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.b) ) (let u = (fix (\x: Rec X. X . ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) in ({a = (let u = 1 in false) , b = (fix (\x: Rec X. X . false )) }.b))) ) ) (\a: Rec X. X .\b: Rec X. X .a))
({a = (iszero (case <l = (let u = ({a = true , b = true }.b) in ({a = 0 , b = false }.a)) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = (((\x: Bool .\y: Bool .x) ({a = ({a = 0 , b = false , c = 1 }.c) , b = false }.b) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (if ({a = (fix (\x: Rec X. X . 0 )) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) , c =  (fix (\x: Unit . 1 )) }.b) then (unfold [ Rec X. X ] (fold [ Bool ] ({a = false , b = true }.b) )) else (let u = (((\x: Bool .\y: Bool .y) false ) false) in ({a = 0 , b = false }.b))) }.b) }.b)
(let u = ({a = (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) ({a = 0 , b = false , c =  0 }.b) ) false) ) (let u = (let u = 0 in 1) in false) ) ) (\a: Nat .\b: Nat .b)) , b = (pred (fix (\x: Rec X. X . (( \f: Bool .((f ({a = 1 , b = true , c = 1 }.c) ) 1 ) ) (\a: Unit .\b: Unit .b)) ))) }.b) in (let u = (((\x: Bool .\y: Rec X. X .x) ({a = (let u = 0 in 0) , b = (if false then 0 else 0) }.b) ) (((\x: Bool .\y: Rec X. X .x) (let u = true in u) ) true)) in (let u = ({a = (if false then 1 else 0) , b = (((\x: Bool .\y: Nat .y) (if true then true else false) ) true) , c =  ({a = (pred 1) , b = false }.a) }.b) in ({a = (let u = true in false) , b = ({a = 1 , b = 1 }.b) }.b))))
({a = (case <l = (let u = (((\x: Bool .\y: Nat .x) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = 1 , b = true , c =  (fix (\x: Rec X. X . 1 )) }.b)) in u) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] (let u = false in u) )) )) , c =  (((\x: Bool .\y: Rec X. X .x) (( \f: Rec X. X .((f (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) then (((\x: Nat .\y: Nat .y) false ) 0) else 1) ) (( \f: Rec X. X .((f 0 ) (succ 1) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = 0 , b = false , c =  (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) }.b))) }.b)
(let u = (let u = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 1 )) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Rec X. X .a)) }.a) in ({a = (if true then 1 else 1) , b = ({a = (iszero 1) , b = true }.b) , c =  (succ 0) }.b)) in (fix (\x: Unit . ({a = (if true then true else false) , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) }.b) )))
({a = ({a = (case <l = (( \f: Nat .((f (pred 1) ) (( \f: Rec X. X .((f (pred 0) ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f (pred (let u = 0 in 0)) ) (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] 0 )) )) ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (((\x: Nat .\y: Bool .x) (let u = false in u) ) (((\x: Unit .\y: Unit .x) false ) true)) , c =  (if (fix (\x: Nat . (let u = true in false) )) then ({a = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a))) , b = (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = false , c = 0 }.c) ) (let u = true in true)) }.b) else (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Bool .y) true ) true) ) 1) ))) }.b)
({a = ({a = (let u = (((\x: Unit .\y: Nat .y) (iszero 1) ) true) in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a))) , b = (((\x: Unit .\y: Bool .x) (let u = true in false) ) (case <r = ({a = true , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) , b = (fix (\x: Nat . ({a = true , b = (fix (\x: Nat . true )) }.b) )) }.b)
({a = (pred (let u = (pred 1) in u)) , b = (let u = (let u = (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Unit .y) false ) 0) else 1) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) in (( \f: Unit .((f ({a = 1 , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) }.b) ) (unfold [ Unit ] (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Unit .a))) }.b)
(fix (\x: Rec X. X . (((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Nat .y) (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) )) ) (( \f: Bool .((f (let u = (pred 1) in false) ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Nat .b))) ) (let u = (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in u) in (fix (\x: Nat . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )))) ))
(if (fix (\x: Bool . ({a = ({a = (fix (\x: Bool . 1 )) , b = ({a = 0 , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.b) }.a) , b = (let u = ({a = ({a = 1 , b = false }.b) , b = false }.b) in u) , c =  ({a = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .b)) , b = 1 }.b) }.b) )) then (case <l = (((\x: Unit .\y: Bool .x) (( \f: Nat .((f (let u = 1 in u) ) (((\x: Bool .\y: Unit .x) 0 ) true) ) ) (\a: Bool .\b: Rec X. X .a)) ) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Unit .y) false ) (let u = true in false)) ))) > as Unit of < l = x > => x | < r = y > => y) else (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Unit ] (if false then 0 else 1) )) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Bool .\b: Rec X. X .a)) )) in u))
(( \f: Unit .((f (((\x: Nat .\y: Rec X. X .y) (iszero (unfold [ Bool ] (fold [ Unit ] 1 ))) ) (pred 0)) ) (pred (case <l = (let u = (let u = true in false) in (let u = true in 0)) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (if (iszero (let u = 0 in 0)) then (((\x: Bool .\y: Nat .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = ({a = false , b = 0 }.a) }.b)) else ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) false) , b = ({a = ({a = 0 , b = true }.a) , b = ({a = 0 , b = false }.b) , c =  ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b) }.a)) in ({a = (pred ({a = 1 , b = ({a = true , b = 1 }.a) , c = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) }.c)) , b = ({a = (iszero 0) , b = (fix (\x: Bool . 0 )) }.b) }.b))
(succ ({a = (let u = ({a = 1 , b = true , c = 0 }.c) in (let u = 0 in 1)) , b = (let u = (( \f: Nat .((f (let u = 0 in false) ) ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = (let u = false in true) , c =  (((\x: Unit .\y: Rec X. X .x) 1 ) false) }.b) ) ) (\a: Nat .\b: Nat .a)) in (let u = (let u = true in 1) in false)) }.a))
(( \f: Rec X. X .((f ({a = (let u = (fix (\x: Nat . (let u = false in 1) )) in u) , b = (if true then (iszero 0) else true) , c = ({a = true , b = ({a = 0 , b = false }.a) }.b) }.c) ) (if (if false then true else false) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 )) else (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) 1 ) true) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = (fix (\x: Unit . 1 )) in (if true then true else true)) )) , b = (let u = (let u = ({a = (let u = ({a = 0 , b = 0 }.b) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 ))) , b = (let u = false in u) }.a) in (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )))) in u) }.a)
(unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f ({a = (let u = false in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) , b = (succ 0) }.b) ) (let u = (pred (let u = ({a = 1 , b = false }.a) in u)) in u) ) ) (\a: Bool .\b: Bool .a)) ))
(let u = (let u = (unfold [ Nat ] (fold [ Unit ] (case <r = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) )) in u) in u)
(((\x: Nat .\y: Bool .x) ({a = (fix (\x: Unit . (if false then 0 else 0) )) , b = (let u = ({a = (((\x: Rec X. X .\y: Nat .y) true ) true) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) }.b) in ({a = 0 , b = ({a = 1 , b = false }.b) , c =  (((\x: Bool .\y: Nat .y) false ) 0) }.b)) , c =  (fix (\x: Bool . ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) , c = (fix (\x: Rec X. X . 1 )) }.c) )) }.b) ) (( \f: Rec X. X .((f (let u = ({a = true , b = 1 }.b) in (unfold [ Nat ] (fold [ Nat ] (( \f: Unit .((f (let u = false in u) ) false ) ) (\a: Unit .\b: Unit .b)) ))) ) (((\x: Rec X. X .\y: Nat .y) (fix (\x: Bool . true )) ) (( \f: Bool .((f (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .b)) ) false ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Nat .\b: Unit .a)))
(let u = (case <l = (( \f: Rec X. X .((f (let u = true in 0) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) in (let u = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , b = (((\x: Rec X. X .\y: Bool .x) 1 ) true) }.a) in ({a = (iszero 1) , b = (iszero 0) }.b)))
({a = ({a = (case <r = ({a = 1 , b = false , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if (let u = 0 in true) then ({a = true , b = false }.b) else (if false then true else false)) }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = false in u) )) }.b)
(( \f: Unit .((f ({a = (( \f: Bool .((f (if false then 1 else 0) ) (fix (\x: Nat . 0 )) ) ) (\a: Bool .\b: Bool .b)) , b = (( \f: Rec X. X .((f (fix (\x: Bool . (if true then true else true) )) ) ({a = true , b = 0 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c = (case <l = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) > as Unit of < l = x > => x | < r = y > => y) }.c) ) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 1 , b = ({a = 0 , b = true , c =  1 }.b) }.a) )) , b = ({a = ({a = 1 , b = (((\x: Bool .\y: Rec X. X .y) false ) false) , c =  0 }.b) , b = (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = true }.a) )) }.a) }.a) ) ) (\a: Rec X. X .\b: Bool .a))
(unfold [ Unit ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) (let u = (unfold [ Bool ] (fold [ Bool ] (let u = 1 in u) )) in u) ) (( \f: Unit .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) in (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b))) ) ) (\a: Rec X. X .\b: Unit .a))) ))
(( \f: Nat .((f ({a = ({a = (((\x: Bool .\y: Bool .y) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b)) ) ({a = false , b = (if false then true else true) }.b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = 1 in 1) )) }.a) , b = ({a = (pred (((\x: Bool .\y: Bool .y) false ) 1)) , b = (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Nat ] true )) ) false) ) (let u = true in false)) , c = (fix (\x: Rec X. X . (((\x: Bool .\y: Bool .x) 1 ) true) )) }.c) }.b) ) ({a = (fix (\x: Nat . 0 )) , b = (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in false) )) }.a) ) ) (\a: Nat .\b: Rec X. X .a))
({a = ({a = (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then (fix (\x: Nat . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) )) else (let u = 1 in u)) , b = (fix (\x: Unit . (unfold [ Nat ] (fold [ Nat ] ({a = false , b = (iszero 0) }.b) )) )) }.a) , b = (let u = ({a = ({a = true , b = 0 }.a) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.a) in u) , c = (( \f: Bool .((f (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Bool . 1 )) )) ) (( \f: Rec X. X .((f (succ 0) ) 1 ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Nat .\y: Bool .y) (let u = false in true) ) (unfold [ Nat ] (fold [ Bool ] 0 ))) ) ) (\a: Nat .\b: Bool .a)) }.c)
(((\x: Nat .\y: Rec X. X .y) (iszero ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) true ) 0) ))) ) (if (let u = ({a = true , b = 0 }.a) in (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) then ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = false , c = 0 }.c) )) else (pred (case <l = 1 > as Unit of < l = x > => x | < r = y > => y))))
(case <l = ({a = ({a = ({a = (unfold [ Rec X. X ] (fold [ Bool ] (let u = 1 in u) )) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.b) , b = (let u = (fix (\x: Bool . true )) in u) }.a) , b = (pred (let u = (let u = 1 in u) in u)) }.b) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Bool .x) (let u = ({a = (succ 1) , b = ({a = (( \f: Bool .((f (iszero 0) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = 0 }.a) )) }.b) , c = (unfold [ Unit ] (fold [ Nat ] (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) )) }.c) in u) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) (iszero (((\x: Bool .\y: Unit .y) false ) 1)) ) ({a = (let u = 0 in 0) , b = (unfold [ Unit ] (fold [ Nat ] true )) , c =  (let u = false in 1) }.b)) ) (let u = true in u) ) ) (\a: Nat .\b: Bool .a)))
(((\x: Rec X. X .\y: Bool .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (if true then false else false) )) )) ) (((\x: Rec X. X .\y: Rec X. X .x) (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (let u = ({a = false , b = 0 }.b) in ({a = (let u = false in u) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) }.b))))
((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Unit . (((\x: Nat .\y: Unit .y) false ) 1) )) )) ))
({a = ({a = (if (if true then false else false) then (fix (\x: Unit . ({a = 0 , b = false , c =  0 }.b) )) else (if false then true else true)) , b = (succ ({a = 0 , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b)) }.a)) }.b) , b = ({a = (( \f: Nat .((f (( \f: Rec X. X .((f (iszero 0) ) ({a = true , b = 0 }.a) ) ) (\a: Bool .\b: Unit .b)) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (( \f: Unit .((f ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = true }.a) ) (((\x: Unit .\y: Rec X. X .y) true ) 0) ) ) (\a: Bool .\b: Bool .b)) }.a) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Bool .((f ({a = false , b = 0 }.b) ) (((\x: Unit .\y: Nat .x) 0 ) false) ) ) (\a: Nat .\b: Bool .b)) )) }.b)
(( \f: Nat .((f (pred ({a = ({a = 1 , b = 0 }.b) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) ) (let u = (((\x: Nat .\y: Nat .x) ({a = true , b = 1 }.a) ) (let u = true in u)) in (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Nat .\b: Bool .b))
(let u = ({a = ({a = ({a = false , b = true }.b) , b = ({a = 1 , b = true }.a) }.a) , b = (fix (\x: Bool . (let u = true in 0) )) }.b) in u)
(if ({a = ({a = ({a = (succ 0) , b = ({a = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) }.a) }.a) , b = (let u = ({a = true , b = 1 }.a) in u) }.a) , b = ({a = (if true then 1 else 0) , b = ({a = 1 , b = true , c =  1 }.b) , c =  (unfold [ Rec X. X ] (fold [ Nat ] (if true then 1 else 1) )) }.b) , c =  (unfold [ Nat ] (fold [ Bool ] ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) )) }.b) then ({a = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = ({a = true , b = false }.b) }.b) , b = ({a = (( \f: Nat .((f (if false then 1 else 1) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Nat .b)) , b = ({a = ({a = false , b = 1 }.b) , b = false }.a) }.b) }.a) else ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = false , b = false }.b) )))
(( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) ) (( \f: Rec X. X .((f (if false then false else true) ) (if false then false else true) ) ) (\a: Nat .\b: Nat .b))) ) (fix (\x: Unit . (if (case <r = ({a = ({a = 0 , b = true }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) }.b) > as Nat of < l = x > => x | < r = y > => y) then ({a = (let u = 1 in u) , b = (fix (\x: Nat . false )) , c = ({a = 0 , b = 0 }.b) }.c) else (pred (((\x: Rec X. X .\y: Unit .y) false ) 0))) )) ) ) (\a: Rec X. X .\b: Unit .b))
(( \f: Nat .((f (iszero (pred (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)))) ) (fix (\x: Unit . (let u = true in (let u = true in false)) )) ) ) (\a: Bool .\b: Nat .b))
(let u = (( \f: Rec X. X .((f (fix (\x: Rec X. X . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) )) ) (succ ({a = true , b = 0 }.b)) ) ) (\a: Unit .\b: Rec X. X .a)) in u)
(iszero ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (pred 1) in u) }.b))
({a = (if ({a = ({a = (((\x: Bool .\y: Unit .x) false ) false) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.a) then (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) in u) else ({a = ({a = 1 , b = true , c = (((\x: Bool .\y: Bool .y) true ) 1) }.c) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in true) ) true) , c = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.c)) , b = (unfold [ Unit ] (fold [ Bool ] (let u = (let u = ({a = true , b = true }.b) in true) in u) )) , c = (let u = (unfold [ Bool ] (fold [ Unit ] 0 )) in (let u = false in (let u = 0 in 1))) }.c)
(let u = (let u = (if false then (if true then true else false) else false) in u) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = false , c = 0 }.c) , b = true , c =  (pred 1) }.b) )))
(( \f: Nat .((f (case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (if ({a = true , b = 1 }.a) then (case <l = (let u = false in 0) > as Nat of < l = x > => x | < r = y > => y) else (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .y) true ) false) ) (((\x: Unit .\y: Unit .y) (let u = 1 in true) ) (unfold [ Unit ] (fold [ Unit ] 1 ))))) in (case <r = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if true then false else false) )) > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Bool .a))
(unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) ({a = (unfold [ Nat ] (fold [ Bool ] 1 )) , b = ({a = (if true then 1 else 0) , b = (let u = false in false) , c =  1 }.b) , c = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c) ) ({a = (fix (\x: Rec X. X . 0 )) , b = (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = false }.b) )) , c =  (let u = true in 1) }.b)) ))
(fix (\x: Rec X. X . (let u = (let u = (succ 0) in u) in (case <l = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) ))
(unfold [ Nat ] (fold [ Nat ] (succ ({a = (fix (\x: Unit . true )) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = 0 in u) )) }.b)) ))
(let u = (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = false }.b) )) )) in (succ (let u = (fix (\x: Rec X. X . 1 )) in (((\x: Bool .\y: Nat .y) false ) 0))))
(let u = ({a = (case <l = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = false }.a) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (if false then false else false) , b = false }.b) }.b) in ({a = ({a = ({a = ({a = true , b = 1 }.b) , b = (let u = 0 in 1) }.b) , b = (((\x: Bool .\y: Bool .y) (let u = true in false) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) , c = (let u = false in ({a = 1 , b = true , c = 0 }.c)) }.c) , b = (let u = (let u = (if false then true else false) in u) in u) }.a))
(((\x: Unit .\y: Nat .y) ({a = (let u = 1 in u) , b = ({a = ({a = true , b = 1 }.b) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , c =  (if true then ({a = 1 , b = false , c = 1 }.c) else (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.b) , c =  (case <l = (((\x: Unit .\y: Unit .x) 0 ) false) > as Nat of < l = x > => x | < r = y > => y) }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (if (fix (\x: Nat . false )) then ({a = (let u = 0 in u) , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)) }.b) else ({a = 1 , b = true , c =  0 }.b)) )))
({a = (( \f: Nat .((f (if (((\x: Bool .\y: Unit .y) ({a = 1 , b = true }.b) ) (fix (\x: Nat . true ))) then ({a = (if true then 0 else 0) , b = (pred 0) }.b) else ({a = true , b = 1 }.b)) ) ({a = (let u = (let u = 1 in true) in 0) , b = (((\x: Nat .\y: Bool .x) false ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b))) }.a) ) ) (\a: Nat .\b: Bool .b)) , b = (fix (\x: Rec X. X . (iszero (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in (((\x: Nat .\y: Nat .y) true ) 0))) )) }.a)
({a = (let u = ({a = (unfold [ Nat ] (fold [ Nat ] ({a = false , b = 0 }.b) )) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = (unfold [ Bool ] (fold [ Rec X. X ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) }.c) in (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Rec X. X .y) false ) true) ) ({a = (let u = 0 in 1) , b = false , c =  (if false then 0 else 1) }.b))) , b = (let u = (fix (\x: Unit . 1 )) in u) }.a)
(if ({a = (( \f: Nat .((f (case <r = (let u = true in false) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (let u = 0 in (iszero 1)) , b = ({a = 1 , b = ({a = 1 , b = false }.b) , c = 1 }.c) }.a) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Bool .x) (let u = 1 in true) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b))) ) (( \f: Nat .((f (((\x: Unit .\y: Nat .x) true ) true) ) (if false then true else false) ) ) (\a: Rec X. X .\b: Nat .b))) }.b) then ({a = (iszero (if true then 0 else 0)) , b = ({a = (((\x: Nat .\y: Unit .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) ) (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in true)) , b = (if ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) then false else (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a))) , c = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) }.c) }.a) else (let u = (let u = ({a = (if true then 0 else 1) , b = true , c = ({a = 1 , b = false }.a) }.c) in (((\x: Nat .\y: Nat .x) true ) true)) in u))
(pred ({a = (( \f: Nat .((f (((\x: Nat .\y: Nat .y) true ) (((\x: Unit .\y: Nat .x) false ) true)) ) ({a = (((\x: Rec X. X .\y: Unit .y) ({a = 1 , b = false , c =  0 }.b) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .a))) , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .a)) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) true ) (fix (\x: Rec X. X . 1 ))) )) , b = ({a = ({a = (let u = 1 in 0) , b = true }.a) , b = (let u = true in u) }.b) }.a) }.b))
(((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Bool .y) (( \f: Nat .((f (let u = ({a = false , b = 0 }.a) in (((\x: Nat .\y: Unit .x) false ) false)) ) (( \f: Unit .((f false ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .b)) ) (((\x: Unit .\y: Bool .y) false ) (let u = 1 in true))) ) (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Nat .x) (( \f: Nat .((f (let u = 1 in false) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . 1 )) }.b) , b = ({a = 1 , b = false , c =  1 }.b) , c =  (let u = 1 in u) }.b)) ) ({a = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) then ({a = 1 , b = true , c = 0 }.c) else (if true then 1 else 1)) , b = (iszero 1) , c =  (fix (\x: Rec X. X . (fix (\x: Nat . 0 )) )) }.b)))
(let u = ({a = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) , b = (case <l = (((\x: Bool .\y: Bool .x) 1 ) true) > as Bool of < l = x > => x | < r = y > => y) }.a) in ({a = ({a = true , b = true }.b) , b = (succ (succ (pred 1))) }.a))
(( \f: Rec X. X .((f (let u = (( \f: Nat .((f (let u = (if true then true else (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .a))) in (if (let u = 1 in true) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) else 1)) ) (((\x: Bool .\y: Nat .y) (let u = true in u) ) ({a = 1 , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Unit .a)) in u) ) (((\x: Bool .\y: Unit .y) (( \f: Nat .((f ({a = true , b = true }.b) ) (let u = ({a = 1 , b = false }.b) in (let u = 1 in (let u = false in true))) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = (((\x: Unit .\y: Unit .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) ) false) , b = ({a = (fix (\x: Bool . ({a = false , b = 1 }.b) )) , b = (let u = ({a = 0 , b = true }.b) in u) }.a) }.b)) ) ) (\a: Unit .\b: Bool .b))
({a = ({a = (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Nat ] false )) , c = (((\x: Nat .\y: Bool .x) (let u = 0 in 1) ) true) }.c) , b = (( \f: Nat .((f ({a = ({a = false , b = 1 }.b) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .a)) , c =  (if true then (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) else 1) }.b) ) (let u = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in false) in u) ) ) (\a: Bool .\b: Bool .b)) , c = ({a = (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f (((\x: Unit .\y: Unit .y) true ) 0) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = (if ({a = ({a = ({a = true , b = 1 }.b) , b = (let u = 0 in true) , c = 0 }.c) , b = (iszero 0) , c =  ({a = (let u = 1 in u) , b = 0 }.b) }.b) then ({a = (((\x: Bool .\y: Bool .y) false ) (((\x: Bool .\y: Bool .y) false ) 1)) , b = (((\x: Nat .\y: Rec X. X .y) false ) ({a = false , b = false }.b)) , c =  (((\x: Nat .\y: Rec X. X .x) 0 ) false) }.b) else ({a = (fix (\x: Nat . 1 )) , b = false }.b)) , c = (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Bool .((f 1 ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) }.c) }.c)
(let u = (let u = (pred ({a = 1 , b = (let u = 1 in true) , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.c)) in (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (iszero 0))) in ({a = ({a = ({a = 0 , b = ({a = 1 , b = false , c =  0 }.b) }.b) , b = ({a = 1 , b = true }.a) }.a) , b = ({a = (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) 1 ) false) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = false , b = 1 }.b) )) }.b) }.b))
(let u = (( \f: Rec X. X .((f (let u = (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) in ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = false }.b)) ) (( \f: Unit .((f ({a = (if (((\x: Rec X. X .\y: Bool .y) true ) false) then true else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) ) (iszero (( \f: Nat .((f (pred 1) ) (pred 1) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .a)) in (let u = (( \f: Bool .((f (fix (\x: Rec X. X . true )) ) false ) ) (\a: Rec X. X .\b: Bool .b)) in u))
({a = (((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Bool .y) (iszero (pred 1)) ) ({a = ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , b = 0 }.b) , b = ({a = 0 , b = false }.b) , c =  (((\x: Bool .\y: Nat .x) 1 ) true) }.b)) ) ({a = (fix (\x: Nat . (unfold [ Unit ] (fold [ Nat ] true )) )) , b = (((\x: Bool .\y: Rec X. X .x) (let u = true in 0) ) (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Bool .y) true ) false) ) false)) }.a)) , b = ({a = (fix (\x: Rec X. X . (let u = (succ 0) in u) )) , b = (fix (\x: Bool . ({a = 1 , b = false , c =  0 }.b) )) }.a) }.a)
({a = ({a = (let u = (unfold [ Nat ] (fold [ Nat ] false )) in u) , b = (pred (unfold [ Unit ] (fold [ Nat ] 1 ))) }.b) , b = (((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) ) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) , b = (let u = false in u) }.a)) }.b)
(( \f: Unit .((f (let u = (unfold [ Unit ] (fold [ Unit ] (fix (\x: Unit . true )) )) in ({a = ({a = true , b = 0 }.a) , b = (let u = true in false) }.b)) ) (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (if false then false else (let u = 1 in true)) )) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Nat .a))
({a = (succ (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) in u)) , b = (let u = (( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) false ) true) ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .a)) in ({a = (succ 1) , b = (( \f: Nat .((f (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) false ) ) (\a: Nat .\b: Rec X. X .b)) , c =  ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = false , c = 1 }.c) )) }.b)) }.b)
({a = (fix (\x: Unit . (fix (\x: Rec X. X . ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) )) )) , b = (let u = (succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))) in ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.b)) }.a)
(case <r = (case <r = (((\x: Nat .\y: Bool .y) (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (fix (\x: Bool . true )) ) ) (\a: Unit .\b: Bool .b)) ) (unfold [ Unit ] (fold [ Rec X. X ] ({a = (let u = 0 in 0) , b = false }.b) ))) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(let u = (succ (let u = ({a = ({a = true , b = 0 }.b) , b = (let u = 0 in 1) }.b) in u)) in u)
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (succ (fix (\x: Nat . 1 ))) , b = (if ({a = false , b = 1 }.a) then ({a = false , b = 0 }.b) else (((\x: Bool .\y: Unit .y) true ) 0)) }.b) ))
(unfold [ Rec X. X ] (fold [ Bool ] (let u = (fix (\x: Bool . (if false then true else true) )) in (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then (unfold [ Nat ] (fold [ Nat ] true )) else (unfold [ Nat ] (fold [ Unit ] (let u = 0 in true) )))) ))
(fix (\x: Unit . (case <r = (( \f: Unit .((f true ) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) ))
(( \f: Bool .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (iszero 0) in (if true then true else false)) )) ) (( \f: Nat .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Nat .((f (let u = 0 in false) ) (((\x: Rec X. X .\y: Unit .x) true ) false) ) ) (\a: Bool .\b: Unit .a)) )) ) (iszero (((\x: Unit .\y: Rec X. X .x) 0 ) false)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .b))
(unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = false , b = false }.b) , b = (unfold [ Nat ] (fold [ Bool ] (fix (\x: Nat . false )) )) }.b) ))
(let u = (((\x: Bool .\y: Rec X. X .y) (let u = (((\x: Nat .\y: Bool .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = false , b = true }.b)) in u) ) (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .y) ({a = 1 , b = true , c =  1 }.b) ) 1) ))) in (let u = (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] false )) )) ) ) (\a: Nat .\b: Bool .a)) in (pred (if ({a = 1 , b = true , c =  1 }.b) then (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) else ({a = 1 , b = false }.a)))))
(( \f: Nat .((f ({a = (((\x: Bool .\y: Nat .x) (if true then 1 else 1) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) , b = ({a = ({a = 0 , b = true , c = 0 }.c) , b = (if true then 0 else 0) }.b) }.b) ) (unfold [ Nat ] (fold [ Unit ] (case <l = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Bool .b))
(iszero ({a = (if (fix (\x: Bool . false )) then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else (( \f: Bool .((f 1 ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 )) ) ) (\a: Unit .\b: Rec X. X .a))) , b = (let u = (let u = 0 in true) in u) , c = (unfold [ Nat ] (fold [ Bool ] (succ 1) )) }.c))
(let u = (let u = (iszero (succ 0)) in ({a = (let u = 0 in u) , b = true }.b)) in u)
(( \f: Nat .((f (case <l = (((\x: Nat .\y: Unit .x) (succ 1) ) (fix (\x: Nat . true ))) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) (fix (\x: Unit . false ))) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in u) , c = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Bool .\b: Bool .b))
(let u = (let u = (((\x: Unit .\y: Nat .y) (let u = 0 in true) ) (let u = (((\x: Unit .\y: Nat .x) 1 ) false) in u)) in (fix (\x: Bool . (if false then (((\x: Unit .\y: Nat .y) true ) false) else false) ))) in ({a = (if ({a = 1 , b = false }.b) then (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) else ({a = 1 , b = false , c =  0 }.b)) , b = (case <r = ({a = false , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) }.b))
(let u = (unfold [ Nat ] (fold [ Nat ] ({a = ({a = false , b = true }.b) , b = ({a = false , b = 0 }.a) }.b) )) in (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] 0 )) )) )))
(let u = (iszero (( \f: Nat .((f (((\x: Bool .\y: Unit .y) (let u = 1 in false) ) ({a = false , b = 1 }.b)) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b))) in (case <l = (((\x: Bool .\y: Bool .y) false ) 0) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Bool .((f ({a = (let u = (iszero (let u = 0 in u)) in (case <l = (if true then 0 else 1) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Bool .y) ({a = false , b = false }.b) ) (unfold [ Unit ] (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] true )) ))) , c =  ({a = (unfold [ Unit ] (fold [ Unit ] (succ (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a))) )) , b = ({a = ({a = 1 , b = false , c =  0 }.b) , b = ({a = 0 , b = 1 }.b) }.b) }.b) }.b) ) (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Nat ] (let u = 0 in true) )) ) (fix (\x: Bool . (if (let u = true in false) then true else (unfold [ Nat ] (fold [ Unit ] true ))) )) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Nat .a))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 1 , b = true , c =  0 }.b) )) )) ))
(((\x: Bool .\y: Nat .x) (let u = ({a = (unfold [ Nat ] (fold [ Rec X. X ] false )) , b = (fix (\x: Unit . ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) )) }.b) in ({a = ({a = true , b = 0 }.b) , b = (((\x: Bool .\y: Unit .x) true ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b))) , c = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.c)) ) (let u = (if false then ({a = 1 , b = false }.b) else true) in u))
(case <l = (let u = (let u = ({a = true , b = 0 }.a) in u) in (let u = (let u = 1 in false) in (((\x: Bool .\y: Unit .x) 0 ) true))) > as Unit of < l = x > => x | < r = y > => y)
({a = (((\x: Nat .\y: Bool .y) (let u = (let u = false in false) in u) ) (((\x: Rec X. X .\y: Unit .x) (pred 1) ) ({a = 1 , b = true }.b))) , b = (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) false ) false) ) (( \f: Unit .((f false ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Bool .\b: Bool .a)) in (((\x: Unit .\y: Unit .y) ({a = 1 , b = true , c =  1 }.b) ) ({a = 1 , b = false }.b))) }.b)
({a = (if ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true , c =  ({a = 0 , b = true , c = 1 }.c) }.b) }.b) then (((\x: Unit .\y: Unit .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) ) ({a = (let u = 1 in false) , b = 0 }.b)) else (pred ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in 0) )))) , b = (let u = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) , b = true }.b) in u) }.b)
(pred (case <l = (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Unit .x) 1 ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(fix (\x: Bool . (pred ({a = ({a = (let u = false in false) , b = (pred (unfold [ Bool ] (fold [ Bool ] 1 ))) }.b) , b = (case <r = ({a = (fix (\x: Rec X. X . false )) , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) , c = ({a = (let u = true in 1) , b = ({a = 1 , b = ({a = false , b = 0 }.b) }.b) }.b) }.c)) ))
(if (((\x: Bool .\y: Nat .y) ({a = (((\x: Nat .\y: Unit .x) 0 ) false) , b = ({a = true , b = 1 }.a) , c =  0 }.b) ) ({a = 1 , b = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) }.b)) then (let u = (case <l = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) in (fix (\x: Unit . (( \f: Rec X. X .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (succ 0) ) ) (\a: Unit .\b: Rec X. X .b)) ))) else (case <l = (fix (\x: Bool . ({a = 1 , b = true }.a) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f (let u = (pred 0) in 0) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .a)) )))
(case <r = (let u = (unfold [ Unit ] (fold [ Unit ] (( \f: Nat .((f (let u = true in u) ) ({a = false , b = 0 }.a) ) ) (\a: Nat .\b: Rec X. X .b)) )) in u) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Bool .x) false ) false) ) (let u = 1 in u)) ) (((\x: Bool .\y: Bool .y) ({a = 0 , b = false , c =  1 }.b) ) 0) ) ) (\a: Bool .\b: Nat .a)) , b = (iszero (( \f: Rec X. X .((f (pred 1) ) 0 ) ) (\a: Bool .\b: Bool .a))) }.b) , b = (if (fix (\x: Rec X. X . (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) )) then ({a = (let u = true in ({a = 0 , b = false }.a)) , b = (( \f: Unit .((f (fix (\x: Unit . true )) ) (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = true }.b) )) ) ) (\a: Bool .\b: Unit .b)) , c = ({a = ({a = ({a = 0 , b = false }.a) , b = (((\x: Unit .\y: Unit .x) false ) false) }.a) , b = (let u = false in false) }.a) }.c) else (let u = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) in ({a = 1 , b = true }.a))) }.b)
({a = (((\x: Unit .\y: Rec X. X .y) (fix (\x: Bool . ({a = true , b = 0 }.a) )) ) (( \f: Unit .((f ({a = (pred (let u = 1 in 0)) , b = ({a = true , b = true }.b) }.a) ) (((\x: Rec X. X .\y: Nat .x) ({a = 0 , b = 1 }.b) ) (let u = false in u)) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = ({a = (( \f: Rec X. X .((f (fix (\x: Nat . (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) )) ) (case <r = (let u = 0 in true) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) , b = ({a = ({a = 0 , b = (((\x: Bool .\y: Nat .y) false ) true) }.a) , b = (((\x: Bool .\y: Bool .x) (iszero 1) ) (let u = 1 in ({a = true , b = false }.b))) , c = (unfold [ Rec X. X ] (fold [ Bool ] (let u = 1 in u) )) }.c) }.a) , c = (((\x: Nat .\y: Nat .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Unit ] true )) )) ) (((\x: Nat .\y: Rec X. X .y) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = (let u = true in u) , b = 1 }.b))) }.c)
({a = (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in 1) ))) , b = ({a = (let u = ({a = true , b = 0 }.b) in (let u = 0 in u)) , b = ({a = 0 , b = true }.b) , c =  (unfold [ Unit ] (fold [ Bool ] (pred 1) )) }.b) }.a)
({a = ({a = (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Bool .y) ({a = 1 , b = false }.b) ) ({a = true , b = 1 }.b)) )) , b = (((\x: Nat .\y: Bool .x) ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = 0 }.a) ) (if (let u = true in true) then (fix (\x: Rec X. X . true )) else (case <r = false > as Nat of < l = x > => x | < r = y > => y))) }.a) , b = (fix (\x: Nat . (( \f: Rec X. X .((f ({a = 1 , b = false }.b) ) (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Nat .b)) )) }.b)
(pred (((\x: Nat .\y: Bool .x) (let u = (unfold [ Bool ] (fold [ Unit ] (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .a)) )) in (( \f: Rec X. X .((f (succ 1) ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) ) ({a = (((\x: Unit .\y: Bool .y) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) (let u = false in true)) , b = (( \f: Nat .((f (if false then false else true) ) false ) ) (\a: Nat .\b: Bool .a)) }.b)))
(fix (\x: Bool . (case <r = (if (let u = 1 in false) then true else true) > as Bool of < l = x > => x | < r = y > => y) ))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .y) ({a = false , b = 1 }.a) ) ({a = true , b = 0 }.b)) )) , b = (((\x: Unit .\y: Bool .x) (iszero (unfold [ Bool ] (fold [ Bool ] 0 ))) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b))) }.b)
(iszero ({a = (pred (let u = 0 in u)) , b = (let u = (((\x: Bool .\y: Nat .y) true ) true) in (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) in true)) }.a))
(pred (succ (( \f: Nat .((f (unfold [ Nat ] (fold [ Nat ] 0 )) ) (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) in (((\x: Rec X. X .\y: Nat .x) 0 ) true)) ) ) (\a: Bool .\b: Bool .b))))
(succ ({a = (unfold [ Unit ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] false )) )) , b = (( \f: Bool .((f (if false then 0 else 1) ) (pred 1) ) ) (\a: Bool .\b: Rec X. X .b)) }.b))
(((\x: Unit .\y: Unit .y) (unfold [ Bool ] (fold [ Bool ] (let u = 0 in (fix (\x: Bool . true ))) )) ) (let u = (let u = (if false then false else true) in (if true then false else false)) in u))
(let u = (case <l = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in u) > as Nat of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Bool .y) (let u = false in true) ) ({a = 1 , b = false }.b)) ) ({a = true , b = (let u = true in false) }.b)) )))
(let u = (let u = ({a = (fix (\x: Unit . 0 )) , b = (if false then false else false) }.b) in (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) in true)) in (let u = ({a = (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) (if false then false else true)) , b = ({a = (((\x: Rec X. X .\y: Nat .x) 1 ) true) , b = ({a = 0 , b = true }.b) , c = (( \f: Unit .((f 0 ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Rec X. X .a)) }.c) }.b) in (((\x: Bool .\y: Unit .y) (unfold [ Unit ] (fold [ Unit ] (fix (\x: Nat . true )) )) ) (fix (\x: Rec X. X . (((\x: Unit .\y: Nat .x) true ) false) )))))
({a = (case <r = (iszero (let u = 1 in u)) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Unit .y) false ) 0) }.b) in u) }.b)
(pred (let u = (((\x: Nat .\y: Bool .y) (iszero ({a = 0 , b = 1 }.b)) ) (unfold [ Nat ] (fold [ Rec X. X ] (pred 1) ))) in u))
({a = (let u = (fix (\x: Rec X. X . false )) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero 0) ))) , b = (let u = (fix (\x: Nat . ({a = 0 , b = 1 }.b) )) in u) }.b)
(iszero ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Bool . (( \f: Bool .((f (((\x: Bool .\y: Unit .y) false ) 1) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (succ 1) )) ) ) (\a: Unit .\b: Unit .b)) )) )))
(let u = (succ ({a = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .a)) , b = (pred (((\x: Unit .\y: Nat .x) 1 ) false)) }.b)) in ({a = (((\x: Nat .\y: Unit .x) (if (unfold [ Nat ] (fold [ Unit ] false )) then 0 else ({a = 0 , b = 1 }.b)) ) ({a = ({a = 1 , b = false }.b) , b = (((\x: Unit .\y: Unit .x) 0 ) false) }.a)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (let u = true in false) , b = (pred (pred 1)) }.a) )) }.b))
(let u = ({a = (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) )) )) , b = (case <r = ({a = 1 , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) )))
(((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f (( \f: Unit .((f (if true then 1 else 1) ) (((\x: Rec X. X .\y: Bool .x) 1 ) false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Unit .y) false ) (let u = false in 0)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Bool .\y: Bool .x) false ) false) ))) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = (((\x: Unit .\y: Rec X. X .x) ({a = true , b = 1 }.b) ) true) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b))
(((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f (case <r = (let u = (fix (\x: Bool . true )) in u) > as Bool of < l = x > => x | < r = y > => y) ) (if (unfold [ Rec X. X ] (fold [ Unit ] true )) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (iszero 0) )) else (((\x: Bool .\y: Unit .y) false ) false)) ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = (( \f: Unit .((f ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = ({a = true , b = true }.b) }.b) ) (( \f: Nat .((f false ) (iszero 1) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Bool .a)) , b = (( \f: Unit .((f (let u = 1 in 1) ) (((\x: Bool .\y: Unit .y) true ) 0) ) ) (\a: Bool .\b: Unit .b)) }.a))
(let u = ({a = ({a = (let u = 1 in 0) , b = (let u = (let u = true in 0) in (((\x: Rec X. X .\y: Bool .y) false ) false)) }.a) , b = (let u = ({a = 1 , b = true }.a) in (unfold [ Rec X. X ] (fold [ Nat ] true ))) }.b) in u)
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Rec X. X . true )) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) )) in u)
({a = ({a = (if true then true else (((\x: Nat .\y: Rec X. X .x) true ) true)) , b = (fix (\x: Nat . false )) }.b) , b = (((\x: Unit .\y: Nat .y) (iszero (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) ) (let u = (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 1 }.b) ) false) in u)) }.a)
(let u = ({a = (case <l = (let u = 0 in 0) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (if true then false else true) ) ({a = true , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = ({a = ({a = 1 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = 0 , b = 0 }.b) }.b) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.c) in (unfold [ Bool ] (fold [ Bool ] ({a = (let u = 1 in u) , b = ({a = ({a = 0 , b = false , c = 1 }.c) , b = false }.b) }.a) )))
(case <r = ({a = (( \f: Bool .((f (let u = ({a = 0 , b = true }.a) in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) (let u = false in true) ) ) (\a: Bool .\b: Unit .a)) , b = ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = ({a = true , b = 1 }.a) }.b) }.b) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Rec X. X .y) (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) ({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) false ) 0) )) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Rec X. X . ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .x) false ) false) )) )) ))
({a = ({a = (((\x: Rec X. X .\y: Unit .y) (if ({a = true , b = 1 }.a) then true else (let u = false in true)) ) (let u = 0 in u)) , b = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in (unfold [ Bool ] (fold [ Bool ] 0 ))) )) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) in u) }.a) }.b) , b = ({a = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) in (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y)) , b = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in (let u = 0 in (((\x: Unit .\y: Bool .x) false ) true))) }.b) }.b)
(if (let u = (case <l = (pred 0) > as Nat of < l = x > => x | < r = y > => y) in (let u = (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false , c =  1 }.b) )) in (case <r = false > as Bool of < l = x > => x | < r = y > => y))) then (let u = (( \f: Rec X. X .((f (iszero 1) ) (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Nat ] (fold [ Bool ] false )) )) ) ) (\a: Nat .\b: Unit .a)) in ({a = (let u = 0 in 0) , b = (let u = true in false) }.a)) else ({a = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Nat .((f (unfold [ Nat ] (fold [ Nat ] 1 )) ) (((\x: Unit .\y: Nat .y) false ) 1) ) ) (\a: Bool .\b: Nat .b)) )) , b = (( \f: Bool .((f (pred ({a = true , b = 0 }.b)) ) (let u = false in 1) ) ) (\a: Rec X. X .\b: Unit .b)) }.b))
(unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Rec X. X . (case <l = (let u = (let u = 0 in u) in 0) > as Rec X. X of < l = x > => x | < r = y > => y) )) ))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Unit .((f ({a = (if false then false else false) , b = (let u = 0 in 1) }.a) ) (if (((\x: Unit .\y: Unit .x) (let u = false in u) ) ({a = (let u = 1 in 1) , b = true }.b)) then ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (let u = true in true) , c =  (unfold [ Unit ] (fold [ Unit ] 1 )) }.b) else (((\x: Rec X. X .\y: Nat .y) false ) false)) ) ) (\a: Rec X. X .\b: Bool .b)) ))
(unfold [ Unit ] (fold [ Rec X. X ] ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (succ (if true then 0 else 1)) )) , b = (unfold [ Bool ] (fold [ Bool ] (fix (\x: Unit . (succ 0) )) )) }.b) ))
(case <r = (let u = (case <r = ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) in u) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Bool .((f ({a = (case <l = (let u = 0 in 0) > as Nat of < l = x > => x | < r = y > => y) , b = (pred (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) in (let u = 1 in u))) }.b) ) (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Unit ] ({a = (((\x: Unit .\y: Nat .y) false ) true) , b = (let u = false in 0) }.a) )) ) (unfold [ Nat ] (fold [ Bool ] ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) , b = true }.a) ))) ) ) (\a: Bool .\b: Rec X. X .a))
({a = (fix (\x: Rec X. X . (let u = (((\x: Unit .\y: Nat .x) ({a = true , b = 0 }.a) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) in ({a = 0 , b = (unfold [ Unit ] (fold [ Bool ] false )) , c = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.c)) )) , b = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = 0 , b = false , c =  0 }.b) )) , b = ({a = (pred ({a = 0 , b = false }.a)) , b = (( \f: Bool .((f ({a = true , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.a) ) (( \f: Rec X. X .((f (iszero 1) ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) }.b) }.a)
(let u = (let u = (let u = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in u) in u) in ({a = (((\x: Nat .\y: Nat .y) (( \f: Unit .((f true ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) ) (\a: Nat .\b: Unit .a)) ) (if (if true then false else true) then false else true)) , b = (let u = 0 in u) }.a))
(((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Nat .y) (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Bool ] (if true then true else false) )) )) ) ({a = (((\x: Rec X. X .\y: Unit .y) (iszero 0) ) (if (((\x: Bool .\y: Nat .x) true ) true) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else true)) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.b) }.b)) ) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) , b = (fix (\x: Nat . (let u = (let u = 1 in false) in u) )) }.a))
(fix (\x: Unit . (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = false }.a) )) ) (pred ({a = ({a = 0 , b = true }.a) , b = 0 }.b)) ) ) (\a: Unit .\b: Rec X. X .b)) ))
(iszero ({a = (if (iszero 1) then ({a = true , b = 0 }.b) else ({a = 1 , b = false , c = 1 }.c)) , b = (fix (\x: Unit . 1 )) }.b))
(iszero ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = false , b = 0 }.b) }.b) )))
({a = ({a = (let u = (let u = false in false) in u) , b = (case <l = (let u = true in (((\x: Unit .\y: Bool .x) 1 ) true)) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (let u = (if (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Bool .a)) then ({a = 0 , b = true , c = 0 }.c) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) in ({a = 0 , b = false }.b)) , c =  (unfold [ Bool ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = true in 1) )) )) )) }.b)
(unfold [ Unit ] (fold [ Bool ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = (case <l = ({a = 1 , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Nat ] (fold [ Unit ] 0 ))) )) ))
({a = (((\x: Bool .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) false ) (let u = 0 in false)) )) ) (iszero (case <l = (succ (((\x: Unit .\y: Nat .y) false ) 1)) > as Unit of < l = x > => x | < r = y > => y))) , b = (( \f: Nat .((f (if (if true then true else false) then ({a = true , b = 0 }.b) else ({a = true , b = 0 }.b)) ) (fix (\x: Rec X. X . (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) ) 0 ) ) (\a: Bool .\b: Bool .a)) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a)
(unfold [ Unit ] (fold [ Unit ] ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Bool .\y: Rec X. X .x) 1 ) false) )) , b = ({a = (let u = true in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 ))) , b = ({a = false , b = false }.b) }.b) }.b) ))
(iszero (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) )))
({a = (fix (\x: Unit . (fix (\x: Nat . 0 )) )) , b = ({a = (case <l = ({a = 1 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y) , b = (case <r = (((\x: Bool .\y: Rec X. X .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , c = ({a = ({a = true , b = 1 }.b) , b = ({a = false , b = (pred 0) }.a) , c = ({a = (let u = false in true) , b = (succ 1) }.b) }.c) }.c)
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = true , c =  (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) )) ))
(let u = (case <l = (pred (((\x: Nat .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) ) 0)) > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Unit ] (fold [ Nat ] ({a = ({a = 0 , b = false , c =  0 }.b) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .x) 1 ) false) ) (case <l = (fix (\x: Rec X. X . 0 )) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) }.b) )))
(((\x: Rec X. X .\y: Nat .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Unit .\y: Rec X. X .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . ({a = false , b = 0 }.a) )) )) ) ({a = false , b = (let u = false in 1) }.a)) )) ) (case <r = ({a = ({a = 1 , b = 1 }.b) , b = (let u = (if false then true else false) in u) , c =  (((\x: Bool .\y: Unit .y) (let u = true in u) ) (((\x: Nat .\y: Nat .x) 0 ) false)) }.b) > as Unit of < l = x > => x | < r = y > => y))
(iszero ({a = ({a = (fix (\x: Unit . 0 )) , b = (let u = ({a = 1 , b = true }.a) in (let u = true in true)) }.b) , b = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u) }.b))
(pred (let u = ({a = ({a = (iszero 1) , b = ({a = 1 , b = 0 }.b) }.b) , b = (((\x: Bool .\y: Unit .x) (iszero 1) ) (((\x: Rec X. X .\y: Nat .y) true ) (let u = false in true))) , c = ({a = 1 , b = true }.a) }.c) in u))
({a = (let u = ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) true) , b = (fix (\x: Bool . false )) }.b) in ({a = (let u = 1 in 1) , b = (((\x: Nat .\y: Rec X. X .y) false ) false) , c = ({a = 0 , b = true }.a) }.c)) , b = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Rec X. X .y) true ) ({a = 1 , b = false , c =  0 }.b)) else ({a = 0 , b = true , c =  (((\x: Rec X. X .\y: Nat .x) 1 ) true) }.b)) }.b)
(( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = false , b = 0 }.a) )) ) (let u = ({a = 0 , b = false , c =  1 }.b) in (((\x: Unit .\y: Rec X. X .y) true ) false)) ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) in u)) ) (((\x: Bool .\y: Bool .x) ({a = (if false then false else true) , b = (fix (\x: Nat . true )) }.b) ) (let u = (case <r = (((\x: Bool .\y: Bool .y) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) in (iszero (let u = 0 in 0)))) ) ) (\a: Rec X. X .\b: Unit .a))
(((\x: Rec X. X .\y: Nat .y) (((\x: Unit .\y: Nat .y) ({a = ({a = (( \f: Bool .((f true ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Unit .\b: Unit .a)) , b = (let u = 1 in u) }.a) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.a) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero ({a = 1 , b = true }.a)) ))) ) ({a = ({a = (( \f: Bool .((f (let u = 1 in u) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Unit .a)) , b = (unfold [ Bool ] (fold [ Unit ] (fix (\x: Nat . false )) )) , c =  (( \f: Bool .((f (let u = 1 in u) ) (((\x: Rec X. X .\y: Nat .x) 0 ) true) ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (let u = (( \f: Nat .((f (let u = true in u) ) true ) ) (\a: Bool .\b: Bool .b)) in (fix (\x: Bool . 0 ))) }.b))
({a = (( \f: Nat .((f (fix (\x: Nat . (iszero (succ 1)) )) ) (unfold [ Rec X. X ] (fold [ Bool ] (if false then (unfold [ Nat ] (fold [ Unit ] true )) else (if false then true else false)) )) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = false , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) )) , b = (let u = (if false then (let u = true in 1) else 0) in (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) in (pred 0))) }.b) }.b)
(let u = ({a = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = ({a = 0 , b = false }.b) , c = (unfold [ Nat ] (fold [ Bool ] 0 )) }.c) , b = ({a = (let u = (let u = 0 in u) in false) , b = (( \f: Bool .((f false ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) }.b) in (((\x: Nat .\y: Bool .x) (case <r = (fix (\x: Unit . true )) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f ({a = false , b = 1 }.a) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .b))))
({a = (let u = (( \f: Unit .((f (if true then 1 else (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a))) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u) , b = (let u = (( \f: Bool .((f (let u = 1 in 0) ) (case <l = (succ 1) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) in (fix (\x: Rec X. X . (iszero (let u = 0 in u)) ))) }.b)
(fix (\x: Bool . (let u = (let u = (((\x: Unit .\y: Nat .y) (unfold [ Bool ] (fold [ Rec X. X ] (iszero 1) )) ) (let u = 1 in false)) in u) in u) ))
({a = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) , b = (((\x: Unit .\y: Rec X. X .y) (let u = 1 in false) ) (iszero 0)) }.b) , b = ({a = (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = true , b = 0 }.b)) , b = ({a = 1 , b = false }.b) , c =  (( \f: Nat .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ) ) (\a: Unit .\b: Unit .b)) }.b) }.b)
(if (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) )) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = ({a = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = 1 }.a) , b = (let u = 1 in u) }.a) in (let u = true in ({a = 1 , b = true }.b))) else (( \f: Rec X. X .((f (let u = (let u = false in 1) in true) ) (iszero 1) ) ) (\a: Unit .\b: Unit .a)))
(((\x: Unit .\y: Unit .x) ({a = ({a = (let u = (unfold [ Nat ] (fold [ Unit ] false )) in (((\x: Unit .\y: Nat .x) false ) true)) , b = (((\x: Nat .\y: Unit .y) true ) 1) }.a) , b = (unfold [ Rec X. X ] (fold [ Bool ] (let u = (let u = (fix (\x: Unit . true )) in u) in (((\x: Rec X. X .\y: Unit .x) false ) (((\x: Nat .\y: Unit .y) false ) true))) )) }.b) ) ({a = ({a = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) , b = (iszero (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a))) , c = (let u = 1 in 1) }.c) , b = (iszero (((\x: Rec X. X .\y: Nat .y) ({a = false , b = false }.b) ) (pred 0))) , c =  ({a = ({a = false , b = 1 }.b) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) }.b))
(((\x: Nat .\y: Bool .x) (iszero ({a = (let u = ({a = 1 , b = false , c = 1 }.c) in 1) , b = (let u = 1 in u) }.b)) ) (let u = (pred (fix (\x: Nat . (unfold [ Bool ] (fold [ Bool ] 1 )) ))) in (fix (\x: Rec X. X . (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) ))))
({a = (((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Nat .x) false ) true) ) ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (case <r = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) > as Nat of < l = x > => x | < r = y > => y) , c = (let u = 1 in (pred 0)) }.c)) , b = ({a = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) , b = (let u = false in 0) }.a) , b = ({a = (let u = (let u = 0 in 0) in ({a = 1 , b = 1 }.b)) , b = (if (( \f: Rec X. X .((f false ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) then (unfold [ Nat ] (fold [ Nat ] true )) else (((\x: Nat .\y: Bool .x) true ) true)) }.a) }.a) }.a)
({a = (( \f: Unit .((f ({a = (( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Bool .x) 1 ) true) , b = false }.a) ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (fix (\x: Unit . ({a = false , b = (if false then false else false) }.b) )) , c = ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = ({a = 0 , b = true }.b) , c = 0 }.c) }.c) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = (((\x: Nat .\y: Nat .x) 0 ) false) , b = (let u = 1 in 1) }.b) )) ) ) (\a: Rec X. X .\b: Nat .b)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = ({a = true , b = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Bool .b)) }.b) in (fix (\x: Bool . true ))) , b = (( \f: Bool .((f (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) ) true ) ) (\a: Rec X. X .\b: Nat .b)) }.b) )) , c =  (((\x: Nat .\y: Bool .y) (let u = (( \f: Nat .((f (if false then true else true) ) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Rec X. X .b)) in u) ) (((\x: Bool .\y: Unit .y) ({a = (case <r = ({a = true , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in 0) }.a) ) (( \f: Nat .((f (((\x: Unit .\y: Unit .y) false ) 1) ) (let u = true in 0) ) ) (\a: Bool .\b: Bool .b)))) }.b)
(if (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) ) (fix (\x: Nat . ({a = 0 , b = true , c =  1 }.b) )) ) ) (\a: Nat .\b: Nat .b)) then (((\x: Rec X. X .\y: Nat .x) ({a = true , b = 1 }.a) ) ({a = (((\x: Rec X. X .\y: Unit .y) true ) false) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.a)) else ({a = (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] (let u = false in true) )) )) , b = ({a = (pred (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b))) , b = (let u = (let u = true in true) in u) }.b) }.b))
(let u = ({a = (( \f: Nat .((f (succ 1) ) (fix (\x: Unit . 0 )) ) ) (\a: Bool .\b: Bool .b)) , b = (iszero (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y)) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .x) (pred 1) ) (fix (\x: Nat . true ))) )) }.b) in u)
({a = ({a = (let u = ({a = (((\x: Rec X. X .\y: Unit .x) false ) ({a = true , b = false }.b)) , b = (let u = false in 1) }.a) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in 1) ))) , b = ({a = (((\x: Bool .\y: Bool .y) true ) false) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) , c = (( \f: Unit .((f (let u = ({a = false , b = 0 }.a) in 0) ) (((\x: Bool .\y: Bool .y) true ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Bool .\b: Rec X. X .a)) }.c) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true , c =  0 }.b)) )) , c = (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) , b = 0 }.b) ) (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = false }.b) ) (if false then 1 else 1)) ) ) (\a: Bool .\b: Rec X. X .b)) )) }.c)
(if (( \f: Bool .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) true ) ) (\a: Unit .\b: Bool .a)) ) (let u = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) in u) ) ) (\a: Rec X. X .\b: Nat .a)) then ({a = (case <l = (fix (\x: Unit . 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) )) , c =  (if (((\x: Nat .\y: Rec X. X .x) true ) true) then ({a = 0 , b = true }.a) else (pred 0)) }.b) else ({a = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) in u) , b = (( \f: Bool .((f ({a = (unfold [ Unit ] (fold [ Nat ] 1 )) , b = (((\x: Unit .\y: Nat .x) (((\x: Unit .\y: Rec X. X .y) true ) false) ) false) }.b) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) }.b))
(((\x: Nat .\y: Bool .x) (((\x: Rec X. X .\y: Nat .x) (case <r = (fix (\x: Nat . (iszero 1) )) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (let u = ({a = true , b = false }.b) in ({a = ({a = 1 , b = true , c =  1 }.b) , b = (unfold [ Nat ] (fold [ Bool ] false )) }.b)) , b = (( \f: Bool .((f (( \f: Unit .((f ({a = 0 , b = true , c = 0 }.c) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Nat .\b: Nat .a)) }.a)) ) (( \f: Unit .((f (let u = (((\x: Unit .\y: Rec X. X .y) false ) true) in u) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) ) ) (\a: Rec X. X .\b: Unit .b)))
({a = (let u = ({a = (fix (\x: Nat . 0 )) , b = ({a = 1 , b = false , c = 0 }.c) }.b) in (( \f: Nat .((f ({a = ({a = false , b = false }.b) , b = ({a = 0 , b = ({a = true , b = false }.b) }.a) }.b) ) ({a = 1 , b = false , c = ({a = 1 , b = 0 }.b) }.c) ) ) (\a: Bool .\b: Bool .a))) , b = ({a = (case <l = (((\x: Unit .\y: Nat .y) false ) 1) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = false }.b) , c =  ({a = true , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b) }.b)
({a = (((\x: Rec X. X .\y: Bool .y) (((\x: Bool .\y: Unit .x) ({a = (let u = (let u = 0 in u) in u) , b = ({a = 0 , b = (let u = true in u) , c =  (fix (\x: Unit . 1 )) }.b) , c =  ({a = true , b = (((\x: Unit .\y: Bool .y) true ) 0) }.b) }.b) ) ({a = 1 , b = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a)) , c =  1 }.b)) ) (if (( \f: Unit .((f ({a = false , b = 0 }.a) ) (((\x: Bool .\y: Nat .y) false ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Nat .a)) then (let u = (let u = false in true) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) else (if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) then 1 else 1))) , b = (( \f: Bool .((f ({a = (if (if false then false else false) then (((\x: Nat .\y: Unit .x) 1 ) true) else (pred 0)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) )) , c =  (let u = false in 1) }.b) ) (let u = true in u) ) ) (\a: Bool .\b: Nat .a)) }.b)
(((\x: Rec X. X .\y: Nat .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (if (let u = false in u) then ({a = 1 , b = false , c =  0 }.b) else (unfold [ Bool ] (fold [ Bool ] true ))) )) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = ({a = false , b = true }.b) , b = (if (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) then 0 else 0) }.a) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = true , b = 1 }.b) )) }.a) )))
({a = (if (fix (\x: Nat . (let u = true in false) )) then ({a = 0 , b = (((\x: Unit .\y: Rec X. X .x) 1 ) true) }.b) else (case <l = (((\x: Rec X. X .\y: Nat .x) 0 ) true) > as Unit of < l = x > => x | < r = y > => y)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Unit .x) false ) true) )) }.b)
(let u = ({a = (( \f: Nat .((f ({a = (if false then 1 else 1) , b = true }.a) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Bool .((f ({a = false , b = (pred 1) }.a) ) (let u = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) in u) ) ) (\a: Rec X. X .\b: Nat .b)) }.a) in u)
({a = (if (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) then (let u = (let u = 0 in 1) in u) else (let u = ({a = 1 , b = true , c = 1 }.c) in u)) , b = (iszero ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = true in true) }.a)) }.b)
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) )) then (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) else ({a = true , b = 0 }.a)) , b = (let u = 0 in (((\x: Bool .\y: Unit .x) 1 ) true)) }.a) ))
(( \f: Rec X. X .((f (case <r = (case <r = (let u = false in u) > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) true ) ) (\a: Nat .\b: Nat .a)) )) ) ) (\a: Bool .\b: Rec X. X .a))
(( \f: Bool .((f (((\x: Nat .\y: Unit .x) (( \f: Nat .((f (let u = (((\x: Unit .\y: Unit .x) false ) true) in (iszero 1)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = 0 in true) ))) ) (( \f: Nat .((f (( \f: Nat .((f (let u = false in u) ) (fix (\x: Nat . (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .a)) )) ) ) (\a: Rec X. X .\b: Unit .b)) ) (((\x: Nat .\y: Unit .y) ({a = 1 , b = false , c =  1 }.b) ) ({a = ({a = false , b = 1 }.a) , b = ({a = 1 , b = false , c = 1 }.c) }.a)) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Rec X. X .b))
(case <r = (let u = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) (succ 1) ) ) (\a: Rec X. X .\b: Nat .a)) in (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (iszero ({a = true , b = 0 }.b)))) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Nat . (( \f: Rec X. X .((f (( \f: Bool .((f true ) (iszero 1) ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = (let u = (succ 1) in true) in u) ) ) (\a: Unit .\b: Nat .a)) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (succ (let u = (fix (\x: Unit . (iszero 1) )) in (( \f: Unit .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) ) (pred 0) ) ) (\a: Nat .\b: Nat .a)))) ))
(((\x: Bool .\y: Unit .x) (pred ({a = ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.a)) ) ({a = (case <l = (succ (let u = false in 0)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero 1) , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b))
(let u = (fix (\x: Rec X. X . ({a = 0 , b = ({a = 1 , b = true , c =  1 }.b) }.a) )) in (((\x: Bool .\y: Unit .y) ({a = (let u = (unfold [ Nat ] (fold [ Nat ] 1 )) in (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b))) , b = (case <r = (if true then false else true) > as Bool of < l = x > => x | < r = y > => y) }.b) ) ({a = (((\x: Nat .\y: Bool .y) false ) (((\x: Bool .\y: Bool .y) true ) 0)) , b = ({a = ({a = false , b = false }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) , c = (( \f: Rec X. X .((f ({a = false , b = 1 }.b) ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.c)))
(( \f: Nat .((f (succ ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .b)) }.a)) ) ({a = (unfold [ Nat ] (fold [ Bool ] 1 )) , b = ({a = (if true then true else true) , b = true }.b) }.a) ) ) (\a: Unit .\b: Unit .a))
(let u = ({a = ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = false , c =  0 }.b) , b = (((\x: Bool .\y: Rec X. X .y) true ) ({a = 1 , b = false }.a)) }.a) in u)
({a = ({a = (case <r = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Rec X. X .y) (if ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) then (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )) else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ({a = ({a = 1 , b = false }.a) , b = (let u = (if false then 1 else 0) in 0) }.b)) }.b) , b = (((\x: Bool .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Bool ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) ) ({a = (if true then true else false) , b = ({a = true , b = 1 }.b) }.a)) , c = (succ ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ))) }.c)
(let u = ({a = (( \f: Rec X. X .((f (case <r = (((\x: Unit .\y: Nat .y) false ) true) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .a)) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) in (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = 1 }.b) ))) }.b) in (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Unit ] (let u = ({a = 0 , b = true , c =  0 }.b) in u) )) )))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = (let u = 1 in u) , b = (if true then 0 else 0) }.b) )) in u)
(case <l = (((\x: Unit .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = 0 , b = false , c =  0 }.b) in u) ))) > as Nat of < l = x > => x | < r = y > => y)
({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Nat .y) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) 1) , b = (( \f: Nat .((f (fix (\x: Rec X. X . true )) ) false ) ) (\a: Rec X. X .\b: Bool .a)) , c = (let u = true in (let u = 0 in 0)) }.c) )) , b = (let u = ({a = (if true then true else false) , b = (((\x: Unit .\y: Rec X. X .x) true ) true) }.b) in u) , c =  (succ ({a = false , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) }.b)) }.b)
(case <r = ({a = (if (if ({a = 1 , b = true , c =  0 }.b) then (let u = 1 in true) else ({a = true , b = false }.b)) then (let u = (let u = ({a = false , b = 1 }.a) in true) in (unfold [ Nat ] (fold [ Bool ] 1 ))) else (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) , b = (((\x: Rec X. X .\y: Nat .y) (let u = ({a = ({a = false , b = 1 }.b) , b = true , c =  0 }.b) in (( \f: Bool .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Rec X. X .\b: Bool .b))) ) ({a = (let u = false in 1) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) , c =  0 }.b)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = (( \f: Nat .((f false ) (let u = 0 in true) ) ) (\a: Unit .\b: Nat .b)) in u) , b = ({a = (let u = false in false) , b = ({a = false , b = 1 }.b) }.b) }.b) ))
(fix (\x: Nat . (let u = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a)) )) in (pred ({a = 1 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = 1 }.c))) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) )) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = false , b = 1 }.a) ))) ))
(((\x: Unit .\y: Bool .x) (( \f: Unit .((f (( \f: Nat .((f (fix (\x: Rec X. X . 1 )) ) (( \f: Bool .((f (((\x: Bool .\y: Unit .y) false ) 0) ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .a)) ) (succ (let u = true in 1)) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Rec X. X .\y: Nat .x) (unfold [ Unit ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) )) ) (( \f: Unit .((f ({a = false , b = 0 }.a) ) ({a = true , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .b))))
(case <r = (case <r = (((\x: Rec X. X .\y: Rec X. X .y) (if (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false )) then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else false) then (if false then true else true) else ({a = 0 , b = true , c =  0 }.b)) ) ({a = (((\x: Unit .\y: Unit .x) true ) false) , b = (let u = 1 in false) }.b)) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Rec X. X .y) ({a = (((\x: Rec X. X .\y: Bool .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) in u) )) ) (let u = (if true then 0 else 1) in ({a = false , b = 1 }.a))) , b = (( \f: Unit .((f (let u = false in 1) ) (if (let u = true in false) then (fix (\x: Rec X. X . 0 )) else 1) ) ) (\a: Unit .\b: Rec X. X .a)) }.a) ) (fix (\x: Rec X. X . (let u = (unfold [ Bool ] (fold [ Bool ] 1 )) in (if false then 1 else 0)) )))
(fix (\x: Bool . (iszero (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )))) ))
({a = ({a = (((\x: Unit .\y: Nat .x) 0 ) (fix (\x: Unit . false ))) , b = (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) 0) }.b) , b = (succ (((\x: Nat .\y: Nat .y) ({a = ({a = 1 , b = (let u = 0 in true) , c = ({a = false , b = 1 }.b) }.c) , b = (let u = ({a = 0 , b = 0 }.b) in false) , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ({a = 0 , b = true }.a) , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) }.a) )))) }.b)
({a = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = (case <r = (let u = false in u) > as Bool of < l = x > => x | < r = y > => y) }.a) , b = ({a = (( \f: Nat .((f (let u = ({a = 0 , b = false , c = 1 }.c) in (pred 0)) ) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) , c = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = (((\x: Nat .\y: Bool .y) true ) 0) , b = (let u = 0 in true) , c =  (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) }.b) , c = (if (((\x: Unit .\y: Unit .y) ({a = 1 , b = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .a)) }.b) ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b))) then (let u = 1 in (if false then 0 else 1)) else (succ 0)) }.c)
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ({a = 0 , b = true }.a) , b = (( \f: Bool .((f ({a = 1 , b = false }.b) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  ({a = 1 , b = false }.a) }.b) )) in u)
(((\x: Rec X. X .\y: Rec X. X .y) ({a = (fix (\x: Rec X. X . (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = (let u = (fix (\x: Bool . (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) )) in u) , c =  (let u = (( \f: Nat .((f ({a = 1 , b = true , c = 1 }.c) ) (if ({a = false , b = 1 }.a) then 0 else (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false)) ) ) (\a: Bool .\b: Unit .b)) in (pred ({a = ({a = 0 , b = true }.a) , b = 0 }.b))) }.b) ) (unfold [ Bool ] (fold [ Bool ] ({a = (let u = (iszero 1) in u) , b = (let u = 0 in u) }.a) )))
(case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = (fix (\x: Unit . 1 )) , b = (fix (\x: Nat . true )) }.b) )) > as Unit of < l = x > => x | < r = y > => y)
({a = (case <l = (( \f: Nat .((f (let u = 0 in 0) ) (if ({a = true , b = 1 }.a) then (pred (succ 1)) else (( \f: Rec X. X .((f 0 ) (let u = false in 1) ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Unit .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (let u = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Bool .x) true ) true) , c = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) }.c) in ({a = (let u = true in 0) , b = (fix (\x: Nat . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) , c =  (((\x: Bool .\y: Unit .y) true ) 1) }.b)) in u) , c =  (fix (\x: Bool . (((\x: Unit .\y: Unit .y) ({a = true , b = 0 }.a) ) (pred 1)) )) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in false) )) ))
(( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) ({a = (let u = ({a = 0 , b = false }.b) in ({a = false , b = true }.b)) , b = ({a = ({a = (fix (\x: Bool . true )) , b = (let u = false in 1) }.b) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) }.a) }.a) ) (unfold [ Nat ] (fold [ Nat ] (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) in u) ))) ) (iszero ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = (((\x: Nat .\y: Bool .x) true ) true) }.a)) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = false , b = false }.b) in (succ 0)) ) ({a = 0 , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b)) }.b)) , b = (((\x: Unit .\y: Unit .y) (unfold [ Nat ] (fold [ Nat ] (let u = false in false) )) ) ({a = (fix (\x: Nat . (let u = 1 in u) )) , b = (let u = (let u = 0 in u) in (let u = false in true)) }.b)) , c = (succ (case <l = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y)) }.c)
(((\x: Nat .\y: Bool .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (iszero 1) in u) )) ) ({a = (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Nat .x) false ) true) ) (let u = 0 in 1)) , b = (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Bool ] 0 )) )) }.b))
(((\x: Unit .\y: Unit .y) (iszero (((\x: Bool .\y: Bool .x) (pred 0) ) ({a = (if false then ({a = false , b = 0 }.a) else false) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = true in true) )) }.b))) ) (( \f: Bool .((f (((\x: Unit .\y: Bool .x) ({a = (( \f: Rec X. X .((f (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) (pred 0) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = 0 in false) }.b) ) ({a = (((\x: Nat .\y: Bool .y) false ) true) , b = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))) }.b)) ) (let u = ({a = 0 , b = false , c =  0 }.b) in (((\x: Nat .\y: Unit .y) ({a = 1 , b = false , c =  0 }.b) ) false)) ) ) (\a: Bool .\b: Unit .a)))
({a = (case <l = (succ (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . (let u = (((\x: Unit .\y: Unit .y) true ) (unfold [ Nat ] (fold [ Bool ] 0 ))) in (let u = (case <r = ({a = false , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) in (let u = true in u))) )) }.b)
(case <r = ({a = (let u = (( \f: Unit .((f ({a = true , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Nat .b)) in u) , b = (((\x: Rec X. X .\y: Unit .y) ({a = true , b = true }.b) ) (iszero 0)) }.b) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Rec X. X .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (let u = 0 in 0) , b = (let u = true in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false ))) , c = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.c) )) ) (((\x: Rec X. X .\y: Unit .y) (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ({a = false , b = true }.b)) ) (case <r = ({a = 1 , b = true , c =  (((\x: Bool .\y: Rec X. X .y) false ) 0) }.b) > as Unit of < l = x > => x | < r = y > => y)))
(case <r = (iszero (let u = true in (let u = 1 in u))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) (case <r = (( \f: Unit .((f ({a = 1 , b = true , c =  0 }.b) ) true ) ) (\a: Unit .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (let u = true in false) in u)) )) ) ({a = (let u = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in (if ({a = false , b = 1 }.a) then ({a = 0 , b = false , c = 1 }.c) else 0)) in u) , b = (case <r = ({a = true , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = true , c = 0 }.c) )) }.b))
({a = ({a = (((\x: Rec X. X .\y: Bool .x) (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ) (fix (\x: Unit . false ))) , b = (fix (\x: Rec X. X . (((\x: Nat .\y: Nat .y) (fix (\x: Bool . false )) ) 1) )) }.b) , b = (succ (succ ({a = 0 , b = 0 }.b))) }.b)
(unfold [ Nat ] (fold [ Bool ] (let u = ({a = (if (let u = true in false) then ({a = 0 , b = false , c = 1 }.c) else (((\x: Unit .\y: Nat .x) 1 ) true)) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) , c =  (case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) > as Nat of < l = x > => x | < r = y > => y) }.b) in (((\x: Rec X. X .\y: Nat .y) ({a = ({a = 1 , b = false , c = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.c) , b = (((\x: Unit .\y: Nat .y) false ) false) }.b) ) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) ({a = 0 , b = true , c = 0 }.c)))) ))
(let u = (succ (let u = 1 in u)) in (let u = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = 1 }.b) )) , b = ({a = (let u = 0 in u) , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) }.b) , c = (case <l = (succ 1) > as Nat of < l = x > => x | < r = y > => y) }.c) in u))
(unfold [ Nat ] (fold [ Unit ] ({a = (( \f: Bool .((f (((\x: Unit .\y: Nat .y) false ) 1) ) ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = 1 in true) )) }.a) ))
(((\x: Unit .\y: Nat .x) (iszero ({a = (succ 1) , b = (let u = 0 in u) }.b)) ) (( \f: Nat .((f ({a = (if true then true else true) , b = (pred (let u = 1 in u)) }.a) ) (let u = (unfold [ Bool ] (fold [ Bool ] true )) in u) ) ) (\a: Unit .\b: Nat .a)))
(fix (\x: Unit . ({a = (let u = ({a = 0 , b = false , c = 0 }.c) in (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b))) , b = (let u = (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) (let u = 0 in false)) in ({a = ({a = 0 , b = true }.b) , b = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)) }.b) ))
(((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Rec X. X .y) ({a = (let u = ({a = true , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.b) in (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Bool .x) 0 ) true) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)))) , b = (( \f: Rec X. X .((f (let u = (let u = true in true) in ({a = 1 , b = true , c =  1 }.b)) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) , c =  (succ ({a = (if true then 0 else 1) , b = (fix (\x: Nat . 1 )) }.b)) }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , c =  ({a = 0 , b = false }.a) }.b) ))) ) (pred (((\x: Rec X. X .\y: Bool .x) (fix (\x: Nat . (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) )) ) (if (fix (\x: Unit . false )) then (let u = (let u = 1 in 1) in true) else (case <r = (((\x: Nat .\y: Nat .y) true ) false) > as Nat of < l = x > => x | < r = y > => y)))))
({a = ({a = (if (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) in (((\x: Unit .\y: Nat .y) false ) true)) then (iszero (let u = 0 in u)) else ({a = (succ 0) , b = ({a = false , b = 0 }.a) , c =  (unfold [ Bool ] (fold [ Bool ] 1 )) }.b)) , b = (unfold [ Bool ] (fold [ Unit ] ({a = (succ 1) , b = (iszero 1) }.b) )) }.b) , b = (fix (\x: Bool . (succ (succ (((\x: Nat .\y: Bool .y) true ) 1))) )) }.a)
(fix (\x: Bool . (( \f: Nat .((f (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .b)) in ({a = 0 , b = false , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) )) ) ) (\a: Bool .\b: Rec X. X .a)) ))
(unfold [ Nat ] (fold [ Nat ] (iszero (pred (pred 1))) ))
(if (let u = (((\x: Bool .\y: Nat .y) (let u = true in true) ) (((\x: Rec X. X .\y: Bool .y) false ) ({a = true , b = 0 }.a))) in u) then (fix (\x: Nat . (let u = (((\x: Nat .\y: Bool .x) 0 ) true) in u) )) else ({a = (if (if false then false else false) then ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) else (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = 0 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) }.a))
(let u = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) )) in ({a = (( \f: Nat .((f 1 ) (let u = false in 1) ) ) (\a: Bool .\b: Bool .a)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) }.b)) in (unfold [ Rec X. X ] (fold [ Bool ] ({a = (unfold [ Rec X. X ] (fold [ Bool ] (let u = true in u) )) , b = ({a = 1 , b = false }.b) }.b) )))
(( \f: Bool .((f (( \f: Nat .((f ({a = ({a = true , b = (let u = true in true) }.b) , b = ({a = (if (let u = true in true) then (unfold [ Unit ] (fold [ Rec X. X ] false )) else ({a = false , b = false }.b)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) }.a) }.b) ) ({a = (let u = ({a = false , b = 0 }.a) in (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (pred ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 ))) }.a) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = ({a = (((\x: Unit .\y: Bool .x) false ) false) , b = 1 }.a) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = false in 1) )) }.a) ) ) (\a: Bool .\b: Nat .a))
(pred ({a = (let u = (( \f: Nat .((f ({a = 1 , b = 0 }.b) ) 1 ) ) (\a: Nat .\b: Nat .a)) in ({a = 1 , b = true , c =  1 }.b)) , b = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (pred 0) )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) }.b))
({a = ({a = (let u = ({a = (pred 1) , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , c = ({a = true , b = 1 }.b) }.c) in (fix (\x: Nat . ({a = false , b = (let u = true in true) }.b) ))) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = 1 in (let u = 1 in u)) )) }.a) , b = ({a = (let u = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = (fix (\x: Unit . 1 )) }.b) in u) , b = (((\x: Bool .\y: Bool .x) ({a = (let u = 1 in false) , b = 1 }.a) ) (((\x: Nat .\y: Unit .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) ) false)) }.b) }.b)
({a = (((\x: Nat .\y: Nat .x) ({a = (let u = true in u) , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .b)) }.b) ) (((\x: Unit .\y: Bool .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Nat .y) true ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b))))) , b = ({a = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c = (unfold [ Unit ] (fold [ Nat ] 0 )) }.c) , b = (((\x: Nat .\y: Unit .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (let u = (fix (\x: Rec X. X . false )) in 1)) }.b) }.a)
({a = (( \f: Bool .((f (fix (\x: Nat . false )) ) ({a = (let u = (((\x: Bool .\y: Rec X. X .y) false ) false) in u) , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = ({a = (pred 1) , b = ({a = true , b = ({a = 0 , b = 0 }.b) }.a) , c =  (let u = 0 in u) }.b) in u) }.b)
(unfold [ Nat ] (fold [ Rec X. X ] (succ ({a = 1 , b = false , c = ({a = 1 , b = 1 }.b) }.c)) ))
(succ ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (if (( \f: Nat .((f ({a = ({a = 1 , b = true , c = 0 }.c) , b = false }.b) ) (let u = 0 in false) ) ) (\a: Bool .\b: Nat .a)) then (let u = (fix (\x: Unit . true )) in ({a = 0 , b = 0 }.b)) else (fix (\x: Unit . 0 ))) )))
(if ({a = (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = (let u = false in u) }.a) )) , b = ({a = (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) , b = (pred (if false then 0 else 0)) }.a) }.b) then (((\x: Bool .\y: Unit .x) (pred (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) ) ({a = ({a = true , b = 0 }.a) , b = (let u = 1 in 0) }.a)) else ({a = (let u = ({a = ({a = false , b = 0 }.b) , b = (( \f: Rec X. X .((f (iszero 0) ) true ) ) (\a: Unit .\b: Bool .b)) }.b) in u) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (if true then 1 else 1) )) }.b))
(if (((\x: Nat .\y: Nat .y) ({a = (( \f: Bool .((f (let u = false in 0) ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) , b = (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 1 in false) ))) then (iszero (succ (let u = 0 in u))) else (let u = (((\x: Nat .\y: Bool .y) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) ) (succ (let u = true in 1))) in (((\x: Rec X. X .\y: Unit .y) (let u = 1 in false) ) (iszero 1))))
(let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = ({a = 0 , b = 1 }.b) in u) )) in u)
(fix (\x: Nat . ({a = (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Bool ] (unfold [ Unit ] (fold [ Bool ] false )) )) ) (((\x: Rec X. X .\y: Bool .x) false ) ({a = 1 , b = false , c =  1 }.b))) , b = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) ) (let u = 1 in u) ) ) (\a: Nat .\b: Rec X. X .a)) }.a) ))
(( \f: Rec X. X .((f (fix (\x: Unit . (let u = (unfold [ Nat ] (fold [ Rec X. X ] (let u = false in u) )) in u) )) ) ({a = (( \f: Bool .((f (pred ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 ))) ) (let u = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = ({a = false , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = ({a = true , b = 1 }.b) }.a)) , c =  (pred (if (((\x: Rec X. X .\y: Bool .x) true ) true) then 0 else 0)) }.b) ) ) (\a: Bool .\b: Unit .a))
(pred ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) (case <l = ({a = 1 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) )))
(( \f: Nat .((f (let u = (((\x: Bool .\y: Unit .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) ) (let u = ({a = 0 , b = true , c =  0 }.b) in u)) in (( \f: Unit .((f (case <l = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = true , c = 1 }.c) )) > as Nat of < l = x > => x | < r = y > => y) ) (succ 1) ) ) (\a: Bool .\b: Bool .b))) ) (( \f: Unit .((f (((\x: Bool .\y: Unit .y) ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) , b = ({a = true , b = 1 }.a) }.b) ) (let u = (succ 0) in 1)) ) ({a = ({a = (let u = 1 in u) , b = 1 }.b) , b = (((\x: Unit .\y: Unit .y) false ) true) , c = ({a = (let u = true in 0) , b = 0 }.b) }.c) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .b))
(( \f: Unit .((f ({a = (if ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) then 0 else (fix (\x: Unit . 1 ))) , b = (fix (\x: Bool . (if true then true else true) )) , c =  (if (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) false ) true) ) (fix (\x: Nat . false )) ) ) (\a: Nat .\b: Bool .b)) then (unfold [ Unit ] (fold [ Unit ] 1 )) else ({a = 1 , b = false , c = 1 }.c)) }.b) ) (case <r = (fix (\x: Unit . true )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (iszero ({a = 1 , b = false , c = 0 }.c)) )) )) in ({a = ({a = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .b)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) )) }.a) , b = (if (let u = false in u) then (if (iszero 0) then true else true) else (( \f: Nat .((f false ) (let u = false in u) ) ) (\a: Nat .\b: Nat .b))) }.b))
({a = (unfold [ Rec X. X ] (fold [ Nat ] ({a = ({a = ({a = 0 , b = false , c = 1 }.c) , b = (((\x: Nat .\y: Bool .x) true ) true) }.a) , b = (let u = 0 in u) }.b) )) , b = (if (((\x: Bool .\y: Bool .y) true ) false) then ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = true }.a) else ({a = (((\x: Bool .\y: Unit .x) 1 ) true) , b = ({a = true , b = false }.b) }.a)) }.b)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = 0 in u) )) , b = (let u = 1 in ({a = false , b = false }.b)) }.a) ) ({a = (unfold [ Bool ] (fold [ Nat ] (let u = 1 in u) )) , b = (iszero 0) , c = (let u = 0 in u) }.c) ) ) (\a: Bool .\b: Unit .a)) ))
(( \f: Rec X. X .((f (( \f: Unit .((f ({a = (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) false ) false) )) , b = ({a = 1 , b = 1 }.b) }.b) ) (case <l = (let u = (if (let u = 1 in true) then 1 else 1) in (((\x: Unit .\y: Nat .y) true ) 1)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) ) (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Bool .x) true ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) ) (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = true in true) )) in (unfold [ Rec X. X ] (fold [ Bool ] 0 )))) ) ) (\a: Bool .\b: Rec X. X .a))
(let u = (fix (\x: Unit . (unfold [ Unit ] (fold [ Unit ] ({a = true , b = 1 }.b) )) )) in (( \f: Unit .((f ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) (let u = ({a = 0 , b = ({a = 1 , b = 0 }.b) }.b) in u) ) ) (\a: Bool .\b: Unit .b)))
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (( \f: Unit .((f (succ (if false then (((\x: Unit .\y: Bool .y) true ) 0) else ({a = true , b = 0 }.b))) ) ({a = ({a = 1 , b = 1 }.b) , b = (unfold [ Bool ] (fold [ Nat ] false )) , c = (((\x: Nat .\y: Nat .x) 0 ) true) }.c) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (iszero (unfold [ Nat ] (fold [ Bool ] 1 ))) }.b) ) ({a = (let u = (if false then 0 else 0) in (iszero ({a = 0 , b = true }.a))) , b = (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in ({a = 1 , b = true , c = 1 }.c)) }.a))
(fix (\x: Nat . (fix (\x: Bool . (fix (\x: Nat . (case <l = (if true then 1 else 0) > as Rec X. X of < l = x > => x | < r = y > => y) )) )) ))
(((\x: Bool .\y: Nat .y) (fix (\x: Rec X. X . (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f (iszero 1) ) (((\x: Bool .\y: Bool .x) false ) true) ) ) (\a: Bool .\b: Bool .a)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) )) ) (if (( \f: Nat .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Unit . false )) )) ) ({a = 1 , b = ({a = false , b = 1 }.a) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) ) (\a: Nat .\b: Bool .b)) then ({a = ({a = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Bool .((f (let u = 1 in true) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) , b = (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.b) else ({a = ({a = (iszero 0) , b = (let u = 1 in 0) }.b) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] false )) , b = (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then ({a = 0 , b = false , c = 0 }.c) else ({a = false , b = 1 }.b)) }.a) }.a)))
({a = (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] (if true then false else false) )) ) (if false then ({a = 1 , b = false }.b) else false)) , b = (if (((\x: Nat .\y: Bool .y) (case <r = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) in (if false then false else false)) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Unit ] (( \f: Bool .((f (((\x: Unit .\y: Unit .y) true ) true) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))) then ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = (((\x: Nat .\y: Nat .y) false ) 1) }.b) else (case <l = ({a = 1 , b = (unfold [ Unit ] (fold [ Nat ] 1 )) }.b) > as Bool of < l = x > => x | < r = y > => y)) }.a)
({a = (((\x: Bool .\y: Unit .x) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) , b = (if ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) then (((\x: Rec X. X .\y: Bool .x) false ) false) else ({a = false , b = true }.b)) }.b) ) (case <r = (unfold [ Bool ] (fold [ Bool ] false )) > as Bool of < l = x > => x | < r = y > => y)) , b = (unfold [ Rec X. X ] (fold [ Unit ] ({a = (( \f: Unit .((f 0 ) (fix (\x: Nat . 0 )) ) ) (\a: Bool .\b: Bool .b)) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) }.a) )) }.b)
(let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = true , c =  (if true then 1 else 1) }.b) )) in (case <l = (let u = (pred 1) in u) > as Bool of < l = x > => x | < r = y > => y))
(unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] (if (((\x: Unit .\y: Bool .x) (unfold [ Nat ] (fold [ Nat ] true )) ) true) then ({a = (let u = true in true) , b = (unfold [ Bool ] (fold [ Unit ] 1 )) }.a) else (( \f: Bool .((f false ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .a))) )) ))
(if (iszero ({a = (if (let u = false in true) then (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) else (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true)) , b = (let u = 1 in u) }.b)) then (let u = (succ ({a = 0 , b = false }.a)) in ({a = ({a = 1 , b = ({a = true , b = 0 }.a) , c = (let u = 0 in u) }.c) , b = ({a = (let u = true in false) , b = 0 }.a) }.b)) else (( \f: Unit .((f (case <r = (((\x: Bool .\y: Unit .y) false ) true) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .a)) )) ) ) (\a: Rec X. X .\b: Bool .a)))
(if (let u = (fix (\x: Bool . (let u = true in u) )) in u) then (pred ({a = ({a = 0 , b = false , c = 0 }.c) , b = ({a = 0 , b = false }.b) }.a)) else (( \f: Nat .((f ({a = 0 , b = ({a = 0 , b = false , c = 1 }.c) }.b) ) (succ 1) ) ) (\a: Rec X. X .\b: Nat .b)))
(let u = (( \f: Unit .((f (case <l = (let u = (((\x: Rec X. X .\y: Nat .y) (iszero 1) ) 1) in (let u = ({a = 0 , b = true , c = 0 }.c) in ({a = 1 , b = true }.a))) > as Nat of < l = x > => x | < r = y > => y) ) ({a = ({a = 1 , b = 1 }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.b) ) ) (\a: Unit .\b: Bool .b)) in u)
(succ (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (if ({a = false , b = 0 }.a) then (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) else (((\x: Rec X. X .\y: Nat .x) (fix (\x: Bool . 1 )) ) true)) ))))
(( \f: Nat .((f ({a = ({a = (let u = false in u) , b = ({a = 0 , b = 1 }.b) }.b) , b = (( \f: Nat .((f (if false then false else true) ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Bool .b)) , c =  (unfold [ Bool ] (fold [ Nat ] (let u = ({a = false , b = 1 }.a) in (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) )) }.b) ) (let u = (unfold [ Nat ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (pred ({a = 1 , b = true }.a)) )) )) in ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = 1 in false) )) , b = ({a = false , b = false }.b) }.b)) ) ) (\a: Unit .\b: Bool .b))
(((\x: Bool .\y: Unit .x) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) ) (( \f: Bool .((f (let u = ({a = (if false then (let u = 1 in u) else (let u = true in 1)) , b = (fix (\x: Nat . (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) )) , c =  (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.b) in (( \f: Nat .((f (((\x: Bool .\y: Nat .y) false ) true) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = true , b = true }.b) )) ) ) (\a: Bool .\b: Bool .a))) ) ({a = (if false then ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) else (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a))) , b = (((\x: Nat .\y: Unit .x) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) ({a = 1 , b = false , c =  1 }.b)) }.a) ) ) (\a: Nat .\b: Rec X. X .a)))
(fix (\x: Nat . (let u = (((\x: Unit .\y: Unit .y) false ) 0) in ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (fix (\x: Bool . false )) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) }.b)) ))
(pred (let u = (unfold [ Unit ] (fold [ Nat ] (fix (\x: Rec X. X . 0 )) )) in u))
({a = (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) ({a = true , b = 0 }.b) ) (fix (\x: Unit . false ))) ) (( \f: Rec X. X .((f (let u = 0 in 0) ) 0 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Unit .\b: Unit .b)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (fix (\x: Bool . 1 )) , b = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in false) }.a) )) }.b)
(fix (\x: Nat . ({a = ({a = 0 , b = (let u = false in u) , c =  ({a = 1 , b = 0 }.b) }.b) , b = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = ({a = 1 , b = true }.a) }.b) }.b) ))
(( \f: Unit .((f (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Unit .x) true ) ({a = true , b = 0 }.a)) else (let u = ({a = true , b = true }.b) in u)) ) (fix (\x: Rec X. X . (fix (\x: Unit . ({a = 0 , b = true , c =  1 }.b) )) )) ) ) (\a: Nat .\b: Rec X. X .b))
(case <r = (let u = (unfold [ Unit ] (fold [ Nat ] (unfold [ Unit ] (fold [ Unit ] (let u = true in u) )) )) in (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .y) (fix (\x: Unit . (iszero 0) )) ) (if false then false else false)) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (pred ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = (let u = 1 in u) }.b) ))) ) (( \f: Rec X. X .((f (( \f: Bool .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) ) (let u = 1 in 0) ) ) (\a: Bool .\b: Rec X. X .a)) ) (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Nat .y) (if false then true else ({a = false , b = 1 }.a)) ) (succ 1))) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .a))
({a = (pred (( \f: Rec X. X .((f (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .x) 0 ) true) ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Nat .b)) ) ({a = 0 , b = false , c = (let u = 0 in 0) }.c) ) ) (\a: Nat .\b: Bool .b))) , b = (case <r = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = false }.b) > as Unit of < l = x > => x | < r = y > => y) }.b)
(pred (let u = ({a = ({a = (((\x: Nat .\y: Unit .y) false ) false) , b = (pred 0) }.b) , b = (let u = 0 in u) }.b) in (((\x: Nat .\y: Bool .x) ({a = 1 , b = true }.a) ) (let u = (if true then 1 else 1) in (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .a))))))
(let u = (let u = (pred (unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ))) in (((\x: Nat .\y: Unit .y) false ) true)) in u)
(( \f: Bool .((f ({a = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = false }.b) , b = ({a = 1 , b = false , c = 1 }.c) }.a) ) (((\x: Nat .\y: Bool .y) (fix (\x: Unit . (fix (\x: Unit . (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) )) ) ({a = (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) in 0) , b = ({a = 1 , b = true , c =  0 }.b) , c =  (fix (\x: Nat . 1 )) }.b)) ) ) (\a: Nat .\b: Bool .a))
(( \f: Nat .((f ({a = (if (let u = (let u = 1 in u) in true) then (succ 1) else (fix (\x: Unit . 0 ))) , b = (((\x: Nat .\y: Unit .y) true ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false ))) }.b) ) (let u = (let u = (succ 0) in false) in (unfold [ Bool ] (fold [ Unit ] ({a = 1 , b = false , c =  0 }.b) ))) ) ) (\a: Nat .\b: Unit .a))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (( \f: Bool .((f (if false then (let u = true in true) else (((\x: Nat .\y: Unit .y) false ) true)) ) (let u = 1 in false) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (if (iszero 0) then 0 else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) ))
(let u = ({a = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Rec X. X .\y: Unit .x) 1 ) false) }.b) , b = (( \f: Nat .((f (((\x: Unit .\y: Unit .x) (pred 1) ) false) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) in (succ (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = false in 1) )) ) (succ 1) ) ) (\a: Bool .\b: Bool .a))))
(((\x: Unit .\y: Rec X. X .x) (((\x: Unit .\y: Bool .y) (iszero (pred (let u = false in 0))) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ))) ) (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Nat .y) (unfold [ Unit ] (fold [ Unit ] true )) ) ({a = false , b = false }.b))) ) ({a = ({a = (if false then true else false) , b = true }.b) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Unit .\b: Rec X. X .b)))
({a = (( \f: Unit .((f (((\x: Bool .\y: Bool .y) (fix (\x: Unit . (if true then true else false) )) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = (succ 0) }.b)) ) (unfold [ Nat ] (fold [ Rec X. X ] (case <l = ({a = true , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Nat .((f (( \f: Bool .((f ({a = true , b = true }.b) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Unit .b)) ) (if ({a = false , b = 0 }.a) then (unfold [ Bool ] (fold [ Nat ] false )) else false) ) ) (\a: Unit .\b: Unit .a)) , c =  ({a = (succ (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .y) true ) 0) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Nat .b))) , b = (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y) }.b) }.b)
(( \f: Rec X. X .((f (((\x: Nat .\y: Nat .y) (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) ) (((\x: Nat .\y: Unit .x) true ) false)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) false ) false) )) )) ) ) (\a: Bool .\b: Rec X. X .b))
(if ({a = (iszero ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 ))) , b = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) }.a) then (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f (fix (\x: Rec X. X . true )) ) ({a = 1 , b = ({a = true , b = false }.b) , c =  ({a = 1 , b = 1 }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) else (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f (iszero ({a = (fix (\x: Unit . 0 )) , b = (if true then 1 else 0) }.b)) ) (((\x: Bool .\y: Bool .y) false ) false) ) ) (\a: Bool .\b: Nat .b)) ) (let u = (pred (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))) in (let u = (let u = 0 in false) in (fix (\x: Unit . false ))))))
(if (iszero ({a = ({a = true , b = 1 }.b) , b = (succ 0) }.b)) then (pred (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Nat .x) false ) ({a = 1 , b = false , c =  1 }.b)) ) (let u = false in (let u = 0 in u)))) else ({a = ({a = (((\x: Nat .\y: Nat .y) false ) true) , b = ({a = 1 , b = true }.a) }.b) , b = (let u = 0 in u) }.b))
(iszero (let u = (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) )) in (succ 1)))
(case <l = (( \f: Bool .((f (let u = (let u = 0 in 1) in u) ) (fix (\x: Rec X. X . (( \f: Nat .((f ({a = 0 , b = false , c = 1 }.c) ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) )) ) ) (\a: Bool .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y)
({a = ({a = ({a = ({a = 1 , b = false , c = 0 }.c) , b = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a)) }.a) , b = (fix (\x: Nat . ({a = false , b = 1 }.b) )) }.b) , b = (fix (\x: Rec X. X . ({a = ({a = 0 , b = false }.a) , b = true , c =  (let u = 1 in 1) }.b) )) , c = (let u = (( \f: Unit .((f ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = true }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) in (let u = 1 in u)) }.c)
(( \f: Rec X. X .((f (( \f: Nat .((f (iszero ({a = 1 , b = true , c = 0 }.c)) ) (if true then true else true) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = (let u = (let u = 1 in (((\x: Nat .\y: Bool .x) false ) true)) in (let u = 1 in false)) , b = ({a = ({a = (fix (\x: Unit . 0 )) , b = (let u = 0 in 1) }.b) , b = (( \f: Rec X. X .((f ({a = false , b = ({a = false , b = false }.b) }.b) ) ({a = (fix (\x: Unit . 0 )) , b = ({a = 1 , b = false }.b) , c =  (if true then 1 else 1) }.b) ) ) (\a: Nat .\b: Unit .a)) }.b) }.b) ) ) (\a: Unit .\b: Rec X. X .a))
(pred (((\x: Rec X. X .\y: Bool .x) ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) false) , b = (unfold [ Nat ] (fold [ Bool ] (let u = 0 in false) )) }.a) ) (fix (\x: Unit . false ))))
(let u = (let u = (( \f: Unit .((f ({a = 0 , b = (((\x: Unit .\y: Unit .y) false ) false) }.b) ) (let u = 1 in (let u = false in u)) ) ) (\a: Nat .\b: Nat .a)) in (((\x: Bool .\y: Unit .x) ({a = ({a = 1 , b = false , c =  0 }.b) , b = (fix (\x: Rec X. X . false )) }.b) ) (if (((\x: Rec X. X .\y: Unit .y) ({a = true , b = false }.b) ) (fix (\x: Bool . true ))) then ({a = ({a = false , b = 1 }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) , c =  (((\x: Rec X. X .\y: Nat .y) true ) 1) }.b) else ({a = 0 , b = false , c =  1 }.b)))) in (pred (succ 0)))
(iszero ({a = (let u = (pred 1) in u) , b = (((\x: Rec X. X .\y: Bool .y) ({a = 0 , b = false }.b) ) (let u = true in false)) , c = ({a = (unfold [ Bool ] (fold [ Nat ] true )) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) }.c))
(succ ({a = (((\x: Bool .\y: Nat .x) ({a = 0 , b = true }.b) ) (let u = 0 in true)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Unit . 1 )) )) }.b))
(let u = ({a = ({a = ({a = (((\x: Rec X. X .\y: Bool .x) true ) true) , b = ({a = (let u = false in 1) , b = ({a = false , b = 0 }.a) }.a) }.a) , b = ({a = 0 , b = (unfold [ Nat ] (fold [ Nat ] true )) }.a) }.b) , b = ({a = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) in u) , b = (fix (\x: Unit . ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true )) )) , c =  (( \f: Nat .((f (pred 1) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) }.a) in u)
(( \f: Unit .((f (let u = (if (unfold [ Unit ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) )) then ({a = ({a = false , b = ({a = 0 , b = false }.a) }.a) , b = (let u = 0 in 0) }.a) else (let u = true in u)) in (((\x: Bool .\y: Nat .x) (let u = true in 0) ) (((\x: Bool .\y: Rec X. X .x) (if false then true else true) ) (let u = 1 in false)))) ) (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Nat .y) (fix (\x: Bool . (let u = true in u) )) ) (((\x: Nat .\y: Nat .y) false ) true)) ) ({a = (let u = 1 in 0) , b = false }.a)) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = (fix (\x: Bool . (if true then 1 else 1) )) }.b) ) ({a = 0 , b = (unfold [ Unit ] (fold [ Bool ] true )) , c = 0 }.c) ) ) (\a: Unit .\b: Rec X. X .b)) ) (fix (\x: Unit . (iszero (let u = (unfold [ Unit ] (fold [ Bool ] false )) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)))) )))
(((\x: Rec X. X .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .x) false ) true) ) (let u = 1 in false) ) ) (\a: Nat .\b: Nat .a)) )) ) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) )) in u))
(if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) , b = false , c =  1 }.b) )) )) then (unfold [ Bool ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (iszero 0) )) )) else ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = (let u = (iszero 0) in (if true then false else true)) }.b))
({a = ({a = (let u = (((\x: Nat .\y: Rec X. X .x) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) ) (iszero 1)) in (case <r = (case <r = true > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) , b = (succ (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b))) }.b) , b = (((\x: Nat .\y: Rec X. X .x) (if ({a = 0 , b = true , c =  1 }.b) then (if true then true else false) else true) ) (((\x: Nat .\y: Unit .x) (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (case <r = true > as Nat of < l = x > => x | < r = y > => y) else true) ) (iszero 1))) , c = (( \f: Unit .((f (((\x: Rec X. X .\y: Rec X. X .y) true ) ({a = true , b = 1 }.b)) ) (let u = false in 0) ) ) (\a: Nat .\b: Rec X. X .a)) }.c)
(iszero (unfold [ Bool ] (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false )) , b = (((\x: Nat .\y: Bool .x) 0 ) (unfold [ Nat ] (fold [ Bool ] true ))) }.b) )) )))
(succ ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (case <l = ({a = 1 , b = false }.a) > as Bool of < l = x > => x | < r = y > => y) )))
(( \f: Unit .((f (((\x: Nat .\y: Nat .y) (let u = (unfold [ Bool ] (fold [ Rec X. X ] (let u = 1 in 0) )) in (( \f: Unit .((f false ) (let u = 0 in false) ) ) (\a: Unit .\b: Unit .a))) ) (( \f: Unit .((f (let u = true in (iszero 0)) ) ({a = (let u = true in 0) , b = (let u = false in false) , c =  1 }.b) ) ) (\a: Nat .\b: Unit .a))) ) (((\x: Unit .\y: Nat .y) (fix (\x: Bool . (case <r = ({a = 1 , b = false , c =  1 }.b) > as Nat of < l = x > => x | < r = y > => y) )) ) (if (((\x: Nat .\y: Bool .y) false ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false ))) then (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .a)) else (fix (\x: Unit . false )))) ) ) (\a: Unit .\b: Bool .b))
(if ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) false ) true) ) ({a = false , b = 1 }.a) ) ) (\a: Nat .\b: Unit .a)) )) , b = (case <l = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = true }.a) > as Bool of < l = x > => x | < r = y > => y) }.a) then (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = ({a = (case <r = (if true then true else false) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = 1 }.b) }.a) > as Nat of < l = x > => x | < r = y > => y) )) else (if (let u = (let u = 0 in true) in (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a))) then ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) else ({a = (let u = 0 in 0) , b = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .b)) , c =  (unfold [ Unit ] (fold [ Bool ] 0 )) }.b)))
(let u = (( \f: Rec X. X .((f (let u = (if true then false else true) in ({a = false , b = false }.b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) )) ) ) (\a: Rec X. X .\b: Bool .b)) in (( \f: Rec X. X .((f ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false , c = 1 }.c) }.b) ) (let u = (let u = 0 in u) in (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) ) ) (\a: Rec X. X .\b: Unit .a)))
(((\x: Nat .\y: Unit .y) ({a = (((\x: Bool .\y: Rec X. X .y) (let u = (fix (\x: Bool . false )) in (unfold [ Unit ] (fold [ Rec X. X ] true ))) ) (let u = (let u = true in u) in (iszero 1))) , b = (unfold [ Unit ] (fold [ Rec X. X ] (iszero 1) )) }.b) ) (( \f: Bool .((f (((\x: Bool .\y: Nat .y) ({a = (if false then 0 else 0) , b = (((\x: Unit .\y: Bool .x) false ) true) }.b) ) ({a = (fix (\x: Nat . 1 )) , b = (succ (pred 0)) }.b)) ) (((\x: Rec X. X .\y: Nat .y) (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b))) ) ({a = 1 , b = false , c = 0 }.c)) ) ) (\a: Nat .\b: Unit .b)))
(unfold [ Bool ] (fold [ Bool ] ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (unfold [ Unit ] (fold [ Nat ] 1 )) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.a) )) ))
(let u = (case <l = (( \f: Unit .((f ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = (pred 0) }.b) ) (let u = 1 in 1) ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) false ) 0) )) )))
(let u = (case <r = ({a = (pred 1) , b = (iszero 1) }.b) > as Nat of < l = x > => x | < r = y > => y) in (if (( \f: Unit .((f true ) (iszero 1) ) ) (\a: Bool .\b: Unit .a)) then (iszero (((\x: Unit .\y: Unit .x) (let u = false in 1) ) false)) else (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) false ) false) ))))
(( \f: Rec X. X .((f ({a = (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then (let u = 1 in true) else (iszero 1)) , b = (((\x: Nat .\y: Unit .x) true ) ({a = 1 , b = false }.b)) }.b) ) (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) true ) true) )) )) ) ) (\a: Bool .\b: Rec X. X .a))
({a = (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Nat .x) 1 ) true) ) (((\x: Unit .\y: Rec X. X .x) false ) false)) ) ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = 1 }.a)) , b = (iszero (((\x: Unit .\y: Bool .x) (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) ) 0 ) ) (\a: Unit .\b: Nat .a)) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) , b = (((\x: Nat .\y: Nat .x) false ) false) }.b))) , c = (((\x: Nat .\y: Nat .y) (( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] false )) ) ({a = 1 , b = false }.b) ) ) (\a: Bool .\b: Unit .b)) ) (case <l = (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) then (let u = 0 in 0) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 ))) > as Rec X. X of < l = x > => x | < r = y > => y)) }.c)
({a = ({a = ({a = (((\x: Unit .\y: Bool .x) 1 ) (unfold [ Bool ] (fold [ Nat ] true ))) , b = (((\x: Unit .\y: Bool .x) ({a = true , b = 1 }.a) ) (((\x: Bool .\y: Bool .x) false ) false)) , c = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = false }.a) }.c) , b = (fix (\x: Unit . ({a = false , b = true }.b) )) , c = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) in u) }.c) , b = (let u = (let u = true in u) in (( \f: Unit .((f (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) true ) ) (\a: Unit .\b: Bool .b))) , c = ({a = (fix (\x: Rec X. X . (( \f: Unit .((f (let u = 0 in u) ) (let u = true in 1) ) ) (\a: Bool .\b: Nat .a)) )) , b = ({a = (fix (\x: Bool . 0 )) , b = (let u = (let u = (let u = 1 in false) in true) in ({a = false , b = false }.b)) }.b) }.a) }.c)
(((\x: Bool .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Nat ] ({a = false , b = ({a = true , b = 1 }.a) }.b) )) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = false , b = 0 }.a) )))
(if (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Nat .y) (case <r = (((\x: Unit .\y: Nat .y) true ) false) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 0 , b = false }.b)) )) then (( \f: Bool .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) )) ) (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Unit .x) false ) false) )) ) ) (\a: Bool .\b: Bool .b)) else ({a = (succ ({a = 1 , b = 0 }.b)) , b = (if (if false then true else (iszero 0)) then (let u = false in u) else (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) , c =  (let u = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) in u) }.b))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (pred 1) in ({a = 0 , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.b)) )) , b = ({a = (pred ({a = true , b = ({a = 1 , b = false }.a) }.b)) , b = (case <r = ({a = 1 , b = true , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (succ (((\x: Nat .\y: Rec X. X .y) true ) 0)) }.c) }.b)
(succ (pred (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) false ) 0) ) (succ 0) ) ) (\a: Nat .\b: Bool .b))))
(let u = (if (((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .x) true ) true) ) (fix (\x: Rec X. X . true ))) then (( \f: Unit .((f (let u = true in u) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Nat .b)) else (if true then true else (fix (\x: Rec X. X . true )))) in u)
({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) (pred ({a = 1 , b = true }.a)) ) (let u = false in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )))) in (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) false ) ) (\a: Unit .\b: Unit .a))) , b = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = ({a = 0 , b = true , c =  0 }.b) }.b) , c = (let u = 0 in 0) }.c) }.b)
(let u = ({a = (if (iszero 0) then (pred (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true)) else ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) , b = (fix (\x: Rec X. X . true )) , c =  (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) true)) }.b) in u)
(pred ({a = (let u = (((\x: Nat .\y: Bool .y) true ) 1) in u) , b = (unfold [ Bool ] (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) )) )) }.b))
(if ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b)) )) then ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .x) ({a = (let u = 1 in 1) , b = false , c =  (if true then 0 else 0) }.b) ) (fix (\x: Nat . (iszero 1) ))) )) else (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .x) (let u = false in u) ) ({a = 0 , b = ({a = 1 , b = false , c =  0 }.b) }.b)) ) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Rec X. X .y) false ) false)) ) ) (\a: Unit .\b: Rec X. X .b)))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (if (if (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) then (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .a)) )) else ({a = (let u = true in 0) , b = true , c =  0 }.b)) then (succ (let u = 1 in (unfold [ Nat ] (fold [ Nat ] 1 )))) else (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ))) ))
(let u = (fix (\x: Nat . (let u = (iszero 0) in (fix (\x: Bool . 0 ))) )) in u)
({a = (( \f: Unit .((f (iszero (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) in u)) ) (if ({a = false , b = true }.b) then ({a = false , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.a) else ({a = 0 , b = true }.b)) ) ) (\a: Nat .\b: Nat .b)) , b = ({a = (case <l = (if true then 0 else 1) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = ({a = (((\x: Rec X. X .\y: Bool .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) false) , b = ({a = (((\x: Unit .\y: Unit .x) false ) true) , b = 1 }.b) }.b) , b = ({a = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (pred 0) }.a) , b = ({a = 1 , b = 1 }.b) }.a) , c =  (( \f: Rec X. X .((f ({a = 0 , b = 0 }.b) ) ({a = false , b = 1 }.b) ) ) (\a: Nat .\b: Unit .b)) }.b) , c =  (let u = (fix (\x: Nat . (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in 1) )) in (((\x: Unit .\y: Rec X. X .y) (fix (\x: Rec X. X . true )) ) 0)) }.b) }.b)
({a = (fix (\x: Unit . (((\x: Rec X. X .\y: Bool .y) ({a = false , b = 0 }.a) ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a))) )) , b = (let u = (unfold [ Nat ] (fold [ Unit ] (let u = false in 1) )) in (unfold [ Nat ] (fold [ Nat ] 1 ))) }.b)
(pred ({a = (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Rec X. X ] (fold [ Unit ] (pred 1) ))) , b = (case <r = ({a = 0 , b = true , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) , c = (let u = (pred ({a = 0 , b = 1 }.b)) in u) }.c))
(let u = (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Nat ] false )) )) in (succ ({a = ({a = 1 , b = true , c =  1 }.b) , b = ({a = 1 , b = true , c = 0 }.c) }.b)))
(if (let u = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = false , c =  1 }.b) )) in u) in u) then (if (let u = (let u = 1 in u) in (((\x: Unit .\y: Nat .y) true ) false)) then (case <r = (let u = (let u = true in true) in false) > as Bool of < l = x > => x | < r = y > => y) else (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) ) (fix (\x: Rec X. X . true )) ) ) (\a: Rec X. X .\b: Bool .a))) else (iszero (((\x: Bool .\y: Bool .y) ({a = 1 , b = (if false then false else false) }.b) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)))))
({a = (((\x: Unit .\y: Bool .y) ({a = 0 , b = true }.b) ) (((\x: Rec X. X .\y: Bool .y) (((\x: Rec X. X .\y: Bool .x) false ) false) ) (let u = 1 in u))) , b = ({a = (iszero (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = (let u = false in true) , b = ({a = 1 , b = false }.a) }.a) }.b) , c = (let u = (fix (\x: Rec X. X . (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) )) in u) }.c)
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Nat .\y: Bool .x) (( \f: Rec X. X .((f (let u = (succ 0) in ({a = 0 , b = true }.b)) ) ({a = (succ 0) , b = (unfold [ Unit ] (fold [ Unit ] false )) }.b) ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Unit .\y: Bool .x) ({a = ({a = false , b = 1 }.b) , b = false , c =  0 }.b) ) (((\x: Unit .\y: Bool .x) ({a = true , b = true }.b) ) ({a = 1 , b = true }.b)))) ))
(let u = ({a = ({a = (let u = ({a = 1 , b = true }.b) in 1) , b = (( \f: Nat .((f (unfold [ Unit ] (fold [ Rec X. X ] true )) ) (let u = 0 in false) ) ) (\a: Bool .\b: Unit .a)) }.a) , b = (let u = true in u) , c =  ({a = (let u = 0 in true) , b = (if false then 1 else 0) }.b) }.b) in ({a = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b))) , b = (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = false }.b) )) , c =  (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f 1 ) ({a = true , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) ) (if true then true else true)) }.b))
(( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] (iszero ({a = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) , b = (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .y) false ) 0) )) }.b)) )) ) (((\x: Bool .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Bool .y) true ) true) in u) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in u)) ) ) (\a: Unit .\b: Unit .a))
(let u = ({a = (((\x: Nat .\y: Rec X. X .x) ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) ) ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = true }.a) , b = ({a = true , b = 0 }.a) , c =  ({a = 0 , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) , c = ({a = false , b = 0 }.b) }.c) }.b)) , b = (let u = (if (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) then false else (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a))) in (((\x: Nat .\y: Rec X. X .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) ) (( \f: Bool .((f (let u = 0 in 1) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Nat .b)))) }.b) in u)
({a = (let u = (let u = ({a = false , b = false }.b) in (( \f: Nat .((f 1 ) (if false then 1 else 1) ) ) (\a: Bool .\b: Unit .a))) in ({a = (let u = false in u) , b = ({a = 0 , b = true , c = 0 }.c) }.b)) , b = (iszero (case <l = (((\x: Bool .\y: Rec X. X .x) ({a = true , b = (let u = 1 in u) }.b) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a))) > as Nat of < l = x > => x | < r = y > => y)) }.a)
(let u = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = (let u = 1 in true) > as Bool of < l = x > => x | < r = y > => y) )) in u)
({a = (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Bool ] true )) ) (unfold [ Bool ] (fold [ Nat ] false )) ) ) (\a: Nat .\b: Nat .b)) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) , b = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Bool . (let u = (((\x: Bool .\y: Rec X. X .x) false ) false) in 1) )) )) }.b)
(fix (\x: Nat . ({a = (case <r = (case <r = ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) , b = (let u = true in true) , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ({a = (let u = false in false) , b = ({a = false , b = true }.b) }.b) , b = ({a = ({a = 0 , b = true }.a) , b = (( \f: Rec X. X .((f true ) (fix (\x: Bool . true )) ) ) (\a: Nat .\b: Rec X. X .b)) , c = ({a = 1 , b = true , c = 1 }.c) }.c) }.b) }.b) ))
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) }.b) in ({a = (fix (\x: Bool . (let u = false in true) )) , b = (fix (\x: Unit . 0 )) }.b)) ))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = true , b = false }.b) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) )) ))
(let u = ({a = ({a = (let u = false in u) , b = (((\x: Unit .\y: Bool .y) (fix (\x: Unit . true )) ) 0) }.a) , b = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = (fix (\x: Nat . (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) )) }.b) }.b) in (pred ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) in true) }.a)))
(let u = (( \f: Unit .((f (let u = ({a = (let u = true in 0) , b = 1 }.b) in (if true then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))) ) ({a = ({a = 1 , b = (iszero 1) }.a) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) in u)
(iszero (succ (if (unfold [ Nat ] (fold [ Unit ] true )) then (pred 1) else (((\x: Rec X. X .\y: Unit .x) (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) (unfold [ Nat ] (fold [ Bool ] false ))))))
(fix (\x: Unit . ({a = (let u = ({a = 1 , b = 0 }.b) in u) , b = (let u = true in (let u = 0 in false)) , c =  (let u = 1 in u) }.b) ))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f false ) (let u = 0 in false) ) ) (\a: Nat .\b: Rec X. X .b)) ) (if true then (succ 1) else (unfold [ Nat ] (fold [ Nat ] 0 )))) ) ({a = (( \f: Rec X. X .((f (let u = false in (let u = true in false)) ) (( \f: Rec X. X .((f (iszero 1) ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) ) (fix (\x: Bool . 0 )) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) ) (\a: Nat .\b: Bool .b))
(case <l = (case <l = (((\x: Nat .\y: Unit .y) true ) 0) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . (if ({a = (let u = 0 in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) , b = (let u = 1 in false) }.b) then ({a = 0 , b = true }.b) else (let u = (( \f: Bool .((f (pred 1) ) (((\x: Nat .\y: Rec X. X .y) false ) 1) ) ) (\a: Bool .\b: Rec X. X .b)) in ({a = 1 , b = false }.b))) ))
(case <r = ({a = (( \f: Rec X. X .((f ({a = 1 , b = ({a = false , b = 0 }.a) }.b) ) (unfold [ Bool ] (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Nat .((f (iszero 1) ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Bool .\b: Unit .b)) }.b) > as Unit of < l = x > => x | < r = y > => y)
(if ({a = (fix (\x: Unit . true )) , b = (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in u) }.a) then ({a = (pred (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) , b = (iszero 0) , c = (let u = 1 in u) }.c) else ({a = (unfold [ Unit ] (fold [ Bool ] (let u = 0 in u) )) , b = (let u = (fix (\x: Rec X. X . 0 )) in ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 ))) }.b))
(((\x: Unit .\y: Bool .x) ({a = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = (iszero 0) , b = (let u = ({a = 1 , b = 1 }.b) in u) }.a) , c =  ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (pred 0) )) , b = ({a = 0 , b = true }.b) }.a) }.b) ) (let u = (let u = ({a = false , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) }.b) in (if true then (let u = 1 in false) else true)) in u))
(((\x: Unit .\y: Unit .y) ({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f (let u = ({a = false , b = false }.b) in u) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Unit .b)) ) (let u = (unfold [ Bool ] (fold [ Bool ] true )) in (let u = ({a = true , b = 0 }.b) in (((\x: Unit .\y: Unit .y) false ) true))) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = ({a = 1 , b = false , c =  1 }.b) in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.b) ) (fix (\x: Rec X. X . (let u = ({a = 0 , b = false , c = (succ 1) }.c) in u) )))
(let u = (((\x: Rec X. X .\y: Unit .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if true then 1 else (((\x: Nat .\y: Unit .y) true ) 0)) )) ) (let u = (let u = (let u = 1 in true) in (succ (((\x: Unit .\y: Nat .x) 1 ) false))) in (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b))))) in (fix (\x: Nat . ({a = (succ 1) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) (fix (\x: Unit . true ))) }.a) )))
({a = ({a = (fix (\x: Rec X. X . (( \f: Rec X. X .((f ({a = 0 , b = 1 }.b) ) 1 ) ) (\a: Nat .\b: Bool .a)) )) , b = (let u = ({a = (let u = 0 in true) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.a) in (let u = (let u = 0 in true) in ({a = false , b = false }.b))) , c =  (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .x) 1 ) false) ) (if ({a = true , b = false }.b) then ({a = 0 , b = true , c = 1 }.c) else 0) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) , b = (( \f: Unit .((f (((\x: Unit .\y: Bool .y) (let u = false in u) ) (let u = false in false)) ) (((\x: Bool .\y: Rec X. X .x) (if true then true else false) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)
(( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . true )) )) ) (((\x: Bool .\y: Bool .y) true ) ({a = 1 , b = 0 }.b))) ) (unfold [ Unit ] (fold [ Bool ] (if (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Bool ] true )) )) then (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = 1 }.b)) else (( \f: Rec X. X .((f (succ 1) ) (let u = true in 1) ) ) (\a: Nat .\b: Nat .a))) )) ) ) (\a: Rec X. X .\b: Unit .a))
(fix (\x: Bool . (fix (\x: Bool . (((\x: Bool .\y: Nat .x) ({a = (case <l = (((\x: Nat .\y: Rec X. X .y) false ) 1) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = (if true then true else false) , c =  (((\x: Bool .\y: Nat .y) true ) 0) }.b) , c =  (pred 1) }.b) ) (if (((\x: Unit .\y: Rec X. X .y) (fix (\x: Nat . false )) ) true) then (let u = true in u) else ({a = (succ 1) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)) }.b))) )) ))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Unit .y) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .b))) ) (unfold [ Bool ] (fold [ Nat ] (case <r = (let u = true in u) > as Bool of < l = x > => x | < r = y > => y) ))) ) (case <r = (fix (\x: Unit . ({a = 0 , b = true , c =  0 }.b) )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b))
(unfold [ Nat ] (fold [ Nat ] (succ ({a = ({a = 1 , b = 1 }.b) , b = (if true then false else false) , c = ({a = 0 , b = true , c = 1 }.c) }.c)) ))
(((\x: Unit .\y: Rec X. X .y) (let u = (let u = 1 in true) in (( \f: Rec X. X .((f (iszero 0) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ) (\a: Bool .\b: Rec X. X .b))) ) ({a = ({a = 0 , b = (((\x: Unit .\y: Rec X. X .x) true ) true) }.b) , b = (let u = (case <l = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) in u) }.a))
(case <r = (let u = ({a = (let u = (fix (\x: Bool . true )) in true) , b = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.a) in u) > as Nat of < l = x > => x | < r = y > => y)
((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = true in u) , b = (iszero 0) }.b) )) ) (iszero (succ 0)) ) ) (\a: Rec X. X .\b: Unit .b)) ))
({a = (((\x: Bool .\y: Nat .x) (succ (let u = ({a = 1 , b = true }.a) in u)) ) (( \f: Unit .((f (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = 0 , b = (((\x: Nat .\y: Rec X. X .x) false ) true) }.b) ) ) (\a: Unit .\b: Nat .b))) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = (case <r = (let u = true in true) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a))) }.a) ) (((\x: Nat .\y: Bool .x) (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = false , c =  1 }.b) ) (fix (\x: Bool . true ))) ) (unfold [ Bool ] (fold [ Nat ] (unfold [ Unit ] (fold [ Bool ] true )) )))) }.a)
(( \f: Unit .((f (( \f: Nat .((f (( \f: Bool .((f ({a = 1 , b = false , c =  0 }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) ) ) (\a: Bool .\b: Unit .b)) ) (((\x: Rec X. X .\y: Nat .x) (((\x: Rec X. X .\y: Unit .x) (let u = true in u) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ))) ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , b = 0 }.a) in u) ) ) (\a: Nat .\b: Nat .a))
(succ ({a = (( \f: Rec X. X .((f ({a = 0 , b = (let u = 1 in 0) }.b) ) (fix (\x: Unit . 0 )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = (pred 0) , b = (let u = false in u) , c =  (let u = false in 0) }.b) }.a))
(((\x: Unit .\y: Rec X. X .x) (fix (\x: Unit . (( \f: Bool .((f ({a = (iszero 0) , b = (let u = 1 in true) }.b) ) (unfold [ Unit ] (fold [ Nat ] false )) ) ) (\a: Nat .\b: Nat .a)) )) ) (fix (\x: Rec X. X . ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = true , b = true }.b) in u) )) )))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = (fix (\x: Nat . (let u = true in (((\x: Nat .\y: Unit .x) true ) false)) )) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(fix (\x: Nat . (if (let u = ({a = ({a = 1 , b = (((\x: Bool .\y: Bool .x) 1 ) false) }.b) , b = (succ 1) }.b) in ({a = true , b = (((\x: Nat .\y: Bool .x) true ) true) }.b)) then ({a = ({a = 0 , b = false , c = 1 }.c) , b = ({a = 0 , b = (succ 1) }.b) }.b) else ({a = (let u = false in 1) , b = ({a = (let u = true in 0) , b = (((\x: Nat .\y: Nat .x) false ) false) }.b) }.a)) ))
(if ({a = (let u = ({a = 0 , b = true }.b) in u) , b = (((\x: Bool .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) (((\x: Rec X. X .\y: Unit .x) 0 ) true)) }.a) then ({a = ({a = (( \f: Bool .((f (let u = 0 in u) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (((\x: Unit .\y: Unit .y) false ) false) }.a) , b = (((\x: Unit .\y: Nat .x) ({a = ({a = 0 , b = false }.b) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .a)) }.b) ) (if true then (let u = 0 in false) else false)) , c =  ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) }.b) }.b) else (( \f: Unit .((f (let u = (succ 1) in ({a = 1 , b = false }.b)) ) (fix (\x: Nat . ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) )) ) ) (\a: Nat .\b: Unit .b)))
(let u = ({a = (((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (iszero 0) )) ) (if ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = true , c =  0 }.b) then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else (if false then (let u = true in u) else (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)))) , b = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) true ) true) )) in u) }.b) in u)
({a = (( \f: Nat .((f ({a = ({a = (((\x: Bool .\y: Bool .y) true ) 1) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) }.a) , b = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = 0 }.a) , c = (((\x: Bool .\y: Bool .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b))) }.c) ) (let u = (let u = false in false) in (succ 0)) ) ) (\a: Unit .\b: Unit .a)) , b = (fix (\x: Nat . ({a = false , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) )) }.a)
({a = (let u = (let u = (((\x: Nat .\y: Unit .y) true ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b))) in (((\x: Rec X. X .\y: Unit .y) true ) true)) in (((\x: Nat .\y: Bool .y) (case <r = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)))) , b = ({a = (((\x: Unit .\y: Rec X. X .x) (pred (let u = 0 in u)) ) (if true then (fix (\x: Rec X. X . true )) else true)) , b = (fix (\x: Bool . true )) , c =  (fix (\x: Unit . (fix (\x: Unit . 0 )) )) }.b) }.b)
({a = (let u = (let u = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) in (let u = false in u)) in (((\x: Nat .\y: Unit .x) ({a = false , b = 0 }.b) ) (let u = false in u))) , b = ({a = (( \f: Nat .((f (iszero 1) ) (fix (\x: Bool . true )) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Bool .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ({a = ({a = false , b = 0 }.b) , b = (( \f: Unit .((f ({a = true , b = 1 }.a) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) , c = (let u = true in 1) }.c) ) ) (\a: Nat .\b: Nat .a)) }.a) , c =  (( \f: Rec X. X .((f (succ (((\x: Nat .\y: Bool .y) ({a = 1 , b = false }.b) ) 0)) ) ({a = (succ 0) , b = (pred (succ 1)) }.b) ) ) (\a: Unit .\b: Unit .a)) }.b)
(((\x: Rec X. X .\y: Nat .y) ({a = (pred (let u = 1 in 1)) , b = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Bool ] (let u = 1 in true) )) ) (((\x: Bool .\y: Nat .y) (iszero 1) ) (case <r = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Nat .a)) }.b) ) (succ (((\x: Nat .\y: Unit .x) ({a = ({a = false , b = 1 }.a) , b = 0 }.b) ) (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = true }.b) )))))
(case <l = (if (let u = ({a = true , b = 0 }.b) in ({a = false , b = 0 }.a)) then (let u = ({a = 1 , b = 0 }.b) in u) else (let u = 1 in u)) > as Nat of < l = x > => x | < r = y > => y)
({a = (case <l = (( \f: Unit .((f ({a = (fix (\x: Bool . 1 )) , b = (fix (\x: Bool . true )) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.c) ) (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) 1 ) false) )) ) (((\x: Nat .\y: Bool .x) 1 ) false) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . (let u = ({a = (unfold [ Bool ] (fold [ Rec X. X ] true )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false )) }.b) in u) )) }.a)
(((\x: Nat .\y: Nat .x) ({a = (if (( \f: Rec X. X .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) ) true ) ) (\a: Nat .\b: Nat .b)) then (unfold [ Nat ] (fold [ Rec X. X ] 1 )) else ({a = 0 , b = (if false then 1 else 1) }.b)) , b = ({a = (fix (\x: Unit . (succ 0) )) , b = ({a = (let u = 1 in 0) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) , c =  (fix (\x: Nat . 0 )) }.b) }.b) , c = (( \f: Nat .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Bool .\y: Bool .x) 1 ) true) ) ) (\a: Rec X. X .\b: Unit .b)) }.c) ) (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Bool .\y: Unit .x) (let u = (fix (\x: Bool . true )) in u) ) (((\x: Bool .\y: Unit .x) false ) true))))
(let u = (fix (\x: Rec X. X . ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) true ) true) , c =  1 }.b) )) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Bool . (succ 1) )) )))
(((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Nat .y) ({a = (let u = 1 in 1) , b = true , c =  (((\x: Unit .\y: Unit .x) 1 ) false) }.b) ) (unfold [ Unit ] (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) true ) 0) ))) ) (let u = (let u = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = 0 }.b) in ({a = 1 , b = false }.b)) in u))
({a = (((\x: Nat .\y: Bool .x) (let u = (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) in u) in ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) true ) true) ))) ) ({a = true , b = 1 }.a)) , b = (((\x: Unit .\y: Rec X. X .x) ({a = (case <l = (unfold [ Nat ] (fold [ Bool ] 1 )) > as Unit of < l = x > => x | < r = y > => y) , b = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (unfold [ Nat ] (fold [ Rec X. X ] false )) else (let u = 1 in true)) }.a) ) (fix (\x: Nat . ({a = (if false then false else false) , b = (fix (\x: Bool . 1 )) }.a) ))) }.b)
(pred (let u = (((\x: Bool .\y: Unit .x) ({a = ({a = false , b = 1 }.a) , b = 1 }.a) ) ({a = 0 , b = true }.b)) in (((\x: Rec X. X .\y: Unit .x) (succ 1) ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)))))
(let u = (( \f: Unit .((f (iszero (let u = (let u = true in 1) in 0)) ) (fix (\x: Rec X. X . (let u = true in u) )) ) ) (\a: Unit .\b: Rec X. X .b)) in u)
(let u = (( \f: Unit .((f (let u = (((\x: Bool .\y: Rec X. X .y) false ) ({a = true , b = true }.b)) in ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) , b = ({a = 1 , b = 1 }.b) }.a)) ) ({a = (pred ({a = 0 , b = 1 }.b)) , b = ({a = ({a = false , b = true }.b) , b = false }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) in u)
(case <l = (case <l = (((\x: Rec X. X .\y: Unit .y) (fix (\x: Unit . false )) ) (if true then 0 else 0)) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(iszero (( \f: Rec X. X .((f (let u = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) in (((\x: Unit .\y: Unit .y) false ) 1)) in ({a = 1 , b = (let u = 1 in false) }.a)) ) (let u = (succ 0) in ({a = (let u = 0 in u) , b = true , c = (let u = 1 in 1) }.c)) ) ) (\a: Nat .\b: Unit .b)))
(case <r = (fix (\x: Rec X. X . (let u = 1 in (fix (\x: Rec X. X . false ))) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) ) (((\x: Rec X. X .\y: Nat .x) false ) (let u = 0 in true)) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) ) 0) )) }.a)
(let u = (( \f: Unit .((f (if ({a = 0 , b = false , c =  0 }.b) then (if true then true else true) else (( \f: Rec X. X .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) true ) ) (\a: Rec X. X .\b: Unit .a))) ) ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] true )) ) (let u = true in false) ) ) (\a: Rec X. X .\b: Unit .a)) , c =  (let u = 0 in u) }.b) ) ) (\a: Nat .\b: Nat .a)) in u)
(let u = ({a = ({a = ({a = 0 , b = true }.a) , b = (let u = (let u = 0 in false) in u) }.a) , b = ({a = (if true then ({a = 1 , b = false }.a) else ({a = 1 , b = true , c = 0 }.c)) , b = (( \f: Unit .((f (((\x: Nat .\y: Nat .x) true ) true) ) (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .b))) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  ({a = ({a = 1 , b = true }.b) , b = 1 }.b) }.b) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (if false then ({a = false , b = false }.b) else ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false ))) , c = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = 0 }.b) }.c) )) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] (let u = (((\x: Unit .\y: Unit .x) true ) false) in (let u = 0 in false)) )))
(let u = (let u = (( \f: Unit .((f false ) (fix (\x: Nat . true )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u) in ({a = (((\x: Bool .\y: Bool .x) (case <l = (if true then 0 else 1) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b))) , b = (( \f: Unit .((f ({a = 0 , b = false , c = 0 }.c) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .a)) }.b))
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f (let u = true in 0) ) (pred 0) ) ) (\a: Unit .\b: Unit .a)) )) , b = (( \f: Rec X. X .((f ({a = ({a = 0 , b = true , c =  1 }.b) , b = 1 }.a) ) (((\x: Unit .\y: Nat .y) true ) ({a = false , b = 1 }.a)) ) ) (\a: Nat .\b: Rec X. X .b)) }.a)
(succ (let u = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (succ (pred 0)) }.b) in (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) false) ))))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Nat ] (let u = ({a = (succ 0) , b = (let u = 0 in true) , c = 1 }.c) in ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 ))) )) ))
(((\x: Unit .\y: Nat .y) ({a = (case <r = (unfold [ Rec X. X ] (fold [ Nat ] true )) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = 1 , b = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a)) , c = (((\x: Nat .\y: Rec X. X .y) true ) 1) }.c)) )) }.a) ) (((\x: Bool .\y: Bool .y) (if true then false else (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = (pred 1) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c =  (fix (\x: Unit . 0 )) }.b)))
({a = (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) in (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) in (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) )) in u)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) )) }.a)
(let u = (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f ({a = 0 , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) ({a = false , b = false }.b) ) ) (\a: Bool .\b: Bool .a)) ) (iszero ({a = 0 , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) }.a))) in ({a = ({a = (((\x: Bool .\y: Rec X. X .x) 1 ) true) , b = ({a = false , b = 1 }.a) , c = (let u = (((\x: Nat .\y: Unit .x) 1 ) false) in (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) }.c) , b = (fix (\x: Rec X. X . (if (let u = 0 in true) then (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) else false) )) }.b))
({a = (succ (case <l = (fix (\x: Unit . 0 )) > as Nat of < l = x > => x | < r = y > => y)) , b = (case <l = (unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f 0 ) (((\x: Unit .\y: Bool .y) true ) 0) ) ) (\a: Rec X. X .\b: Bool .b)) )) > as Nat of < l = x > => x | < r = y > => y) }.b)
(((\x: Bool .\y: Unit .y) (( \f: Nat .((f ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) , c =  ({a = 1 , b = false }.a) }.b) ) (((\x: Rec X. X .\y: Nat .x) (iszero 0) ) ({a = 1 , b = true }.b)) ) ) (\a: Nat .\b: Rec X. X .a)) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) ({a = 1 , b = true }.b) ) true) )))
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (( \f: Nat .((f (case <l = (if false then (unfold [ Unit ] (fold [ Unit ] 0 )) else (((\x: Rec X. X .\y: Nat .x) 1 ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Nat .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Bool .a)) ))
(succ (case <l = (unfold [ Bool ] (fold [ Nat ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(( \f: Bool .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) in (pred 1)) )) ) ({a = (case <l = ({a = 1 , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Unit .x) (if ({a = true , b = 0 }.a) then (if (if false then true else true) then false else false) else (((\x: Unit .\y: Bool .y) true ) true)) ) (((\x: Bool .\y: Rec X. X .x) false ) (let u = 0 in false))) }.a) ) ) (\a: Unit .\b: Nat .b))
(let u = (let u = ({a = (fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] true )) )) , b = (( \f: Nat .((f false ) (let u = false in false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) in u) in (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (pred 1) )) in (((\x: Rec X. X .\y: Nat .y) ({a = ({a = false , b = false }.b) , b = 0 }.a) ) (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y))))
(if (( \f: Bool .((f (if (iszero 1) then ({a = false , b = ({a = 0 , b = 1 }.b) }.a) else ({a = (let u = true in true) , b = ({a = 1 , b = false , c = 0 }.c) }.a)) ) (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) (fix (\x: Unit . true )) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .a)) then (((\x: Bool .\y: Nat .x) (fix (\x: Unit . (let u = 0 in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) )) ) (((\x: Bool .\y: Nat .y) (case <r = (if false then true else false) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Unit .x) ({a = false , b = false }.b) ) (let u = false in u)))) else (let u = (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = false , c = 0 }.c) )) in (let u = (((\x: Unit .\y: Nat .y) false ) false) in (unfold [ Bool ] (fold [ Bool ] 0 )))))
(( \f: Nat .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Bool . (fix (\x: Rec X. X . ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) )) )) )) ) (unfold [ Bool ] (fold [ Nat ] (((\x: Nat .\y: Rec X. X .x) ({a = true , b = 0 }.a) ) (if false then true else true)) )) ) ) (\a: Nat .\b: Unit .a))
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Nat .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) (fix (\x: Bool . ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )) )) ) ) (\a: Unit .\b: Rec X. X .a)) )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (if (iszero 0) then (unfold [ Nat ] (fold [ Bool ] true )) else ({a = false , b = (let u = false in true) }.b)) )) }.b)
(let u = (let u = (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) > as Unit of < l = x > => x | < r = y > => y) in u) in ({a = (unfold [ Nat ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) )) , b = (((\x: Unit .\y: Nat .y) ({a = 0 , b = true , c =  1 }.b) ) ({a = false , b = 0 }.a)) , c = ({a = 0 , b = false , c = 0 }.c) }.c))
(( \f: Rec X. X .((f (fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) )) )) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a))) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f (( \f: Unit .((f (let u = false in u) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .a)) ) (( \f: Nat .((f ({a = (if true then false else true) , b = ({a = 1 , b = true , c =  0 }.b) }.b) ) (((\x: Nat .\y: Unit .y) ({a = false , b = true }.b) ) false) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Bool .a)) ))
(case <r = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (fix (\x: Nat . (let u = false in u) )) )) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (fix (\x: Rec X. X . (let u = (let u = false in u) in u) )) ) (let u = (((\x: Nat .\y: Unit .y) false ) ({a = 1 , b = 0 }.b)) in (fix (\x: Unit . (let u = true in u) ))) ) ) (\a: Unit .\b: Rec X. X .b))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = ({a = ({a = true , b = 0 }.a) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) in (((\x: Rec X. X .\y: Nat .x) (unfold [ Bool ] (fold [ Nat ] 0 )) ) ({a = true , b = 0 }.a))) ))
(unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) ({a = true , b = ({a = 0 , b = true }.a) }.a) ) ({a = (fix (\x: Rec X. X . 0 )) , b = (((\x: Nat .\y: Nat .y) false ) false) , c =  (let u = 0 in 0) }.b)) ) (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Unit .b)) ))
(( \f: Rec X. X .((f (( \f: Nat .((f (succ (((\x: Unit .\y: Rec X. X .y) true ) 0)) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a))) ) ) (\a: Unit .\b: Bool .b)) ) (( \f: Bool .((f (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) ) (pred (((\x: Nat .\y: Unit .x) 1 ) true)) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .a))
(fix (\x: Unit . (fix (\x: Nat . (let u = (let u = ({a = 0 , b = true , c = 0 }.c) in 0) in (let u = 1 in false)) )) ))
(case <r = (let u = ({a = (( \f: Unit .((f 0 ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (fix (\x: Unit . true )) , c =  ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) false) , b = true }.a) }.b) in u) > as Bool of < l = x > => x | < r = y > => y)
(let u = (((\x: Rec X. X .\y: Unit .y) (fix (\x: Bool . (((\x: Bool .\y: Bool .x) false ) true) )) ) (((\x: Unit .\y: Rec X. X .y) (((\x: Nat .\y: Bool .x) (let u = 0 in true) ) ({a = (let u = 0 in false) , b = (let u = 1 in u) }.a)) ) (unfold [ Rec X. X ] (fold [ Bool ] true )))) in (pred ({a = (fix (\x: Nat . 1 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .b)) , c = (pred 0) }.c)))
(( \f: Unit .((f (((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) ) (((\x: Bool .\y: Rec X. X .x) true ) ({a = false , b = false }.b))) ) (let u = ({a = (pred 0) , b = (((\x: Bool .\y: Nat .x) false ) false) }.b) in (((\x: Rec X. X .\y: Nat .x) ({a = 0 , b = true }.b) ) (unfold [ Nat ] (fold [ Nat ] true ))))) ) ({a = (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f (succ 1) ) (pred 0) ) ) (\a: Rec X. X .\b: Unit .b)) )) , b = (((\x: Bool .\y: Unit .x) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (unfold [ Rec X. X ] (fold [ Bool ] true ))) , c =  ({a = (let u = 1 in 0) , b = (fix (\x: Nat . true )) }.a) }.b) ) ) (\a: Bool .\b: Nat .b))
(unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) (iszero (let u = true in 0)) ) ({a = (let u = 0 in u) , b = (let u = true in false) , c = (((\x: Nat .\y: Bool .y) true ) 1) }.c)) ))
(((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Rec X. X .y) ({a = (iszero 0) , b = (let u = 1 in 1) }.a) ) (( \f: Rec X. X .((f (let u = 0 in (if true then false else false)) ) (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .x) true ) false) ) false) ) ) (\a: Nat .\b: Rec X. X .b))) ) ({a = ({a = 1 , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (let u = true in false) }.b)) ) ({a = ({a = 0 , b = (let u = false in true) , c = (pred 0) }.c) , b = (((\x: Nat .\y: Unit .y) true ) false) }.b))
({a = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Nat . 0 )) )) , b = (let u = (unfold [ Bool ] (fold [ Rec X. X ] false )) in (let u = 1 in 1)) }.b) , b = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) in (( \f: Nat .((f (( \f: Unit .((f true ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ) (let u = (fix (\x: Unit . 0 )) in (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Nat .b))) , c =  ({a = (succ ({a = 0 , b = 0 }.b)) , b = ({a = (fix (\x: Bool . false )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) }.b) }.a) }.b)
({a = (unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f (let u = true in u) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Rec X. X .a)) )) , b = ({a = (if false then false else true) , b = ({a = (let u = 1 in u) , b = ({a = 0 , b = false }.a) }.b) }.a) }.b)
(case <l = (( \f: Rec X. X .((f ({a = 1 , b = (let u = true in true) }.a) ) (((\x: Rec X. X .\y: Bool .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) ) ({a = 0 , b = false , c =  0 }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) true ) 0) )) )) in ({a = (pred 1) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = ({a = 1 , b = ({a = 0 , b = false }.b) , c =  (if false then 1 else 1) }.b) }.a) }.b))
(case <l = (if (fix (\x: Bool . (fix (\x: Bool . false )) )) then (let u = (pred ({a = 0 , b = true , c = 1 }.c)) in (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Bool .a))) else ({a = ({a = (((\x: Rec X. X .\y: Unit .x) (succ 1) ) (fix (\x: Unit . true ))) , b = (let u = false in u) , c =  (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) , b = (((\x: Rec X. X .\y: Nat .y) ({a = false , b = ({a = false , b = false }.b) }.b) ) (let u = 0 in u)) }.b)) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (case <l = (unfold [ Unit ] (fold [ Unit ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = 0 }.b) )) )) ) ) (\a: Nat .\b: Bool .a))
({a = (if (( \f: Bool .((f (let u = 1 in false) ) (unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) )) ) ) (\a: Unit .\b: Nat .b)) then (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) in u) else ({a = (fix (\x: Bool . (( \f: Nat .((f (let u = 0 in u) ) (if false then 1 else 0) ) ) (\a: Bool .\b: Bool .a)) )) , b = ({a = false , b = (fix (\x: Unit . true )) }.b) }.a)) , b = (iszero (pred (if false then 1 else 0))) }.b)
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = ({a = (if false then 0 else 1) , b = ({a = false , b = false }.b) , c =  (((\x: Unit .\y: Nat .y) true ) 0) }.b) in ({a = (let u = (succ 0) in (((\x: Rec X. X .\y: Nat .x) 0 ) false)) , b = (unfold [ Bool ] (fold [ Rec X. X ] (if true then false else false) )) }.b)) ))
(((\x: Bool .\y: Nat .x) (pred (fix (\x: Nat . (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) ))) ) ({a = (let u = ({a = false , b = true }.b) in ({a = 0 , b = 0 }.b)) , b = (if true then true else true) , c =  ({a = (if false then 1 else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Nat .y) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) false) , c = (( \f: Unit .((f (pred 1) ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.c) }.b))
({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f (fix (\x: Rec X. X . 1 )) ) (((\x: Bool .\y: Unit .y) true ) 1) ) ) (\a: Nat .\b: Bool .b)) }.a) , b = ({a = (( \f: Bool .((f (if true then 1 else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 1 ))) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (if true then false else false) }.b) }.a) }.a)
(if (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Unit . (let u = (((\x: Unit .\y: Bool .y) true ) 0) in true) )) )) then ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero (pred 1)) )) )) else (((\x: Nat .\y: Rec X. X .x) (case <r = (((\x: Bool .\y: Unit .y) true ) false) > as Nat of < l = x > => x | < r = y > => y) ) (iszero (succ (fix (\x: Bool . 1 ))))))
(let u = (let u = ({a = (let u = 1 in u) , b = (let u = false in true) }.b) in (let u = 1 in true)) in u)
(((\x: Unit .\y: Unit .y) (let u = (let u = (((\x: Unit .\y: Bool .x) true ) true) in ({a = true , b = true }.b)) in u) ) (case <r = (let u = ({a = 1 , b = false , c = 0 }.c) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y))
(fix (\x: Unit . (fix (\x: Rec X. X . (iszero ({a = (((\x: Nat .\y: Rec X. X .y) true ) 1) , b = ({a = 1 , b = false }.b) , c = (let u = 0 in 0) }.c)) )) ))
(( \f: Unit .((f (pred (succ (if true then 1 else 0))) ) (if (if (unfold [ Nat ] (fold [ Nat ] true )) then (case <r = false > as Unit of < l = x > => x | < r = y > => y) else (unfold [ Nat ] (fold [ Unit ] false ))) then (if ({a = ({a = 1 , b = false , c = 0 }.c) , b = false }.b) then (unfold [ Nat ] (fold [ Rec X. X ] 1 )) else ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = 0 in u) ))) else ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .x) 1 ) false) ))) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (((\x: Rec X. X .\y: Nat .x) ({a = (let u = true in 0) , b = ({a = 1 , b = true }.b) , c =  (if false then ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) else 1) }.b) ) ({a = (let u = true in 1) , b = ({a = (fix (\x: Nat . 0 )) , b = false }.b) , c =  ({a = 0 , b = ({a = 0 , b = false }.a) }.b) }.b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (fix (\x: Rec X. X . 0 )) , b = 1 }.b) )) }.b)
(if ({a = (fix (\x: Nat . (succ 1) )) , b = (let u = (iszero 1) in u) , c =  (((\x: Rec X. X .\y: Rec X. X .x) (succ (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) ) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (let u = true in true) , c =  0 }.b)) }.b) then ({a = (if (let u = true in true) then (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) else (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) else ({a = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.c) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , b = (((\x: Bool .\y: Rec X. X .x) true ) false) , c = (((\x: Unit .\y: Unit .x) (succ ({a = 1 , b = 1 }.b)) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) }.c) }.b))
({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) true ) true) )) , b = (pred 1) }.b) , b = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (if (((\x: Bool .\y: Bool .x) true ) true) then ({a = 1 , b = false }.b) else (let u = true in true))) )) }.a)
({a = ({a = (((\x: Nat .\y: Bool .x) (if (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Unit .b)) then true else false) ) (( \f: Bool .((f false ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a))) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = 0 , b = 0 }.b) in u) )) }.a) , b = (( \f: Bool .((f ({a = ({a = 0 , b = true }.b) , b = true }.b) ) (((\x: Unit .\y: Rec X. X .x) true ) false) ) ) (\a: Unit .\b: Rec X. X .b)) }.b)
(((\x: Unit .\y: Unit .x) (fix (\x: Nat . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .b)) )) )) ) (let u = (iszero (((\x: Nat .\y: Unit .x) 1 ) true)) in u))
(let u = ({a = (fix (\x: Unit . ({a = 1 , b = false }.a) )) , b = (((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Unit .x) false ) true) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .b))) , c =  (let u = ({a = (( \f: Bool .((f ({a = 0 , b = false , c = 0 }.c) ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = ({a = 0 , b = false }.b) , c = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) }.c) in u) }.b) in u)
(( \f: Unit .((f (( \f: Bool .((f (( \f: Bool .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = true in 1) ) ) (\a: Bool .\b: Unit .a)) ) (case <l = (let u = 1 in 1) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) ) (succ (succ 0)) ) ) (\a: Nat .\b: Unit .a))
(fix (\x: Nat . (let u = (let u = (let u = false in u) in u) in u) ))
({a = (( \f: Rec X. X .((f ({a = (((\x: Unit .\y: Unit .y) false ) false) , b = (((\x: Unit .\y: Unit .y) (((\x: Nat .\y: Rec X. X .y) true ) true) ) (let u = 1 in u)) }.b) ) (if ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) then (fix (\x: Nat . 1 )) else ({a = 0 , b = false , c = 1 }.c)) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (unfold [ Unit ] (fold [ Bool ] (fix (\x: Bool . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = true , b = true }.b) )) )) )) }.b)
(((\x: Unit .\y: Rec X. X .y) (let u = (let u = (let u = 0 in 1) in 1) in ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Unit .y) true ) true) }.b)) ) (let u = (( \f: Rec X. X .((f ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = false , c = (let u = true in 1) }.c) ) (( \f: Nat .((f (((\x: Nat .\y: Nat .y) true ) 0) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Unit .\b: Rec X. X .a)) in (( \f: Unit .((f (if false then 0 else 1) ) ({a = 0 , b = true }.a) ) ) (\a: Unit .\b: Nat .a))))
(((\x: Bool .\y: Unit .x) ({a = (let u = 1 in ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 ))) , b = ({a = true , b = ({a = true , b = true }.b) }.b) }.a) ) ({a = (let u = (let u = 0 in 1) in (let u = 0 in 1)) , b = ({a = (if false then 0 else 1) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , c =  (((\x: Bool .\y: Nat .y) true ) 1) }.b) }.b))
({a = (( \f: Unit .((f (((\x: Unit .\y: Nat .y) (let u = true in false) ) 0) ) (let u = ({a = 0 , b = true , c =  1 }.b) in (fix (\x: Nat . 0 ))) ) ) (\a: Nat .\b: Bool .a)) , b = ({a = (let u = false in (unfold [ Bool ] (fold [ Unit ] 1 ))) , b = (unfold [ Nat ] (fold [ Nat ] ({a = true , b = false }.b) )) }.b) , c = ({a = (pred ({a = ({a = true , b = true }.b) , b = 0 }.b)) , b = (pred ({a = false , b = (pred 1) }.b)) }.b) }.c)
({a = (fix (\x: Bool . (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = true , b = 1 }.a) )) ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Unit .a)) )) , b = (let u = (( \f: Unit .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Nat .\y: Nat .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) 1) ) ) (\a: Rec X. X .\b: Bool .a)) in (let u = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .b)) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y))) }.b)
({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = ({a = 0 , b = 1 }.b) in (( \f: Rec X. X .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true ) ) (\a: Rec X. X .\b: Unit .a))) }.b) , b = (fix (\x: Bool . (case <l = (let u = 1 in 1) > as Unit of < l = x > => x | < r = y > => y) )) }.b)
(pred (let u = ({a = (((\x: Unit .\y: Unit .x) ({a = 0 , b = true }.b) ) ({a = false , b = 1 }.a)) , b = (let u = 1 in ({a = false , b = false }.b)) }.b) in (succ ({a = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = true , b = 0 }.b) }.b))))
(let u = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .y) false ) false) )) in u) in ({a = (((\x: Bool .\y: Rec X. X .x) (( \f: Rec X. X .((f (let u = 0 in 1) ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = (fix (\x: Bool . false )) , b = (unfold [ Unit ] (fold [ Nat ] 1 )) }.a)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = (succ 0) in true) )) , c =  (( \f: Unit .((f ({a = (let u = 0 in 1) , b = true , c = ({a = true , b = 0 }.b) }.c) ) ({a = 0 , b = true }.a) ) ) (\a: Nat .\b: Nat .a)) }.b))
({a = (((\x: Bool .\y: Bool .y) (let u = (((\x: Nat .\y: Nat .y) true ) 1) in ({a = 1 , b = false , c =  1 }.b)) ) ({a = 1 , b = true , c = 0 }.c)) , b = (case <r = (let u = ({a = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Rec X. X .((f 1 ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) in (let u = ({a = 1 , b = false }.a) in false)) > as Unit of < l = x > => x | < r = y > => y) }.b)
({a = (let u = ({a = ({a = 0 , b = 0 }.b) , b = (((\x: Bool .\y: Rec X. X .x) false ) true) , c = (succ (if false then 0 else 1)) }.c) in (unfold [ Nat ] (fold [ Nat ] (let u = 1 in 0) ))) , b = (( \f: Unit .((f (let u = (if false then 1 else ({a = 1 , b = false }.a)) in (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Bool .y) (if true then true else true) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false ))) ))) ) ({a = (pred 1) , b = ({a = 0 , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , c =  (let u = 1 in 0) }.b) }.b) ) ) (\a: Unit .\b: Bool .a)) }.b)
({a = (let u = (((\x: Nat .\y: Rec X. X .y) ({a = true , b = 0 }.a) ) (pred 1)) in (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .b))) , b = (((\x: Rec X. X .\y: Unit .x) (( \f: Unit .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = true , b = 0 }.b) )) ) (let u = 1 in u) ) ) (\a: Nat .\b: Nat .a)) ) (if (iszero (if false then (((\x: Bool .\y: Rec X. X .y) false ) 1) else (let u = true in 0))) then (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) ) (\a: Bool .\b: Unit .a)) else (fix (\x: Bool . false )))) }.b)
({a = (let u = (( \f: Unit .((f (let u = (((\x: Bool .\y: Bool .y) false ) false) in (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) ) (((\x: Nat .\y: Bool .x) (let u = true in false) ) (let u = true in u)) ) ) (\a: Unit .\b: Nat .b)) in (((\x: Rec X. X .\y: Rec X. X .x) ({a = (if true then 1 else 1) , b = (unfold [ Nat ] (fold [ Bool ] false )) , c = (let u = true in 1) }.c) ) (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) (let u = 1 in false)))) , b = (((\x: Unit .\y: Unit .x) (let u = (unfold [ Nat ] (fold [ Bool ] true )) in u) ) (((\x: Bool .\y: Nat .y) ({a = true , b = true }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )))) , c =  (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) ) (let u = ({a = false , b = 0 }.a) in u)) }.b)
(let u = ({a = (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Bool .x) false ) true) ) ({a = (if false then true else (((\x: Rec X. X .\y: Nat .x) true ) false)) , b = (let u = 1 in u) }.b)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Unit ] false )) )) )) , c = (pred (((\x: Nat .\y: Nat .y) (if false then false else true) ) 1)) }.c) in u)
(let u = (let u = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = false in u) )) }.b) in u) in (case <r = (unfold [ Bool ] (fold [ Unit ] (((\x: Bool .\y: Bool .x) false ) true) )) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Unit .y) (iszero (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) false ) true) ) ({a = ({a = true , b = 0 }.b) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b))) ) ({a = (( \f: Nat .((f (((\x: Bool .\y: Bool .x) 0 ) false) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) , b = (iszero (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ))) }.a))
(fix (\x: Unit . (((\x: Rec X. X .\y: Unit .y) (fix (\x: Unit . ({a = true , b = 1 }.a) )) ) (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .x) 0 ) (iszero 0)) ))) ))
(iszero (( \f: Bool .((f (let u = (if false then ({a = 1 , b = 0 }.b) else (let u = 0 in 1)) in u) ) ({a = ({a = 0 , b = true }.a) , b = (fix (\x: Unit . false )) }.a) ) ) (\a: Rec X. X .\b: Unit .a)))
(case <r = (fix (\x: Unit . (iszero (if (let u = true in true) then 1 else ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )))) )) > as Nat of < l = x > => x | < r = y > => y)
({a = (pred (let u = (let u = 1 in true) in (fix (\x: Nat . 1 )))) , b = (if (((\x: Unit .\y: Nat .x) (let u = true in true) ) (if ({a = 0 , b = false }.b) then (let u = true in u) else (let u = 0 in false))) then (( \f: Rec X. X .((f ({a = (unfold [ Unit ] (fold [ Bool ] true )) , b = true }.b) ) (unfold [ Nat ] (fold [ Nat ] false )) ) ) (\a: Nat .\b: Nat .b)) else (( \f: Rec X. X .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (if true then false else true) ) ) (\a: Rec X. X .\b: Bool .a))) , c = (((\x: Rec X. X .\y: Unit .y) (let u = true in false) ) ({a = (let u = 1 in true) , b = (let u = 0 in 0) }.b)) }.c)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (iszero (let u = (fix (\x: Nat . true )) in ({a = 0 , b = 1 }.b))) ))
(pred (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) 0 ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) )))
(((\x: Rec X. X .\y: Nat .y) (( \f: Unit .((f (case <r = (((\x: Nat .\y: Nat .x) true ) true) > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c =  0 }.b) )) ) ) (\a: Nat .\b: Unit .a)) ) (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) in ({a = ({a = 0 , b = true }.b) , b = (((\x: Unit .\y: Rec X. X .y) false ) 1) }.b)))
(let u = (let u = (if (((\x: Unit .\y: Nat .x) (iszero 0) ) ({a = 0 , b = true }.b)) then (((\x: Nat .\y: Bool .x) (iszero 0) ) ({a = 0 , b = (let u = 0 in true) , c =  0 }.b)) else ({a = 1 , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.b)) in (let u = (let u = 0 in false) in u)) in (( \f: Rec X. X .((f (let u = ({a = (((\x: Unit .\y: Rec X. X .x) 1 ) (iszero 1)) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = (fix (\x: Rec X. X . (let u = 1 in 1) )) }.c) in u) ) ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) ) ) (\a: Rec X. X .\b: Bool .b)))
({a = (let u = (case <l = ({a = 1 , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) in u) , b = (let u = ({a = ({a = 0 , b = 1 }.b) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  (fix (\x: Unit . 1 )) }.b) in (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f ({a = 0 , b = (iszero 1) , c =  1 }.b) ) (((\x: Rec X. X .\y: Bool .y) true ) true) ) ) (\a: Nat .\b: Nat .a)) ))) }.b)
({a = (unfold [ Rec X. X ] (fold [ Nat ] (let u = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) , b = (fix (\x: Nat . (let u = (let u = true in false) in (iszero 1)) )) }.b)
(( \f: Bool .((f ({a = (( \f: Bool .((f (unfold [ Bool ] (fold [ Bool ] false )) ) (let u = 1 in false) ) ) (\a: Nat .\b: Nat .b)) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = true , c =  (((\x: Bool .\y: Bool .x) 0 ) true) }.b) }.b) ) ({a = (fix (\x: Nat . (unfold [ Bool ] (fold [ Rec X. X ] false )) )) , b = ({a = (succ ({a = 1 , b = false }.a)) , b = (( \f: Bool .((f (let u = true in true) ) (fix (\x: Bool . (unfold [ Unit ] (fold [ Rec X. X ] false )) )) ) ) (\a: Nat .\b: Nat .a)) , c =  ({a = (iszero 0) , b = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.b) }.b) }.b) ) ) (\a: Unit .\b: Unit .b))
(( \f: Rec X. X .((f ({a = (( \f: Nat .((f (( \f: Rec X. X .((f (let u = false in u) ) true ) ) (\a: Nat .\b: Unit .a)) ) (let u = true in false) ) ) (\a: Unit .\b: Nat .a)) , b = (( \f: Unit .((f (succ (if true then 0 else 0)) ) (let u = ({a = true , b = 1 }.b) in ({a = 1 , b = false }.a)) ) ) (\a: Unit .\b: Bool .a)) }.a) ) (iszero ({a = (let u = (((\x: Nat .\y: Nat .x) true ) false) in u) , b = (succ 1) }.b)) ) ) (\a: Unit .\b: Bool .b))
(let u = (iszero (let u = (let u = 1 in u) in u)) in u)
({a = (unfold [ Nat ] (fold [ Unit ] (case <r = (let u = (((\x: Bool .\y: Unit .x) true ) false) in (fix (\x: Nat . false ))) > as Bool of < l = x > => x | < r = y > => y) )) , b = (unfold [ Bool ] (fold [ Bool ] (iszero (let u = true in 1)) )) }.b)
(( \f: Nat .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 ))) in u) )) ) (( \f: Rec X. X .((f (succ (succ 0)) ) (let u = (case <r = (let u = true in true) > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Bool . (((\x: Nat .\y: Unit .x) 1 ) false) ))) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .b))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u) )) , b = (case <r = ({a = ({a = 0 , b = false }.b) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (let u = (succ (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in 1)) in u) }.b)
(( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = true , c = 0 }.c) )) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Bool .x) 0 ) true) ) true) )) ) ) (\a: Unit .\b: Rec X. X .a))
(((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Unit .x) (( \f: Unit .((f ({a = true , b = false }.b) ) ({a = false , b = 1 }.a) ) ) (\a: Unit .\b: Unit .a)) ) (if ({a = (((\x: Bool .\y: Bool .x) 1 ) true) , b = (unfold [ Nat ] (fold [ Bool ] true )) , c =  (((\x: Bool .\y: Bool .y) false ) 1) }.b) then (let u = ({a = 1 , b = false }.b) in false) else (iszero 1))) ) ({a = (( \f: Bool .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) ) (pred 1) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b))
({a = ({a = (fix (\x: Bool . (((\x: Nat .\y: Bool .y) false ) 0) )) , b = (((\x: Bool .\y: Bool .y) (let u = 0 in false) ) (let u = 1 in 0)) }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f (let u = ({a = 1 , b = false }.a) in u) ) (let u = 1 in u) ) ) (\a: Unit .\b: Unit .a)) )) }.b)
(pred (pred ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , c = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = true , b = 0 }.b) )) }.c)))
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) in (let u = false in ({a = 0 , b = false , c = 1 }.c))) )) , b = ({a = (((\x: Unit .\y: Unit .x) (fix (\x: Rec X. X . 0 )) ) false) , b = ({a = 0 , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b) }.b)
(((\x: Unit .\y: Rec X. X .x) (let u = ({a = (let u = ({a = 1 , b = true , c =  0 }.b) in u) , b = (if (((\x: Bool .\y: Rec X. X .x) false ) false) then (let u = 0 in u) else 0) }.a) in (succ (let u = true in (((\x: Unit .\y: Bool .y) true ) 0)))) ) (( \f: Rec X. X .((f (fix (\x: Unit . (unfold [ Nat ] (fold [ Unit ] true )) )) ) ({a = ({a = 0 , b = true , c = 1 }.c) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) , c =  (fix (\x: Rec X. X . 0 )) }.b) ) ) (\a: Unit .\b: Nat .a)))
({a = (let u = ({a = (fix (\x: Rec X. X . ({a = false , b = false }.b) )) , b = ({a = ({a = true , b = false }.b) , b = false }.b) }.b) in (( \f: Bool .((f (succ 0) ) (succ 0) ) ) (\a: Rec X. X .\b: Nat .b))) , b = (( \f: Unit .((f (( \f: Rec X. X .((f (let u = ({a = false , b = false }.b) in u) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Rec X. X .\y: Bool .x) true ) true) ) true) ) ) (\a: Unit .\b: Nat .b)) ) (fix (\x: Bool . (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  (((\x: Unit .\y: Bool .y) (let u = (( \f: Nat .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in ({a = 0 , b = true }.b)) ) (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Nat .x) true ) false) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)))) }.b)
(fix (\x: Nat . (unfold [ Unit ] (fold [ Unit ] (( \f: Nat .((f (succ ({a = true , b = 0 }.b)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) )) ))
({a = (let u = ({a = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) , b = (( \f: Bool .((f 0 ) (let u = 1 in 0) ) ) (\a: Nat .\b: Nat .a)) }.a) in u) , b = (iszero (unfold [ Bool ] (fold [ Bool ] 0 ))) }.b)
(((\x: Bool .\y: Bool .x) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in (iszero 0)) }.b) ) (if (case <r = (unfold [ Rec X. X ] (fold [ Unit ] false )) > as Bool of < l = x > => x | < r = y > => y) then ({a = ({a = true , b = 1 }.a) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.a) else ({a = (((\x: Nat .\y: Nat .x) 0 ) true) , b = ({a = false , b = 0 }.a) , c =  0 }.b)))
(succ (( \f: Nat .((f (fix (\x: Rec X. X . (let u = 0 in 1) )) ) (let u = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) in 1) in (((\x: Bool .\y: Rec X. X .y) (( \f: Nat .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) false ) ) (\a: Unit .\b: Unit .a)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = false }.a) )))) ) ) (\a: Bool .\b: Nat .b)))
(((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = (let u = 1 in false) }.b) ) (let u = (let u = (((\x: Bool .\y: Rec X. X .y) true ) 0) in true) in u) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = ({a = false , b = 1 }.b) , b = (iszero (fix (\x: Bool . (pred 0) ))) , c = (fix (\x: Unit . 1 )) }.c))
(((\x: Nat .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Nat .y) ({a = 1 , b = true }.b) ) (((\x: Rec X. X .\y: Bool .y) true ) false)) ) ({a = (let u = 0 in u) , b = (fix (\x: Nat . true )) }.b)) in (succ (succ 1))) ) (let u = ({a = false , b = 1 }.a) in u))
(if ({a = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) , b = (iszero (((\x: Bool .\y: Nat .y) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a)) ) 0)) }.b) then (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Rec X. X .((f (fix (\x: Nat . false )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) ) ) (\a: Nat .\b: Bool .b)) )) > as Bool of < l = x > => x | < r = y > => y) else (((\x: Unit .\y: Unit .y) (if ({a = false , b = (let u = 0 in 1) }.a) then (((\x: Rec X. X .\y: Rec X. X .y) (if false then false else false) ) false) else (( \f: Bool .((f false ) (if false then true else true) ) ) (\a: Bool .\b: Nat .b))) ) (let u = ({a = false , b = 0 }.a) in u)))
(let u = ({a = (fix (\x: Rec X. X . ({a = true , b = true }.b) )) , b = (if (unfold [ Bool ] (fold [ Unit ] false )) then ({a = 0 , b = true }.b) else false) }.b) in (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Bool ] false )) ) (if (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) then (let u = false in u) else (fix (\x: Rec X. X . false )))))
(((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .y) true ) true) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) ) (if (((\x: Rec X. X .\y: Nat .y) (let u = false in u) ) (((\x: Bool .\y: Nat .y) false ) false)) then ({a = false , b = false }.b) else ({a = (let u = true in u) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.a))) ) (((\x: Nat .\y: Rec X. X .x) (( \f: Unit .((f (iszero 0) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .a)) ) (let u = (let u = (if true then true else true) in ({a = ({a = 1 , b = true , c = 1 }.c) , b = ({a = 1 , b = false , c = 0 }.c) }.b)) in ({a = ({a = 1 , b = true , c = 0 }.c) , b = ({a = (((\x: Unit .\y: Rec X. X .x) true ) false) , b = ({a = 1 , b = false , c =  0 }.b) }.b) , c =  (((\x: Bool .\y: Bool .x) 0 ) (((\x: Rec X. X .\y: Nat .y) false ) false)) }.b))))
(((\x: Rec X. X .\y: Nat .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (case <r = ({a = 0 , b = false , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) )) ) ({a = (let u = true in u) , b = (fix (\x: Nat . (unfold [ Unit ] (fold [ Nat ] 1 )) )) }.a))
(fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Rec X. X . ({a = 1 , b = 1 }.b) )) )) ))
(((\x: Rec X. X .\y: Unit .x) (if (((\x: Nat .\y: Nat .y) (((\x: Unit .\y: Nat .y) true ) false) ) (fix (\x: Rec X. X . true ))) then (fix (\x: Nat . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) )) else (fix (\x: Rec X. X . ({a = (unfold [ Unit ] (fold [ Unit ] false )) , b = (fix (\x: Bool . 0 )) }.b) ))) ) ({a = (((\x: Unit .\y: Bool .y) ({a = false , b = 1 }.a) ) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) false ) false) ))) , b = ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a)) , b = (let u = false in 0) }.b) }.a))
({a = ({a = (((\x: Rec X. X .\y: Nat .y) false ) 1) , b = (if ({a = 1 , b = true }.b) then (((\x: Unit .\y: Rec X. X .x) true ) false) else (unfold [ Unit ] (fold [ Rec X. X ] true ))) }.b) , b = (( \f: Bool .((f (( \f: Rec X. X .((f ({a = 0 , b = false , c = 0 }.c) ) (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) true ) false) ) 0) ) ) (\a: Bool .\b: Bool .a)) ) ({a = (succ (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) , b = (let u = false in false) }.a) ) ) (\a: Nat .\b: Unit .b)) }.b)
(( \f: Unit .((f (fix (\x: Nat . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) , c = 0 }.c) )) )) ) (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (if false then 0 else 0) )) ) (fix (\x: Rec X. X . (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) false ) 0) ) 0 ) ) (\a: Bool .\b: Bool .b)) )) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(fix (\x: Rec X. X . (let u = (fix (\x: Bool . (pred 1) )) in u) ))
(let u = (( \f: Bool .((f (iszero (pred 1)) ) (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Rec X. X .((f (iszero 0) ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Rec X. X .b)) )) ) ) (\a: Bool .\b: Unit .b)) in u)
(case <r = (let u = (( \f: Nat .((f (let u = (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b)) in (fix (\x: Unit . 1 ))) ) (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Nat .x) 0 ) true) ) (let u = 0 in false)) ) ) (\a: Nat .\b: Rec X. X .b)) in ({a = (((\x: Nat .\y: Rec X. X .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) true) , b = (fix (\x: Bool . false )) }.b)) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Nat . ({a = (case <l = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) ({a = 1 , b = true }.b)) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) )) , c = (fix (\x: Unit . (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) )) }.c) ))
({a = (((\x: Rec X. X .\y: Bool .y) ({a = (((\x: Nat .\y: Unit .x) false ) true) , b = (((\x: Bool .\y: Nat .x) ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = ({a = 0 , b = true }.b) }.a) ) (((\x: Rec X. X .\y: Bool .x) false ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)))) }.a) ) (let u = ({a = true , b = 0 }.a) in (((\x: Rec X. X .\y: Bool .x) true ) true))) , b = (let u = (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Unit ] (fix (\x: Unit . false )) )) )) in (fix (\x: Rec X. X . ({a = ({a = 0 , b = 0 }.b) , b = 0 }.b) ))) }.b)
(((\x: Bool .\y: Nat .x) (succ (((\x: Unit .\y: Bool .y) ({a = (succ 0) , b = true , c =  1 }.b) ) (( \f: Unit .((f (let u = 0 in 0) ) 1 ) ) (\a: Bool .\b: Nat .b)))) ) ({a = (((\x: Rec X. X .\y: Rec X. X .y) ({a = (iszero 1) , b = ({a = false , b = 1 }.b) }.a) ) ({a = (let u = true in u) , b = (let u = 1 in u) }.a)) , b = ({a = ({a = 1 , b = true }.a) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.a) }.a))
(let u = (succ ({a = (((\x: Rec X. X .\y: Rec X. X .y) (if false then false else true) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) , b = (let u = 0 in u) }.b)) in (case <l = (let u = (fix (\x: Bool . (let u = 0 in u) )) in (let u = 0 in (let u = 1 in 0))) > as Bool of < l = x > => x | < r = y > => y))
(case <r = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) false ) (let u = true in u)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <r = (let u = (let u = (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = 0 , b = true }.b)) in (succ ({a = 1 , b = 1 }.b))) in (if ({a = true , b = 0 }.a) then (( \f: Rec X. X .((f (fix (\x: Bool . true )) ) false ) ) (\a: Nat .\b: Nat .b)) else (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)))) > as Unit of < l = x > => x | < r = y > => y)
(let u = (pred (( \f: Nat .((f ({a = 1 , b = 0 }.b) ) 1 ) ) (\a: Bool .\b: Rec X. X .a))) in u)
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) )) , b = (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Unit .y) (fix (\x: Unit . true )) ) (if true then (fix (\x: Bool . 1 )) else (let u = false in 0))) ) (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) in (unfold [ Rec X. X ] (fold [ Unit ] (let u = 1 in false) )))) }.a)
(((\x: Bool .\y: Rec X. X .y) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = false }.b) )) , b = (pred 0) }.a) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = (iszero 1) , c =  (succ 0) }.b) }.b) )))
(( \f: Bool .((f ({a = ({a = (((\x: Rec X. X .\y: Unit .y) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) ({a = 0 , b = 1 }.b)) , b = (((\x: Rec X. X .\y: Unit .x) ({a = false , b = true }.b) ) (iszero 0)) }.b) , b = (( \f: Nat .((f ({a = 1 , b = false , c =  1 }.b) ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) ) (let u = ({a = (if false then true else false) , b = 0 }.a) in (case <r = (( \f: Unit .((f false ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .b))
(unfold [ Rec X. X ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Bool .y) (let u = true in u) ) (iszero 0)) )) )) ))
(( \f: Unit .((f (( \f: Nat .((f (( \f: Rec X. X .((f (( \f: Unit .((f (pred 0) ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Nat .a)) ) (let u = false in 0) ) ) (\a: Unit .\b: Unit .a)) ) (let u = (let u = 0 in 0) in ({a = 1 , b = true }.a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = (let u = (((\x: Nat .\y: Bool .y) false ) 1) in (pred ({a = false , b = 0 }.b))) , b = ({a = (let u = false in u) , b = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 ))) }.a) }.a) ) ) (\a: Unit .\b: Unit .a))
(let u = (if (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in (case <r = ({a = 0 , b = false , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y)) then (fix (\x: Unit . ({a = 0 , b = false }.a) )) else (if false then 1 else 1)) in u)
({a = (let u = ({a = (((\x: Nat .\y: Unit .x) true ) true) , b = ({a = false , b = 1 }.b) }.a) in ({a = (let u = 0 in 1) , b = (let u = (let u = 0 in 1) in ({a = true , b = true }.b)) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) )) }.b)) , b = (succ (let u = (((\x: Nat .\y: Bool .x) (if true then 0 else 1) ) false) in u)) }.b)
(fix (\x: Rec X. X . (case <l = (case <l = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ))
(pred (let u = (unfold [ Nat ] (fold [ Nat ] (let u = 1 in u) )) in ({a = (case <l = ({a = 1 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f (let u = true in true) ) true ) ) (\a: Bool .\b: Nat .a)) }.a)))
({a = (( \f: Unit .((f ({a = (let u = 1 in 0) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.a) ) ({a = ({a = false , b = true }.b) , b = ({a = ({a = 1 , b = 0 }.b) , b = 0 }.b) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) , b = ({a = ({a = ({a = (if true then true else false) , b = true }.b) , b = ({a = 1 , b = true , c = 0 }.c) }.b) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c = (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in u) }.c) }.b)
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (iszero 1) )) ))
(let u = (((\x: Unit .\y: Rec X. X .x) (if ({a = true , b = 1 }.a) then ({a = (iszero 0) , b = (((\x: Bool .\y: Unit .y) false ) 0) }.a) else ({a = 1 , b = false }.b)) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = ({a = 1 , b = false , c = 0 }.c) in (let u = false in true)) ))) in ({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) true ) 1) ) (pred ({a = 1 , b = true }.a)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Nat .((f (let u = false in u) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Unit .\b: Rec X. X .b)) }.b))
(fix (\x: Unit . ({a = (let u = (let u = 1 in (let u = false in 0)) in u) , b = (((\x: Nat .\y: Rec X. X .x) ({a = (fix (\x: Nat . 1 )) , b = ({a = 1 , b = true , c =  1 }.b) }.b) ) (( \f: Bool .((f ({a = 0 , b = ({a = 0 , b = false , c =  1 }.b) }.b) ) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in u) ) ) (\a: Rec X. X .\b: Nat .a))) }.a) ))
(((\x: Unit .\y: Rec X. X .y) (iszero (let u = 1 in (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)))) ) ({a = (case <r = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (succ 1) in ({a = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , b = (let u = true in 1) }.b)) }.a))
(fix (\x: Nat . ({a = ({a = (iszero 1) , b = (let u = 1 in 1) }.b) , b = (case <r = (( \f: Nat .((f ({a = ({a = 1 , b = false , c = 1 }.c) , b = ({a = false , b = false }.b) }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (if ({a = 0 , b = true , c =  0 }.b) then (((\x: Unit .\y: Bool .x) 1 ) (if false then false else true)) else (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) }.b) ))
(fix (\x: Bool . (((\x: Rec X. X .\y: Unit .x) (let u = (fix (\x: Nat . false )) in ({a = 0 , b = false }.b)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = true , c =  0 }.b) ))) ))
(let u = ({a = ({a = (( \f: Bool .((f 1 ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Nat .\b: Nat .a)) , b = ({a = 1 , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) }.b) , c = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.c) , b = (if (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) true ) true) ) (((\x: Nat .\y: Nat .x) false ) false) ) ) (\a: Rec X. X .\b: Unit .a)) then (iszero (unfold [ Bool ] (fold [ Nat ] 0 ))) else (let u = 0 in (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)))) }.b) in ({a = (let u = ({a = (case <l = (fix (\x: Unit . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = false , b = 1 }.b) }.b) in (( \f: Rec X. X .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) true ) true) )) ) (((\x: Nat .\y: Unit .x) false ) false) ) ) (\a: Bool .\b: Unit .b))) , b = (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Unit .x) true ) false) ) ({a = (let u = 1 in false) , b = 0 }.a)) }.b))
(let u = (iszero ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = (((\x: Unit .\y: Unit .y) false ) false) }.a)) in (let u = (let u = ({a = 0 , b = ({a = true , b = 1 }.a) , c =  (pred 0) }.b) in ({a = (let u = 1 in false) , b = ({a = 0 , b = true , c = 1 }.c) }.a)) in (let u = (if true then ({a = 0 , b = true }.b) else false) in u)))
(if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = 0 , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) )) }.b) )) then (let u = (let u = true in u) in u) else (( \f: Bool .((f ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) true ) 1) )) , b = ({a = 1 , b = true , c =  1 }.b) , c =  ({a = false , b = 1 }.b) }.b) , b = ({a = (unfold [ Unit ] (fold [ Bool ] 1 )) , b = false }.a) }.a) ) ({a = (if true then false else true) , b = (fix (\x: Nat . false )) }.b) ) ) (\a: Bool .\b: Rec X. X .a)))
({a = (case <r = ({a = (let u = false in 1) , b = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (let u = true in false) , c =  ({a = 1 , b = 1 }.b) }.b) , c =  (((\x: Unit .\y: Rec X. X .x) 0 ) true) }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = (let u = (((\x: Unit .\y: Bool .x) 0 ) true) in (fix (\x: Bool . 0 ))) , b = (unfold [ Nat ] (fold [ Bool ] ({a = 1 , b = false , c =  1 }.b) )) }.b) in u) }.b)
(unfold [ Nat ] (fold [ Nat ] (if ({a = (succ 1) , b = (((\x: Bool .\y: Unit .y) false ) true) , c =  ({a = ({a = 1 , b = true }.a) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) }.b) }.b) then (( \f: Unit .((f (if true then false else true) ) (let u = false in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .a)) else ({a = ({a = 0 , b = true }.b) , b = true }.b)) ))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (((\x: Bool .\y: Nat .y) (let u = true in u) ) ({a = 1 , b = true , c = 0 }.c)) , b = (((\x: Unit .\y: Rec X. X .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .y) false ) true)) }.b) ))
(if (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Unit . true )) )) > as Nat of < l = x > => x | < r = y > => y) then (((\x: Unit .\y: Unit .y) (case <r = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = 0 }.a) ) (fix (\x: Rec X. X . 0 )))) else ({a = ({a = (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then 0 else 0) , b = (( \f: Nat .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) , b = (((\x: Bool .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) (fix (\x: Bool . false )) ) ) (\a: Unit .\b: Bool .b)) ) (((\x: Nat .\y: Unit .y) false ) true)) }.a))
({a = (((\x: Bool .\y: Nat .y) (let u = ({a = 0 , b = false }.b) in u) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) (let u = true in (let u = 0 in false)) ) (if (unfold [ Unit ] (fold [ Bool ] false )) then false else (iszero 0))) ))) , b = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Bool . 0 )) )) }.b)
({a = (case <l = (let u = ({a = (unfold [ Bool ] (fold [ Unit ] false )) , b = (let u = true in 1) }.b) in u) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Bool ] (fold [ Nat ] (if ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) then 1 else (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a))) )) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in true) ))) , c = (unfold [ Nat ] (fold [ Unit ] (fix (\x: Unit . (( \f: Unit .((f 1 ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Nat .a)) )) )) }.c)
(( \f: Nat .((f (fix (\x: Bool . (let u = 0 in u) )) ) (case <l = (if (iszero ({a = 0 , b = true }.a)) then (if (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Unit ] false )) )) then (succ 1) else ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 ))) else (((\x: Rec X. X .\y: Unit .x) (unfold [ Bool ] (fold [ Unit ] 0 )) ) false)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (succ (((\x: Nat .\y: Bool .y) (unfold [ Nat ] (fold [ Nat ] (case <r = (if true then true else false) > as Nat of < l = x > => x | < r = y > => y) )) ) (pred 0))) , b = (unfold [ Nat ] (fold [ Bool ] (case <r = ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = ({a = 1 , b = false , c =  0 }.b) , c =  ({a = 1 , b = true , c = 0 }.c) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a)
(if ({a = (case <l = ({a = false , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] false )) ) true ) ) (\a: Bool .\b: Unit .b)) , b = (let u = true in false) }.b) }.b) then (((\x: Unit .\y: Bool .x) (if (let u = false in u) then 0 else 1) ) ({a = (let u = 0 in u) , b = true , c =  (((\x: Bool .\y: Bool .x) 1 ) true) }.b)) else ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (if true then (let u = true in 0) else 1) )))
(( \f: Unit .((f ({a = ({a = ({a = 1 , b = true }.b) , b = (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .x) 0 ) false) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) }.a) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = 0 }.b) )) , b = ({a = false , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .b)) }.b) , c = (( \f: Unit .((f (if true then 1 else 0) ) (let u = 0 in (fix (\x: Rec X. X . 1 ))) ) ) (\a: Nat .\b: Bool .a)) }.c) }.a) ) (( \f: Unit .((f (let u = (let u = 1 in true) in (iszero 0)) ) ({a = ({a = ({a = false , b = 1 }.b) , b = true , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.c) , b = (let u = 0 in true) }.b) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .a))
(let u = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in u) )) , b = (if ({a = 0 , b = false }.b) then (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .b)) else true) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] (let u = (( \f: Nat .((f (let u = false in 1) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = 1 , b = false }.b)) )))
(case <l = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Nat ] (case <l = (let u = 0 in u) > as Unit of < l = x > => x | < r = y > => y) )) ) ({a = (((\x: Nat .\y: Bool .y) false ) false) , b = (unfold [ Unit ] (fold [ Bool ] (unfold [ Bool ] (fold [ Bool ] 0 )) )) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (case <r = ({a = ({a = 0 , b = true , c = 0 }.c) , b = ({a = 1 , b = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) , c =  (((\x: Nat .\y: Rec X. X .y) true ) 1) }.b) , c =  (let u = ({a = false , b = 1 }.b) in u) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero (pred ({a = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = 0 }.b))) ) ) (\a: Rec X. X .\b: Bool .b))
({a = (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Rec X. X .x) (let u = 0 in u) ) true) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) ) ({a = (let u = 1 in u) , b = (((\x: Unit .\y: Bool .y) false ) true) }.b)) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (pred 0) )) , b = (let u = ({a = 1 , b = false }.b) in (let u = (if false then false else true) in u)) , c = (fix (\x: Bool . 1 )) }.c) ) ) (\a: Bool .\b: Nat .a)) , b = (if ({a = (let u = false in true) , b = (((\x: Rec X. X .\y: Nat .x) 0 ) (unfold [ Nat ] (fold [ Bool ] false ))) }.a) then (if (iszero (fix (\x: Rec X. X . 1 ))) then (iszero 1) else (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) else (let u = (((\x: Bool .\y: Unit .y) false ) ({a = 0 , b = true , c =  0 }.b)) in u)) , c =  ({a = (case <l = (if false then 1 else 1) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Bool ] (let u = true in u) )) }.a) }.b)
(((\x: Nat .\y: Bool .y) (unfold [ Bool ] (fold [ Nat ] ({a = (( \f: Bool .((f (((\x: Unit .\y: Unit .y) false ) 1) ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = (iszero 0) , c =  (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.b) )) ) (let u = ({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) in (succ 0)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (iszero ({a = 1 , b = 0 }.b)) )) }.b) in (((\x: Rec X. X .\y: Unit .x) ({a = 0 , b = 1 }.b) ) (iszero ({a = false , b = 0 }.b)))))
(case <l = (if ({a = (let u = (fix (\x: Nat . false )) in u) , b = (((\x: Unit .\y: Nat .x) 1 ) false) }.a) then (((\x: Bool .\y: Unit .x) (succ ({a = 1 , b = true , c = 1 }.c)) ) ({a = 1 , b = true }.b)) else (unfold [ Nat ] (fold [ Unit ] (succ 0) ))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Bool .y) ({a = ({a = 1 , b = false , c = 0 }.c) , b = (let u = false in false) , c =  ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.b) ) (succ (let u = (let u = 1 in 1) in u)))
({a = ({a = ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 )) }.c) , b = (pred 1) }.b) , b = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Unit .x) 0 ) false) )) in (let u = ({a = 0 , b = (let u = 1 in 0) }.b) in ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )))) }.b)
(fix (\x: Unit . (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) (let u = false in u)) in ({a = (((\x: Nat .\y: Unit .y) false ) 1) , b = (fix (\x: Rec X. X . true )) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.b)) ))
(((\x: Nat .\y: Unit .x) ({a = ({a = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) ) (case <r = ({a = 1 , b = false , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = (let u = 0 in false) in false) }.b) , b = (((\x: Unit .\y: Rec X. X .y) ({a = 0 , b = true , c =  0 }.b) ) (let u = 0 in u)) }.a) ) (if (iszero (unfold [ Bool ] (fold [ Bool ] 0 ))) then ({a = (((\x: Unit .\y: Unit .x) true ) true) , b = true }.b) else ({a = ({a = 0 , b = false , c =  1 }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.a)))
({a = (( \f: Rec X. X .((f (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in u) ) ({a = (pred 1) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (let u = (succ (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a))) in (let u = ({a = true , b = ({a = 1 , b = true }.a) }.a) in (succ (let u = 0 in u)))) }.a)
({a = (( \f: Nat .((f (let u = 0 in u) ) ({a = ({a = 0 , b = false }.a) , b = ({a = true , b = 1 }.a) , c = (case <l = (let u = 0 in 0) > as Bool of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = (case <r = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Nat .y) ({a = true , b = false }.b) ) ({a = 1 , b = false }.b))) , c = (fix (\x: Nat . (fix (\x: Bool . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) )) }.c)
({a = (case <l = (if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) then (let u = 1 in 1) else (let u = 1 in 0)) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Nat .\y: Bool .y) false ) true) }.b) , b = ({a = (iszero 1) , b = (fix (\x: Nat . 0 )) }.a) }.b) }.b)
({a = (if (let u = (let u = (pred 1) in 0) in (let u = (let u = 1 in 1) in (((\x: Rec X. X .\y: Rec X. X .x) true ) false))) then ({a = ({a = 1 , b = ({a = 1 , b = true }.b) , c = 0 }.c) , b = ({a = ({a = 0 , b = true , c =  1 }.b) , b = 0 }.b) }.b) else (unfold [ Nat ] (fold [ Nat ] (succ 1) ))) , b = (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (fix (\x: Rec X. X . (if true then false else true) )) )) > as Rec X. X of < l = x > => x | < r = y > => y) }.a)
(if ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Bool .\y: Unit .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (iszero 0)) )) then (fix (\x: Unit . ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .a)) )) , c =  (let u = true in 1) }.b) )) else (let u = ({a = ({a = true , b = 0 }.a) , b = (if false then true else true) }.b) in (((\x: Bool .\y: Bool .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = ({a = 1 , b = 1 }.b) , b = true }.b))))
(unfold [ Bool ] (fold [ Bool ] (iszero (if (( \f: Unit .((f false ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Bool .\b: Rec X. X .a)) then (if true then 0 else (((\x: Nat .\y: Nat .x) 0 ) true)) else (pred 1))) ))
({a = (let u = (unfold [ Nat ] (fold [ Rec X. X ] (iszero 0) )) in ({a = (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (succ 1) )) )) , b = (if (( \f: Rec X. X .((f ({a = false , b = false }.b) ) ({a = false , b = false }.b) ) ) (\a: Unit .\b: Unit .b)) then (let u = true in u) else ({a = (unfold [ Nat ] (fold [ Rec X. X ] true )) , b = true }.b)) , c = (((\x: Bool .\y: Bool .x) 1 ) (let u = true in true)) }.c)) , b = ({a = (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = (case <l = ({a = 0 , b = true }.a) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b)
({a = ({a = (let u = ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) true ) true) }.a) in u) , b = (let u = ({a = true , b = 1 }.a) in (let u = true in 0)) }.b) , b = ({a = (( \f: Nat .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Nat .x) 0 ) false) ) ) (\a: Bool .\b: Bool .b)) , b = (let u = ({a = 0 , b = 1 }.b) in (iszero 0)) , c =  ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = 1 }.b) )) }.b) , c = ({a = (let u = ({a = (let u = 0 in u) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) in (let u = (let u = false in 1) in (succ 1))) , b = (fix (\x: Nat . (iszero 0) )) }.a) }.c)
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (unfold [ Nat ] (fold [ Bool ] ({a = true , b = ({a = 0 , b = true , c = 0 }.c) }.b) )) in (succ (pred (unfold [ Unit ] (fold [ Bool ] 1 ))))) ))
(((\x: Rec X. X .\y: Bool .y) (((\x: Bool .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Bool ] (if true then false else ({a = true , b = 1 }.a)) )) ) ({a = ({a = (if true then 1 else (let u = 0 in u)) , b = ({a = false , b = false }.b) }.a) , b = (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) false ) ) (\a: Bool .\b: Rec X. X .a)) , c =  (if false then (succ 0) else 0) }.b)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Unit .x) (case <l = (fix (\x: Unit . 1 )) > as Unit of < l = x > => x | < r = y > => y) ) ({a = false , b = 1 }.a)) )))
({a = ({a = (let u = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) in 0) in (if true then 1 else 1)) , b = (unfold [ Rec X. X ] (fold [ Bool ] (iszero 1) )) }.b) , b = (fix (\x: Unit . (((\x: Unit .\y: Bool .y) ({a = true , b = 1 }.a) ) (let u = 0 in 0)) )) }.a)
(( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = (pred 1) , b = (let u = true in false) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) )) ) (((\x: Unit .\y: Unit .y) (fix (\x: Nat . false )) ) (let u = (((\x: Nat .\y: Bool .y) false ) 1) in 1)) ) ) (\a: Nat .\b: Nat .b))
(if (if (let u = (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in (iszero 1)) in (if (let u = (unfold [ Unit ] (fold [ Nat ] 0 )) in ({a = 0 , b = false }.b)) then ({a = true , b = 1 }.a) else ({a = 0 , b = true }.b))) then ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = (pred 1) , b = ({a = ({a = 1 , b = true }.b) , b = false }.b) }.b) )) else (if (((\x: Rec X. X .\y: Nat .y) (let u = 0 in true) ) ({a = true , b = 1 }.a)) then ({a = (unfold [ Rec X. X ] (fold [ Nat ] false )) , b = 1 }.a) else ({a = 1 , b = (let u = true in u) , c =  0 }.b))) then ({a = (( \f: Unit .((f ({a = false , b = 0 }.b) ) (succ ({a = false , b = 1 }.b)) ) ) (\a: Bool .\b: Unit .b)) , b = (let u = (let u = 0 in 1) in (let u = 1 in (iszero 1))) , c = (let u = ({a = true , b = 0 }.a) in (pred ({a = 1 , b = true , c = 0 }.c))) }.c) else (if (let u = (((\x: Unit .\y: Nat .x) 1 ) false) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) then ({a = (let u = (if false then true else true) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) , b = (if (((\x: Nat .\y: Nat .x) false ) false) then 1 else (((\x: Rec X. X .\y: Unit .x) 1 ) false)) }.b) else (( \f: Bool .((f (let u = 1 in u) ) (fix (\x: Unit . (fix (\x: Unit . 1 )) )) ) ) (\a: Unit .\b: Rec X. X .b))))
(if ({a = (succ 1) , b = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = 1 }.a) , c =  ({a = (((\x: Bool .\y: Rec X. X .y) true ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) , b = ({a = true , b = false }.b) , c = (((\x: Unit .\y: Rec X. X .y) false ) 0) }.c) }.b) then ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = (pred 1) in (let u = 0 in 1)) )) )) else (pred (unfold [ Rec X. X ] (fold [ Bool ] (pred (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) ))))
(( \f: Bool .((f (iszero ({a = (succ 1) , b = (fix (\x: Nat . 1 )) }.b)) ) (if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = false }.b) )) then (iszero (pred 0)) else ({a = (fix (\x: Unit . 1 )) , b = (let u = 0 in (let u = false in true)) }.b)) ) ) (\a: Nat .\b: Unit .a))
(case <l = ({a = (let u = (((\x: Unit .\y: Unit .y) (if false then true else (if false then false else false)) ) ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = 0 }.a)) in ({a = 1 , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.b)) , b = (if ({a = (((\x: Unit .\y: Bool .y) true ) false) , b = (pred 0) }.a) then (( \f: Rec X. X .((f ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = false }.a) ) (( \f: Unit .((f ({a = 1 , b = false , c = 0 }.c) ) (let u = 0 in 0) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) else (( \f: Rec X. X .((f (fix (\x: Unit . 0 )) ) 0 ) ) (\a: Nat .\b: Nat .b))) }.b) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (let u = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] true )) )) in u) in u) ) (if (let u = (case <r = ({a = 1 , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) in u) then ({a = ({a = (if (fix (\x: Nat . false )) then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else (fix (\x: Rec X. X . false ))) , b = (((\x: Unit .\y: Unit .y) (fix (\x: Bool . true )) ) 1) }.a) , b = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Rec X. X . 1 )) )) }.a) else (((\x: Rec X. X .\y: Bool .x) ({a = false , b = (if true then 1 else 0) }.a) ) (( \f: Unit .((f (let u = false in true) ) (((\x: Bool .\y: Bool .y) true ) true) ) ) (\a: Rec X. X .\b: Nat .b)))) ) ) (\a: Nat .\b: Unit .b))
(( \f: Nat .((f (((\x: Rec X. X .\y: Nat .y) (let u = (((\x: Unit .\y: Nat .x) 0 ) false) in (((\x: Bool .\y: Bool .y) (unfold [ Unit ] (fold [ Bool ] true )) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y))) ) (( \f: Bool .((f ({a = 0 , b = false }.a) ) 1 ) ) (\a: Bool .\b: Rec X. X .b))) ) (case <l = (( \f: Rec X. X .((f ({a = 0 , b = true }.a) ) (let u = true in 1) ) ) (\a: Nat .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a))
(if (let u = (succ ({a = ({a = 1 , b = true }.a) , b = 0 }.b)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = (succ (succ 1)) in (((\x: Rec X. X .\y: Unit .y) true ) false)) ))) then (let u = ({a = (iszero 0) , b = (((\x: Rec X. X .\y: Nat .x) true ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true ))) }.b) in u) else (let u = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Rec X. X . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) )) , b = (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) }.b) in (let u = (((\x: Nat .\y: Rec X. X .y) true ) true) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )))))
(( \f: Nat .((f (let u = (case <l = (if true then 0 else 1) > as Nat of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (pred 1) ))) ) (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) ) (\a: Unit .\b: Bool .a))
({a = (let u = (( \f: Rec X. X .((f ({a = true , b = (((\x: Nat .\y: Nat .y) false ) false) }.b) ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) in (((\x: Bool .\y: Bool .x) (iszero 1) ) ({a = (iszero 1) , b = true }.b))) , b = (fix (\x: Bool . (if (let u = (let u = true in 1) in (let u = 1 in true)) then ({a = ({a = false , b = 0 }.b) , b = ({a = 0 , b = true }.b) , c = (((\x: Nat .\y: Nat .x) ({a = 1 , b = true , c = 0 }.c) ) true) }.c) else (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Rec X. X . 1 )) ))) )) }.b)
({a = (((\x: Unit .\y: Nat .y) (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 1 , b = true }.b) )) in (let u = false in false)) ) ({a = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Bool .x) true ) false) )) , b = ({a = 0 , b = true , c =  0 }.b) }.b)) , b = ({a = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = false , c = 1 }.c) , b = (fix (\x: Rec X. X . true )) }.a) }.a)
(let u = (((\x: Nat .\y: Bool .x) ({a = ({a = (succ 1) , b = (if true then (let u = false in u) else false) , c =  ({a = 1 , b = 1 }.b) }.b) , b = (let u = (pred 0) in u) }.a) ) (((\x: Nat .\y: Rec X. X .y) (let u = false in (let u = true in false)) ) (((\x: Unit .\y: Bool .x) ({a = 0 , b = false }.b) ) (( \f: Nat .((f (iszero 0) ) true ) ) (\a: Unit .\b: Unit .b))))) in ({a = (((\x: Bool .\y: Nat .y) (let u = 0 in true) ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b))) , b = (let u = true in u) , c = ({a = (let u = 1 in u) , b = (if false then 1 else 0) }.b) }.c))
((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Bool . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = false in u) )) )) ))
(( \f: Rec X. X .((f ({a = ({a = ({a = 1 , b = 1 }.b) , b = ({a = true , b = 0 }.a) }.a) , b = ({a = (((\x: Unit .\y: Bool .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . false ))) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a) , c =  (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.b) ) ({a = (pred ({a = 1 , b = true , c = 0 }.c)) , b = (let u = (fix (\x: Unit . true )) in u) , c =  (( \f: Bool .((f (pred 1) ) (succ (((\x: Rec X. X .\y: Rec X. X .y) true ) 0)) ) ) (\a: Unit .\b: Nat .a)) }.b) ) ) (\a: Unit .\b: Unit .a))
(case <l = (((\x: Unit .\y: Bool .x) (unfold [ Nat ] (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = true , b = 1 }.b) )) )) ) ({a = (((\x: Bool .\y: Unit .x) true ) true) , b = ({a = 0 , b = true }.b) }.b)) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Unit . (let u = 0 in u) )) )) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(( \f: Nat .((f (let u = (fix (\x: Unit . ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (let u = true in 1) )) )) in (( \f: Bool .((f (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 ))) ) (case <l = ({a = 1 , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b))) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] (succ (if false then 1 else 1)) )) )) ) ) (\a: Nat .\b: Nat .b))
({a = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = 1 , b = (((\x: Rec X. X .\y: Unit .y) false ) 0) }.b) in u) )) ) (let u = (pred (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) in (pred ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) , b = ({a = 0 , b = true }.b) }.a))) ) ) (\a: Nat .\b: Nat .a)) , b = (case <r = (case <r = ({a = false , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (pred (pred (((\x: Nat .\y: Rec X. X .y) true ) 1))) }.b)
(fix (\x: Nat . (( \f: Unit .((f (( \f: Bool .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .b)) ) (iszero 0) ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = (fix (\x: Bool . (((\x: Rec X. X .\y: Bool .y) true ) 1) )) , b = (iszero 1) , c =  (let u = false in 1) }.b) ) ) (\a: Nat .\b: Bool .a)) ))
(if (iszero (unfold [ Nat ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = 1 , b = 1 }.b) }.b) ))) then (if (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Unit . false )) ) (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then true else (let u = 0 in true))) then (let u = ({a = 1 , b = true }.a) in (let u = true in true)) else (( \f: Bool .((f (let u = true in u) ) ({a = ({a = true , b = true }.b) , b = 0 }.a) ) ) (\a: Nat .\b: Bool .b))) else ({a = (succ (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) 1 ) ) (\a: Bool .\b: Rec X. X .a))) , b = ({a = (let u = (succ 0) in ({a = 1 , b = (if false then true else false) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)) , b = (let u = (((\x: Rec X. X .\y: Nat .y) true ) true) in (( \f: Unit .((f (fix (\x: Rec X. X . 0 )) ) 1 ) ) (\a: Unit .\b: Unit .b))) }.a) }.b))
(let u = (if (if ({a = (let u = 1 in false) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.a) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false ))) then (((\x: Bool .\y: Unit .y) ({a = false , b = 0 }.a) ) ({a = 1 , b = 0 }.b)) else (((\x: Rec X. X .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) (((\x: Rec X. X .\y: Bool .x) true ) false))) in (fix (\x: Nat . (let u = (case <l = (((\x: Bool .\y: Bool .y) true ) 1) > as Bool of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Bool .y) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) , b = 1 }.a) ) (let u = false in 0))) )))
(if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (let u = 0 in (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a))) )) then (fix (\x: Nat . ({a = (( \f: Bool .((f (fix (\x: Nat . 1 )) ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = ({a = false , b = false }.b) , c = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c) )) else ({a = (let u = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = false }.a) in (succ 0)) , b = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) else (let u = (fix (\x: Bool . true )) in ({a = true , b = 0 }.a))) }.a))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Nat .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) false) in u) )) )) ))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Bool .\y: Unit .y) false ) 1) ) ({a = 1 , b = false }.b)) ) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (((\x: Bool .\y: Bool .y) (let u = true in false) ) (let u = false in false)) }.a) ) ) (\a: Unit .\b: Unit .b)) ))
(( \f: Nat .((f (( \f: Rec X. X .((f ({a = false , b = false }.b) ) ({a = ({a = false , b = 0 }.a) , b = (let u = false in 0) }.a) ) ) (\a: Nat .\b: Unit .b)) ) (unfold [ Unit ] (fold [ Rec X. X ] ({a = ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = (iszero 1) }.b) , b = (let u = true in u) }.b) )) ) ) (\a: Rec X. X .\b: Bool .a))
(( \f: Unit .((f (let u = (( \f: Nat .((f ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) , b = (unfold [ Nat ] (fold [ Unit ] true )) }.b) ) (((\x: Unit .\y: Unit .y) false ) true) ) ) (\a: Nat .\b: Rec X. X .a)) in u) ) (( \f: Nat .((f (let u = ({a = (((\x: Unit .\y: Rec X. X .y) false ) true) , b = (iszero 1) }.b) in u) ) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Unit .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) ) (unfold [ Unit ] (fold [ Unit ] true ))) )) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Nat .a))
(let u = (let u = (( \f: Nat .((f (((\x: Nat .\y: Unit .x) 0 ) false) ) ({a = 1 , b = false }.a) ) ) (\a: Bool .\b: Rec X. X .b)) in (( \f: Unit .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.a) )) ) (let u = (( \f: Rec X. X .((f true ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .a)) in u) ) ) (\a: Nat .\b: Rec X. X .a))) in u)
(let u = (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) (((\x: Nat .\y: Nat .y) (fix (\x: Rec X. X . false )) ) (((\x: Rec X. X .\y: Nat .x) false ) true)) ) ) (\a: Bool .\b: Nat .b)) in ({a = (((\x: Nat .\y: Unit .y) false ) (fix (\x: Rec X. X . true ))) , b = ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) }.b))
(((\x: Nat .\y: Nat .x) (let u = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) in false) in (let u = (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y) in u)) ) (if (case <r = (((\x: Nat .\y: Rec X. X .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) then (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) false ) true) )) else (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .a))))
({a = (let u = ({a = ({a = 1 , b = false , c = 0 }.c) , b = ({a = true , b = 0 }.b) }.b) in (let u = (let u = 1 in 0) in u)) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] (let u = ({a = true , b = false }.b) in true) )) )) , c =  ({a = (pred (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = 1 }.b) ))) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) }.a) }.b)
({a = (if (let u = (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = false in u)) in u) then (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) }.b) }.a)
(let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = true , b = 1 }.a) , b = (((\x: Nat .\y: Bool .x) 0 ) false) }.b) )) in u)
(let u = ({a = (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (fix (\x: Rec X. X . 1 )) ) ({a = true , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) in u)
({a = (( \f: Nat .((f (unfold [ Nat ] (fold [ Nat ] (let u = false in 0) )) ) ({a = (((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) (let u = 0 in u)) , b = (( \f: Nat .((f true ) ({a = false , b = 0 }.a) ) ) (\a: Bool .\b: Bool .b)) }.a) ) ) (\a: Nat .\b: Bool .b)) , b = (unfold [ Nat ] (fold [ Unit ] (iszero (if true then 1 else 1)) )) }.b)
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .y) true ) 0) )) in ({a = 0 , b = ({a = 1 , b = false , c = 0 }.c) }.b)) ))
(case <r = (if (( \f: Unit .((f (fix (\x: Nat . ({a = false , b = 1 }.a) )) ) ({a = true , b = 1 }.a) ) ) (\a: Nat .\b: Unit .b)) then (iszero (let u = 1 in u)) else (let u = 0 in true)) > as Nat of < l = x > => x | < r = y > => y)
(let u = (pred (fix (\x: Nat . (if true then 0 else 0) ))) in (let u = (unfold [ Unit ] (fold [ Unit ] (if false then (let u = 1 in 1) else 1) )) in (let u = (fix (\x: Bool . 1 )) in u)))
(if (fix (\x: Rec X. X . (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Rec X. X .y) true ) false) ) ({a = 1 , b = true , c =  0 }.b)) ) (fix (\x: Nat . true ))) )) then (unfold [ Nat ] (fold [ Bool ] (case <l = (fix (\x: Nat . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) )) else (unfold [ Unit ] (fold [ Unit ] (unfold [ Nat ] (fold [ Rec X. X ] (let u = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) in (let u = true in 1)) )) )))
(fix (\x: Nat . (( \f: Rec X. X .((f (( \f: Unit .((f ({a = 0 , b = false , c =  0 }.b) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = 1 , b = false , c =  (if false then 0 else 1) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = 0 , b = false }.b) in u) )) in u)
(((\x: Rec X. X .\y: Rec X. X .y) ({a = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (iszero 0) , b = 0 }.a) )) , b = (case <l = ({a = false , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) (( \f: Bool .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = ({a = 1 , b = false }.a) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Unit .a)))
({a = (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f (if true then true else true) ) true ) ) (\a: Nat .\b: Nat .a)) )) , b = ({a = ({a = (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] 0 )) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = 1 , b = true }.b) }.a) , b = (case <r = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in false) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.a)
(succ (succ (( \f: Bool .((f (succ 0) ) (pred 0) ) ) (\a: Unit .\b: Bool .b))))
(iszero (((\x: Bool .\y: Nat .y) (unfold [ Unit ] (fold [ Rec X. X ] (if ({a = false , b = true }.b) then (let u = false in u) else (fix (\x: Bool . false ))) )) ) (( \f: Rec X. X .((f ({a = (fix (\x: Bool . 1 )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (pred 0) )) }.b) ) (unfold [ Nat ] (fold [ Unit ] (let u = true in 1) )) ) ) (\a: Bool .\b: Unit .b))))
(( \f: Nat .((f (((\x: Unit .\y: Unit .y) (if false then false else true) ) (let u = (pred 1) in u)) ) (unfold [ Unit ] (fold [ Unit ] (( \f: Bool .((f (fix (\x: Nat . (((\x: Nat .\y: Bool .y) true ) 1) )) ) (((\x: Nat .\y: Bool .y) false ) 0) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ) (\a: Nat .\b: Rec X. X .a))
(pred (pred (let u = ({a = false , b = 0 }.b) in u)))
(((\x: Unit .\y: Nat .x) (let u = (( \f: Rec X. X .((f (if true then 0 else 1) ) 0 ) ) (\a: Bool .\b: Bool .a)) in u) ) (let u = ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) in (let u = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = true , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a))))
(let u = ({a = ({a = 1 , b = 1 }.b) , b = ({a = (fix (\x: Rec X. X . ({a = 0 , b = false , c =  0 }.b) )) , b = ({a = true , b = ({a = false , b = 1 }.b) }.b) }.a) }.a) in u)
(let u = (if (iszero (let u = true in 1)) then (if ({a = true , b = ({a = 0 , b = true }.b) }.b) then (unfold [ Rec X. X ] (fold [ Unit ] (if true then true else false) )) else (((\x: Nat .\y: Rec X. X .y) true ) false)) else (((\x: Unit .\y: Unit .y) (iszero 1) ) (let u = 1 in false))) in (iszero (( \f: Nat .((f (let u = 1 in u) ) (if true then 0 else 1) ) ) (\a: Rec X. X .\b: Unit .b))))
({a = (let u = ({a = (case <l = ({a = false , b = (((\x: Rec X. X .\y: Nat .y) false ) 1) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Rec X. X .\y: Nat .x) true ) false) in 0) }.b) in u) , b = (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ))) , c = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) (((\x: Bool .\y: Unit .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) true ) 0))) )) }.c)
(case <l = (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Bool .x) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) , b = (((\x: Bool .\y: Bool .x) 1 ) true) }.b) ) (let u = ({a = false , b = true }.b) in u)) ) (((\x: Bool .\y: Bool .y) (if true then true else false) ) false)) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (( \f: Nat .((f ({a = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) , b = ({a = true , b = false }.b) }.a) ) (if ({a = 0 , b = false , c =  0 }.b) then (let u = false in 1) else (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (if (let u = true in u) then (fix (\x: Nat . false )) else (let u = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) in (let u = true in true))) , b = ({a = (pred (let u = true in 1)) , b = (case <r = (iszero 0) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b) , c = (succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 ))) }.c)
({a = (( \f: Nat .((f (fix (\x: Nat . (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) )) ) (succ (if false then 1 else 0)) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (unfold [ Bool ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero (pred 0)) )) )) }.a)
({a = (((\x: Rec X. X .\y: Nat .y) (let u = (pred (let u = (fix (\x: Rec X. X . 1 )) in u)) in (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in u)) ) (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = true }.b) ))) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) ({a = 1 , b = true }.a)) , b = (( \f: Nat .((f ({a = true , b = false }.b) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = ({a = 1 , b = true , c =  0 }.b) , c =  1 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) }.b)
(iszero (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) 1 ) true) )))
({a = (((\x: Rec X. X .\y: Bool .x) (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .y) true ) 0) )) ) (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 0 }.a) ) (((\x: Rec X. X .\y: Unit .x) false ) true))) , b = (unfold [ Bool ] (fold [ Nat ] (((\x: Bool .\y: Unit .y) ({a = 0 , b = false }.b) ) true) )) , c =  (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .x) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = (let u = 1 in 0) in true)) ) (let u = ({a = 1 , b = 0 }.b) in 0) ) ) (\a: Bool .\b: Unit .a)) }.b)
(if (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = false in u) )) then (unfold [ Unit ] (fold [ Unit ] (let u = false in (iszero 1)) )) else (case <r = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y)) then (( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] 0 )) ) (( \f: Rec X. X .((f ({a = (fix (\x: Rec X. X . true )) , b = (if false then 1 else 1) }.b) ) (succ 1) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Unit .b)) else (unfold [ Bool ] (fold [ Nat ] (( \f: Bool .((f ({a = 0 , b = true }.a) ) 0 ) ) (\a: Nat .\b: Bool .a)) )))
(( \f: Nat .((f (succ (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a))) ) (fix (\x: Bool . (((\x: Nat .\y: Nat .x) 1 ) false) )) ) ) (\a: Nat .\b: Rec X. X .b))
(( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = (((\x: Unit .\y: Bool .x) false ) true) in (fix (\x: Nat . false ))) )) ) (( \f: Unit .((f ({a = (fix (\x: Bool . (let u = false in true) )) , b = (let u = 1 in u) }.a) ) (((\x: Unit .\y: Rec X. X .y) (let u = false in true) ) ({a = 0 , b = false }.b)) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
({a = (if (case <r = (if true then true else true) > as Bool of < l = x > => x | < r = y > => y) then ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = 1 in u) )) else (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (if true then true else true) in (((\x: Rec X. X .\y: Nat .y) false ) 1)) )) }.b)
(case <r = (( \f: Bool .((f (let u = ({a = ({a = true , b = 1 }.a) , b = ({a = false , b = 0 }.b) }.a) in ({a = 0 , b = false , c =  ({a = 1 , b = 1 }.b) }.b)) ) ({a = (fix (\x: Nat . (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .a)) )) , b = ({a = (let u = false in true) , b = 0 }.b) }.a) ) ) (\a: Bool .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Nat .x) false ) false) )) ) (let u = true in true)) ) (let u = 0 in ({a = false , b = false }.b))) ))
({a = (((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = (succ 1) , b = (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) in (((\x: Nat .\y: Unit .y) true ) false)) , c = (pred 1) }.c) in ({a = (fix (\x: Unit . (let u = 0 in false) )) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b)) }.b)) ) (let u = (( \f: Bool .((f (((\x: Unit .\y: Nat .y) false ) 1) ) 0 ) ) (\a: Bool .\b: Bool .b)) in (((\x: Bool .\y: Nat .x) true ) true))) , b = ({a = ({a = (let u = ({a = true , b = true }.b) in 0) , b = (let u = 0 in 1) }.b) , b = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = 1 , b = false }.a) ) (succ 0) ) ) (\a: Unit .\b: Unit .b)) }.b) }.b) }.b)
(( \f: Rec X. X .((f ({a = (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = (( \f: Unit .((f (fix (\x: Unit . true )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y) , c = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (let u = ({a = false , b = (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.b) in u) )) }.c) ) (( \f: Rec X. X .((f (( \f: Bool .((f ({a = ({a = false , b = 1 }.b) , b = (succ 0) }.b) ) (let u = (fix (\x: Rec X. X . 0 )) in u) ) ) (\a: Bool .\b: Unit .a)) ) (succ (pred (fix (\x: Bool . 1 )))) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .b))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (if (let u = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) in u) then ({a = (( \f: Unit .((f (let u = true in u) ) (fix (\x: Unit . ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Nat .y) false ) 0) ) ({a = 1 , b = false , c =  1 }.b)) }.a) else ({a = (((\x: Nat .\y: Rec X. X .y) false ) (iszero 0)) , b = ({a = 1 , b = 0 }.b) }.a)) ))
(case <r = (fix (\x: Rec X. X . ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = 0 in true) )) )) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Nat .x) (unfold [ Bool ] (fold [ Nat ] (fix (\x: Rec X. X . (let u = 0 in u) )) )) ) (if (((\x: Bool .\y: Rec X. X .y) true ) true) then (let u = (((\x: Bool .\y: Rec X. X .x) true ) true) in u) else ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) }.a)))
({a = (fix (\x: Bool . (if ({a = false , b = 1 }.a) then (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) else (if false then 1 else 0)) )) , b = (((\x: Nat .\y: Bool .x) (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .b)) )) ) (fix (\x: Unit . (((\x: Bool .\y: Unit .x) false ) true) ))) , c =  (unfold [ Unit ] (fold [ Bool ] ({a = (( \f: Bool .((f 0 ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = 1 , b = false }.b) }.a) )) }.b)
(( \f: Nat .((f ({a = (((\x: Rec X. X .\y: Nat .y) true ) 1) , b = ({a = 0 , b = ({a = true , b = false }.b) }.b) }.a) ) (pred (fix (\x: Bool . (fix (\x: Nat . 0 )) ))) ) ) (\a: Nat .\b: Bool .a))
(let u = (let u = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) ) (((\x: Nat .\y: Nat .y) true ) false)) in (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .x) true ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true ))) ))) in u)
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Rec X. X . ({a = ({a = ({a = 0 , b = false }.b) , b = 1 }.a) , b = (((\x: Nat .\y: Nat .x) (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) ) false) }.a) )) ))
(let u = (unfold [ Nat ] (fold [ Bool ] ({a = (((\x: Bool .\y: Rec X. X .y) ({a = true , b = true }.b) ) 1) , b = (let u = 0 in false) }.a) )) in (((\x: Unit .\y: Rec X. X .y) (let u = (iszero (unfold [ Rec X. X ] (fold [ Unit ] 0 ))) in u) ) (let u = (fix (\x: Rec X. X . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) )) in u)))
(if (fix (\x: Bool . (fix (\x: Rec X. X . ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = true , c =  1 }.b) )) )) then ({a = (case <l = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = false , b = false }.b) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = true in true) )) ) (if (iszero (if false then 0 else 0)) then ({a = 1 , b = false }.b) else (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Bool .b)) , c = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (let u = 1 in 0) ) false) , b = (unfold [ Unit ] (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) }.a) }.c) else (let u = (succ (let u = (let u = true in 1) in 0)) in u))
(let u = ({a = (case <r = ({a = (((\x: Bool .\y: Unit .x) ({a = 1 , b = true }.b) ) false) , b = ({a = true , b = 1 }.a) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (let u = 0 in u) , b = (( \f: Bool .((f 0 ) (let u = 0 in u) ) ) (\a: Unit .\b: Bool .b)) }.b) }.b) in u)
(case <l = ({a = ({a = ({a = 1 , b = 1 }.b) , b = ({a = false , b = 1 }.b) }.b) , b = (fix (\x: Rec X. X . (let u = 0 in u) )) }.b) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Nat .y) (iszero ({a = ({a = true , b = ({a = 0 , b = true }.a) }.b) , b = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = 1 }.b) }.b)) ) (((\x: Unit .\y: Rec X. X .y) (case <r = (fix (\x: Bool . false )) > as Nat of < l = x > => x | < r = y > => y) ) (if ({a = true , b = 1 }.a) then true else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))))
(succ (fix (\x: Unit . (succ (if ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) then 0 else 0)) )))
(( \f: Nat .((f (( \f: Unit .((f (( \f: Rec X. X .((f ({a = (let u = 1 in 0) , b = 0 }.b) ) ({a = true , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (pred ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 ))) ) ) (\a: Nat .\b: Unit .a)) ) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .y) (iszero 1) ) (if (let u = 1 in false) then 0 else 1)) )) , b = ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (fix (\x: Bool . true )) }.a) , b = (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Nat .x) 0 ) false) ) (unfold [ Unit ] (fold [ Bool ] true ))) }.b) }.b) ) ) (\a: Bool .\b: Nat .b))
(if (unfold [ Bool ] (fold [ Nat ] (case <r = (unfold [ Nat ] (fold [ Bool ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) > as Rec X. X of < l = x > => x | < r = y > => y) )) then ({a = (((\x: Bool .\y: Unit .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) ) false) , b = (( \f: Bool .((f ({a = 1 , b = 0 }.b) ) (let u = 1 in u) ) ) (\a: Bool .\b: Unit .a)) }.b) else (( \f: Unit .((f (let u = 0 in ({a = 1 , b = 0 }.b)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 )) )) ) ) (\a: Rec X. X .\b: Nat .b)))
(case <r = ({a = ({a = ({a = 1 , b = (iszero 1) , c = 0 }.c) , b = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] true )) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) ) (\a: Bool .\b: Bool .a)) , c =  (let u = (let u = 1 in 0) in (((\x: Nat .\y: Nat .y) true ) 1)) }.b) , b = (( \f: Bool .((f (let u = 1 in u) ) ({a = 1 , b = true }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) > as Bool of < l = x > => x | < r = y > => y)
(succ (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Bool .y) false ) false) ) (((\x: Nat .\y: Rec X. X .y) true ) 0)) )))
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Nat .a)) )) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) (let u = (fix (\x: Unit . false )) in u) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.b)) )))
(unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Rec X. X .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 0 , b = false , c =  1 }.b)) ) (let u = (succ 1) in u)) ))
(( \f: Rec X. X .((f (let u = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = (fix (\x: Nat . true )) }.a) in (let u = (let u = (let u = true in 1) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true ))) in (let u = (succ 1) in (unfold [ Nat ] (fold [ Unit ] 1 ))))) ) (case <l = (if (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .x) true ) false) ) (let u = 1 in false) ) ) (\a: Unit .\b: Unit .b)) then (unfold [ Bool ] (fold [ Unit ] (let u = false in 1) )) else (pred (let u = 0 in 1))) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a))
(let u = (case <l = (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) (fix (\x: Bool . (((\x: Bool .\y: Bool .x) 1 ) false) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) in (if ({a = 1 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) then (((\x: Bool .\y: Unit .x) (let u = 1 in u) ) true) else (( \f: Rec X. X .((f (let u = (succ 0) in u) ) (succ (let u = 1 in u)) ) ) (\a: Rec X. X .\b: Bool .a))))
({a = (let u = (let u = (let u = 1 in u) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 1 in 0) ))) in (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero 1) )) )) ) (iszero ({a = (fix (\x: Bool . false )) , b = ({a = 0 , b = 0 }.b) }.b)) ) ) (\a: Rec X. X .\b: Bool .b))) , b = ({a = (( \f: Unit .((f ({a = false , b = 0 }.a) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) , b = ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = ({a = 0 , b = false , c = 1 }.c) }.b) }.b) }.a)
(let u = (succ (fix (\x: Unit . (pred 0) ))) in u)
(( \f: Nat .((f (let u = (( \f: Bool .((f (let u = true in false) ) (iszero (if false then 0 else 1)) ) ) (\a: Unit .\b: Unit .b)) in ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = ({a = 0 , b = 0 }.b) }.b)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then ({a = 0 , b = false , c = 0 }.c) else (pred 1)) )) ) ) (\a: Unit .\b: Bool .a))
({a = (if (iszero (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true)) then ({a = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = 0 in u) }.b) else ({a = 0 , b = (let u = true in true) , c = (unfold [ Bool ] (fold [ Bool ] 0 )) }.c)) , b = (let u = (unfold [ Bool ] (fold [ Nat ] true )) in (fix (\x: Unit . ({a = 0 , b = true }.b) ))) }.a)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (if ({a = (let u = false in u) , b = (if false then (let u = true in false) else (if true then false else false)) }.b) then (let u = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) 1 ) ) (\a: Nat .\b: Bool .b)) in (((\x: Rec X. X .\y: Unit .y) false ) true)) else ({a = (((\x: Unit .\y: Unit .y) false ) 0) , b = false , c =  (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) }.b)) ))
(( \f: Unit .((f (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) ) (if ({a = (((\x: Bool .\y: Bool .y) true ) false) , b = ({a = 0 , b = false , c = 0 }.c) }.a) then (iszero 0) else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Nat .a)) ) (((\x: Bool .\y: Bool .x) (( \f: Nat .((f true ) (let u = 1 in false) ) ) (\a: Unit .\b: Unit .b)) ) (let u = (( \f: Unit .((f 0 ) (succ 0) ) ) (\a: Bool .\b: Nat .b)) in ({a = true , b = 0 }.a))) ) ) (\a: Unit .\b: Rec X. X .a))
(((\x: Unit .\y: Bool .x) ({a = ({a = ({a = 0 , b = false , c =  0 }.b) , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)) }.b) , b = (let u = 0 in u) }.a) ) (let u = ({a = (let u = 1 in 1) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) }.a) in (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) (let u = true in false) ) ) (\a: Unit .\b: Rec X. X .a))))
(let u = (pred ({a = ({a = 0 , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .a)) }.b) , b = ({a = (if true then 1 else 1) , b = 0 }.b) }.b)) in u)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] (fix (\x: Rec X. X . true )) )) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ({a = (let u = 0 in u) , b = (unfold [ Unit ] (fold [ Nat ] 1 )) }.b) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) in (let u = true in true)) }.b) )) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Unit . ({a = ({a = (let u = ({a = ({a = true , b = 1 }.b) , b = false , c =  0 }.b) in (if true then 1 else 0)) , b = (let u = (unfold [ Unit ] (fold [ Unit ] true )) in (let u = true in u)) , c =  (fix (\x: Unit . ({a = 0 , b = true , c = 0 }.c) )) }.b) , b = (if ({a = ({a = 1 , b = true }.a) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .a)) }.b) then (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) else (unfold [ Unit ] (fold [ Bool ] (fix (\x: Unit . 0 )) ))) }.a) ))
(( \f: Unit .((f (fix (\x: Nat . (succ (case <l = (succ 0) > as Unit of < l = x > => x | < r = y > => y)) )) ) (fix (\x: Bool . (case <l = (pred 1) > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Nat .a))
(let u = (let u = (fix (\x: Unit . (((\x: Unit .\y: Bool .y) (unfold [ Unit ] (fold [ Unit ] true )) ) (fix (\x: Rec X. X . 1 ))) )) in (unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = false , b = 0 }.a) , b = (let u = false in 0) }.a) ))) in ({a = (let u = 1 in (let u = true in 1)) , b = (let u = (let u = true in u) in ({a = (let u = 1 in 0) , b = true }.a)) }.b))
({a = (pred (((\x: Unit .\y: Bool .y) false ) 0)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) )) }.a)
(((\x: Bool .\y: Unit .x) (((\x: Rec X. X .\y: Unit .y) ({a = (((\x: Rec X. X .\y: Unit .y) false ) true) , b = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.a) ) (let u = ({a = 0 , b = false , c =  0 }.b) in (fix (\x: Rec X. X . 1 )))) ) ({a = (case <r = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Bool ] (( \f: Nat .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) ({a = 0 , b = false }.a) ) ) (\a: Bool .\b: Unit .a)) )) }.a))
(let u = (let u = (unfold [ Bool ] (fold [ Unit ] (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) )) in u) in u)
(if (fix (\x: Unit . ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = ({a = 1 , b = false }.b) , c =  (((\x: Nat .\y: Bool .y) false ) 1) }.b) )) then (fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) true ) true) ) (let u = false in false)) )) else (((\x: Nat .\y: Unit .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Unit .a))) )) ) (((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .b)) ) (let u = (if true then false else false) in true))))
(if (if (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) then (iszero (pred 0)) else (case <r = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y)) then ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = ({a = true , b = 1 }.b) in ({a = 0 , b = true }.b)) )) else ({a = (fix (\x: Bool . ({a = 1 , b = false , c = 1 }.c) )) , b = (((\x: Nat .\y: Rec X. X .x) (((\x: Unit .\y: Rec X. X .x) true ) true) ) (unfold [ Unit ] (fold [ Unit ] true ))) }.b))
(((\x: Nat .\y: Bool .x) (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Unit .y) false ) false) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) )) in u) ) ({a = (let u = (let u = 1 in 0) in (let u = true in u)) , b = (((\x: Unit .\y: Nat .y) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) ) ({a = (let u = 0 in 0) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b)) }.a))
({a = (fix (\x: Nat . (( \f: Rec X. X .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . false )) ) ) (\a: Unit .\b: Unit .a)) )) , b = (let u = (unfold [ Unit ] (fold [ Bool ] (let u = true in 0) )) in u) }.a)
({a = ({a = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in u) , b = (iszero (let u = 0 in u)) , c = (fix (\x: Nat . ({a = 1 , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) )) }.c) , b = (fix (\x: Rec X. X . (((\x: Bool .\y: Bool .x) (fix (\x: Bool . false )) ) ({a = false , b = true }.b)) )) }.a)
(( \f: Bool .((f (( \f: Nat .((f (pred ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) true) , b = (iszero 1) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c)) ) (case <l = (fix (\x: Bool . (((\x: Nat .\y: Nat .x) 1 ) true) )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) ) (let u = (( \f: Nat .((f ({a = ({a = 1 , b = 1 }.b) , b = false }.a) ) (((\x: Unit .\y: Unit .y) (iszero (((\x: Bool .\y: Rec X. X .y) true ) 1)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 ))) ) ) (\a: Unit .\b: Unit .a)) in (((\x: Rec X. X .\y: Nat .x) (((\x: Nat .\y: Rec X. X .x) ({a = true , b = ({a = 1 , b = false , c = 1 }.c) }.b) ) ({a = ({a = 1 , b = true }.a) , b = true }.b)) ) (let u = ({a = (if true then false else false) , b = (pred 0) }.a) in u))) ) ) (\a: Bool .\b: Bool .a))
({a = (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f ({a = true , b = true }.b) ) ({a = ({a = 0 , b = 0 }.b) , b = (if false then false else false) }.b) ) ) (\a: Rec X. X .\b: Nat .a))) )) , b = (let u = (let u = (if (let u = 0 in false) then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else 1) in u) in u) }.b)
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) (let u = false in u) ) (let u = 1 in true)) )) , b = (let u = (let u = (pred 0) in u) in (fix (\x: Nat . ({a = ({a = 0 , b = true }.b) , b = (let u = false in (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) }.b) ))) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = (fix (\x: Bool . false )) }.a) , b = (((\x: Unit .\y: Rec X. X .y) (let u = (fix (\x: Nat . true )) in true) ) (((\x: Nat .\y: Rec X. X .x) (let u = (let u = 1 in true) in u) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)))) , c =  (let u = ({a = true , b = 1 }.b) in (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)))) }.b) ))
(unfold [ Nat ] (fold [ Nat ] (case <r = (fix (\x: Bool . true )) > as Bool of < l = x > => x | < r = y > => y) ))
(let u = (((\x: Bool .\y: Nat .y) (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) in ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = false }.b)) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (succ 1) )) , b = (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) , c =  (if (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .b)) then (pred 1) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a))) }.b)) in (succ (((\x: Unit .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ) (let u = 0 in true))))
(let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (if (iszero 1) then false else true) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Nat .a)) )) in u)
(if (if ({a = ({a = (fix (\x: Rec X. X . true )) , b = true }.b) , b = (iszero (((\x: Unit .\y: Nat .x) 0 ) true)) }.b) then (let u = (let u = false in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 ))) in (if true then (((\x: Nat .\y: Nat .y) true ) false) else (let u = 0 in false))) else (case <r = ({a = false , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y)) then ({a = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = (((\x: Bool .\y: Rec X. X .x) ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = true }.b) ) (fix (\x: Bool . false ))) }.b) else (( \f: Rec X. X .((f (case <r = (let u = false in u) > as Nat of < l = x > => x | < r = y > => y) ) ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = (iszero 0) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(( \f: Nat .((f (let u = (( \f: Bool .((f (let u = (((\x: Nat .\y: Unit .y) true ) 0) in u) ) (((\x: Bool .\y: Unit .y) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = true in 1)) ) ) (\a: Rec X. X .\b: Nat .a)) in (let u = (((\x: Unit .\y: Bool .y) true ) true) in (if false then false else true))) ) (iszero ({a = (fix (\x: Unit . ({a = 0 , b = true , c = 0 }.c) )) , b = ({a = 0 , b = false }.b) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (if false then 0 else 1) )) }.c)) ) ) (\a: Rec X. X .\b: Bool .a))
(if (case <r = (case <r = (let u = true in true) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Nat .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = 0 , b = false }.b)) ) (let u = (pred 1) in ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )))) else ({a = (((\x: Bool .\y: Bool .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) ) (case <r = (let u = false in false) > as Nat of < l = x > => x | < r = y > => y)) , b = (case <r = (( \f: Unit .((f (((\x: Nat .\y: Unit .y) true ) true) ) true ) ) (\a: Bool .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) }.b))
({a = (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = false , c =  0 }.b) )) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (if (iszero (((\x: Unit .\y: Nat .y) false ) 0)) then ({a = ({a = 0 , b = false }.a) , b = ({a = true , b = false }.b) }.b) else (fix (\x: Rec X. X . (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) ))) )) }.b)
(((\x: Bool .\y: Unit .y) (let u = (case <r = ({a = (((\x: Nat .\y: Bool .x) false ) false) , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) in u) ) (let u = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) in u) in u))
(((\x: Rec X. X .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Bool ] ({a = (succ (succ 0)) , b = ({a = 1 , b = true }.b) }.b) )) ) (iszero (((\x: Nat .\y: Bool .y) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) ({a = true , b = 1 }.b))))
(iszero (let u = (( \f: Nat .((f (fix (\x: Nat . false )) ) true ) ) (\a: Nat .\b: Bool .b)) in (if (let u = false in true) then (unfold [ Unit ] (fold [ Unit ] 0 )) else (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)))))
(( \f: Bool .((f (fix (\x: Nat . (let u = ({a = 1 , b = true , c = 1 }.c) in u) )) ) (((\x: Bool .\y: Bool .y) (let u = ({a = 0 , b = false , c =  1 }.b) in u) ) (((\x: Unit .\y: Rec X. X .x) 0 ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a)))) ) ) (\a: Bool .\b: Unit .b))
(((\x: Unit .\y: Bool .y) ({a = (fix (\x: Unit . 0 )) , b = (if ({a = 0 , b = false }.b) then (let u = true in ({a = 0 , b = false }.b)) else (if true then false else (case <r = true > as Nat of < l = x > => x | < r = y > => y))) , c =  (if (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Bool ] false )) )) then (unfold [ Bool ] (fold [ Unit ] 1 )) else ({a = 0 , b = true , c = 0 }.c)) }.b) ) (let u = (if (let u = false in u) then (let u = false in 0) else ({a = false , b = 1 }.b)) in (case <r = (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)))
(((\x: Rec X. X .\y: Nat .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (if ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = 1 , b = true , c =  0 }.b) , c =  ({a = 0 , b = true , c = 0 }.c) }.b) then (unfold [ Bool ] (fold [ Unit ] ({a = 1 , b = false }.a) )) else (succ 0)) )) ) (( \f: Unit .((f (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) true ) true) )) ) (((\x: Bool .\y: Unit .x) false ) true) ) ) (\a: Rec X. X .\b: Unit .a)))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (pred ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (if (let u = (let u = 1 in 0) in false) then (fix (\x: Unit . 1 )) else (fix (\x: Bool . 0 ))) ))) ))
(((\x: Unit .\y: Unit .x) (( \f: Bool .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = 0 }.a) )) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) (((\x: Unit .\y: Rec X. X .y) (let u = ({a = (if true then 0 else 1) , b = 1 }.b) in (let u = (let u = true in u) in (let u = false in false))) ) (let u = (if false then true else true) in u)))
(((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Nat .x) (((\x: Rec X. X .\y: Unit .y) (let u = false in u) ) (((\x: Bool .\y: Rec X. X .y) false ) false)) ) (( \f: Nat .((f ({a = 1 , b = false , c =  0 }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Bool .b))) ) (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = (let u = false in 1) }.b) )) ) (case <l = (case <l = (let u = false in 1) > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)))
(((\x: Unit .\y: Unit .y) (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f ({a = false , b = 1 }.a) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) )) ) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (unfold [ Bool ] (fold [ Nat ] 0 )) in 1) )) , b = (let u = (((\x: Rec X. X .\y: Bool .x) (let u = true in true) ) (unfold [ Bool ] (fold [ Nat ] true ))) in (let u = ({a = 0 , b = 0 }.b) in (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Bool .y) true ) false) ) (if false then false else true)))) , c =  ({a = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 1 , b = true }.b) }.a) , b = (let u = (((\x: Bool .\y: Unit .y) ({a = false , b = 0 }.a) ) ({a = 1 , b = 1 }.b)) in (((\x: Bool .\y: Bool .y) true ) 1)) }.b) }.b))
(pred (let u = (if false then (let u = 1 in true) else (((\x: Unit .\y: Bool .x) false ) true)) in ({a = ({a = 0 , b = false }.b) , b = 1 }.b)))
(( \f: Rec X. X .((f ({a = (((\x: Bool .\y: Unit .y) (let u = ({a = false , b = 1 }.a) in (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Bool .b))) ) ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  (((\x: Unit .\y: Bool .y) false ) 1) }.b)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) }.a) ) (let u = (pred (succ 1)) in (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Bool .\y: Unit .x) true ) true) ))) ) ) (\a: Nat .\b: Rec X. X .b))
(succ (((\x: Bool .\y: Unit .x) ({a = false , b = ({a = 1 , b = false }.a) }.b) ) ({a = (unfold [ Nat ] (fold [ Bool ] 1 )) , b = (let u = true in u) , c =  (((\x: Nat .\y: Bool .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.b)))
(( \f: Nat .((f (case <r = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) , b = ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , b = (succ 0) }.a) , c =  ({a = 0 , b = true }.a) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .x) ({a = (let u = 0 in u) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) }.b) ) ({a = (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Unit .x) true ) false) ) true) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b)) ) ) (\a: Nat .\b: Nat .a))
({a = (((\x: Nat .\y: Unit .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) ({a = 1 , b = true }.a)) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in true) }.b) )) , b = ({a = ({a = true , b = false }.b) , b = (((\x: Unit .\y: Rec X. X .x) false ) true) }.b) }.b) , c =  (let u = (( \f: Rec X. X .((f ({a = false , b = ({a = 0 , b = false }.a) }.b) ) (if (unfold [ Rec X. X ] (fold [ Nat ] false )) then 1 else (let u = false in 0)) ) ) (\a: Nat .\b: Unit .b)) in u) }.b)
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (iszero (if (fix (\x: Unit . true )) then (pred 0) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )))) , b = ({a = ({a = 1 , b = true , c = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) }.c) , b = (let u = (unfold [ Nat ] (fold [ Unit ] 0 )) in (succ ({a = 0 , b = false }.a))) }.b) }.b) ))
(fix (\x: Nat . (let u = ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a)) , b = (unfold [ Bool ] (fold [ Nat ] 1 )) }.b) in u) ))
(let u = (fix (\x: Rec X. X . (let u = ({a = 0 , b = (unfold [ Unit ] (fold [ Bool ] true )) }.a) in (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Unit .\y: Rec X. X .x) true ) false) ))) )) in ({a = (( \f: Nat .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) ) (((\x: Nat .\y: Nat .y) false ) 1) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.b))
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Unit .x) ({a = 1 , b = true , c =  1 }.b) ) true) )) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) }.a) ))
(let u = (pred (succ ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .y) false ) 1) )))) in u)
(let u = (let u = (((\x: Bool .\y: Nat .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .x) 1 ) false)) in (iszero (let u = ({a = (let u = 1 in 1) , b = 1 }.b) in (unfold [ Nat ] (fold [ Nat ] 0 ))))) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = true in (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a))) )))
({a = (case <l = (((\x: Nat .\y: Nat .x) (pred 0) ) ({a = false , b = false }.b)) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = ({a = 1 , b = 1 }.b) , b = (fix (\x: Rec X. X . true )) }.b) }.b)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) (if false then false else false) ) (let u = false in true)) )) ) ({a = (unfold [ Nat ] (fold [ Unit ] false )) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) }.a) ) ) (\a: Nat .\b: Rec X. X .a)) ))
(( \f: Bool .((f (( \f: Rec X. X .((f ({a = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) in u) , b = (let u = false in true) }.b) ) (unfold [ Bool ] (fold [ Bool ] true )) ) ) (\a: Nat .\b: Unit .a)) ) ({a = (let u = (let u = 0 in (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b))) in u) , b = (( \f: Rec X. X .((f (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b)) ) false ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) ) (\a: Rec X. X .\b: Nat .b))
(pred (let u = (fix (\x: Unit . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) in u))
(if (( \f: Nat .((f (if (if true then false else false) then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else true) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) ) ) (\a: Bool .\b: Bool .b)) then (((\x: Rec X. X .\y: Nat .x) ({a = ({a = 1 , b = false }.b) , b = (if false then 0 else 1) }.a) ) (((\x: Bool .\y: Unit .y) (let u = false in false) ) (if (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) then (if true then true else true) else false))) else ({a = (( \f: Unit .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) (let u = 0 in u) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) }.b))
(let u = (case <r = ({a = 1 , b = (unfold [ Bool ] (fold [ Bool ] true )) , c =  1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .x) (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.a) )) ) (((\x: Bool .\y: Unit .x) (if ({a = 1 , b = false , c =  0 }.b) then true else false) ) (((\x: Bool .\y: Rec X. X .x) false ) ({a = 1 , b = false , c =  1 }.b)))))
(let u = (case <r = (( \f: Rec X. X .((f (iszero (unfold [ Nat ] (fold [ Unit ] 1 ))) ) (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) in (( \f: Bool .((f (let u = 1 in 1) ) (succ (let u = (let u = true in u) in 0)) ) ) (\a: Unit .\b: Nat .a)))
(let u = (pred (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (fix (\x: Unit . (if true then 1 else 1) )) ) ) (\a: Rec X. X .\b: Rec X. X .b))) in ({a = ({a = ({a = (let u = 0 in false) , b = (((\x: Unit .\y: Bool .y) false ) 0) }.a) , b = ({a = (if (iszero 0) then false else true) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 )) }.b) }.b) , b = (iszero (let u = false in 1)) }.b))
({a = (unfold [ Bool ] (fold [ Rec X. X ] (let u = (((\x: Unit .\y: Nat .y) false ) 0) in u) )) , b = (let u = (((\x: Nat .\y: Nat .x) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = false , c =  1 }.b) ) ({a = false , b = false }.b)) in ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = true }.a) ))) }.b)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = ({a = ({a = 0 , b = ({a = false , b = 0 }.b) }.b) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) }.b) }.b) ) (case <l = (let u = (let u = true in 1) in 1) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)) ))
({a = ({a = (let u = ({a = false , b = 0 }.b) in 1) , b = (case <l = (fix (\x: Bool . 1 )) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) )) , c =  (succ (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a))) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (case <r = (iszero ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) > as Unit of < l = x > => x | < r = y > => y) ))
(((\x: Rec X. X .\y: Rec X. X .y) ({a = (iszero (succ 1)) , b = (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) )) }.b) ) ({a = (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] 0 )) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = (fix (\x: Bool . true )) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a))
(case <r = ({a = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Nat .x) (succ 1) ) ({a = ({a = false , b = 0 }.a) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.b)) }.b) , b = (( \f: Bool .((f (((\x: Nat .\y: Bool .y) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .b)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false ))) ) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Bool .y) false ) true) )) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  (((\x: Bool .\y: Nat .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f ({a = 1 , b = true , c =  0 }.b) ) (let u = 1 in false) ) ) (\a: Unit .\b: Unit .b))) }.b) > as Bool of < l = x > => x | < r = y > => y)
(let u = (( \f: Nat .((f ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = 1 , b = 1 }.b) , b = (let u = 0 in true) , c =  0 }.b) )) ) ) (\a: Nat .\b: Bool .a)) in (let u = (let u = (((\x: Bool .\y: Rec X. X .x) 1 ) false) in u) in (( \f: Bool .((f (let u = ({a = 1 , b = true }.b) in u) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b))))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = (((\x: Nat .\y: Unit .y) (let u = false in false) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .a))) in (( \f: Bool .((f ({a = 1 , b = 1 }.b) ) (if true then 1 else 0) ) ) (\a: Nat .\b: Unit .a))) ))
(( \f: Rec X. X .((f ({a = (let u = (if false then 1 else 1) in (let u = ({a = false , b = 1 }.a) in u)) , b = ({a = (((\x: Bool .\y: Rec X. X .x) true ) true) , b = ({a = 0 , b = 1 }.b) }.b) }.b) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) (fix (\x: Unit . true ))) ) (((\x: Bool .\y: Nat .y) (iszero ({a = 0 , b = (let u = false in 1) }.b)) ) (if ({a = (let u = 1 in false) , b = true }.b) then (((\x: Nat .\y: Unit .x) 0 ) true) else (fix (\x: Bool . 0 )))) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .a))
(unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f (let u = (if (((\x: Unit .\y: Unit .y) (fix (\x: Rec X. X . false )) ) (iszero 1)) then ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Nat ] true )) }.a) else (let u = 1 in ({a = 0 , b = false , c = 1 }.c))) in (let u = (unfold [ Unit ] (fold [ Unit ] false )) in (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)))) ) (((\x: Unit .\y: Unit .y) (fix (\x: Bool . false )) ) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Rec X. X .\b: Nat .a)) ))
({a = (((\x: Bool .\y: Unit .y) (let u = (case <r = (let u = false in u) > as Bool of < l = x > => x | < r = y > => y) in (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) ) (succ ({a = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = 0 }.b))) , b = (succ (fix (\x: Unit . (( \f: Nat .((f 0 ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Bool .\b: Bool .b)) ))) }.b)
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (if true then 1 else 1) )) )) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .y) (case <r = (fix (\x: Unit . false )) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . ({a = ({a = 1 , b = true }.a) , b = false , c =  1 }.b) ))) ))
({a = (succ (fix (\x: Nat . ({a = true , b = 0 }.b) ))) , b = (case <l = (let u = (let u = true in 0) in u) > as Unit of < l = x > => x | < r = y > => y) }.b)
({a = (( \f: Nat .((f (let u = (( \f: Rec X. X .((f true ) ({a = true , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .a)) in u) ) ({a = (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = true }.a) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , c =  (pred (let u = 0 in u)) }.b) ) ) (\a: Nat .\b: Unit .b)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (((\x: Nat .\y: Bool .y) true ) ({a = 0 , b = 0 }.b)) in u) )) }.b)
(if (( \f: Bool .((f (iszero 1) ) (let u = (iszero 1) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) in u) , b = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (let u = true in 0) , b = ({a = true , b = 0 }.a) }.a) )) , b = (( \f: Bool .((f (((\x: Bool .\y: Nat .y) true ) 0) ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) }.b) else ({a = (if ({a = 0 , b = (let u = true in u) }.b) then (iszero 1) else (fix (\x: Nat . true ))) , b = ({a = (succ 1) , b = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .a)) }.b) }.a) }.b))
({a = ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) }.a) , b = (let u = (fix (\x: Rec X. X . (( \f: Rec X. X .((f (if false then true else false) ) (iszero 1) ) ) (\a: Bool .\b: Nat .b)) )) in (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in (unfold [ Bool ] (fold [ Bool ] false )))) , c =  (((\x: Unit .\y: Unit .x) ({a = (let u = 0 in 1) , b = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.b) ) ({a = ({a = 1 , b = false , c =  1 }.b) , b = (if false then true else true) }.b)) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f (fix (\x: Nat . (((\x: Bool .\y: Unit .x) (let u = false in true) ) (iszero 0)) )) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Unit .x) false ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .b))) ) (( \f: Rec X. X .((f ({a = true , b = false }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ) (\a: Unit .\b: Rec X. X .b))) ) ) (\a: Nat .\b: Unit .a)) ))
(( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Unit .((f (pred (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b))) ) ({a = (if true then 0 else 0) , b = false , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) }.c) ) ) (\a: Rec X. X .\b: Unit .a)) )) ) ({a = ({a = (((\x: Rec X. X .\y: Nat .y) true ) true) , b = (iszero (unfold [ Bool ] (fold [ Nat ] 0 ))) }.b) , b = ({a = (((\x: Unit .\y: Rec X. X .x) 0 ) true) , b = (((\x: Bool .\y: Nat .x) false ) true) }.a) }.b) ) ) (\a: Nat .\b: Bool .a))
(fix (\x: Nat . (let u = ({a = ({a = 0 , b = false , c =  0 }.b) , b = ({a = 1 , b = true , c =  1 }.b) }.b) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ))
(succ (if (unfold [ Bool ] (fold [ Unit ] (( \f: Rec X. X .((f ({a = true , b = 1 }.a) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Nat .a)) )) then ({a = (fix (\x: Unit . 0 )) , b = (let u = (pred 1) in u) }.b) else (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Bool ] (fold [ Bool ] (if false then 0 else 1) )) ))))
(( \f: Rec X. X .((f (fix (\x: Unit . (pred (let u = 1 in 0)) )) ) ({a = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = false in 1) else (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) in u)) , b = (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = false , b = true }.b) )) > as Unit of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Rec X. X .\b: Unit .b))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (iszero ({a = 1 , b = false , c = 0 }.c)) ))
(case <r = ({a = ({a = 1 , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .a)) }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = true }.a) )) }.a) > as Bool of < l = x > => x | < r = y > => y)
(let u = (fix (\x: Unit . (fix (\x: Nat . (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Rec X. X .x) false ) true) ) true) )) )) in (( \f: Bool .((f (pred (succ 1)) ) ({a = (let u = (pred 1) in u) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.a) ) ) (\a: Rec X. X .\b: Nat .b)))
(let u = (let u = (( \f: Nat .((f (if ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = true }.b) then ({a = false , b = 0 }.a) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = true , c =  1 }.b) ))) ) ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = true , c =  1 }.b) ) ) (\a: Unit .\b: Bool .b)) in u) in (( \f: Rec X. X .((f (( \f: Nat .((f (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ) (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = false }.a) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Bool .\y: Rec X. X .y) (if true then (unfold [ Nat ] (fold [ Bool ] false )) else (unfold [ Unit ] (fold [ Nat ] false ))) ) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = false }.a)) ) ) (\a: Nat .\b: Nat .a)))
({a = (succ (((\x: Unit .\y: Unit .x) ({a = true , b = 0 }.b) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .a)))) , b = ({a = (if (fix (\x: Rec X. X . true )) then (iszero 0) else (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a))) , b = (fix (\x: Unit . ({a = true , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.a) )) }.b) , c = ({a = (((\x: Nat .\y: Nat .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (let u = 0 in (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)))) , b = ({a = (let u = 0 in u) , b = false , c =  0 }.b) }.a) }.c)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if ({a = (let u = 1 in u) , b = (((\x: Unit .\y: Bool .y) ({a = true , b = ({a = 1 , b = true , c =  0 }.b) }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) , c =  (fix (\x: Rec X. X . (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) )) }.b) then (( \f: Bool .((f (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (iszero (( \f: Unit .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Nat .b)) else ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (if false then true else true) ))) ))
(( \f: Unit .((f ({a = (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . ({a = ({a = true , b = 1 }.b) , b = (let u = 1 in false) }.b) )) }.b) ) (fix (\x: Rec X. X . (( \f: Unit .((f ({a = 0 , b = true , c =  0 }.b) ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Bool .b)) )) ) ) (\a: Rec X. X .\b: Bool .b))
(let u = ({a = (succ ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (pred 1) ))) , b = (if ({a = (iszero 0) , b = (pred 0) }.a) then ({a = 0 , b = false , c =  1 }.b) else (let u = true in u)) , c = (if (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.c) in (( \f: Unit .((f ({a = ({a = (let u = 1 in u) , b = (iszero 0) }.b) , b = (pred 1) }.a) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Nat .y) (let u = 0 in true) ) true) , c =  (fix (\x: Nat . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) }.b) ) ) (\a: Nat .\b: Bool .b)))
(let u = (((\x: Nat .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Nat ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) ) (iszero (let u = false in 0))) in ({a = (let u = ({a = 0 , b = false , c = 0 }.c) in (( \f: Nat .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Unit .\b: Unit .a))) , b = (((\x: Nat .\y: Nat .x) ({a = 0 , b = true , c =  0 }.b) ) ({a = 0 , b = false , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)) }.a))
({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (case <r = (let u = 0 in false) > as Rec X. X of < l = x > => x | < r = y > => y) )) in (((\x: Bool .\y: Bool .y) (let u = 0 in true) ) ({a = ({a = 0 , b = true }.a) , b = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) , c = (let u = 1 in u) }.c))) , b = ({a = ({a = (if false then (((\x: Bool .\y: Rec X. X .x) 1 ) false) else (((\x: Rec X. X .\y: Bool .y) false ) 0)) , b = (if true then 1 else 1) }.b) , b = ({a = ({a = false , b = false }.b) , b = (fix (\x: Rec X. X . true )) }.b) , c = ({a = (((\x: Bool .\y: Unit .y) false ) false) , b = ({a = true , b = 0 }.b) }.b) }.c) }.b)
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Bool .x) ({a = true , b = 1 }.a) ) (case <r = (let u = false in u) > as Unit of < l = x > => x | < r = y > => y)) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = ({a = ({a = 1 , b = false , c = 1 }.c) , b = (succ 1) }.b) in (let u = (let u = 1 in u) in (unfold [ Bool ] (fold [ Rec X. X ] false )))) )) }.b)
(let u = (let u = ({a = (let u = 1 in u) , b = (let u = 1 in 0) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) in u)
({a = (( \f: Nat .((f (((\x: Bool .\y: Unit .x) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) ) ({a = 0 , b = false }.b)) ) (succ ({a = 0 , b = (((\x: Unit .\y: Rec X. X .x) true ) true) }.a)) ) ) (\a: Nat .\b: Unit .a)) , b = (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Rec X. X .x) (let u = true in false) ) (( \f: Bool .((f (fix (\x: Unit . true )) ) true ) ) (\a: Unit .\b: Bool .b))) ) (unfold [ Unit ] (fold [ Bool ] false ))) )) , c = (fix (\x: Unit . (succ 1) )) }.c)
(( \f: Rec X. X .((f (case <r = (case <r = ({a = (let u = true in u) , b = (iszero 1) }.b) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (( \f: Bool .((f ({a = (fix (\x: Nat . 1 )) , b = (fix (\x: Bool . true )) }.b) ) (let u = (let u = 1 in 1) in (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Nat .a)) ) (iszero (( \f: Unit .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) 0 ) ) (\a: Nat .\b: Nat .a)) ) (succ 1) ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .b))
(((\x: Rec X. X .\y: Unit .x) (case <r = ({a = ({a = 0 , b = (pred 0) }.b) , b = (fix (\x: Rec X. X . true )) }.b) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (( \f: Unit .((f 1 ) (let u = 0 in u) ) ) (\a: Bool .\b: Unit .a)) in (((\x: Bool .\y: Bool .x) (let u = true in true) ) ({a = 0 , b = true }.b))))
(let u = (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Nat .x) (let u = false in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false ))) ) (fix (\x: Nat . false ))) in u)
({a = (iszero ({a = (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] true )) ) (let u = 0 in true) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = true , c =  0 }.b) )) )) }.b)
(let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Unit . (fix (\x: Bool . (unfold [ Unit ] (fold [ Bool ] 1 )) )) )) )) in u)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) ({a = 1 , b = true }.b) ) (if true then false else true)) )) ))
(iszero (( \f: Nat .((f (let u = (pred 0) in (succ 1)) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) (pred 0) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .a)))
(let u = ({a = (unfold [ Nat ] (fold [ Bool ] ({a = ({a = 1 , b = ({a = false , b = 0 }.a) , c =  0 }.b) , b = ({a = 0 , b = true }.a) }.b) )) , b = (if (((\x: Nat .\y: Unit .x) ({a = false , b = true }.b) ) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .b))) then ({a = (succ 1) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = true , b = 0 }.a) )) }.b) else (unfold [ Nat ] (fold [ Nat ] (fix (\x: Unit . false )) ))) , c =  (pred (( \f: Rec X. X .((f 0 ) ({a = true , b = 0 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.b) in u)
(iszero ({a = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .y) false ) false) )) ) (fix (\x: Rec X. X . false )) ) ) (\a: Unit .\b: Unit .b)) , b = ({a = true , b = 0 }.b) }.b))
(((\x: Nat .\y: Unit .x) ({a = (iszero (((\x: Unit .\y: Nat .y) true ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)))) , b = (( \f: Nat .((f ({a = (pred 1) , b = ({a = true , b = 1 }.a) , c =  (let u = 0 in u) }.b) ) (let u = true in false) ) ) (\a: Unit .\b: Unit .b)) }.b) ) (iszero (let u = (if false then 1 else 0) in ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) }.b))))
(((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Nat .y) ({a = true , b = true }.b) ) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) , b = true , c =  1 }.b)) ) (if true then 0 else (succ 0))) ) (let u = (((\x: Unit .\y: Nat .x) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = 1 , b = true , c =  0 }.b)) in (iszero 1)))
(iszero (let u = (case <r = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) , b = (iszero 1) }.b) > as Bool of < l = x > => x | < r = y > => y) in (( \f: Unit .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (let u = 1 in ({a = 1 , b = 1 }.b)) ) ) (\a: Bool .\b: Nat .a))))
(let u = (unfold [ Unit ] (fold [ Unit ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .b)) )) )) in u)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (fix (\x: Bool . (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .a)) )) , b = (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .x) false ) true) )) ) (let u = true in u)) }.b) ))
(if (((\x: Nat .\y: Bool .y) (let u = ({a = true , b = (let u = 1 in false) }.b) in ({a = (let u = 1 in false) , b = ({a = false , b = 1 }.b) }.a)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = true }.b) ) true) ))) then (unfold [ Bool ] (fold [ Bool ] ({a = ({a = false , b = 0 }.a) , b = ({a = (let u = 1 in u) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) , c = ({a = (iszero 0) , b = 0 }.b) }.c) }.a) )) else (let u = (if false then (let u = true in false) else true) in u))
(fix (\x: Rec X. X . ({a = (((\x: Nat .\y: Rec X. X .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) true) , b = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = (if true then false else true) , c = 1 }.c) }.b) ))
(let u = ({a = (fix (\x: Unit . (((\x: Unit .\y: Bool .x) false ) false) )) , b = ({a = (succ (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b))) , b = (((\x: Bool .\y: Rec X. X .y) true ) 0) }.b) }.b) in u)
(case <r = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = (if false then 0 else 1) , b = true , c =  1 }.b) )) in (let u = (((\x: Unit .\y: Bool .y) ({a = 0 , b = false , c =  0 }.b) ) ({a = 1 , b = true }.b)) in ({a = (( \f: Unit .((f ({a = true , b = 0 }.a) ) true ) ) (\a: Unit .\b: Rec X. X .b)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) }.b))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Nat .x) (case <r = (( \f: Bool .((f (let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , b = 1 }.a) in u) ) (let u = ({a = 0 , b = false }.b) in u) ) ) (\a: Rec X. X .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) ({a = ({a = (let u = 1 in u) , b = (let u = 0 in false) , c =  1 }.b) , b = ({a = false , b = 0 }.b) }.a) ) (let u = (let u = (( \f: Unit .((f ({a = 0 , b = false , c = 1 }.c) ) (((\x: Unit .\y: Nat .x) 0 ) false) ) ) (\a: Unit .\b: Rec X. X .b)) in ({a = 1 , b = true }.b)) in (if (unfold [ Bool ] (fold [ Unit ] true )) then ({a = true , b = true }.b) else (iszero 1)))))
(fix (\x: Nat . (let u = (unfold [ Nat ] (fold [ Nat ] (if true then 0 else 0) )) in (let u = (((\x: Bool .\y: Unit .x) false ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .b))) in (if (let u = false in true) then ({a = 1 , b = ({a = true , b = 1 }.a) , c =  0 }.b) else (let u = true in u)))) ))
({a = ({a = (let u = 0 in 1) , b = ({a = 1 , b = false }.b) , c =  ({a = true , b = (if true then 0 else 1) }.b) }.b) , b = ({a = ({a = ({a = 1 , b = 0 }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] true )) }.a) , b = (((\x: Rec X. X .\y: Bool .y) true ) (let u = 1 in 1)) }.b) }.b)
({a = (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (fix (\x: Bool . ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false )) ))) , b = ({a = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = (let u = true in u) }.a) , b = (unfold [ Unit ] (fold [ Nat ] (((\x: Nat .\y: Unit .y) true ) false) )) , c = (if (if ({a = 1 , b = true , c =  1 }.b) then true else false) then ({a = false , b = 0 }.b) else ({a = 1 , b = true , c = 0 }.c)) }.c) }.a)
(case <l = (if (unfold [ Bool ] (fold [ Nat ] (let u = 1 in true) )) then (pred (((\x: Rec X. X .\y: Unit .y) false ) 0)) else ({a = (pred 0) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , c = (((\x: Nat .\y: Nat .y) true ) 0) }.c)) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = (( \f: Unit .((f (fix (\x: Rec X. X . ({a = false , b = 1 }.a) )) ) (let u = (let u = false in u) in u) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.a) in (succ (if ({a = true , b = (let u = 1 in u) }.a) then (pred 1) else (let u = true in 1))))
(unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) (fix (\x: Nat . true )) ) (fix (\x: Bool . 0 ))) ))
(let u = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = 0 in false) }.b) in (( \f: Bool .((f (unfold [ Nat ] (fold [ Rec X. X ] (let u = false in false) )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = true , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.b) )) ) ) (\a: Bool .\b: Unit .a)))
(let u = ({a = (fix (\x: Unit . 1 )) , b = (iszero 1) , c =  ({a = true , b = (((\x: Bool .\y: Bool .y) true ) 1) }.b) }.b) in (( \f: Unit .((f (let u = ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.b) in u) ) (( \f: Unit .((f ({a = true , b = 1 }.a) ) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .b)))
({a = (fix (\x: Unit . (let u = 0 in (fix (\x: Nat . 1 ))) )) , b = (let u = (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = true }.a) ) false) ) (( \f: Bool .((f 1 ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .a)) in (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) in (iszero (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)))) }.a)
(fix (\x: Nat . (let u = (case <l = ({a = 1 , b = false }.a) > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Rec X. X . (fix (\x: Rec X. X . 0 )) ))) ))
(let u = ({a = (fix (\x: Unit . (((\x: Unit .\y: Nat .x) 0 ) true) )) , b = (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) }.b) in (( \f: Unit .((f (let u = (fix (\x: Bool . ({a = false , b = 1 }.a) )) in u) ) ({a = (( \f: Bool .((f (fix (\x: Rec X. X . 1 )) ) (let u = true in 0) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (( \f: Bool .((f (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) in false) ) (let u = true in u) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) ) (\a: Unit .\b: Bool .a)))
(unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = (if true then 0 else 0) , b = true }.b) )) ))
(let u = (( \f: Bool .((f (let u = (let u = 0 in true) in u) ) (if (iszero 1) then (unfold [ Nat ] (fold [ Unit ] ({a = false , b = true }.b) )) else (if false then false else false)) ) ) (\a: Bool .\b: Unit .a)) in (let u = (iszero (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Rec X. X . 1 )) ) (let u = true in u))) in (succ (let u = 1 in u))))
(case <r = (let u = (iszero 0) in u) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Bool .x) (case <r = (( \f: Bool .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (let u = true in ({a = false , b = true }.b)) ) ) (\a: Bool .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (unfold [ Nat ] (fold [ Bool ] ({a = true , b = 0 }.a) )) in u))
(let u = (( \f: Bool .((f (( \f: Nat .((f ({a = (fix (\x: Nat . false )) , b = (pred 0) }.a) ) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .a)) ) (if (unfold [ Nat ] (fold [ Nat ] false )) then (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .b)) else (let u = 1 in true)) ) ) (\a: Unit .\b: Nat .a)) in u)
(let u = (( \f: Bool .((f (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f ({a = 0 , b = true , c =  1 }.b) ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Bool .b)) in (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .x) 1 ) true) ) false) )))
({a = (case <l = (if false then 0 else (let u = 0 in u)) > as Bool of < l = x > => x | < r = y > => y) , b = (if (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) in u) then (let u = (pred 1) in ({a = 0 , b = true }.b)) else (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else ({a = false , b = false }.b))) }.a)
(case <l = ({a = (succ (((\x: Unit .\y: Unit .y) false ) (let u = 1 in 1))) , b = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Nat . true )) )) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Unit ] ({a = ({a = 0 , b = false , c = 0 }.c) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = (iszero 1) , b = ({a = 0 , b = true , c = 0 }.c) }.a) )))
(case <l = (fix (\x: Bool . ({a = (let u = ({a = false , b = false }.b) in false) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Unit . ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = ({a = true , b = 0 }.b) }.b) )) ))
(let u = (unfold [ Nat ] (fold [ Rec X. X ] (if (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) then (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) false ) true) )) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))) )) in u)
(if (if (let u = (succ (((\x: Nat .\y: Rec X. X .x) 1 ) false)) in ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Nat . false )) ))) then (((\x: Rec X. X .\y: Nat .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) ))) else (let u = (case <l = (((\x: Nat .\y: Unit .x) 1 ) (fix (\x: Bool . true ))) > as Unit of < l = x > => x | < r = y > => y) in (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 ))))) then (pred (unfold [ Bool ] (fold [ Nat ] (let u = (let u = ({a = true , b = false }.b) in 1) in ({a = 1 , b = (iszero 1) }.a)) ))) else (let u = (( \f: Nat .((f (let u = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .a)) in true) ) (let u = 0 in false) ) ) (\a: Bool .\b: Nat .b)) in (let u = (unfold [ Nat ] (fold [ Bool ] 1 )) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)))))
({a = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Bool .\y: Unit .x) (((\x: Nat .\y: Unit .x) true ) true) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) ) (let u = 0 in ({a = true , b = 1 }.a))) , b = (((\x: Rec X. X .\y: Bool .x) ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.b) ) (( \f: Rec X. X .((f false ) (((\x: Unit .\y: Bool .y) false ) false) ) ) (\a: Rec X. X .\b: Unit .a))) }.b)
(((\x: Nat .\y: Bool .x) (unfold [ Unit ] (fold [ Unit ] (iszero (unfold [ Bool ] (fold [ Nat ] 0 ))) )) ) (fix (\x: Nat . ({a = ({a = false , b = 0 }.b) , b = (let u = false in u) }.b) )))
(( \f: Unit .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (( \f: Nat .((f ({a = true , b = 1 }.a) ) false ) ) (\a: Bool .\b: Nat .a)) , b = (unfold [ Unit ] (fold [ Unit ] (let u = false in u) )) }.b) )) ) (( \f: Nat .((f (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = false in false) ))) ) (( \f: Nat .((f (( \f: Unit .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ) (\a: Nat .\b: Nat .b)) ) (let u = 1 in ({a = 0 , b = true , c =  0 }.b)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .b))
({a = (pred (( \f: Nat .((f (( \f: Bool .((f (((\x: Unit .\y: Unit .x) 0 ) false) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .a))) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] false )) )) }.b) }.b)
(let u = (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = true }.b) )) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .x) false ) true) ))) in u)
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <l = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) in (if ({a = 0 , b = false , c =  0 }.b) then (succ 1) else (let u = 0 in u))) > as Rec X. X of < l = x > => x | < r = y > => y) ))
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (if (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Bool .((f true ) (let u = true in true) ) ) (\a: Unit .\b: Rec X. X .b)) )) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) then (if ({a = (let u = (let u = 0 in u) in (let u = true in u)) , b = (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Nat .y) true ) true) ) true) }.b) then (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) then (((\x: Nat .\y: Nat .x) ({a = 1 , b = true , c =  1 }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) else (if true then ({a = 0 , b = false , c =  0 }.b) else false)) else ({a = ({a = ({a = 1 , b = false }.b) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = ({a = 1 , b = (let u = true in true) , c = ({a = 1 , b = false , c = 1 }.c) }.c) }.a)) else (( \f: Nat .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = false , c =  1 }.b) )) ) (let u = ({a = ({a = 1 , b = true }.a) , b = (iszero 0) , c =  (let u = 0 in u) }.b) in u) ) ) (\a: Nat .\b: Unit .a))) ))
(((\x: Bool .\y: Bool .y) ({a = (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Bool .y) (if true then false else true) ) 0) ) (fix (\x: Nat . (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) , b = (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Nat .x) false ) false) ) (unfold [ Rec X. X ] (fold [ Unit ] false ))) }.b) ) (fix (\x: Rec X. X . (case <r = (let u = ({a = 0 , b = ({a = 1 , b = false }.a) }.b) in (iszero (let u = 1 in u))) > as Unit of < l = x > => x | < r = y > => y) )))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 1 in false) )) , b = (((\x: Bool .\y: Rec X. X .y) (iszero (((\x: Unit .\y: Rec X. X .y) true ) 1)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) )) ))) }.b)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] (( \f: Rec X. X .((f (let u = false in (((\x: Unit .\y: Nat .y) false ) 1)) ) (fix (\x: Unit . 1 )) ) ) (\a: Rec X. X .\b: Unit .b)) )) ) ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = true }.a) , b = (unfold [ Unit ] (fold [ Bool ] false )) , c = ({a = (if true then 0 else 0) , b = false }.a) }.c) ) ) (\a: Bool .\b: Nat .a))
({a = ({a = (fix (\x: Nat . (pred 1) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) true ) true) )) }.a) , b = (iszero (succ ({a = (if true then true else true) , b = (((\x: Nat .\y: Unit .x) 0 ) true) }.b))) , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Unit .((f ({a = (( \f: Bool .((f ({a = true , b = false }.b) ) false ) ) (\a: Rec X. X .\b: Bool .a)) , b = (pred 0) }.b) ) (( \f: Nat .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) ) (pred 1) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .a)) )) }.c)
({a = (fix (\x: Bool . (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] (let u = true in true) )) ) ({a = (iszero 1) , b = (((\x: Unit .\y: Unit .x) 1 ) false) }.a) ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = (let u = (( \f: Unit .((f (iszero (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) ) (let u = (fix (\x: Rec X. X . 1 )) in (let u = false in u)) ) ) (\a: Bool .\b: Bool .b)) in (succ (if (((\x: Unit .\y: Bool .x) true ) false) then (if false then 1 else 0) else (let u = 1 in u)))) }.a)
({a = ({a = (if (((\x: Nat .\y: Rec X. X .x) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true }.b)) then (let u = (let u = (succ 1) in u) in (((\x: Nat .\y: Nat .y) true ) 1)) else (fix (\x: Bool . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) ))) , b = (unfold [ Unit ] (fold [ Bool ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) }.a) , b = ({a = ({a = (let u = ({a = 0 , b = true , c = 0 }.c) in 0) , b = ({a = (((\x: Bool .\y: Unit .y) false ) false) , b = false }.b) }.a) , b = ({a = ({a = 0 , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) }.c) , b = (fix (\x: Nat . false )) }.b) }.a) }.b)
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Rec X. X .x) 1 ) false) , b = (unfold [ Bool ] (fold [ Bool ] false )) , c = (((\x: Nat .\y: Bool .y) ({a = 0 , b = true }.b) ) 0) }.c) )) , b = (iszero (((\x: Unit .\y: Bool .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) (unfold [ Unit ] (fold [ Bool ] false )))) }.a)
(fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Unit . true )) )) ))
(let u = (iszero (if (iszero (succ 0)) then (( \f: Nat .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) (fix (\x: Unit . (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) )) ) ) (\a: Bool .\b: Nat .a)) else (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)))) in (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Rec X. X .y) ({a = false , b = 0 }.a) ) (unfold [ Unit ] (fold [ Nat ] ({a = false , b = false }.b) ))) ) ({a = (((\x: Nat .\y: Bool .y) false ) 0) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) }.a) }.b)))
({a = (((\x: Rec X. X .\y: Nat .y) (let u = (pred 1) in (let u = ({a = false , b = true }.b) in u)) ) (if (let u = 1 in false) then (((\x: Rec X. X .\y: Rec X. X .y) false ) false) else (if true then false else false))) , b = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .x) false ) false) )) then (let u = (((\x: Nat .\y: Rec X. X .x) false ) true) in (((\x: Nat .\y: Bool .x) 0 ) (((\x: Rec X. X .\y: Bool .x) true ) true))) else ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = 1 , b = true }.a) }.b)) }.b)
(((\x: Rec X. X .\y: Nat .x) ({a = (fix (\x: Nat . (unfold [ Bool ] (fold [ Bool ] 1 )) )) , b = (let u = (let u = true in (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) in (let u = false in u)) }.b) ) (((\x: Nat .\y: Bool .y) (fix (\x: Bool . false )) ) (let u = (((\x: Bool .\y: Unit .y) false ) 1) in false)))
(fix (\x: Nat . (succ (let u = ({a = (((\x: Bool .\y: Bool .y) true ) false) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.a) in (if false then 1 else 0))) ))
(let u = (( \f: Nat .((f ({a = (let u = false in (let u = 0 in 0)) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (if (let u = true in u) then 1 else (unfold [ Nat ] (fold [ Nat ] 0 ))) )) ) ) (\a: Unit .\b: Bool .a)) in (pred (fix (\x: Bool . ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) ))))
(let u = (if (( \f: Nat .((f (iszero ({a = 1 , b = true }.a)) ) ({a = (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in false) )) , b = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) }.a) ) ) (\a: Bool .\b: Bool .b)) then ({a = (fix (\x: Bool . 1 )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = false , c =  1 }.b) )) }.a) else (let u = ({a = ({a = ({a = false , b = 1 }.b) , b = (unfold [ Nat ] (fold [ Nat ] 1 )) }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = true }.b) )) , c = (fix (\x: Unit . 1 )) }.c) in u)) in (( \f: Nat .((f ({a = ({a = true , b = true }.b) , b = 1 }.b) ) ({a = (pred (((\x: Nat .\y: Rec X. X .y) true ) 0)) , b = ({a = false , b = false }.b) , c = ({a = (let u = 1 in 0) , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)) , c = 1 }.c) }.c) ) ) (\a: Bool .\b: Bool .b)))
({a = ({a = (let u = 0 in u) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.b) , b = (case <r = (iszero (succ 0)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(case <l = (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then 0 else 1) ))) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Bool . ({a = (if ({a = (if true then 0 else 1) , b = true , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.b) then (let u = (pred 1) in 0) else (((\x: Bool .\y: Rec X. X .x) (let u = 1 in 0) ) (iszero 1))) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (case <r = (let u = true in u) > as Bool of < l = x > => x | < r = y > => y) )) }.a) ))
(((\x: Unit .\y: Unit .x) ({a = ({a = ({a = (if true then false else false) , b = 1 }.a) , b = (((\x: Rec X. X .\y: Bool .x) true ) ({a = 1 , b = true , c =  0 }.b)) }.b) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.a) ) (( \f: Nat .((f (let u = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) false) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) ) ) (\a: Nat .\b: Bool .b)) in u) ) (let u = (fix (\x: Unit . true )) in u) ) ) (\a: Bool .\b: Rec X. X .a)))
(fix (\x: Rec X. X . ({a = (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Bool .a)) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a)) }.a) ))
({a = ({a = (case <l = (fix (\x: Bool . 0 )) > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = 1 in true) )) , c = ({a = (succ 0) , b = ({a = (pred 0) , b = ({a = true , b = false }.b) }.b) , c = (pred 0) }.c) }.c) , b = ({a = (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] 1 )) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (unfold [ Bool ] (fold [ Unit ] ({a = ({a = 0 , b = true }.a) , b = ({a = true , b = 0 }.b) }.b) )) }.b) }.b)
(let u = ({a = (( \f: Nat .((f ({a = 1 , b = true , c =  0 }.b) ) (( \f: Unit .((f (let u = false in u) ) (((\x: Nat .\y: Rec X. X .x) false ) true) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .b)) , b = (if true then ({a = 0 , b = false , c = 1 }.c) else (pred 0)) }.b) in u)
(( \f: Bool .((f (( \f: Unit .((f (let u = 0 in 1) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Nat .a)) ) (( \f: Rec X. X .((f ({a = ({a = 1 , b = 1 }.b) , b = (iszero 0) }.a) ) (((\x: Bool .\y: Rec X. X .y) ({a = (fix (\x: Unit . 0 )) , b = (let u = true in u) }.b) ) ({a = 0 , b = true }.a)) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .b))
(fix (\x: Unit . (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ))) ))
({a = (let u = (unfold [ Bool ] (fold [ Bool ] ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = true in u) }.b) )) in u) , b = (iszero (case <l = (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = 0 }.b) )) > as Bool of < l = x > => x | < r = y > => y)) }.b)
({a = (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Bool ] 0 )) )) )) , b = (unfold [ Unit ] (fold [ Bool ] ({a = ({a = (let u = 1 in u) , b = 1 }.b) , b = ({a = true , b = false }.b) , c =  (let u = 0 in 0) }.b) )) }.a)
(case <r = (( \f: Nat .((f (let u = false in ({a = true , b = true }.b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (iszero (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) )) ) ) (\a: Unit .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(pred ({a = (let u = ({a = (let u = 0 in u) , b = true , c =  0 }.b) in (unfold [ Nat ] (fold [ Unit ] (pred 1) ))) , b = (let u = ({a = false , b = 0 }.b) in (((\x: Bool .\y: Nat .y) (let u = false in u) ) false)) , c = (let u = (((\x: Rec X. X .\y: Nat .y) false ) (let u = 1 in 1)) in u) }.c))
(( \f: Rec X. X .((f (if (if (let u = false in u) then ({a = true , b = false }.b) else ({a = false , b = 0 }.a)) then ({a = (let u = false in 1) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b) else ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = false in u) ))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = true in u) )) ) ) (\a: Bool .\b: Bool .b))
(let u = (case <l = (( \f: Rec X. X .((f ({a = 0 , b = true }.a) ) (((\x: Rec X. X .\y: Bool .x) 0 ) true) ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) in (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] (let u = ({a = true , b = false }.b) in u) )) )))
(( \f: Nat .((f (((\x: Unit .\y: Unit .x) (let u = (((\x: Rec X. X .\y: Bool .x) false ) false) in u) ) (let u = false in ({a = 0 , b = true }.b))) ) (if (let u = (( \f: Bool .((f (let u = 0 in u) ) (((\x: Nat .\y: Bool .x) (let u = 0 in u) ) true) ) ) (\a: Bool .\b: Rec X. X .a)) in (( \f: Unit .((f ({a = true , b = 0 }.a) ) (let u = false in u) ) ) (\a: Bool .\b: Rec X. X .a))) then ({a = (((\x: Unit .\y: Rec X. X .y) true ) true) , b = (fix (\x: Rec X. X . false )) }.b) else (fix (\x: Rec X. X . ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = (((\x: Bool .\y: Nat .x) false ) true) , c =  0 }.b) ))) ) ) (\a: Unit .\b: Bool .b))
(let u = (if (((\x: Nat .\y: Rec X. X .x) ({a = (if false then true else false) , b = (if (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b)) then true else (if false then true else true)) }.b) ) ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) , c =  ({a = 0 , b = false }.a) }.b)) then (( \f: Nat .((f ({a = ({a = 1 , b = true , c =  0 }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] true )) }.b) ) (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] true )) ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Bool .\b: Unit .b)) else (( \f: Bool .((f (if ({a = 1 , b = true , c =  0 }.b) then (let u = true in u) else (((\x: Unit .\y: Unit .x) false ) true)) ) (let u = (((\x: Nat .\y: Nat .x) true ) true) in ({a = true , b = true }.b)) ) ) (\a: Unit .\b: Bool .a))) in (unfold [ Nat ] (fold [ Unit ] ({a = (if false then 0 else 0) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.b) )))
(((\x: Bool .\y: Unit .x) (if (case <r = (if false then true else false) > as Unit of < l = x > => x | < r = y > => y) then ({a = (if false then 0 else 1) , b = 1 }.b) else (( \f: Bool .((f (((\x: Bool .\y: Unit .x) 1 ) false) ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) ) ({a = ({a = ({a = 1 , b = true }.a) , b = (let u = 1 in true) }.b) , b = (iszero ({a = ({a = 0 , b = 1 }.b) , b = true , c = 0 }.c)) }.b))
(let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) in u)
(fix (\x: Rec X. X . (((\x: Nat .\y: Bool .x) (fix (\x: Unit . (iszero 0) )) ) ({a = ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = 0 }.b) , b = (case <r = (let u = 0 in false) > as Unit of < l = x > => x | < r = y > => y) , c =  (let u = (let u = 1 in false) in (fix (\x: Bool . 0 ))) }.b)) ))
(( \f: Unit .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] false )) )) ) ({a = (( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in 1) , b = (fix (\x: Unit . ({a = true , b = false }.b) )) }.a) }.a) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = ({a = ({a = (let u = true in true) , b = (((\x: Bool .\y: Unit .y) (((\x: Unit .\y: Rec X. X .x) false ) true) ) ({a = 0 , b = true , c = 0 }.c)) }.b) , b = ({a = (let u = false in (((\x: Unit .\y: Nat .y) true ) 0)) , b = ({a = false , b = 1 }.b) }.b) }.b) in (fix (\x: Unit . (let u = ({a = 1 , b = 0 }.b) in (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a))) )))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) in u)) ))
(pred (case <l = ({a = (succ (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) , b = (iszero ({a = 1 , b = false , c = 0 }.c)) , c = (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ) (if true then 0 else 1) ) ) (\a: Bool .\b: Bool .a)) }.c) > as Bool of < l = x > => x | < r = y > => y))
(let u = (fix (\x: Bool . ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = true , b = 0 }.a) )) )) in u)
({a = (let u = (( \f: Bool .((f ({a = 0 , b = true , c = 1 }.c) ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) in (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = false , c = ({a = 0 , b = 1 }.b) }.c) ) (iszero 0))) , b = (((\x: Rec X. X .\y: Bool .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) )) ) (fix (\x: Bool . ({a = 0 , b = false , c =  0 }.b) ))) }.a)
({a = (((\x: Bool .\y: Unit .y) (iszero ({a = 0 , b = false , c = 0 }.c)) ) (let u = (( \f: Unit .((f false ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .a)) in u)) , b = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in (let u = 0 in 1)) )) , b = ({a = (pred 1) , b = (let u = 1 in false) }.b) , c =  ({a = ({a = 0 , b = false }.a) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.b) }.b) }.b)
(let u = ({a = (succ (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = true , b = 1 }.a) , c =  (( \f: Rec X. X .((f (let u = true in 1) ) (( \f: Rec X. X .((f 0 ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .b)) }.b) in (case <r = (((\x: Bool .\y: Rec X. X .x) (let u = true in false) ) ({a = true , b = 1 }.a)) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = 0 }.b) ) false) in (let u = (((\x: Bool .\y: Unit .x) 1 ) true) in (unfold [ Rec X. X ] (fold [ Unit ] 0 )))) in u) ) (let u = (((\x: Nat .\y: Rec X. X .y) (fix (\x: Bool . true )) ) (( \f: Bool .((f true ) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .a))) in (((\x: Rec X. X .\y: Unit .x) ({a = true , b = 0 }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] false )))) ) ) (\a: Nat .\b: Unit .b))
(let u = (( \f: Nat .((f (let u = ({a = 0 , b = 0 }.b) in (let u = 1 in 1)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (if true then 0 else 1) )) ) ) (\a: Bool .\b: Nat .a)) in (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) false) )))
({a = (succ ({a = 1 , b = 0 }.b)) , b = (fix (\x: Nat . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) > as Unit of < l = x > => x | < r = y > => y) )) )) }.a)
(unfold [ Bool ] (fold [ Unit ] (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Rec X. X ] (if false then true else false) )) ) (( \f: Bool .((f false ) (let u = true in u) ) ) (\a: Bool .\b: Bool .a))) else (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) false ) ) (\a: Rec X. X .\b: Unit .b))) ))
(let u = (( \f: Rec X. X .((f ({a = (if true then 1 else (((\x: Unit .\y: Unit .y) false ) 0)) , b = (let u = 0 in (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) }.b) ) ({a = ({a = (fix (\x: Rec X. X . false )) , b = (fix (\x: Unit . (((\x: Nat .\y: Nat .x) 1 ) false) )) }.a) , b = (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Bool .a)) in 1) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) in (if (let u = (succ ({a = 1 , b = 0 }.b)) in ({a = false , b = true }.b)) then (succ ({a = (let u = false in true) , b = 0 }.b)) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] 1 )) ))))
(( \f: Rec X. X .((f (pred (if ({a = 1 , b = true , c =  0 }.b) then (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) else 0)) ) (unfold [ Nat ] (fold [ Bool ] (let u = (let u = true in true) in 0) )) ) ) (\a: Nat .\b: Rec X. X .a))
({a = (succ (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ))) , b = (( \f: Bool .((f (( \f: Nat .((f ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) true) , b = true , c =  0 }.b) ) (iszero 0) ) ) (\a: Unit .\b: Bool .a)) ) (if (fix (\x: Nat . false )) then false else (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .b))) ) ) (\a: Unit .\b: Bool .a)) }.b)
(((\x: Unit .\y: Rec X. X .y) (let u = (let u = (let u = (let u = true in 1) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = true in 0) ))) in (let u = (((\x: Bool .\y: Unit .x) false ) (let u = true in u)) in u)) in u) ) (let u = (((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Unit .x) (iszero 0) ) true) ) ({a = false , b = true }.b)) in u))
(case <l = (((\x: Unit .\y: Unit .x) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = (let u = 0 in (let u = 0 in u)) }.b) ) ({a = ({a = false , b = (let u = false in false) }.b) , b = ({a = 1 , b = false , c = 1 }.c) }.a)) > as Nat of < l = x > => x | < r = y > => y)
(pred (((\x: Bool .\y: Unit .x) (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .y) (let u = 1 in false) ) ({a = 0 , b = false , c = 1 }.c)) )) ) ({a = (( \f: Nat .((f ({a = (let u = false in u) , b = ({a = 0 , b = 0 }.b) }.a) ) (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in false) ) ) (\a: Bool .\b: Unit .a)) , b = (iszero ({a = 1 , b = 0 }.b)) }.b)))
(unfold [ Unit ] (fold [ Unit ] (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = true , c =  1 }.b) )) in (unfold [ Unit ] (fold [ Bool ] false ))) ))
(if (iszero (let u = (( \f: Rec X. X .((f (pred 1) ) (let u = 1 in u) ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Bool .\y: Rec X. X .y) true ) ({a = 1 , b = false , c = 1 }.c)))) then ({a = (pred (if false then 0 else (unfold [ Nat ] (fold [ Unit ] 0 )))) , b = (let u = (((\x: Rec X. X .\y: Unit .x) (fix (\x: Rec X. X . false )) ) (let u = 0 in true)) in (((\x: Bool .\y: Unit .x) 1 ) false)) }.b) else (let u = (( \f: Nat .((f ({a = (pred 1) , b = ({a = 0 , b = false , c =  0 }.b) , c =  (let u = 0 in 1) }.b) ) (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (pred 0) )) in ({a = (let u = true in 0) , b = true }.b)) ) ) (\a: Nat .\b: Nat .a)) in (fix (\x: Unit . ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .y) true ) 1) )) ))))
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] ({a = (((\x: Bool .\y: Unit .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) ) false) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) }.b) )) ))
(( \f: Rec X. X .((f (if (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) > as Nat of < l = x > => x | < r = y > => y) then (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) else (let u = false in (fix (\x: Bool . 0 )))) ) (let u = ({a = ({a = 1 , b = true , c =  1 }.b) , b = (pred 0) }.b) in (case <l = (pred 0) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .a))
(let u = (let u = (succ (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a))) in (succ 1)) in (let u = ({a = (let u = true in u) , b = ({a = 1 , b = ({a = false , b = 0 }.b) }.b) }.a) in u))
(unfold [ Bool ] (fold [ Nat ] ({a = ({a = ({a = 1 , b = 1 }.b) , b = false }.a) , b = (((\x: Nat .\y: Unit .x) ({a = 1 , b = true }.b) ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .a))) }.a) ))
({a = (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Unit .x) ({a = 0 , b = false }.a) ) true) )) , b = (iszero (succ (((\x: Bool .\y: Unit .y) true ) (pred 1)))) }.b)
(unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Unit . (((\x: Bool .\y: Unit .x) true ) (((\x: Bool .\y: Rec X. X .x) true ) true)) )) ))
({a = (iszero (succ (((\x: Unit .\y: Nat .x) (case <l = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Nat ] true ))))) , b = (let u = (unfold [ Rec X. X ] (fold [ Bool ] (pred 0) )) in u) }.b)
(fix (\x: Rec X. X . ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 0 in (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) )) ))
(((\x: Bool .\y: Rec X. X .x) ({a = ({a = (let u = true in 1) , b = 1 }.b) , b = ({a = false , b = 1 }.a) , c =  ({a = (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .x) false ) false) )) , b = (((\x: Nat .\y: Bool .y) true ) 1) }.b) }.b) ) (unfold [ Unit ] (fold [ Bool ] ({a = ({a = false , b = 1 }.a) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) }.a) )))
({a = (fix (\x: Rec X. X . (let u = (unfold [ Unit ] (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] 0 )) )) in ({a = 1 , b = true }.a)) )) , b = (((\x: Nat .\y: Rec X. X .y) (case <r = (( \f: Rec X. X .((f ({a = 1 , b = false }.b) ) (((\x: Bool .\y: Bool .y) false ) false) ) ) (\a: Bool .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (((\x: Nat .\y: Nat .y) true ) 1) ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Nat .a))) }.b)
(let u = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) in (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = 1 , b = true }.b))) in u)
({a = (fix (\x: Bool . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) , b = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c = ({a = true , b = 1 }.b) }.c) )) ) (let u = (((\x: Unit .\y: Unit .y) true ) 0) in u) ) ) (\a: Rec X. X .\b: Bool .a)) }.b)
(let u = (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f ({a = true , b = 0 }.a) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false ))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = ({a = false , b = false }.b) in (unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] false )) )))) in (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = true in true)) )))
(fix (\x: Nat . (((\x: Nat .\y: Nat .x) ({a = (let u = 1 in 0) , b = true , c =  1 }.b) ) ({a = ({a = true , b = 1 }.a) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) }.a)) ))
(let u = (((\x: Rec X. X .\y: Bool .y) ({a = (fix (\x: Unit . 0 )) , b = ({a = 0 , b = (unfold [ Unit ] (fold [ Nat ] false )) , c =  (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) }.b) ) ({a = (iszero 1) , b = 1 }.a)) in (( \f: Nat .((f (if true then (unfold [ Bool ] (fold [ Nat ] 0 )) else (fix (\x: Unit . 1 ))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f 1 ) (pred 0) ) ) (\a: Unit .\b: Bool .a)) )) ) ) (\a: Nat .\b: Rec X. X .b)))
(((\x: Unit .\y: Rec X. X .y) ({a = (((\x: Bool .\y: Rec X. X .y) (let u = false in false) ) (let u = 0 in u)) , b = (iszero (((\x: Nat .\y: Nat .y) false ) 0)) }.b) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Bool .\y: Bool .x) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) (let u = 0 in false)) )))
(if (case <r = (if (iszero 1) then (((\x: Unit .\y: Rec X. X .y) false ) true) else (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b))) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = (let u = ({a = true , b = 1 }.a) in (unfold [ Nat ] (fold [ Unit ] 0 ))) , b = ({a = (succ 0) , b = (let u = 0 in ({a = true , b = false }.b)) }.b) }.b) else (let u = (( \f: Nat .((f (fix (\x: Unit . true )) ) (((\x: Nat .\y: Bool .y) false ) false) ) ) (\a: Bool .\b: Rec X. X .b)) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .x) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) true) ))))
(iszero ({a = (if (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) then (succ 1) else (pred 1)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) }.a))
(( \f: Rec X. X .((f (( \f: Unit .((f (fix (\x: Nat . ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = ({a = false , b = true }.b) , c =  ({a = 0 , b = (fix (\x: Unit . true )) , c = (pred 0) }.c) }.b) )) ) (fix (\x: Nat . (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) in (unfold [ Bool ] (fold [ Rec X. X ] false ))) )) ) ) (\a: Bool .\b: Nat .b)) ) (let u = (((\x: Bool .\y: Nat .y) (if true then (((\x: Unit .\y: Nat .y) true ) false) else false) ) (((\x: Nat .\y: Unit .y) false ) true)) in u) ) ) (\a: Unit .\b: Unit .a))
(pred (((\x: Bool .\y: Rec X. X .y) ({a = (((\x: Rec X. X .\y: Unit .x) 1 ) true) , b = false , c =  1 }.b) ) ({a = (let u = true in 0) , b = (fix (\x: Unit . true )) }.a)))
(( \f: Nat .((f (succ ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = 0 in 0) )) , b = (let u = (if true then true else true) in true) , c = (((\x: Nat .\y: Bool .y) false ) 1) }.c)) ) (let u = (((\x: Nat .\y: Bool .y) ({a = ({a = false , b = 1 }.b) , b = ({a = 1 , b = false , c =  1 }.b) , c =  (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) }.b) ) (case <l = (if true then 1 else 0) > as Nat of < l = x > => x | < r = y > => y)) in (succ ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = true , b = 0 }.b) }.b))) ) ) (\a: Unit .\b: Rec X. X .b))
(fix (\x: Nat . (case <r = (fix (\x: Bool . (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .a)) )) > as Unit of < l = x > => x | < r = y > => y) ))
(( \f: Rec X. X .((f (((\x: Bool .\y: Nat .y) (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) true ) ({a = true , b = 0 }.a)) ) (if true then false else true) ) ) (\a: Bool .\b: Bool .b)) ) (fix (\x: Unit . ({a = 1 , b = false }.b) ))) ) (case <r = ({a = 1 , b = (let u = true in true) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b))
(( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Bool ] (if (fix (\x: Nat . true )) then true else (let u = false in true)) )) )) , b = ({a = ({a = (succ 0) , b = (fix (\x: Unit . true )) , c = 1 }.c) , b = (case <r = (if false then true else true) > as Unit of < l = x > => x | < r = y > => y) }.a) }.b) ) (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) ({a = (fix (\x: Nat . 1 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) , c = (pred (let u = 1 in 0)) }.c) ) ({a = true , b = (let u = false in true) }.b)) ) (pred ({a = 1 , b = ({a = false , b = 0 }.a) , c = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.c)) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .a))
(( \f: Unit .((f (fix (\x: Rec X. X . (((\x: Bool .\y: Unit .x) (unfold [ Bool ] (fold [ Unit ] false )) ) ({a = 0 , b = false }.b)) )) ) (( \f: Unit .((f ({a = true , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) )) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Bool .b))
(case <r = ({a = (( \f: Rec X. X .((f 1 ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Nat .b)) , b = (iszero ({a = 0 , b = true , c = 0 }.c)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(case <l = (( \f: Bool .((f (succ 0) ) (((\x: Nat .\y: Rec X. X .x) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = 1 }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (let u = (( \f: Unit .((f (((\x: Bool .\y: Nat .y) (let u = false in false) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) in (case <l = (unfold [ Bool ] (fold [ Bool ] (pred 1) )) > as Bool of < l = x > => x | < r = y > => y)) ) (((\x: Rec X. X .\y: Bool .x) (pred ({a = 1 , b = true }.a)) ) (let u = (if true then true else false) in u)) ) ) (\a: Bool .\b: Bool .a))
(succ (let u = ({a = (let u = true in 0) , b = (let u = 1 in 1) }.b) in u))
(( \f: Bool .((f (let u = (let u = (((\x: Unit .\y: Nat .x) true ) false) in (let u = true in true)) in (case <l = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .y) (let u = (((\x: Unit .\y: Unit .y) false ) false) in (let u = true in true)) ) (case <l = (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) 1) > as Unit of < l = x > => x | < r = y > => y)) )) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (( \f: Bool .((f (let u = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) , b = true }.b) in ({a = true , b = 1 }.a)) ) (iszero (case <l = ({a = 0 , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = (case <l = ({a = (fix (\x: Unit . 0 )) , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) ) (fix (\x: Nat . 0 )) ) ) (\a: Bool .\b: Nat .b)) }.b) }.b)
(pred (((\x: Unit .\y: Unit .y) (if (((\x: Rec X. X .\y: Rec X. X .x) false ) false) then ({a = false , b = 1 }.a) else false) ) (case <l = ({a = 0 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y)))
(iszero (( \f: Rec X. X .((f (succ (pred 0)) ) (fix (\x: Nat . (let u = 1 in u) )) ) ) (\a: Unit .\b: Rec X. X .b)))
(let u = (let u = (unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = true , b = 0 }.b) , b = true }.a) )) in u) in u)
(((\x: Nat .\y: Nat .x) (( \f: Nat .((f (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .x) (pred 0) ) (fix (\x: Rec X. X . true ))) )) ) (let u = ({a = 1 , b = false , c = 0 }.c) in u) ) ) (\a: Bool .\b: Unit .a)) ) (( \f: Unit .((f (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in u) ) (let u = 1 in (((\x: Unit .\y: Bool .y) true ) false)) ) ) (\a: Bool .\b: Unit .b)))
({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = 1 }.b) ) ({a = 1 , b = (((\x: Nat .\y: Rec X. X .x) true ) true) }.b)) in u) , b = (succ ({a = 1 , b = (iszero 0) }.a)) }.b)
({a = (((\x: Nat .\y: Unit .y) ({a = ({a = (let u = 1 in false) , b = (iszero 1) }.b) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) true ) 0) ) (pred 0) ) ) (\a: Nat .\b: Rec X. X .a)) }.a) ) (let u = (if (unfold [ Bool ] (fold [ Nat ] false )) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) else 1) in ({a = ({a = true , b = false }.b) , b = (fix (\x: Rec X. X . 1 )) }.a))) , b = (fix (\x: Bool . ({a = (fix (\x: Rec X. X . false )) , b = (let u = 0 in false) }.b) )) }.b)
(case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (((\x: Rec X. X .\y: Nat .y) false ) false) , b = (((\x: Bool .\y: Unit .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Nat ] false ))) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f (if (iszero (succ (let u = (fix (\x: Nat . 0 )) in (((\x: Bool .\y: Unit .y) true ) 0)))) then (if (iszero ({a = 0 , b = 0 }.b)) then (iszero 1) else (fix (\x: Unit . (case <r = true > as Nat of < l = x > => x | < r = y > => y) ))) else (( \f: Unit .((f (let u = false in u) ) (((\x: Bool .\y: Bool .y) true ) false) ) ) (\a: Rec X. X .\b: Unit .b))) ) (let u = ({a = (( \f: Rec X. X .((f 1 ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (((\x: Unit .\y: Rec X. X .x) false ) true) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 )) }.c) in ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] false )) , b = (let u = false in u) }.b) , b = (let u = 0 in true) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = (((\x: Bool .\y: Rec X. X .x) (( \f: Rec X. X .((f (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .b)) ) (((\x: Unit .\y: Bool .y) (let u = (unfold [ Rec X. X ] (fold [ Unit ] true )) in (((\x: Rec X. X .\y: Unit .x) true ) false)) ) (((\x: Nat .\y: Rec X. X .x) true ) true))) , b = (((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Bool .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) ) (let u = (iszero 0) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )))) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .y) false ) (fix (\x: Unit . true ))) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Unit .\b: Nat .a))) }.a)
(let u = ({a = (((\x: Rec X. X .\y: Bool .x) (((\x: Bool .\y: Nat .y) true ) 1) ) (let u = true in false)) , b = (let u = (fix (\x: Rec X. X . 0 )) in (let u = false in false)) }.a) in u)
({a = (iszero ({a = 1 , b = (((\x: Unit .\y: Unit .x) 1 ) false) }.b)) , b = (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . 1 )) )) ) (let u = ({a = 0 , b = true }.a) in u) ) ) (\a: Nat .\b: Rec X. X .a)) }.a)
(((\x: Bool .\y: Bool .x) (let u = (case <r = ({a = (let u = false in u) , b = ({a = 1 , b = false }.a) }.a) > as Bool of < l = x > => x | < r = y > => y) in u) ) (iszero (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = (iszero 1) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c) ))))
(( \f: Unit .((f (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) )) ) (( \f: Rec X. X .((f (let u = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = 0 , b = true , c =  1 }.b) , c = (let u = true in 0) }.c) in (((\x: Nat .\y: Nat .x) (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = 1 , b = false , c =  1 }.b))) ) (let u = ({a = ({a = 0 , b = true }.a) , b = (if true then false else true) , c = (unfold [ Nat ] (fold [ Nat ] 0 )) }.c) in u) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Nat .a))
(unfold [ Bool ] (fold [ Unit ] (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) (succ (let u = 1 in u)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ))) )) ))
(let u = (let u = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (let u = true in 1) }.b) in ({a = (((\x: Unit .\y: Unit .x) false ) true) , b = (let u = 1 in 0) }.b)) in ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (succ 1) }.b))
(unfold [ Bool ] (fold [ Bool ] (let u = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true) ) (( \f: Nat .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .x) true ) false) ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Unit .\b: Bool .b)) in u) ))
(( \f: Unit .((f (iszero (((\x: Rec X. X .\y: Rec X. X .x) (let u = 0 in 0) ) (((\x: Bool .\y: Nat .x) true ) false))) ) (( \f: Bool .((f (let u = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) )) in (fix (\x: Rec X. X . (if true then true else false) ))) ) ({a = (( \f: Rec X. X .((f (succ 1) ) (( \f: Unit .((f (pred 1) ) ({a = false , b = 0 }.b) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) (fix (\x: Rec X. X . true )) ) ) (\a: Nat .\b: Bool .a)) , c =  ({a = 1 , b = 1 }.b) }.b) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .b))
(let u = (let u = ({a = (((\x: Unit .\y: Bool .x) false ) true) , b = ({a = false , b = ({a = 0 , b = 0 }.b) }.b) }.a) in u) in (succ (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Unit . 1 )))))
(( \f: Rec X. X .((f (let u = (let u = (let u = true in 0) in 0) in (succ 1)) ) (( \f: Rec X. X .((f (let u = 0 in u) ) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , c = 1 }.c) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Bool .\b: Rec X. X .b))
(((\x: Unit .\y: Bool .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = 0 , b = 0 }.b) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false ))) )) ) (let u = (pred ({a = 0 , b = (((\x: Bool .\y: Unit .y) false ) true) }.a)) in (((\x: Unit .\y: Rec X. X .x) (let u = 0 in 1) ) (if true then true else (case <r = false > as Nat of < l = x > => x | < r = y > => y)))))
(((\x: Unit .\y: Nat .y) (((\x: Nat .\y: Unit .y) ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 0 in 1) }.a) ) (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) false ) true) ) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Rec X. X .b))) ) ({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) in u) , b = (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Unit .\y: Rec X. X .x) false ) (if true then true else false))) }.b))
({a = (pred (let u = (let u = true in false) in ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = (let u = 1 in u) }.b))) , b = (iszero (fix (\x: Bool . (pred (((\x: Unit .\y: Bool .y) true ) 0)) ))) , c = (let u = (case <r = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Rec X. X .y) (let u = true in u) ) 0)) }.c)
(let u = (((\x: Unit .\y: Unit .y) (let u = false in u) ) (if (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) then (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) else ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )))) in (unfold [ Rec X. X ] (fold [ Bool ] (let u = (fix (\x: Nat . (((\x: Nat .\y: Bool .y) true ) 1) )) in (fix (\x: Unit . (if false then 1 else 0) ))) )))
(let u = (( \f: Bool .((f ({a = (((\x: Unit .\y: Bool .y) true ) 1) , b = false , c = ({a = true , b = 0 }.b) }.c) ) ({a = (pred ({a = 1 , b = 0 }.b)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Unit .\b: Unit .a)) in (pred (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Bool ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) )) ))))
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (pred 0) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , c = ({a = false , b = 1 }.b) }.c) )) , b = ({a = (((\x: Bool .\y: Unit .y) false ) 1) , b = ({a = true , b = 1 }.a) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = ({a = 0 , b = false , c = 1 }.c) in u) )) }.b) , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (unfold [ Nat ] (fold [ Nat ] (pred 1) )) , b = (fix (\x: Nat . ({a = false , b = 0 }.b) )) }.b) )) }.c)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if ({a = (if (let u = false in false) then (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) else (let u = true in true)) , b = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (if false then false else true) }.a) }.a) then ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = true , b = 1 }.a) )) else (unfold [ Unit ] (fold [ Rec X. X ] (if (((\x: Bool .\y: Bool .x) true ) true) then true else false) ))) ))
(unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .x) (if true then (unfold [ Bool ] (fold [ Rec X. X ] true )) else false) ) (let u = (let u = false in u) in (fix (\x: Nat . false )))) ) (let u = true in u) ) ) (\a: Nat .\b: Bool .a)) ))
({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = (succ 0) in u) )) , b = (fix (\x: Unit . (( \f: Unit .((f (((\x: Bool .\y: Nat .x) 0 ) true) ) 0 ) ) (\a: Bool .\b: Bool .a)) )) }.b)
(((\x: Bool .\y: Bool .y) (iszero (fix (\x: Bool . ({a = (unfold [ Nat ] (fold [ Nat ] 1 )) , b = (let u = true in true) }.a) ))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (( \f: Unit .((f (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Bool .\y: Unit .y) true ) false) ) ) (\a: Rec X. X .\b: Unit .b)) )))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = (let u = 1 in u) , b = (iszero 0) , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.c) )) , b = (( \f: Nat .((f (fix (\x: Nat . 1 )) ) (unfold [ Unit ] (fold [ Bool ] 1 )) ) ) (\a: Nat .\b: Unit .b)) }.b)
(((\x: Rec X. X .\y: Nat .y) ({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] (iszero 1) )) , b = (let u = 0 in true) }.b) , b = (let u = (unfold [ Rec X. X ] (fold [ Nat ] (pred 1) )) in u) }.a) ) (unfold [ Unit ] (fold [ Rec X. X ] ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) 1 ) true) )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .y) (let u = true in u) ) false) )) }.b) )))
({a = ({a = ({a = (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Nat . 0 )) )) ) (unfold [ Rec X. X ] (fold [ Unit ] (pred 1) )) ) ) (\a: Bool .\b: Unit .a)) , b = ({a = ({a = true , b = 0 }.a) , b = true }.b) , c = (fix (\x: Rec X. X . ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 1 )) )) }.c) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Unit .((f (fix (\x: Nat . 0 )) ) ({a = false , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) )) }.b) , b = ({a = ({a = (if true then 1 else 0) , b = (fix (\x: Bool . false )) }.b) , b = (((\x: Nat .\y: Bool .y) ({a = (unfold [ Unit ] (fold [ Bool ] true )) , b = ({a = true , b = false }.b) }.b) ) (if (iszero 0) then 1 else (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)))) }.a) , c = (((\x: Unit .\y: Nat .x) (let u = (succ 0) in ({a = 1 , b = false }.a)) ) (let u = 0 in false)) }.c)
(iszero (pred (let u = 0 in u)))
(let u = (( \f: Rec X. X .((f (let u = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) in u) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) in u)
(fix (\x: Unit . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) )) )) )) ))
({a = (( \f: Nat .((f (case <l = (pred (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) > as Rec X. X of < l = x > => x | < r = y > => y) ) (pred (let u = (let u = 0 in u) in ({a = 0 , b = 0 }.b))) ) ) (\a: Unit .\b: Unit .a)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = (let u = 1 in u) , b = (fix (\x: Nat . false )) , c =  ({a = 0 , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , c = ({a = 0 , b = 1 }.b) }.c) }.b) )) }.b)
({a = ({a = (let u = (succ 0) in (( \f: Nat .((f 0 ) (((\x: Nat .\y: Bool .x) 1 ) false) ) ) (\a: Unit .\b: Rec X. X .b))) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (fix (\x: Bool . (let u = true in 1) )) }.b) , b = ({a = (( \f: Unit .((f ({a = false , b = false }.b) ) ({a = ({a = 0 , b = true }.a) , b = (fix (\x: Unit . false )) }.b) ) ) (\a: Nat .\b: Bool .a)) , b = (((\x: Bool .\y: Bool .y) (case <r = (let u = 0 in true) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Unit .x) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = 0 , b = false }.b))) }.b) }.b)
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) ({a = ({a = true , b = 1 }.a) , b = (((\x: Nat .\y: Rec X. X .x) (if true then false else true) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) }.b) ) (( \f: Unit .((f (((\x: Unit .\y: Unit .x) false ) false) ) ({a = (((\x: Bool .\y: Rec X. X .y) false ) false) , b = ({a = true , b = 0 }.b) }.a) ) ) (\a: Nat .\b: Unit .b))) ) (unfold [ Unit ] (fold [ Bool ] ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) )) , b = (fix (\x: Rec X. X . (fix (\x: Rec X. X . false )) )) }.b) )) ) ) (\a: Bool .\b: Bool .b))
({a = (((\x: Bool .\y: Unit .x) (succ (((\x: Bool .\y: Bool .x) 0 ) true)) ) (let u = (((\x: Unit .\y: Rec X. X .x) (let u = false in 0) ) true) in ({a = 0 , b = false , c =  0 }.b))) , b = (let u = (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f ({a = false , b = true }.b) ) false ) ) (\a: Bool .\b: Bool .b)) )) in (( \f: Bool .((f (iszero 1) ) (((\x: Nat .\y: Unit .y) false ) (let u = true in false)) ) ) (\a: Nat .\b: Unit .b))) }.b)
(((\x: Bool .\y: Unit .x) (case <l = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) )) , b = (let u = false in u) }.a) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (case <r = (fix (\x: Rec X. X . false )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) (let u = false in false) ) (iszero 0)) ) ) (\a: Rec X. X .\b: Bool .a)))
(( \f: Nat .((f (( \f: Bool .((f (iszero (((\x: Rec X. X .\y: Rec X. X .y) true ) ({a = 1 , b = true }.a))) ) (iszero (((\x: Unit .\y: Unit .y) ({a = 1 , b = false }.b) ) (fix (\x: Nat . 1 )))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (unfold [ Unit ] (fold [ Rec X. X ] (let u = ({a = 1 , b = false , c = 0 }.c) in (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b))) )) ) ) (\a: Bool .\b: Nat .b))
(unfold [ Bool ] (fold [ Bool ] (fix (\x: Unit . (fix (\x: Unit . 0 )) )) ))
(let u = ({a = (unfold [ Rec X. X ] (fold [ Unit ] true )) , b = (case <r = (let u = true in u) > as Bool of < l = x > => x | < r = y > => y) }.b) in u)
(((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Nat .x) ({a = (let u = ({a = 0 , b = true }.b) in u) , b = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (succ 1) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true )) , c =  (succ 0) }.b) , c =  ({a = 1 , b = false , c = 0 }.c) }.b) }.b) ) ({a = (let u = true in (iszero 0)) , b = (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in false) }.b)) ) (((\x: Unit .\y: Bool .x) ({a = ({a = (((\x: Nat .\y: Bool .y) false ) 1) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) }.b) , b = ({a = (iszero 1) , b = (let u = 0 in 1) }.a) , c = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 0 , b = false , c =  0 }.b) }.a) }.c) ) (iszero (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)))))
(pred ({a = ({a = (pred (let u = 0 in 0)) , b = (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) 0 ) true) ) (pred 1) ) ) (\a: Bool .\b: Nat .a)) }.b) , b = (( \f: Bool .((f (pred ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) ) (succ (((\x: Nat .\y: Rec X. X .x) 1 ) true)) ) ) (\a: Rec X. X .\b: Unit .b)) }.b))
(let u = (if ({a = (((\x: Unit .\y: Nat .x) (let u = false in false) ) false) , b = (((\x: Nat .\y: Unit .x) false ) ({a = 1 , b = true , c =  0 }.b)) }.b) then (let u = true in false) else (let u = 0 in true)) in (let u = (if (iszero 0) then (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) else (fix (\x: Rec X. X . 0 ))) in (( \f: Unit .((f ({a = (((\x: Unit .\y: Nat .x) 0 ) true) , b = (if true then false else true) , c = 0 }.c) ) (if false then (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) else 1) ) ) (\a: Unit .\b: Nat .b))))
(iszero (let u = (( \f: Bool .((f (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (fix (\x: Unit . false )) ) ) (\a: Unit .\b: Bool .b)) in ({a = (iszero 0) , b = (((\x: Bool .\y: Bool .x) 1 ) false) }.b)))
(if ({a = (let u = (succ ({a = 0 , b = false , c = 0 }.c)) in u) , b = (let u = ({a = false , b = (let u = false in false) }.b) in (((\x: Bool .\y: Unit .y) true ) false)) }.b) then (if (let u = (case <l = (if ({a = 0 , b = false }.b) then 0 else (pred 0)) > as Nat of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Rec X. X .x) (let u = true in true) ) (((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Unit .x) false ) false) ) ({a = 0 , b = false }.b)))) then (let u = ({a = ({a = 1 , b = false , c = (((\x: Nat .\y: Unit .x) 0 ) true) }.c) , b = (((\x: Unit .\y: Bool .x) true ) false) , c = (((\x: Bool .\y: Rec X. X .x) 1 ) true) }.c) in (( \f: Unit .((f (iszero 0) ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Unit .a))) else ({a = (if false then (((\x: Nat .\y: Bool .y) true ) false) else true) , b = (fix (\x: Nat . ({a = 1 , b = 1 }.b) )) }.a)) else (let u = (fix (\x: Rec X. X . ({a = 0 , b = false }.a) )) in ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if false then 0 else 0) )) , b = (((\x: Unit .\y: Unit .x) ({a = (fix (\x: Bool . false )) , b = false }.b) ) ({a = 1 , b = true , c =  0 }.b)) , c =  (let u = 1 in 1) }.b)))
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] 1 )) )) )) ))
(fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .x) (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) )) ) (case <r = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) > as Bool of < l = x > => x | < r = y > => y)) ))
(((\x: Bool .\y: Unit .x) ({a = (let u = ({a = (fix (\x: Nat . true )) , b = ({a = 0 , b = true }.b) }.b) in ({a = ({a = 1 , b = true , c = 0 }.c) , b = true }.a)) , b = (let u = ({a = (iszero 1) , b = (let u = true in 0) }.a) in ({a = (let u = 1 in u) , b = (if false then false else false) }.a)) }.b) ) (let u = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  ({a = (((\x: Unit .\y: Rec X. X .y) true ) false) , b = 1 }.b) }.b) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then false else false) ))))
(fix (\x: Nat . ({a = (if ({a = true , b = 1 }.a) then 1 else ({a = true , b = 0 }.b)) , b = (((\x: Unit .\y: Unit .y) (if false then true else false) ) (fix (\x: Nat . true ))) }.b) ))
({a = (let u = (if (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) then (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = (let u = 1 in u) }.b) ))) in (case <r = (unfold [ Bool ] (fold [ Unit ] ({a = 1 , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , c =  (((\x: Nat .\y: Nat .x) 1 ) true) }.b) )) > as Nat of < l = x > => x | < r = y > => y)) , b = (((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] (if true then true else true) )) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .y) (fix (\x: Bool . false )) ) (iszero (fix (\x: Unit . 1 )))) ))) }.b)
(succ (unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Bool .x) 1 ) true) )) )))
({a = (fix (\x: Nat . (((\x: Nat .\y: Nat .x) (succ 1) ) (iszero 0)) )) , b = (((\x: Unit .\y: Bool .x) (let u = (unfold [ Unit ] (fold [ Unit ] ({a = false , b = 1 }.a) )) in ({a = (let u = false in 0) , b = true }.b)) ) (if (let u = (if (((\x: Unit .\y: Unit .y) false ) true) then (let u = 1 in u) else 1) in ({a = 0 , b = true , c =  0 }.b)) then (fix (\x: Bool . (let u = true in true) )) else (if (if true then false else false) then ({a = true , b = 1 }.a) else (unfold [ Bool ] (fold [ Rec X. X ] false ))))) }.a)
(pred ({a = (case <l = (fix (\x: Rec X. X . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = true }.b) , c = (((\x: Rec X. X .\y: Bool .y) ({a = true , b = false }.b) ) (fix (\x: Nat . 0 ))) }.c))
(if (let u = (((\x: Bool .\y: Unit .x) (unfold [ Nat ] (fold [ Nat ] (if true then true else true) )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = 1 in true) ))) in (((\x: Bool .\y: Nat .y) (case <r = ({a = false , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y))) then (((\x: Unit .\y: Rec X. X .x) (fix (\x: Rec X. X . (succ 1) )) ) ({a = (((\x: Bool .\y: Bool .x) 1 ) true) , b = ({a = 1 , b = false }.b) , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b)) else (let u = (( \f: Bool .((f (let u = false in false) ) (case <r = (((\x: Unit .\y: Rec X. X .y) true ) true) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = 1 in ({a = 1 , b = false }.a))))
(let u = ({a = (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Unit . ({a = false , b = 1 }.a) )) )) ) (unfold [ Unit ] (fold [ Nat ] ({a = false , b = 1 }.a) ))) , b = (( \f: Nat .((f (((\x: Bool .\y: Nat .y) false ) 0) ) (((\x: Unit .\y: Rec X. X .y) false ) ({a = false , b = 0 }.b)) ) ) (\a: Unit .\b: Rec X. X .b)) }.a) in u)
({a = (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Nat .x) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (let u = (((\x: Rec X. X .\y: Bool .y) false ) 0) in (case <r = false > as Nat of < l = x > => x | < r = y > => y))) ) (let u = (((\x: Bool .\y: Rec X. X .x) true ) true) in u)) ) (fix (\x: Bool . (((\x: Unit .\y: Nat .y) true ) false) ))) , b = (iszero (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b)
(( \f: Unit .((f ({a = (((\x: Bool .\y: Rec X. X .x) (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) in ({a = 0 , b = false , c = 1 }.c)) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .a))) , b = ({a = (if true then true else false) , b = ({a = 1 , b = 1 }.b) }.a) }.b) ) (((\x: Rec X. X .\y: Rec X. X .y) (iszero (let u = (((\x: Rec X. X .\y: Bool .x) false ) true) in (succ (let u = 0 in 1)))) ) ({a = ({a = ({a = false , b = true }.b) , b = (let u = 0 in 0) }.b) , b = (unfold [ Unit ] (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] false )) )) , c =  (fix (\x: Nat . (let u = 1 in 0) )) }.b)) ) ) (\a: Bool .\b: Rec X. X .b))
(succ (case <l = (pred ({a = (fix (\x: Unit . 1 )) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .a)) , c = ({a = false , b = 1 }.b) }.c)) > as Rec X. X of < l = x > => x | < r = y > => y))
(((\x: Rec X. X .\y: Bool .y) (iszero ({a = (((\x: Rec X. X .\y: Unit .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 ))) , b = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = true }.b) }.a)) ) ({a = (((\x: Bool .\y: Bool .x) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) (let u = ({a = 1 , b = 0 }.b) in false)) , b = (if ({a = 0 , b = false , c =  1 }.b) then ({a = 0 , b = true , c =  0 }.b) else false) , c =  (case <l = (unfold [ Bool ] (fold [ Unit ] 0 )) > as Nat of < l = x > => x | < r = y > => y) }.b))
(succ (let u = (let u = (( \f: Bool .((f 1 ) ({a = 0 , b = 1 }.b) ) ) (\a: Nat .\b: Bool .a)) in u) in ({a = (fix (\x: Nat . (pred 0) )) , b = (let u = 1 in false) }.a)))
(let u = (((\x: Unit .\y: Unit .y) (iszero (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a))) ) ({a = 0 , b = true }.a)) in u)
(let u = (iszero (let u = ({a = (pred 0) , b = (unfold [ Nat ] (fold [ Unit ] false )) }.a) in u)) in (((\x: Nat .\y: Bool .x) (let u = (fix (\x: Nat . false )) in (if false then false else true)) ) (if ({a = 1 , b = true , c =  0 }.b) then (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] true )) ) false ) ) (\a: Unit .\b: Nat .b)) else (let u = false in ({a = true , b = 0 }.a)))))
(unfold [ Unit ] (fold [ Nat ] (let u = (unfold [ Nat ] (fold [ Unit ] true )) in u) ))
(let u = ({a = (iszero (let u = 0 in u)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) )) }.b) in u)
({a = (case <l = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) in (pred 0)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (if (( \f: Bool .((f true ) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Bool .b)) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) else (if ({a = 1 , b = false }.b) then ({a = 0 , b = false , c = 1 }.c) else (let u = 1 in 0))) )) }.b)
(fix (\x: Rec X. X . (pred (( \f: Bool .((f ({a = (fix (\x: Rec X. X . false )) , b = (((\x: Rec X. X .\y: Bool .x) 1 ) false) }.b) ) (pred 1) ) ) (\a: Bool .\b: Rec X. X .b))) ))
(case <l = (let u = (if (let u = false in u) then ({a = 1 , b = true }.a) else ({a = 1 , b = (((\x: Unit .\y: Unit .y) true ) true) }.a)) in u) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (( \f: Bool .((f ({a = (let u = false in true) , b = ({a = 0 , b = false }.a) }.a) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = true , b = (if false then false else true) }.b) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = (let u = (succ (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) in u) , b = (iszero (let u = 1 in 1)) , c =  (if (case <r = ({a = false , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = false , b = 0 }.b) else (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) in u)) }.b) ) ) (\a: Unit .\b: Nat .a))
(((\x: Nat .\y: Unit .x) (unfold [ Unit ] (fold [ Nat ] (if (let u = (succ 1) in (fix (\x: Rec X. X . true ))) then ({a = true , b = 1 }.a) else ({a = 0 , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) , c =  1 }.b)) )) ) (unfold [ Nat ] (fold [ Bool ] (if (let u = true in u) then (unfold [ Unit ] (fold [ Bool ] false )) else (case <r = (((\x: Unit .\y: Bool .x) true ) true) > as Unit of < l = x > => x | < r = y > => y)) )))
(if (unfold [ Unit ] (fold [ Rec X. X ] (if (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Nat .y) true ) false) ) ({a = false , b = false }.b)) then ({a = (if false then (fix (\x: Nat . 1 )) else 1) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , c =  (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) else (case <r = (iszero 0) > as Nat of < l = x > => x | < r = y > => y)) )) then (let u = (succ (succ 0)) in (pred (pred (pred 1)))) else (let u = (let u = ({a = (let u = true in 1) , b = false , c =  1 }.b) in u) in (let u = (((\x: Nat .\y: Bool .x) false ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false ))) in (if false then 0 else 1))))
(let u = (if (let u = (((\x: Rec X. X .\y: Bool .y) false ) (fix (\x: Bool . 0 ))) in (let u = false in true)) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (if false then 0 else 1) )) else (case <l = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)) in (((\x: Nat .\y: Rec X. X .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] false )) )) ) ({a = (let u = true in 1) , b = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) }.b)))
({a = (unfold [ Unit ] (fold [ Bool ] ({a = ({a = 1 , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) , c =  1 }.b) , b = ({a = ({a = true , b = 0 }.b) , b = (let u = false in true) , c = ({a = 1 , b = true }.a) }.c) }.b) )) , b = (pred (let u = (if (fix (\x: Nat . false )) then false else (((\x: Unit .\y: Bool .x) true ) true)) in ({a = (pred 0) , b = true , c = (let u = 1 in u) }.c))) }.b)
(let u = (( \f: Nat .((f ({a = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (case <r = (unfold [ Bool ] (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y) }.b) ) (case <r = (fix (\x: Unit . true )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) in u)
(let u = (((\x: Nat .\y: Nat .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (succ (fix (\x: Rec X. X . 1 ))) )) ) (let u = ({a = false , b = 0 }.a) in (((\x: Rec X. X .\y: Rec X. X .x) (if false then false else false) ) false))) in u)
(let u = (((\x: Rec X. X .\y: Bool .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = true in true) )) ) (let u = (succ (let u = 1 in 1)) in ({a = false , b = true }.b))) in (if (let u = (fix (\x: Unit . (unfold [ Nat ] (fold [ Bool ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) )) )) in u) then (pred ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) else ({a = ({a = ({a = 1 , b = (((\x: Bool .\y: Bool .x) true ) true) , c = (((\x: Nat .\y: Bool .y) true ) 1) }.c) , b = (let u = 1 in false) }.a) , b = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) in u) }.b)))
(unfold [ Bool ] (fold [ Unit ] (let u = (let u = (case <l = (let u = 1 in u) > as Nat of < l = x > => x | < r = y > => y) in (succ 0)) in u) ))
({a = (fix (\x: Rec X. X . (let u = (let u = 0 in 1) in u) )) , b = (case <r = (unfold [ Bool ] (fold [ Bool ] (iszero 1) )) > as Bool of < l = x > => x | < r = y > => y) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if (if false then true else false) then (let u = 1 in 1) else (( \f: Unit .((f ({a = 0 , b = 0 }.b) ) (((\x: Bool .\y: Unit .x) 0 ) false) ) ) (\a: Unit .\b: Nat .a))) )) }.b)
(( \f: Unit .((f (( \f: Nat .((f (( \f: Bool .((f ({a = true , b = true }.b) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Nat .\b: Bool .a)) ) (if (fix (\x: Bool . false )) then (if false then (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .a)) else (((\x: Rec X. X .\y: Unit .y) false ) true)) else (fix (\x: Bool . true ))) ) ) (\a: Bool .\b: Bool .b)) ) (( \f: Rec X. X .((f ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = ({a = (let u = false in u) , b = (( \f: Unit .((f ({a = true , b = 1 }.a) ) false ) ) (\a: Bool .\b: Rec X. X .a)) }.b) }.b) ) (if (((\x: Bool .\y: Bool .y) true ) true) then (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .b)) else ({a = false , b = false }.b)) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .a))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Unit .((f (succ 0) ) (( \f: Rec X. X .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Rec X. X .b)) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] 1 )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f (let u = (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] false )) )) in (if ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) then true else ({a = false , b = false }.b))) ) (let u = (iszero 0) in u) ) ) (\a: Unit .\b: Bool .a)) ) (case <r = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = false }.b) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (case <l = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
({a = (( \f: Bool .((f (let u = (((\x: Bool .\y: Bool .y) true ) 0) in u) ) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Unit .\y: Unit .y) (unfold [ Bool ] (fold [ Unit ] false )) ) (fix (\x: Bool . 1 ))) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (( \f: Bool .((f (iszero (fix (\x: Unit . ({a = (fix (\x: Nat . 0 )) , b = false , c = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.c) ))) ) (((\x: Rec X. X .\y: Unit .y) ({a = (iszero 0) , b = false }.b) ) ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = ({a = true , b = true }.b) , c =  (pred 0) }.b)) ) ) (\a: Nat .\b: Nat .a)) }.b)
(if ({a = (let u = ({a = ({a = true , b = 0 }.a) , b = (unfold [ Unit ] (fold [ Rec X. X ] (pred 0) )) }.a) in (iszero 1)) , b = (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in (let u = (let u = 1 in false) in 1)) }.a) then (((\x: Nat .\y: Unit .x) (let u = (((\x: Rec X. X .\y: Unit .x) false ) false) in (if (((\x: Nat .\y: Unit .x) false ) true) then (unfold [ Nat ] (fold [ Bool ] (if true then false else false) )) else (let u = true in (let u = true in true)))) ) (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = ({a = (fix (\x: Rec X. X . 0 )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) in (unfold [ Bool ] (fold [ Unit ] (let u = 0 in true) ))) )))
({a = (fix (\x: Bool . ({a = (((\x: Bool .\y: Unit .x) 1 ) false) , b = ({a = true , b = 1 }.a) , c = (((\x: Unit .\y: Nat .x) 0 ) false) }.c) )) , b = (let u = (( \f: Bool .((f ({a = false , b = 0 }.a) ) true ) ) (\a: Nat .\b: Rec X. X .a)) in u) }.a)
(( \f: Nat .((f (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Bool ] (let u = 1 in (let u = false in false)) )) ) ({a = ({a = true , b = 0 }.b) , b = ({a = true , b = false }.b) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = (let u = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .a)) in true) , b = ({a = ({a = 0 , b = 1 }.b) , b = true , c =  0 }.b) }.b) ) ) (\a: Nat .\b: Nat .a))
(((\x: Nat .\y: Nat .y) ({a = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in (case <r = ({a = 0 , b = false , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .a)) ) ({a = false , b = (pred 0) }.a) ) ) (\a: Nat .\b: Unit .b)) }.b) ) ({a = (let u = (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in ({a = false , b = (((\x: Nat .\y: Nat .x) 1 ) true) }.a)) , b = (((\x: Nat .\y: Rec X. X .x) ({a = 1 , b = true }.a) ) (iszero (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)))) }.b))
(( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f (if false then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else (pred 1)) ) ({a = 1 , b = 1 }.b) ) ) (\a: Nat .\b: Bool .b)) )) ) (if ({a = (fix (\x: Unit . false )) , b = ({a = 1 , b = false }.a) }.a) then (( \f: Unit .((f ({a = 1 , b = false }.a) ) ({a = true , b = 1 }.b) ) ) (\a: Unit .\b: Bool .b)) else (if (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) then 0 else (let u = true in 0))) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (let u = 1 in u) in (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = 0 }.b) ))) }.b) in u)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (succ (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))) ))
(((\x: Nat .\y: Rec X. X .y) (let u = (case <r = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) ({a = (let u = (( \f: Nat .((f (if false then true else true) ) (if false then false else false) ) ) (\a: Rec X. X .\b: Bool .a)) in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Bool ] true )) ) (if false then 0 else 1)) }.b))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (iszero ({a = 1 , b = false , c = 0 }.c)) in (case <l = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) , b = (fix (\x: Rec X. X . ({a = 0 , b = true , c =  0 }.b) )) }.a) > as Nat of < l = x > => x | < r = y > => y)) ))
(( \f: Bool .((f (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] true )) )) in (unfold [ Nat ] (fold [ Nat ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ))) ) ({a = (((\x: Unit .\y: Bool .y) ({a = true , b = 1 }.a) ) (let u = false in u)) , b = (succ (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) true ) 0) ))) }.b) ) ) (\a: Nat .\b: Unit .a))
({a = ({a = (let u = true in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 ))) , b = (iszero (((\x: Bool .\y: Unit .y) false ) 0)) , c = ({a = (let u = 0 in 0) , b = (let u = 0 in false) , c = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) in u) }.c) }.c) , b = (((\x: Nat .\y: Nat .x) (( \f: Unit .((f (let u = false in (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b))) ) (pred 0) ) ) (\a: Unit .\b: Nat .b)) ) (let u = (((\x: Bool .\y: Unit .x) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) (unfold [ Unit ] (fold [ Bool ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) ))) in ({a = ({a = false , b = true }.b) , b = ({a = true , b = 0 }.b) }.a))) }.b)
(((\x: Nat .\y: Rec X. X .y) (let u = (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (pred 0) ))) in (( \f: Unit .((f (let u = false in u) ) (((\x: Rec X. X .\y: Bool .x) false ) false) ) ) (\a: Bool .\b: Rec X. X .b))) ) (( \f: Rec X. X .((f (let u = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) in ({a = 0 , b = false }.a)) ) ({a = (succ 1) , b = false , c = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) }.c) ) ) (\a: Unit .\b: Nat .b)))
(((\x: Rec X. X .\y: Bool .x) ({a = ({a = (succ 1) , b = ({a = false , b = false }.b) }.a) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) , b = (pred 0) }.a) }.a) ) ({a = ({a = (( \f: Nat .((f ({a = 0 , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (unfold [ Unit ] (fold [ Unit ] false )) }.b) , b = ({a = true , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) }.b))
(if (fix (\x: Unit . (( \f: Unit .((f (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) ) (iszero 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = 0 in true) ) ) (\a: Bool .\b: Bool .a)) )) then (iszero ({a = (succ 0) , b = (let u = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) in 1) }.b)) else (iszero (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Nat .x) ({a = 0 , b = false , c = 0 }.c) ) (fix (\x: Rec X. X . false ))) ))))
(( \f: Nat .((f (((\x: Bool .\y: Nat .y) (if ({a = (let u = true in u) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) }.a) then (case <r = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) else (fix (\x: Unit . true ))) ) (let u = ({a = 1 , b = (let u = 1 in u) }.b) in (case <r = true > as Unit of < l = x > => x | < r = y > => y))) ) ({a = (pred 1) , b = (( \f: Nat .((f ({a = 1 , b = ({a = true , b = 1 }.a) }.b) ) ({a = false , b = false }.b) ) ) (\a: Unit .\b: Bool .b)) , c =  (pred (((\x: Rec X. X .\y: Nat .y) true ) 1)) }.b) ) ) (\a: Nat .\b: Rec X. X .a))
(fix (\x: Bool . ({a = ({a = (fix (\x: Bool . 0 )) , b = (fix (\x: Rec X. X . 0 )) }.b) , b = (let u = ({a = ({a = true , b = false }.b) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.a) in u) , c = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.c) ))
({a = (let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = true , c = 1 }.c) )) , b = (if (let u = false in false) then (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) else false) , c = ({a = 1 , b = false }.a) }.c) in (pred ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) )))) , b = (let u = (((\x: Rec X. X .\y: Bool .y) (iszero 0) ) (pred 1)) in (fix (\x: Rec X. X . (let u = false in true) ))) , c = ({a = (pred (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = false , c = 1 }.c) ))) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) false ) false) )) }.a) }.c)
(let u = (case <r = (unfold [ Bool ] (fold [ Nat ] (let u = (let u = (iszero 1) in u) in (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b))) )) > as Rec X. X of < l = x > => x | < r = y > => y) in (case <r = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Nat .b)) }.b) > as Nat of < l = x > => x | < r = y > => y))
(let u = (( \f: Unit .((f (( \f: Nat .((f ({a = (pred (pred 0)) , b = (iszero 0) , c =  ({a = 1 , b = true , c = 0 }.c) }.b) ) (((\x: Unit .\y: Nat .x) false ) (iszero 1)) ) ) (\a: Bool .\b: Bool .a)) ) (fix (\x: Bool . (fix (\x: Nat . (case <r = ({a = true , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) )) ) ) (\a: Bool .\b: Bool .b)) in (( \f: Rec X. X .((f ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Nat .x) false ) true) , c =  ({a = true , b = 1 }.b) }.b) ) (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)))
(((\x: Rec X. X .\y: Unit .x) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .x) true ) true) )) in u) ) (((\x: Bool .\y: Rec X. X .x) (fix (\x: Unit . (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) )) ) ({a = (((\x: Bool .\y: Bool .x) 0 ) false) , b = true }.b)))
(iszero (case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = 1 , b = 1 }.b) , b = false , c = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.c) )) > as Rec X. X of < l = x > => x | < r = y > => y))
(fix (\x: Bool . (if (( \f: Nat .((f (let u = (fix (\x: Unit . false )) in true) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) ) (\a: Bool .\b: Unit .b)) then (if (unfold [ Bool ] (fold [ Bool ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) then ({a = (if ({a = false , b = true }.b) then 0 else (pred 1)) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) else (( \f: Nat .((f (let u = 1 in ({a = 0 , b = true , c = 1 }.c)) ) ({a = true , b = 0 }.b) ) ) (\a: Unit .\b: Bool .a))) else (let u = (unfold [ Nat ] (fold [ Nat ] (((\x: Unit .\y: Bool .x) ({a = 1 , b = true , c = 1 }.c) ) ({a = true , b = false }.b)) )) in (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (pred 0) ) ) (\a: Rec X. X .\b: Bool .a)))) ))
(((\x: Nat .\y: Unit .y) (let u = ({a = ({a = false , b = 0 }.a) , b = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) }.a) in u) ) ({a = (if (( \f: Unit .((f (if true then true else false) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) ) ) (\a: Nat .\b: Rec X. X .a)) then (let u = (((\x: Unit .\y: Bool .x) 0 ) true) in u) else (if true then 1 else 0)) , b = ({a = (let u = 0 in u) , b = ({a = true , b = (((\x: Rec X. X .\y: Nat .y) true ) false) }.b) }.b) }.b))
(fix (\x: Nat . (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Bool ] 1 )) )) )) ))
(((\x: Unit .\y: Unit .x) ({a = (let u = 1 in 1) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] true )) , b = false }.b) }.b) ) (((\x: Nat .\y: Nat .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (if false then (if false then false else true) else ({a = true , b = 1 }.a)) )) ) (((\x: Rec X. X .\y: Nat .y) (let u = ({a = 0 , b = false }.b) in u) ) ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) }.b))))
(iszero ({a = (( \f: Rec X. X .((f (( \f: Nat .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) ) (unfold [ Nat ] (fold [ Unit ] 1 )) ) ) (\a: Nat .\b: Bool .b)) ) (( \f: Nat .((f (let u = true in 1) ) (unfold [ Bool ] (fold [ Unit ] (succ 0) )) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Rec X. X .((f (if (fix (\x: Rec X. X . false )) then true else (if false then true else false)) ) (fix (\x: Unit . (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .b)) )) ) ) (\a: Bool .\b: Rec X. X .b)) , c = ({a = (((\x: Bool .\y: Rec X. X .x) false ) false) , b = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = (((\x: Bool .\y: Rec X. X .y) (let u = true in u) ) 0) }.b) }.b) }.c))
(let u = (( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] (let u = (((\x: Rec X. X .\y: Nat .y) false ) (fix (\x: Rec X. X . 0 ))) in u) )) ) ({a = (( \f: Nat .((f ({a = 1 , b = true , c = 1 }.c) ) ({a = 1 , b = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .b)) }.a) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (((\x: Nat .\y: Unit .y) (iszero 0) ) (iszero 0)) }.a) ) ) (\a: Nat .\b: Bool .a)) in (( \f: Unit .((f ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) (succ 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) ) (if (unfold [ Nat ] (fold [ Unit ] (if false then true else true) )) then (((\x: Nat .\y: Rec X. X .y) true ) 0) else (((\x: Bool .\y: Nat .y) true ) 1)) ) ) (\a: Nat .\b: Bool .b)))
(let u = ({a = (let u = true in false) , b = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (iszero 0) }.b) }.b) in (let u = (let u = (unfold [ Bool ] (fold [ Rec X. X ] false )) in u) in u))
(let u = (iszero ({a = true , b = (let u = false in 1) }.b)) in u)
({a = (fix (\x: Bool . ({a = 1 , b = true , c = 0 }.c) )) , b = ({a = (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .b)) ) true) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = (pred (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a))) in (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .a))) , c = (((\x: Rec X. X .\y: Rec X. X .x) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) , c = (let u = 1 in u) }.c) ) (unfold [ Nat ] (fold [ Unit ] (fix (\x: Bool . false )) ))) }.c) }.b)
(unfold [ Nat ] (fold [ Nat ] (((\x: Nat .\y: Nat .x) (( \f: Unit .((f ({a = ({a = (iszero 0) , b = 0 }.a) , b = ({a = true , b = 1 }.a) }.b) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) (((\x: Nat .\y: Nat .y) ({a = true , b = (pred 0) }.a) ) (case <r = ({a = 1 , b = false }.b) > as Unit of < l = x > => x | < r = y > => y))) ))
({a = (let u = (let u = ({a = true , b = 0 }.b) in (iszero ({a = 1 , b = true }.a))) in (unfold [ Unit ] (fold [ Unit ] ({a = (succ 1) , b = false }.a) ))) , b = (( \f: Bool .((f (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if false then 1 else 1) ))) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (iszero 0) )) ) ) (\a: Rec X. X .\b: Nat .b)) , c = (((\x: Bool .\y: Rec X. X .x) (let u = (fix (\x: Unit . 0 )) in (unfold [ Bool ] (fold [ Bool ] (let u = 1 in 1) ))) ) ({a = (let u = false in ({a = 1 , b = false , c =  0 }.b)) , b = (iszero (fix (\x: Unit . 1 ))) }.b)) }.c)
(pred ({a = (let u = (fix (\x: Nat . 1 )) in u) , b = ({a = (fix (\x: Nat . 0 )) , b = (unfold [ Bool ] (fold [ Bool ] true )) }.b) , c = (( \f: Nat .((f 0 ) (if false then 0 else 0) ) ) (\a: Unit .\b: Nat .b)) }.c))
(if (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (iszero (pred 0)) else ({a = (if true then 0 else 1) , b = ({a = false , b = (let u = false in 1) }.a) }.b)) then (fix (\x: Nat . (case <r = (iszero (fix (\x: Bool . 0 ))) > as Bool of < l = x > => x | < r = y > => y) )) else (if (let u = (let u = true in ({a = 1 , b = true }.b)) in u) then (( \f: Nat .((f (fix (\x: Bool . (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) )) ) (((\x: Bool .\y: Nat .x) ({a = true , b = 0 }.a) ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Bool .\b: Bool .a)) else (( \f: Bool .((f ({a = 0 , b = true , c =  1 }.b) ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Unit .a))))
(if ({a = ({a = (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Unit .x) false ) true) ) (iszero 0)) , b = ({a = 1 , b = 1 }.b) }.a) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) (let u = 0 in false) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Bool .b))) )) }.b) then ({a = (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Bool .x) 0 ) true) ) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) , b = false , c =  (pred 0) }.b)) , b = (((\x: Rec X. X .\y: Nat .x) true ) true) , c = (if ({a = false , b = 1 }.a) then ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = 0 , b = false , c = 0 }.c) )) else (let u = (iszero 1) in (((\x: Rec X. X .\y: Nat .y) true ) 0))) }.c) else (let u = (if false then (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) else (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) in u))
(( \f: Unit .((f (((\x: Nat .\y: Unit .y) (let u = (let u = (let u = 1 in 1) in false) in u) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = 0 , b = true }.a) ))) ) (succ (if (let u = (((\x: Unit .\y: Unit .y) false ) true) in u) then (((\x: Nat .\y: Rec X. X .x) (if true then 1 else 0) ) false) else (let u = 0 in (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b))))) ) ) (\a: Unit .\b: Unit .a))
(((\x: Bool .\y: Nat .x) (case <l = (let u = (( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] true )) ) false ) ) (\a: Rec X. X .\b: Bool .a)) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a))) > as Bool of < l = x > => x | < r = y > => y) ) (iszero ({a = 1 , b = (let u = true in u) }.a)))
({a = (case <l = (( \f: Rec X. X .((f (( \f: Rec X. X .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .y) false ) 1) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) 1) ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Bool .\y: Nat .y) ({a = false , b = ({a = true , b = true }.b) }.b) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .a))) , b = (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .b)) in (let u = false in 0)) }.a) , c = (( \f: Rec X. X .((f ({a = (if (unfold [ Nat ] (fold [ Bool ] false )) then 1 else 1) , b = (((\x: Rec X. X .\y: Nat .x) true ) false) }.a) ) ({a = true , b = 1 }.b) ) ) (\a: Unit .\b: Unit .a)) }.c)
(succ (let u = ({a = true , b = 1 }.b) in u))
(((\x: Rec X. X .\y: Unit .y) (iszero (if (fix (\x: Unit . false )) then (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) else (if true then 0 else 0))) ) (pred (case <l = (let u = 0 in 1) > as Rec X. X of < l = x > => x | < r = y > => y)))
(((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Unit .y) (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] true )) )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) ) (unfold [ Unit ] (fold [ Rec X. X ] (succ 1) ))) ) ({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .y) false ) 0) )) , b = (let u = false in u) }.b) , b = (((\x: Unit .\y: Bool .y) true ) true) }.b))
(unfold [ Bool ] (fold [ Rec X. X ] (( \f: Bool .((f (let u = true in (pred 1)) ) (((\x: Rec X. X .\y: Unit .x) (fix (\x: Rec X. X . 0 )) ) (iszero 0)) ) ) (\a: Unit .\b: Bool .a)) ))
(let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Unit . (if (((\x: Nat .\y: Nat .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) ) (let u = 1 in false)) then (succ 0) else (let u = 0 in u)) )) )) in (let u = (case <r = (((\x: Nat .\y: Nat .y) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) in u))
(let u = ({a = (fix (\x: Nat . ({a = 0 , b = true }.b) )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = (let u = true in 0) in (if true then true else true)) )) }.b) in ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (if (if true then false else true) then ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = 1 }.b) )) else (let u = true in 1)) )) , b = (let u = ({a = false , b = false }.b) in u) , c =  ({a = (let u = false in false) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b) }.b))
(let u = (fix (\x: Rec X. X . ({a = (iszero (let u = true in 1)) , b = (if (if ({a = true , b = true }.b) then (let u = 0 in false) else true) then (unfold [ Rec X. X ] (fold [ Bool ] false )) else (iszero 1)) }.b) )) in (iszero ({a = (succ 0) , b = (let u = true in u) }.a)))
({a = ({a = (iszero 0) , b = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = false , c = 0 }.c) }.b) , b = ({a = (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Rec X. X .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (iszero 0) )) ) ({a = false , b = true }.b)) }.b) , c = (((\x: Nat .\y: Rec X. X .y) (let u = (let u = true in u) in u) ) (fix (\x: Unit . 0 ))) }.c)
((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = (pred (let u = (succ 1) in (let u = 1 in u))) > as Nat of < l = x > => x | < r = y > => y) ))
(fix (\x: Unit . (if (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Bool ] (let u = 0 in true) )) )) > as Nat of < l = x > => x | < r = y > => y) then (let u = (fix (\x: Nat . (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) )) in (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) (( \f: Unit .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) (pred 1) ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Unit .\b: Rec X. X .a))) else ({a = (let u = ({a = 0 , b = 0 }.b) in false) , b = ({a = 1 , b = false , c = 1 }.c) }.b)) ))
(iszero (( \f: Rec X. X .((f (if (let u = (let u = true in u) in u) then (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) else (unfold [ Unit ] (fold [ Nat ] 0 ))) ) (let u = (let u = (unfold [ Nat ] (fold [ Rec X. X ] true )) in (unfold [ Bool ] (fold [ Unit ] 1 ))) in ({a = 0 , b = true , c = (pred 1) }.c)) ) ) (\a: Nat .\b: Nat .b)))
(( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] (iszero ({a = 1 , b = false , c = 1 }.c)) )) ) (((\x: Rec X. X .\y: Unit .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = (let u = 1 in true) in true) )) ) ({a = ({a = false , b = false }.b) , b = (((\x: Bool .\y: Rec X. X .x) true ) (let u = 0 in false)) }.b)) ) ) (\a: Unit .\b: Unit .b))
(let u = (( \f: Bool .((f (let u = (let u = true in true) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a))) ) ({a = (let u = 1 in u) , b = (((\x: Rec X. X .\y: Unit .x) (let u = true in false) ) (iszero 1)) , c = ({a = 1 , b = (fix (\x: Rec X. X . false )) }.a) }.c) ) ) (\a: Nat .\b: Unit .a)) in (case <l = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) (fix (\x: Unit . 0 ))) }.b) > as Nat of < l = x > => x | < r = y > => y))
({a = (unfold [ Bool ] (fold [ Bool ] (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) then ({a = 1 , b = false }.a) else (if true then 0 else 0)) )) , b = (let u = (((\x: Unit .\y: Bool .x) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .b))) in u) , c =  ({a = (let u = (((\x: Nat .\y: Unit .y) false ) false) in u) , b = (let u = ({a = 0 , b = true , c = 1 }.c) in u) }.b) }.b)
(let u = (((\x: Rec X. X .\y: Bool .y) (case <r = (iszero 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 0 in u)) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = 1 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.c) , b = (((\x: Rec X. X .\y: Unit .y) false ) 0) }.b) )) )))
(let u = (iszero (let u = ({a = false , b = 1 }.a) in ({a = (((\x: Unit .\y: Unit .x) 0 ) false) , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) }.a))) in ({a = ({a = (iszero (( \f: Bool .((f 1 ) (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Bool .b))) , b = ({a = 1 , b = 0 }.b) }.b) , b = (( \f: Nat .((f (if false then true else false) ) ({a = 1 , b = (unfold [ Nat ] (fold [ Unit ] true )) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) }.a))
({a = ({a = ({a = 0 , b = (if true then true else true) , c = 1 }.c) , b = ({a = (let u = false in u) , b = (unfold [ Nat ] (fold [ Nat ] 0 )) }.a) }.b) , b = (if (iszero 0) then (pred (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) else (pred ({a = 0 , b = false , c = 1 }.c))) }.a)
(( \f: Unit .((f (succ (( \f: Rec X. X .((f (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Nat ] (let u = true in 1) )) ) ) (\a: Nat .\b: Unit .b))) ) (((\x: Bool .\y: Rec X. X .x) (let u = ({a = true , b = 1 }.a) in (((\x: Unit .\y: Bool .y) true ) 1)) ) (fix (\x: Nat . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Rec X. X .y) false ) false) )) ))) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (case <r = (fix (\x: Nat . (iszero 0) )) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Unit .y) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .a)) ) (fix (\x: Rec X. X . 1 ))) else ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Bool .y) true ) 0) ))) in (let u = 1 in 1)) }.a)
(let u = (((\x: Unit .\y: Bool .x) (( \f: Rec X. X .((f ({a = false , b = false }.b) ) (fix (\x: Nat . false )) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = 1 , b = (if false then true else false) , c =  (pred 0) }.b)) in u)
(( \f: Nat .((f (unfold [ Bool ] (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] (let u = false in u) )) )) ) (((\x: Bool .\y: Bool .y) (iszero ({a = ({a = (let u = 0 in u) , b = (if false then 1 else 0) }.b) , b = (((\x: Nat .\y: Nat .y) true ) false) , c = (if false then 1 else 0) }.c)) ) (let u = (iszero (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) in u)) ) ) (\a: Nat .\b: Nat .b))
({a = (if (unfold [ Nat ] (fold [ Unit ] false )) then (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Bool .y) false ) false) ) (if true then true else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )))) else (( \f: Bool .((f (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ) ({a = false , b = (let u = 0 in false) }.b) ) ) (\a: Unit .\b: Rec X. X .b))) , b = (( \f: Rec X. X .((f (let u = (succ 1) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ({a = false , b = true }.b) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) ))) ) (case <r = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)
(( \f: Unit .((f (let u = (((\x: Bool .\y: Rec X. X .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .x) true ) true)) in u) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) (( \f: Unit .((f true ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = true in false)) ) (( \f: Nat .((f (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Unit .a)) in u) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .a))
(if (( \f: Rec X. X .((f ({a = (let u = 1 in false) , b = (((\x: Unit .\y: Nat .x) 1 ) false) }.a) ) (let u = (( \f: Bool .((f false ) ({a = 1 , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b)) in u) ) ) (\a: Bool .\b: Nat .b)) then (let u = (((\x: Nat .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) ) (let u = 1 in 1)) in (iszero (((\x: Bool .\y: Unit .x) 0 ) false))) else ({a = (unfold [ Bool ] (fold [ Nat ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .y) true ) true) )) )) , b = ({a = (iszero 1) , b = (fix (\x: Bool . 1 )) }.a) }.b))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (pred ({a = ({a = 0 , b = 1 }.b) , b = true , c = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.c)) in (if (fix (\x: Rec X. X . (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) then (unfold [ Bool ] (fold [ Bool ] (((\x: Nat .\y: Nat .y) false ) true) )) else (( \f: Nat .((f (if false then false else false) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)))) ))
({a = (fix (\x: Rec X. X . (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) ({a = 0 , b = false }.a) ) ) (\a: Bool .\b: Rec X. X .a)) ) (((\x: Unit .\y: Unit .y) ({a = 1 , b = false , c =  1 }.b) ) (pred 1)) ) ) (\a: Nat .\b: Unit .a)) )) , b = (((\x: Nat .\y: Unit .x) (case <l = (if true then 1 else 0) > as Unit of < l = x > => x | < r = y > => y) ) (iszero (((\x: Rec X. X .\y: Bool .y) false ) 1))) }.b)
(if (fix (\x: Rec X. X . (fix (\x: Unit . ({a = 0 , b = true , c =  0 }.b) )) )) then (case <r = (((\x: Unit .\y: Bool .x) ({a = 1 , b = false }.b) ) (if false then (let u = false in true) else false)) > as Nat of < l = x > => x | < r = y > => y) else (if (let u = (unfold [ Unit ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] false )) )) in (case <r = ({a = true , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y)) then (if (let u = false in u) then (( \f: Bool .((f false ) (let u = 0 in true) ) ) (\a: Rec X. X .\b: Unit .a)) else (let u = (if true then true else (((\x: Nat .\y: Unit .x) false ) true)) in u)) else (let u = (iszero (pred 1)) in u)))
(((\x: Bool .\y: Nat .x) (if (let u = (((\x: Unit .\y: Nat .y) false ) false) in (((\x: Rec X. X .\y: Rec X. X .x) false ) false)) then (case <r = (iszero 0) > as Nat of < l = x > => x | < r = y > => y) else (let u = (if true then false else false) in true)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) (fix (\x: Nat . false )) ) (((\x: Nat .\y: Rec X. X .x) true ) true)) )))
(unfold [ Nat ] (fold [ Bool ] (pred (let u = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = 0 }.a) in (let u = (succ 0) in u))) ))
({a = (fix (\x: Rec X. X . ({a = (( \f: Bool .((f (succ 0) ) (pred 1) ) ) (\a: Unit .\b: Nat .b)) , b = (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = false , c =  1 }.b) )) , c =  (fix (\x: Unit . ({a = 0 , b = true }.a) )) }.b) )) , b = (let u = ({a = (if false then true else false) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = false , c = 0 }.c) )) }.b) in ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = ({a = true , b = 1 }.a) , c = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.c)) }.b)
(( \f: Nat .((f ({a = (((\x: Nat .\y: Nat .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) (fix (\x: Rec X. X . false ))) , b = (fix (\x: Bool . ({a = true , b = 0 }.b) )) }.b) ) (let u = (if (let u = (( \f: Unit .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Rec X. X .b)) in u) then ({a = ({a = 0 , b = false , c =  0 }.b) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) else (((\x: Nat .\y: Bool .x) ({a = 1 , b = true }.a) ) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .a)))) in u) ) ) (\a: Nat .\b: Rec X. X .b))
(if (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) (if false then true else true) ) (((\x: Rec X. X .\y: Nat .y) false ) true)) ) (if (((\x: Rec X. X .\y: Rec X. X .x) ({a = 0 , b = true , c =  1 }.b) ) (iszero 1)) then ({a = 1 , b = true }.b) else (if false then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) else ({a = true , b = 1 }.a))) ) ) (\a: Bool .\b: Nat .a)) then ({a = (pred (if false then 0 else 0)) , b = (( \f: Unit .((f (( \f: Rec X. X .((f (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .b)) ) true ) ) (\a: Unit .\b: Nat .a)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .b)) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  ({a = (let u = (iszero 0) in 0) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) ({a = 1 , b = false , c =  0 }.b)) }.a) }.b) else (( \f: Bool .((f (let u = (((\x: Rec X. X .\y: Unit .x) (((\x: Bool .\y: Unit .y) true ) 1) ) (((\x: Bool .\y: Nat .x) true ) false)) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true ))) ) (((\x: Bool .\y: Nat .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) ) ({a = (succ 0) , b = ({a = 1 , b = true }.b) }.b)) ) ) (\a: Unit .\b: Bool .a)))
(let u = (case <l = (succ (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) > as Unit of < l = x > => x | < r = y > => y) in (pred ({a = 1 , b = 1 }.b)))
(iszero (unfold [ Bool ] (fold [ Bool ] (fix (\x: Bool . ({a = 0 , b = 1 }.b) )) )))
(((\x: Bool .\y: Rec X. X .y) (iszero (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) 1 ) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b))) ) (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) 0) ) ) (\a: Nat .\b: Unit .a))) ) (((\x: Unit .\y: Unit .x) ({a = ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) , b = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Unit .b)) , c = ({a = 1 , b = false }.a) }.c) ) (iszero ({a = false , b = 0 }.b))))
(fix (\x: Rec X. X . (let u = ({a = ({a = 1 , b = 0 }.b) , b = ({a = 0 , b = true }.b) , c =  0 }.b) in ({a = (fix (\x: Unit . 1 )) , b = (let u = false in u) }.b)) ))
({a = (((\x: Rec X. X .\y: Bool .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = true , c =  1 }.b) )) ) (let u = ({a = 0 , b = false , c =  1 }.b) in (let u = (((\x: Nat .\y: Nat .x) true ) true) in u))) , b = ({a = ({a = (let u = 0 in 0) , b = (((\x: Rec X. X .\y: Unit .y) (let u = 1 in true) ) (iszero 1)) , c = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) in u) }.c) , b = ({a = (succ 0) , b = (if false then (fix (\x: Unit . 0 )) else (pred 1)) }.b) }.b) }.b)
(( \f: Bool .((f ({a = ({a = 1 , b = (let u = true in false) }.b) , b = (((\x: Unit .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Unit ] false )) ) 1) }.a) ) (fix (\x: Bool . (unfold [ Unit ] (fold [ Nat ] (if (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .b)) then (let u = true in true) else ({a = 0 , b = false , c =  0 }.b)) )) )) ) ) (\a: Rec X. X .\b: Unit .a))
(succ (((\x: Bool .\y: Rec X. X .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (if true then 0 else 0) )) ) (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .y) true ) false) ))))
({a = (fix (\x: Nat . (let u = ({a = 0 , b = ({a = 0 , b = false }.b) }.a) in (succ 0)) )) , b = (iszero (let u = (( \f: Bool .((f 1 ) (let u = false in 0) ) ) (\a: Bool .\b: Bool .b)) in (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)))) }.a)
({a = (fix (\x: Bool . (case <l = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 ))) > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = ({a = (pred (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b))) , b = ({a = (let u = (fix (\x: Bool . 0 )) in (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b))) , b = (((\x: Nat .\y: Bool .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (let u = true in false)) }.b) , c =  (( \f: Unit .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ({a = (pred 1) , b = true , c = ({a = 0 , b = true }.a) }.c) ) ) (\a: Unit .\b: Unit .b)) }.b) }.b)
(let u = (if (((\x: Rec X. X .\y: Nat .y) (let u = false in false) ) (let u = false in false)) then (unfold [ Bool ] (fold [ Nat ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) )) else (let u = (fix (\x: Nat . ({a = 1 , b = true , c = 0 }.c) )) in (((\x: Rec X. X .\y: Unit .y) false ) 1))) in (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Nat . ({a = 1 , b = false , c = 0 }.c) )) ) ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , b = (let u = true in u) }.b)))
(let u = (if (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) (let u = false in false)) ) (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) in (unfold [ Unit ] (fold [ Unit ] true ))) ) ) (\a: Bool .\b: Unit .b)) then (let u = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = true , c =  1 }.b) ) 1) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a))) else ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (( \f: Nat .((f ({a = 1 , b = 0 }.b) ) ({a = 1 , b = (((\x: Rec X. X .\y: Nat .x) true ) true) }.a) ) ) (\a: Nat .\b: Unit .a)) }.b)) in (case <r = (( \f: Bool .((f (( \f: Unit .((f false ) (fix (\x: Bool . false )) ) ) (\a: Unit .\b: Unit .b)) ) (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) )) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) ) ) (\a: Unit .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y))
({a = (case <l = ({a = ({a = 0 , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (succ (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b))) }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) false ) ) (\a: Unit .\b: Rec X. X .a)) , c = ({a = 1 , b = true , c = ({a = 1 , b = true }.a) }.c) }.c) in (fix (\x: Unit . (if false then true else true) ))) , c = (((\x: Bool .\y: Unit .x) (( \f: Nat .((f ({a = (if false then 1 else 0) , b = (iszero 0) , c = 1 }.c) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .a)) ) (let u = ({a = 0 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  1 }.b) in u)) }.c)
({a = (iszero (let u = (( \f: Unit .((f (((\x: Nat .\y: Nat .x) 0 ) false) ) (succ 1) ) ) (\a: Unit .\b: Rec X. X .a)) in (pred (let u = 1 in 1)))) , b = ({a = (succ 0) , b = (((\x: Unit .\y: Bool .y) false ) (iszero 1)) }.b) }.b)
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) (let u = false in u) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in false) ))) ))
(if (unfold [ Rec X. X ] (fold [ Bool ] (case <r = (let u = 0 in false) > as Bool of < l = x > => x | < r = y > => y) )) then ({a = ({a = (if true then 1 else 0) , b = ({a = 0 , b = true , c =  1 }.b) }.a) , b = ({a = (let u = (if true then 1 else 0) in u) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = ({a = 1 , b = false }.a) }.c) }.b) else (let u = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) in (( \f: Unit .((f ({a = 0 , b = false }.a) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Bool .\b: Rec X. X .a))))
(let u = (case <l = ({a = (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Nat .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.b) > as Bool of < l = x > => x | < r = y > => y) in (let u = (((\x: Nat .\y: Nat .y) (if true then true else ({a = false , b = false }.b)) ) (((\x: Bool .\y: Unit .y) true ) (unfold [ Bool ] (fold [ Nat ] 1 )))) in (((\x: Nat .\y: Bool .x) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .a)) ) (let u = 1 in false))))
({a = (let u = (let u = ({a = 1 , b = false , c = 1 }.c) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in false) ))) in (let u = (case <r = (let u = true in u) > as Rec X. X of < l = x > => x | < r = y > => y) in u)) , b = (if (unfold [ Unit ] (fold [ Nat ] (( \f: Rec X. X .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) ) (\a: Unit .\b: Bool .b)) )) then (let u = ({a = true , b = 1 }.a) in (if (iszero 0) then false else ({a = 1 , b = false , c =  0 }.b))) else ({a = (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in 0) , b = ({a = (succ 1) , b = (case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b)) }.b)
(pred (if (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Unit ] false )) )) then (succ (let u = (let u = 1 in u) in (succ 1))) else (fix (\x: Nat . (( \f: Nat .((f 0 ) (pred 1) ) ) (\a: Rec X. X .\b: Bool .a)) ))))
(unfold [ Bool ] (fold [ Nat ] (( \f: Bool .((f ({a = (succ 1) , b = true }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c =  0 }.b) )) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(if (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Bool . false )) )) )) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) )) else (let u = (let u = (pred 0) in (( \f: Rec X. X .((f (fix (\x: Rec X. X . 0 )) ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) in (let u = (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) in u)))
(case <l = ({a = (case <l = (let u = (if true then 1 else 0) in u) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Unit .\y: Bool .y) false ) true) , b = ({a = (unfold [ Nat ] (fold [ Bool ] true )) , b = (let u = false in 0) }.b) }.a) , c = (pred (((\x: Bool .\y: Unit .y) (iszero 1) ) 0)) }.c) > as Nat of < l = x > => x | < r = y > => y)
(iszero ({a = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Nat .x) ({a = 1 , b = true , c = 1 }.c) ) true) )) , b = (((\x: Unit .\y: Rec X. X .x) (fix (\x: Rec X. X . (let u = true in u) )) ) (fix (\x: Bool . false ))) , c = (((\x: Nat .\y: Bool .x) (( \f: Unit .((f (fix (\x: Unit . 1 )) ) (fix (\x: Bool . 1 )) ) ) (\a: Unit .\b: Unit .b)) ) (unfold [ Unit ] (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = true in u) )) ))) }.c))
(let u = ({a = ({a = ({a = (pred 1) , b = true , c = 0 }.c) , b = (let u = ({a = false , b = true }.b) in u) , c =  (let u = false in (fix (\x: Rec X. X . 1 ))) }.b) , b = (succ ({a = ({a = true , b = 0 }.a) , b = (let u = ({a = 0 , b = true , c = 0 }.c) in u) }.b)) }.a) in (case <l = (( \f: Unit .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) (pred 1) ) ) (\a: Bool .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y))
({a = (if (if (fix (\x: Nat . true )) then (let u = 0 in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) else (((\x: Rec X. X .\y: Nat .y) false ) true)) then (((\x: Unit .\y: Unit .x) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .a)) ) (((\x: Unit .\y: Rec X. X .y) true ) (((\x: Unit .\y: Rec X. X .x) true ) false))) else (unfold [ Nat ] (fold [ Rec X. X ] (let u = true in u) ))) , b = ({a = (let u = ({a = (let u = true in u) , b = (let u = 1 in ({a = false , b = 0 }.b)) }.b) in (((\x: Bool .\y: Nat .x) (fix (\x: Bool . false )) ) (let u = true in true))) , b = (let u = ({a = 1 , b = false }.b) in (((\x: Nat .\y: Nat .y) (if true then false else true) ) 1)) }.b) }.b)
(let u = (case <l = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) in (pred 0)) > as Rec X. X of < l = x > => x | < r = y > => y) in (succ (( \f: Rec X. X .((f (fix (\x: Nat . (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) )) ) (if (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true ))) then ({a = true , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b))) ) ) (\a: Unit .\b: Nat .a))))
({a = ({a = (((\x: Rec X. X .\y: Bool .y) (((\x: Bool .\y: Unit .x) false ) true) ) (( \f: Nat .((f true ) (fix (\x: Bool . true )) ) ) (\a: Unit .\b: Nat .b))) , b = ({a = (fix (\x: Nat . 1 )) , b = ({a = ({a = 0 , b = false }.b) , b = (((\x: Nat .\y: Unit .y) true ) true) }.b) }.b) }.b) , b = (let u = (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = true , c = 1 }.c) )) in u) }.b)
({a = (succ ({a = (let u = false in u) , b = (pred ({a = 0 , b = false }.a)) }.b)) , b = (case <r = (let u = (iszero 1) in (iszero (case <l = 1 > as Bool of < l = x > => x | < r = y > => y))) > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = (((\x: Bool .\y: Bool .y) true ) ({a = 0 , b = false , c = 1 }.c)) in u) }.b)
(succ (fix (\x: Unit . ({a = ({a = 0 , b = true }.b) , b = (succ 1) }.b) )))
(let u = (fix (\x: Unit . ({a = ({a = 1 , b = false }.b) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) }.a) )) in ({a = (iszero 1) , b = (unfold [ Rec X. X ] (fold [ Nat ] (let u = 1 in 0) )) }.b))
(let u = (case <r = (( \f: Nat .((f ({a = 1 , b = true , c =  0 }.b) ) false ) ) (\a: Unit .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) in (if ({a = (let u = 1 in 1) , b = ({a = true , b = true }.b) }.b) then (if (fix (\x: Unit . false )) then (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) true) else (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) else (((\x: Nat .\y: Rec X. X .y) false ) ({a = true , b = 1 }.b))))
(case <r = (( \f: Bool .((f (let u = ({a = 1 , b = true }.b) in u) ) (fix (\x: Bool . (if true then ({a = 0 , b = true , c =  0 }.b) else true) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Nat .x) (let u = (((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Nat .y) false ) 1) ) (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .y) false ) false) ) (unfold [ Unit ] (fold [ Bool ] ({a = false , b = 0 }.a) )) ) ) (\a: Rec X. X .\b: Bool .b))) in (unfold [ Rec X. X ] (fold [ Bool ] ({a = true , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b) ))) ) ({a = (iszero (fix (\x: Rec X. X . 0 ))) , b = (let u = (((\x: Nat .\y: Nat .y) true ) false) in u) }.b))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] (if false then ({a = false , b = 0 }.b) else ({a = true , b = 0 }.b)) )) )) in (( \f: Nat .((f ({a = 0 , b = true }.a) ) (let u = (let u = 0 in u) in (case <l = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(case <r = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = (fix (\x: Nat . false )) , c =  (let u = true in 0) }.b) ) (iszero 0)) ) (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)) ) ({a = (if false then false else (let u = true in true)) , b = ({a = 0 , b = true }.b) }.b) ) ) (\a: Unit .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (if (case <r = (if false then true else true) > as Unit of < l = x > => x | < r = y > => y) then ({a = 0 , b = true , c =  (let u = 0 in 1) }.b) else (fix (\x: Unit . (unfold [ Unit ] (fold [ Bool ] false )) ))) ) (case <r = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) in u) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b))
({a = (let u = (let u = (iszero (unfold [ Unit ] (fold [ Unit ] 1 ))) in (((\x: Nat .\y: Rec X. X .y) ({a = (let u = 0 in false) , b = (pred 1) }.a) ) (((\x: Rec X. X .\y: Nat .y) false ) true))) in ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = (case <r = (let u = true in false) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) , b = ({a = ({a = 1 , b = (if true then false else true) , c =  1 }.b) , b = (((\x: Bool .\y: Unit .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = 0 , b = true , c =  0 }.b)) }.b) }.b)
(if ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (( \f: Nat .((f ({a = 1 , b = false , c = 1 }.c) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (let u = (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Nat ] true )) )) in u) }.b) then (let u = (if (((\x: Nat .\y: Rec X. X .x) false ) false) then (((\x: Bool .\y: Nat .y) (let u = 1 in false) ) 1) else (((\x: Nat .\y: Nat .y) (fix (\x: Rec X. X . true )) ) (((\x: Rec X. X .\y: Nat .y) true ) 1))) in (let u = true in ({a = 1 , b = false }.b))) else ({a = (iszero (case <l = (((\x: Bool .\y: Unit .x) (let u = 1 in 0) ) false) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = ({a = 0 , b = true }.a) , b = (if (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) then ({a = false , b = false }.b) else false) , c =  (succ 1) }.b) }.b))
(let u = (fix (\x: Bool . (iszero (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) )) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = (pred (pred 0)) , b = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .a)) }.b) )))
(((\x: Bool .\y: Bool .y) (if (case <r = (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .y) true ) false) ) (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) ) ) (\a: Unit .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) (let u = (fix (\x: Nat . false )) in (let u = false in u)) ) (case <r = ({a = 0 , b = false }.b) > as Unit of < l = x > => x | < r = y > => y)) ) (iszero 0) ) ) (\a: Bool .\b: Bool .a)) else ({a = (pred (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a))) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  (if false then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else ({a = 0 , b = 1 }.b)) }.b)) ) (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) (let u = false in 1) ) (((\x: Nat .\y: Nat .x) false ) false)) )))
(let u = (((\x: Bool .\y: Unit .x) (fix (\x: Rec X. X . (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a)) )) ) (let u = (let u = false in false) in (case <r = (let u = true in u) > as Bool of < l = x > => x | < r = y > => y))) in (fix (\x: Unit . ({a = ({a = ({a = 0 , b = true , c = 0 }.c) , b = false }.b) , b = ({a = 0 , b = ({a = 0 , b = true }.b) }.b) }.b) )))
(iszero (let u = (let u = (let u = 0 in 0) in (pred 0)) in u))
(fix (\x: Bool . (unfold [ Nat ] (fold [ Nat ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) )) )) ))
(((\x: Bool .\y: Rec X. X .x) (let u = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Rec X. X ] true )) ) ({a = ({a = 0 , b = 0 }.b) , b = true , c =  1 }.b)) in (case <l = (fix (\x: Rec X. X . ({a = 0 , b = true }.a) )) > as Bool of < l = x > => x | < r = y > => y)) ) ({a = (let u = 0 in (let u = 0 in u)) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = true in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) }.b))
({a = ({a = (succ (( \f: Rec X. X .((f (let u = 1 in u) ) 1 ) ) (\a: Unit .\b: Nat .b))) , b = (fix (\x: Bool . (let u = true in false) )) , c = (case <l = (((\x: Nat .\y: Unit .x) ({a = 0 , b = false }.a) ) true) > as Nat of < l = x > => x | < r = y > => y) }.c) , b = ({a = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = (fix (\x: Rec X. X . false )) }.b) , b = (let u = 1 in true) }.b) }.b)
(if ({a = (let u = false in (let u = 0 in u)) , b = (let u = (let u = 1 in (((\x: Bool .\y: Rec X. X .x) true ) false)) in (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a))) }.b) then (let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b)) , b = true }.b) }.b) in (let u = (let u = (let u = 0 in true) in (let u = 0 in false)) in u)) else (((\x: Nat .\y: Rec X. X .y) (( \f: Unit .((f (((\x: Nat .\y: Bool .y) false ) false) ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Bool .((f true ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Unit .b))))
(let u = (let u = (case <r = (fix (\x: Unit . true )) > as Bool of < l = x > => x | < r = y > => y) in (let u = (if (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .a)) then 1 else (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a))) in u)) in (((\x: Unit .\y: Nat .x) (fix (\x: Nat . (((\x: Unit .\y: Unit .y) ({a = true , b = true }.b) ) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b))) )) ) (let u = ({a = false , b = 0 }.a) in (fix (\x: Unit . true )))))
({a = (unfold [ Unit ] (fold [ Nat ] (case <r = (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) then (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) else true) > as Bool of < l = x > => x | < r = y > => y) )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (iszero (let u = true in 0)) )) }.b)
({a = (( \f: Nat .((f (((\x: Unit .\y: Nat .x) 1 ) true) ) (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) in u) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = ({a = ({a = (pred 1) , b = 0 }.b) , b = (let u = 0 in (if false then true else false)) }.a) , b = (iszero (( \f: Unit .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Bool .a))) , c =  (unfold [ Nat ] (fold [ Unit ] (fix (\x: Rec X. X . 0 )) )) }.b) }.b)
(if (iszero (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) true ) ) (\a: Unit .\b: Bool .a)) ) ({a = 0 , b = false , c = 1 }.c))) then (((\x: Bool .\y: Unit .x) (let u = (( \f: Nat .((f ({a = 1 , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Bool .b)) in ({a = true , b = 0 }.a)) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = false , b = (let u = 0 in u) }.a) ))) else ({a = (unfold [ Unit ] (fold [ Unit ] ({a = (fix (\x: Bool . false )) , b = 1 }.b) )) , b = (fix (\x: Nat . (((\x: Unit .\y: Rec X. X .x) true ) true) )) , c =  ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = 0 , b = 1 }.b) )) }.b))
(let u = ({a = (((\x: Bool .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true )) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) , b = (pred (( \f: Unit .((f (let u = true in 0) ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Nat .b))) }.b) in (let u = (( \f: Bool .((f ({a = true , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Unit .a)) in (iszero (let u = (let u = false in 0) in u))))
(let u = ({a = (( \f: Bool .((f ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = (iszero (let u = 1 in 0)) }.a) ) ({a = 1 , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = ({a = 1 , b = 1 }.b) }.b) }.b) in (unfold [ Bool ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) )) )))
(let u = (let u = (succ (succ 0)) in u) in u)
(fix (\x: Rec X. X . ({a = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Bool .((f (let u = false in u) ) false ) ) (\a: Nat .\b: Bool .a)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) , b = (if ({a = true , b = false }.b) then (if true then 1 else 1) else (fix (\x: Nat . (if false then 0 else 1) ))) }.b) ))
(let u = (if (( \f: Nat .((f (fix (\x: Bool . false )) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .a)) then (((\x: Bool .\y: Bool .y) (let u = false in u) ) (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . 1 )) ))) else ({a = false , b = 1 }.b)) in u)
(( \f: Nat .((f ({a = (if (unfold [ Rec X. X ] (fold [ Bool ] false )) then (((\x: Nat .\y: Nat .y) (((\x: Rec X. X .\y: Nat .x) false ) false) ) (unfold [ Nat ] (fold [ Rec X. X ] true ))) else (((\x: Bool .\y: Bool .y) true ) ({a = false , b = false }.b))) , b = (let u = (let u = true in 0) in u) }.b) ) (( \f: Rec X. X .((f ({a = (if true then 1 else 1) , b = (let u = false in false) }.a) ) (( \f: Unit .((f ({a = (let u = true in 1) , b = true }.a) ) (fix (\x: Nat . ({a = 1 , b = true }.a) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .a))
(let u = (case <l = ({a = (( \f: Nat .((f (case <l = ({a = 1 , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y) ) (succ 1) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = ({a = 1 , b = false , c =  1 }.b) , b = 0 }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) false ) false) ) 0) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) ))))
({a = ({a = ({a = (succ 1) , b = true }.a) , b = (succ ({a = false , b = (let u = 0 in 1) }.b)) }.b) , b = ({a = (let u = (case <r = (( \f: Rec X. X .((f false ) (if true then false else true) ) ) (\a: Rec X. X .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) , b = ({a = false , b = 0 }.a) }.b)) , b = (( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] 0 )) ) (( \f: Rec X. X .((f (succ 0) ) (if false then 0 else 1) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Unit .\b: Nat .b)) }.a) }.a)
(((\x: Unit .\y: Nat .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Bool .\y: Unit .y) true ) true) )) ) (( \f: Bool .((f (fix (\x: Nat . (fix (\x: Rec X. X . false )) )) ) (iszero ({a = true , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Unit .b)))
(let u = (unfold [ Bool ] (fold [ Rec X. X ] (let u = ({a = ({a = true , b = true }.b) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in (( \f: Unit .((f (( \f: Nat .((f ({a = false , b = 1 }.a) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (fix (\x: Bool . true )) ) ) (\a: Nat .\b: Unit .a))) )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = false , b = 1 }.a) )))
(pred (let u = ({a = (((\x: Bool .\y: Unit .y) true ) 1) , b = ({a = 0 , b = false , c =  0 }.b) , c = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.c) in u))
(((\x: Bool .\y: Unit .y) (iszero ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Unit .x) 0 ) false) }.b)) ) (((\x: Bool .\y: Nat .x) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = ({a = 1 , b = true , c =  0 }.b) }.b) ) (iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )))))
(let u = (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) in (if (unfold [ Unit ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) )) then ({a = (unfold [ Unit ] (fold [ Bool ] (succ 1) )) , b = ({a = false , b = 0 }.a) , c = (unfold [ Nat ] (fold [ Nat ] (let u = 0 in u) )) }.c) else (succ (((\x: Unit .\y: Nat .y) true ) 1))))
({a = ({a = (case <r = ({a = true , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (succ (pred 0)) , b = ({a = 1 , b = true , c =  0 }.b) }.a) }.a) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (succ (let u = 0 in u)) )) }.a)
(let u = ({a = (( \f: Nat .((f (case <r = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y) ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) , b = (let u = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = true }.a) in (succ (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)))) }.b) in (((\x: Unit .\y: Bool .x) (let u = 1 in (unfold [ Rec X. X ] (fold [ Bool ] false ))) ) (iszero ({a = 1 , b = false }.a))))
({a = (let u = (( \f: Unit .((f (let u = 0 in 0) ) (((\x: Nat .\y: Unit .x) ({a = true , b = 0 }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .a)) in u) , b = ({a = (fix (\x: Bool . (succ 0) )) , b = (case <r = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b)
(iszero (unfold [ Nat ] (fold [ Bool ] (fix (\x: Bool . ({a = 0 , b = true , c = 1 }.c) )) )))
(( \f: Rec X. X .((f (iszero (( \f: Rec X. X .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) true ) 1) ) ) (\a: Bool .\b: Nat .b))) ) (if (let u = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = (fix (\x: Rec X. X . true )) , c = ({a = 1 , b = false }.a) }.c) in (fix (\x: Unit . false ))) then (let u = (iszero 1) in u) else (if (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) false ) false) )) then (unfold [ Unit ] (fold [ Nat ] (let u = 1 in true) )) else (let u = (((\x: Nat .\y: Rec X. X .y) false ) true) in u))) ) ) (\a: Bool .\b: Nat .b))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = (succ 1) , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) }.b) in u) ))
(((\x: Unit .\y: Nat .x) (fix (\x: Nat . (succ ({a = (( \f: Nat .((f 0 ) (pred 1) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = 0 in true) }.a)) )) ) ({a = (let u = (if false then 0 else 1) in u) , b = ({a = true , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) }.b) }.b))
(case <r = (fix (\x: Nat . (let u = (let u = (if false then 0 else 1) in 1) in (((\x: Bool .\y: Bool .y) true ) false)) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = false in 1) )) in (if (((\x: Rec X. X .\y: Nat .y) (if true then false else true) ) (if (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) then (((\x: Bool .\y: Unit .y) true ) true) else (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)))) then (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) else (succ ({a = 0 , b = false , c = (((\x: Rec X. X .\y: Nat .x) 0 ) false) }.c))))
(unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = (unfold [ Bool ] (fold [ Unit ] (let u = true in u) )) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (let u = (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) in (let u = ({a = true , b = 0 }.b) in false)) }.b) ))
({a = (if (fix (\x: Bool . (let u = (let u = true in u) in (((\x: Unit .\y: Rec X. X .x) true ) false)) )) then (let u = (unfold [ Unit ] (fold [ Bool ] 1 )) in u) else ({a = (( \f: Nat .((f (let u = 1 in u) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 0 , b = false , c =  0 }.b) }.a)) , b = (case <r = (unfold [ Unit ] (fold [ Bool ] (let u = false in u) )) > as Bool of < l = x > => x | < r = y > => y) }.a)
(((\x: Bool .\y: Unit .x) ({a = ({a = (let u = (let u = 1 in 1) in u) , b = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) in false) }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) )) }.b) ) (fix (\x: Rec X. X . (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) (if false then false else false) ) ) (\a: Bool .\b: Nat .b)) )))
({a = (succ (fix (\x: Unit . ({a = 0 , b = 1 }.b) ))) , b = (unfold [ Bool ] (fold [ Bool ] ({a = ({a = 1 , b = false }.a) , b = (iszero 0) , c =  (( \f: Nat .((f (( \f: Unit .((f 0 ) (let u = 1 in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (succ 1) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) )) }.a)
(succ (let u = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) in (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = true , c = 0 }.c) ))))
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (if true then 0 else 1) ))) ))
({a = (succ (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (if true then 1 else 0) )) in u)) , b = (let u = ({a = ({a = (let u = 0 in 0) , b = false }.a) , b = (fix (\x: Rec X. X . false )) , c =  ({a = 0 , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.a) }.b) in ({a = (fix (\x: Bool . false )) , b = (((\x: Nat .\y: Nat .y) true ) false) }.b)) , c = ({a = (((\x: Nat .\y: Unit .x) ({a = (((\x: Unit .\y: Nat .y) false ) 0) , b = ({a = 0 , b = false , c =  1 }.b) , c = 1 }.c) ) ({a = true , b = ({a = true , b = false }.b) }.b)) , b = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (succ 0) )) in ({a = ({a = 0 , b = false , c = 0 }.c) , b = 0 }.b)) }.b) }.c)
({a = (((\x: Bool .\y: Nat .y) (let u = (succ ({a = 1 , b = false , c = 1 }.c)) in ({a = 1 , b = true }.b)) ) (if (( \f: Rec X. X .((f false ) ({a = true , b = 1 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) then (((\x: Bool .\y: Rec X. X .x) (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) ({a = 0 , b = false }.b)) else (( \f: Unit .((f 0 ) (unfold [ Rec X. X ] (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Bool .a)))) , b = (case <r = ({a = true , b = 1 }.a) > as Nat of < l = x > => x | < r = y > => y) }.a)
({a = (succ (( \f: Nat .((f (let u = (succ (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) in (let u = 0 in 1)) ) (let u = ({a = 0 , b = 1 }.b) in (fix (\x: Nat . 1 ))) ) ) (\a: Rec X. X .\b: Nat .b))) , b = ({a = (((\x: Bool .\y: Nat .y) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a)) ) (fix (\x: Nat . 0 ))) , b = ({a = (iszero 0) , b = (((\x: Bool .\y: Unit .y) false ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b))) }.a) }.b) , c =  (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = ({a = false , b = 1 }.b) in 0) ))) }.b)
(let u = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] ({a = false , b = ({a = 0 , b = false }.a) }.a) )) )) in (( \f: Rec X. X .((f (if (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .b)) then ({a = true , b = false }.b) else (case <r = (case <r = false > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)) ) ({a = (( \f: Rec X. X .((f (let u = 1 in 1) ) (fix (\x: Nat . 1 )) ) ) (\a: Unit .\b: Unit .b)) , b = (iszero (((\x: Nat .\y: Rec X. X .x) 0 ) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)))) }.b) ) ) (\a: Nat .\b: Nat .a)))
({a = (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Unit .y) true ) 1) )) )) , b = (let u = ({a = ({a = (let u = 1 in false) , b = 0 }.b) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b) in u) }.b)
(let u = (unfold [ Bool ] (fold [ Nat ] ({a = (((\x: Bool .\y: Unit .y) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 1 , b = true }.b) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (let u = 0 in true)) , b = ({a = (if true then (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) else (let u = false in u)) , b = (( \f: Unit .((f (fix (\x: Nat . true )) ) false ) ) (\a: Nat .\b: Unit .a)) }.b) }.b) )) in ({a = (let u = ({a = false , b = 1 }.b) in u) , b = ({a = (let u = 0 in u) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  (if false then 1 else 0) }.b) }.b))
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (if (unfold [ Nat ] (fold [ Unit ] ({a = false , b = true }.b) )) then (fix (\x: Nat . (((\x: Rec X. X .\y: Unit .y) false ) 1) )) else (pred (((\x: Nat .\y: Rec X. X .x) 0 ) true))) )) , b = (( \f: Unit .((f (( \f: Bool .((f ({a = false , b = false }.b) ) (case <r = (if true then true else false) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)) ) (( \f: Rec X. X .((f (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .a)) ) (let u = true in true) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  (((\x: Rec X. X .\y: Nat .y) (if (iszero 0) then (let u = true in u) else (((\x: Bool .\y: Bool .y) false ) true)) ) (( \f: Rec X. X .((f (( \f: Nat .((f (fix (\x: Nat . 1 )) ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Bool .\b: Bool .a)) ) (let u = ({a = true , b = false }.b) in ({a = true , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Nat .a))) }.b)
(let u = (fix (\x: Bool . (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .y) true ) true)) )) in (( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Rec X. X .y) (fix (\x: Rec X. X . false )) ) (iszero 1)) )) ) ({a = (let u = false in false) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) }.a) ) ) (\a: Unit .\b: Unit .a)))
(let u = (( \f: Unit .((f (pred (if true then (let u = false in 1) else (succ 0))) ) (fix (\x: Unit . ({a = 0 , b = true }.a) )) ) ) (\a: Unit .\b: Rec X. X .b)) in u)
(( \f: Nat .((f (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) (let u = 0 in u)) )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a)) in (fix (\x: Bool . 1 ))) )) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = (((\x: Unit .\y: Nat .y) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = (((\x: Nat .\y: Bool .x) true ) false) , b = false }.b)) , b = ({a = 0 , b = (((\x: Rec X. X .\y: Bool .y) false ) false) }.a) }.b) ) ) (\a: Bool .\b: Bool .a))
(( \f: Nat .((f (((\x: Nat .\y: Nat .x) (( \f: Rec X. X .((f (( \f: Nat .((f false ) (fix (\x: Nat . false )) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) , b = 1 }.a) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = (let u = 1 in 0) , b = true , c =  1 }.b)) ) (( \f: Nat .((f (((\x: Bool .\y: Unit .y) (( \f: Bool .((f ({a = 0 , b = false }.b) ) true ) ) (\a: Nat .\b: Bool .b)) ) (iszero 1)) ) (case <r = ({a = 0 , b = false , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Bool .b))
({a = (if (unfold [ Rec X. X ] (fold [ Unit ] (let u = 0 in false) )) then (( \f: Unit .((f ({a = 0 , b = false }.a) ) (pred 0) ) ) (\a: Nat .\b: Unit .a)) else (unfold [ Nat ] (fold [ Nat ] (let u = 1 in 1) ))) , b = (fix (\x: Nat . (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) false ) false) ) ({a = true , b = (let u = 1 in 1) }.a) ) ) (\a: Nat .\b: Bool .b)) )) }.a)
((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (let u = (( \f: Unit .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Nat .\b: Nat .b)) in (( \f: Rec X. X .((f false ) (let u = true in u) ) ) (\a: Bool .\b: Rec X. X .b))) ))
(iszero ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (let u = 0 in 1) )))
({a = (unfold [ Nat ] (fold [ Unit ] (if (if false then true else false) then (unfold [ Bool ] (fold [ Nat ] 0 )) else (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) in u)) )) , b = (( \f: Unit .((f (let u = (( \f: Bool .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (succ (pred 0)) ) ) (\a: Unit .\b: Nat .a)) in ({a = (let u = false in 0) , b = (unfold [ Bool ] (fold [ Bool ] false )) }.b)) ) (((\x: Unit .\y: Nat .y) (if (let u = true in u) then (((\x: Nat .\y: Nat .y) false ) true) else (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .b))) ) (let u = 1 in true)) ) ) (\a: Nat .\b: Nat .a)) }.b)
({a = (let u = ({a = (let u = 1 in u) , b = (if (iszero 1) then ({a = 0 , b = (let u = false in true) , c =  (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) else (unfold [ Unit ] (fold [ Bool ] false ))) , c = (case <l = (((\x: Bool .\y: Nat .x) 0 ) false) > as Unit of < l = x > => x | < r = y > => y) }.c) in u) , b = (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (pred (unfold [ Unit ] (fold [ Rec X. X ] (if true then 1 else 1) ))) ))) , c = (let u = ({a = (fix (\x: Unit . 1 )) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) }.b) in (( \f: Unit .((f (succ 1) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b))) }.c)
({a = (fix (\x: Bool . (pred (pred 1)) )) , b = (( \f: Unit .((f ({a = (succ 1) , b = (let u = 1 in false) }.a) ) (((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Bool .a)) }.b)
({a = (let u = (succ ({a = 0 , b = (fix (\x: Rec X. X . true )) }.a)) in (case <l = (if false then 1 else 0) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Unit .y) false ) false) ) (let u = false in (let u = 1 in true))) ) (((\x: Nat .\y: Rec X. X .y) true ) true)) }.a)
(( \f: Bool .((f (iszero (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Rec X. X .((f (fix (\x: Rec X. X . 0 )) ) 1 ) ) (\a: Unit .\b: Bool .b)) ))) ) (fix (\x: Unit . ({a = false , b = 1 }.a) )) ) ) (\a: Bool .\b: Nat .a))
(unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Nat .y) ({a = (( \f: Unit .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = false in (if false then true else false)) }.b) ) (( \f: Rec X. X .((f ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) , b = (unfold [ Unit ] (fold [ Unit ] (let u = true in u) )) }.b) ) ({a = ({a = 1 , b = false }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) }.b) ) ) (\a: Rec X. X .\b: Bool .a))) ))
(((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Rec X. X .x) ({a = (((\x: Bool .\y: Unit .x) 1 ) true) , b = (let u = true in u) }.b) ) (let u = (fix (\x: Bool . true )) in u)) ) (((\x: Bool .\y: Bool .y) (if (( \f: Rec X. X .((f (fix (\x: Bool . true )) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Nat .b)) then (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) false) else (fix (\x: Bool . (if true then true else true) ))) ) ({a = (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) (let u = 0 in false) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = 1 , b = false }.b) }.b)))
({a = ({a = (if ({a = (case <r = (((\x: Rec X. X .\y: Nat .y) true ) true) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = (iszero 1) , c = (unfold [ Unit ] (fold [ Bool ] 1 )) }.c) }.a) then (let u = false in (succ 1)) else ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 ))) , b = (let u = (( \f: Nat .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = true in 1) ) ) (\a: Unit .\b: Rec X. X .b)) in u) }.b) , b = (iszero ({a = (pred 0) , b = (((\x: Bool .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) ) false) }.a)) , c = (((\x: Nat .\y: Unit .x) ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (((\x: Unit .\y: Unit .x) true ) (((\x: Nat .\y: Bool .x) false ) true)) , c = (let u = true in 0) }.c) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in 1) )) , b = (let u = (succ 0) in (let u = true in u)) , c =  ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = ({a = 1 , b = true }.a) }.b) }.b)) }.c)
(unfold [ Nat ] (fold [ Unit ] (fix (\x: Rec X. X . (pred (let u = true in 0)) )) ))
(let u = (succ (( \f: Unit .((f (fix (\x: Bool . 1 )) ) (pred (if true then 1 else 0)) ) ) (\a: Rec X. X .\b: Unit .a))) in u)
(let u = (( \f: Bool .((f (( \f: Unit .((f ({a = false , b = 0 }.a) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true , c =  1 }.b) )) ) ) (\a: Nat .\b: Unit .b)) ) (( \f: Bool .((f (if (let u = 0 in false) then false else true) ) (( \f: Nat .((f (fix (\x: Unit . (let u = true in u) )) ) ({a = false , b = true }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Nat .\b: Nat .b)) in ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Bool ] false )) ) (((\x: Nat .\y: Nat .x) true ) (unfold [ Nat ] (fold [ Unit ] true ))) ) ) (\a: Nat .\b: Unit .b)) )))
({a = ({a = (((\x: Nat .\y: Rec X. X .x) (let u = true in ({a = 1 , b = false }.a)) ) (( \f: Rec X. X .((f (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (if false then false else false) ) ) (\a: Nat .\b: Unit .b))) , b = (let u = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) , b = 1 }.b) in (case <r = (if (iszero 1) then true else (if false then true else false)) > as Bool of < l = x > => x | < r = y > => y)) }.a) , b = (( \f: Unit .((f (fix (\x: Unit . (fix (\x: Nat . (((\x: Unit .\y: Nat .x) ({a = true , b = false }.b) ) true) )) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (if (fix (\x: Unit . true )) then true else (if true then false else true)) )) ) ) (\a: Unit .\b: Nat .a)) , c = (let u = ({a = (((\x: Rec X. X .\y: Nat .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) ) (unfold [ Unit ] (fold [ Rec X. X ] false ))) , b = (fix (\x: Nat . true )) }.b) in (pred ({a = 0 , b = 1 }.b))) }.c)
(( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Unit .x) (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) ({a = 1 , b = true }.b)) ) (let u = 0 in false)) ) (let u = (case <r = ({a = 0 , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) in (let u = (unfold [ Unit ] (fold [ Bool ] 0 )) in ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )))) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(fix (\x: Nat . (( \f: Nat .((f (let u = (let u = 0 in false) in (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) )) ) ({a = false , b = true }.b))) ) (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = false }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Nat .a)) ))
(((\x: Unit .\y: Unit .x) (case <r = (fix (\x: Rec X. X . (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) )) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (fix (\x: Nat . 1 )) in (((\x: Unit .\y: Nat .x) (fix (\x: Rec X. X . ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) )) ) ({a = 0 , b = true , c =  1 }.b))))
(( \f: Bool .((f (let u = (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) ({a = true , b = 1 }.a) ) (iszero 1)) ) (let u = ({a = false , b = false }.b) in (let u = true in u))) in (((\x: Bool .\y: Bool .y) (let u = false in u) ) (let u = false in 1))) ) (let u = (((\x: Nat .\y: Unit .x) (let u = 0 in 0) ) ({a = 0 , b = false , c =  1 }.b)) in (unfold [ Bool ] (fold [ Rec X. X ] (succ 1) ))) ) ) (\a: Bool .\b: Unit .b))
(let u = (( \f: Nat .((f (pred (let u = 1 in 1)) ) (( \f: Unit .((f (let u = 1 in u) ) (if true then 0 else 1) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .a)) in (let u = ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) , b = ({a = true , b = true }.b) }.b) in (fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) )) ))))
(if (if ({a = (( \f: Nat .((f 0 ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b)) }.b) then ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (if true then 1 else 1) , b = ({a = true , b = true }.b) , c = ({a = 1 , b = false }.a) }.c) }.a) else ({a = (pred (((\x: Bool .\y: Unit .y) true ) 0)) , b = (( \f: Nat .((f true ) (if false then true else true) ) ) (\a: Nat .\b: Nat .b)) }.b)) then (let u = (fix (\x: Nat . (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) )) in (if (((\x: Bool .\y: Nat .y) false ) true) then (if true then true else ({a = 1 , b = false , c =  1 }.b)) else (((\x: Nat .\y: Unit .y) (let u = 0 in true) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) false)))) else ({a = (( \f: Nat .((f (let u = 0 in 0) ) (((\x: Bool .\y: Nat .y) (unfold [ Bool ] (fold [ Unit ] false )) ) (((\x: Rec X. X .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) true)) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (case <r = (if true then true else true) > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = ({a = (if false then true else true) , b = ({a = 1 , b = false , c = 0 }.c) }.a) in (let u = 1 in u)) }.b))
(((\x: Rec X. X .\y: Unit .y) ({a = (case <l = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f (let u = false in u) ) (fix (\x: Bool . false )) ) ) (\a: Rec X. X .\b: Nat .b)) , c =  (let u = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) in u) in ({a = ({a = true , b = 0 }.a) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b)) }.b) ) ({a = (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) then (succ (pred 1)) else (succ ({a = 1 , b = false }.a))) , b = ({a = (let u = 1 in u) , b = (let u = 0 in true) }.b) , c =  (fix (\x: Bool . (succ 1) )) }.b))
(let u = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) 1 ) (iszero 1)) )) , b = (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) )) , c =  ({a = (let u = 0 in (succ 1)) , b = ({a = true , b = true }.b) }.a) }.b) in u)
(( \f: Nat .((f ({a = ({a = ({a = (pred 1) , b = (((\x: Nat .\y: Bool .x) false ) true) , c = (if true then 1 else 0) }.c) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , c = (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) }.c) , b = (if (((\x: Rec X. X .\y: Rec X. X .x) true ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false ))) then (let u = true in u) else (((\x: Bool .\y: Nat .y) (let u = false in true) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y))) , c = ({a = (unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = (((\x: Nat .\y: Rec X. X .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) true) }.b) }.c) ) (( \f: Unit .((f (case <l = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = (fix (\x: Unit . false )) }.a) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (( \f: Nat .((f ({a = 1 , b = 1 }.b) ) (fix (\x: Bool . 1 )) ) ) (\a: Unit .\b: Bool .a)) , b = (( \f: Bool .((f (let u = 0 in true) ) ({a = 0 , b = false }.b) ) ) (\a: Unit .\b: Nat .a)) , c = (let u = ({a = 1 , b = (((\x: Bool .\y: Bool .y) true ) 0) }.b) in (pred 1)) }.c) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Unit .b))
({a = (case <l = ({a = (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Unit .x) (fix (\x: Bool . 0 )) ) false) ) (let u = false in u)) , b = (fix (\x: Rec X. X . (let u = 0 in ({a = false , b = 0 }.b)) )) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f (fix (\x: Unit . false )) ) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) ) (\a: Nat .\b: Bool .a)) )) }.b)
(((\x: Bool .\y: Nat .x) ({a = (let u = (if ({a = 1 , b = true , c =  0 }.b) then (((\x: Unit .\y: Nat .x) ({a = 1 , b = 1 }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) else (((\x: Nat .\y: Bool .y) (let u = 0 in true) ) 1)) in (let u = ({a = 1 , b = true }.a) in (let u = (let u = 1 in 0) in false))) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (succ 1) )) }.b) ) (( \f: Bool .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = 1 , b = true , c = 0 }.c) , b = (let u = true in u) , c =  ({a = 1 , b = false }.a) }.b) )) ) (iszero (succ (( \f: Nat .((f ({a = 1 , b = false , c = 1 }.c) ) (((\x: Unit .\y: Rec X. X .x) 0 ) false) ) ) (\a: Unit .\b: Nat .b)))) ) ) (\a: Rec X. X .\b: Nat .a)))
({a = (let u = ({a = (let u = 0 in u) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) in ({a = ({a = (if true then 1 else 1) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (((\x: Nat .\y: Bool .y) false ) 1) }.b) , b = (iszero (unfold [ Rec X. X ] (fold [ Unit ] 0 ))) }.b)) , b = (let u = (((\x: Nat .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) (let u = 0 in true)) in u) }.b)
(let u = (if (((\x: Rec X. X .\y: Unit .x) (let u = false in true) ) (((\x: Bool .\y: Unit .y) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) true)) then (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .a)) else (pred (succ (unfold [ Nat ] (fold [ Rec X. X ] 0 ))))) in (succ (( \f: Bool .((f ({a = 0 , b = false , c = 0 }.c) ) ({a = 1 , b = false , c = 1 }.c) ) ) (\a: Bool .\b: Unit .a))))
(fix (\x: Unit . (let u = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) false ) (fix (\x: Rec X. X . true ))) )) in (let u = ({a = false , b = 0 }.b) in u)) ))
(let u = (unfold [ Rec X. X ] (fold [ Bool ] ({a = (let u = ({a = 0 , b = false }.a) in 0) , b = (unfold [ Nat ] (fold [ Nat ] true )) , c =  (succ 1) }.b) )) in (((\x: Nat .\y: Bool .y) (if (if false then false else false) then ({a = 0 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = 1 , b = false , c = 0 }.c) }.b) else ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = 1 }.a)) ) (succ (unfold [ Bool ] (fold [ Unit ] ({a = 1 , b = true , c = 0 }.c) )))))
(let u = (case <r = ({a = (((\x: Unit .\y: Bool .x) (if ({a = 1 , b = false }.b) then 0 else (((\x: Rec X. X .\y: Nat .y) true ) 0)) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b))) , b = (unfold [ Unit ] (fold [ Unit ] (let u = false in u) )) , c =  (let u = ({a = false , b = 1 }.b) in u) }.b) > as Nat of < l = x > => x | < r = y > => y) in u)
(((\x: Bool .\y: Unit .y) (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .x) (fix (\x: Bool . true )) ) (let u = 0 in false)) ) (case <r = (( \f: Bool .((f (let u = false in true) ) false ) ) (\a: Rec X. X .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = ({a = ({a = 1 , b = false }.a) , b = 1 }.b) , b = ({a = (unfold [ Nat ] (fold [ Rec X. X ] false )) , b = (if false then 1 else 0) }.b) }.b))
(unfold [ Unit ] (fold [ Rec X. X ] (pred ({a = (((\x: Bool .\y: Nat .y) ({a = 0 , b = true }.b) ) ({a = 1 , b = true , c = 0 }.c)) , b = (fix (\x: Nat . (let u = 0 in 0) )) }.b)) ))
(let u = (unfold [ Bool ] (fold [ Bool ] ({a = (if (let u = 0 in false) then ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) else (let u = 1 in u)) , b = ({a = true , b = 0 }.b) }.b) )) in (let u = (let u = (iszero 1) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) in ({a = (((\x: Rec X. X .\y: Unit .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Bool ] 0 ))) , b = ({a = 1 , b = false }.b) , c =  ({a = 0 , b = (iszero 0) }.a) }.b)))
(case <r = (let u = (if false then false else (iszero 0)) in u) > as Unit of < l = x > => x | < r = y > => y)
(case <l = (unfold [ Nat ] (fold [ Nat ] (succ (succ 0)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (if (((\x: Unit .\y: Rec X. X .x) (if true then true else false) ) ({a = false , b = ({a = false , b = true }.b) }.b)) then ({a = 0 , b = true }.b) else ({a = (( \f: Rec X. X .((f (let u = 1 in 1) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (((\x: Rec X. X .\y: Unit .x) false ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) }.b)) in (( \f: Unit .((f (((\x: Unit .\y: Nat .x) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) (iszero 0)) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) , b = ({a = 1 , b = true }.b) }.b) ) ) (\a: Unit .\b: Unit .b)))
(succ ({a = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) , b = (((\x: Nat .\y: Nat .y) ({a = false , b = 1 }.a) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b))) }.b))
(pred (let u = (succ (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b))) in (let u = 0 in u)))
(case <r = (let u = (((\x: Unit .\y: Nat .y) (( \f: Bool .((f ({a = 1 , b = true }.b) ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = true , b = false }.b)) in (unfold [ Nat ] (fold [ Nat ] ({a = ({a = false , b = 1 }.a) , b = 1 }.a) ))) > as Unit of < l = x > => x | < r = y > => y)
(let u = (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (pred 0) )) in (((\x: Unit .\y: Bool .y) (let u = 0 in false) ) 0)) in (iszero (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 ))))) in u)
(let u = (( \f: Rec X. X .((f (( \f: Nat .((f (let u = 1 in u) ) (((\x: Rec X. X .\y: Nat .x) 0 ) (if false then false else false)) ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Rec X. X .((f (( \f: Bool .((f ({a = false , b = 1 }.b) ) 1 ) ) (\a: Bool .\b: Nat .b)) ) ({a = (((\x: Unit .\y: Unit .y) false ) true) , b = 1 }.b) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .a)) in (fix (\x: Unit . (if (unfold [ Nat ] (fold [ Rec X. X ] ({a = false , b = 1 }.a) )) then ({a = 1 , b = true }.b) else (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a))) )))
(( \f: Bool .((f (let u = (pred ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = 1 , b = true }.a) ))) in (succ (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)))) ) (let u = (succ ({a = 0 , b = true }.a)) in ({a = (fix (\x: Nat . 1 )) , b = (let u = ({a = 1 , b = true }.a) in (((\x: Unit .\y: Unit .y) true ) false)) , c = (((\x: Nat .\y: Rec X. X .x) 0 ) ({a = false , b = false }.b)) }.c)) ) ) (\a: Unit .\b: Unit .a))
(((\x: Unit .\y: Rec X. X .x) ({a = (if (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) then ({a = 1 , b = true }.a) else (succ 1)) , b = (fix (\x: Bool . (((\x: Nat .\y: Unit .x) true ) false) )) , c =  ({a = 0 , b = true }.a) }.b) ) (((\x: Bool .\y: Rec X. X .x) ({a = (((\x: Unit .\y: Rec X. X .x) 1 ) true) , b = ({a = 1 , b = true }.b) , c =  1 }.b) ) (iszero (fix (\x: Rec X. X . 1 )))))
({a = (( \f: Rec X. X .((f (fix (\x: Bool . (fix (\x: Bool . 1 )) )) ) ({a = (succ 1) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) , c = (pred 1) }.c) ) ) (\a: Bool .\b: Unit .b)) , b = (( \f: Bool .((f (fix (\x: Nat . true )) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) , c =  ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Nat .x) (unfold [ Nat ] (fold [ Bool ] 0 )) ) false) }.b) }.b)
(let u = (succ (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Unit .x) 0 ) false) ) ({a = 0 , b = true }.b))) in u)
(iszero (fix (\x: Unit . (if (fix (\x: Bool . (if true then true else true) )) then (let u = (let u = true in 0) in u) else (((\x: Rec X. X .\y: Nat .x) (pred 1) ) ({a = false , b = (let u = 0 in u) }.a))) )))
({a = (fix (\x: Nat . (case <l = (let u = (((\x: Unit .\y: Rec X. X .y) false ) ({a = false , b = false }.b)) in (let u = 1 in 1)) > as Bool of < l = x > => x | < r = y > => y) )) , b = (let u = ({a = (pred (succ 1)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = 0 in true) )) }.b) in u) }.a)
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (succ ({a = (let u = (fix (\x: Unit . true )) in 0) , b = ({a = ({a = 0 , b = 1 }.b) , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = 1 }.c) }.b)) ))
({a = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in u) )) , b = ({a = (let u = (((\x: Rec X. X .\y: Nat .x) 1 ) true) in u) , b = (iszero 0) }.b) }.b) , b = ({a = (pred ({a = false , b = 1 }.b)) , b = (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.a)
(fix (\x: Rec X. X . ({a = (( \f: Rec X. X .((f (let u = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) , b = ({a = true , b = false }.b) , c =  (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in u) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .x) false ) true) )) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = (let u = true in 0) , b = (let u = 1 in false) }.a) }.a) ))
(fix (\x: Bool . (let u = (( \f: Unit .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = ({a = false , b = 1 }.b) }.b) )) ) (((\x: Bool .\y: Bool .x) ({a = 1 , b = true , c = 0 }.c) ) false) ) ) (\a: Bool .\b: Bool .a)) in (pred (((\x: Bool .\y: Bool .y) false ) ({a = false , b = 1 }.b)))) ))
(if (( \f: Bool .((f ({a = (let u = false in u) , b = (((\x: Unit .\y: Unit .y) true ) false) }.b) ) ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = (unfold [ Unit ] (fold [ Unit ] true )) , c =  (( \f: Unit .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Bool .\y: Bool .y) false ) 1) ) ) (\a: Nat .\b: Bool .b)) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) then (((\x: Bool .\y: Bool .x) (fix (\x: Bool . (((\x: Unit .\y: Nat .y) (if true then true else true) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) )) ) (let u = ({a = 1 , b = true , c =  0 }.b) in u)) else (iszero (( \f: Bool .((f (( \f: Rec X. X .((f (succ ({a = 1 , b = false }.a)) ) (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = (case <r = (unfold [ Bool ] (fold [ Unit ] false )) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) }.b) ) ) (\a: Rec X. X .\b: Nat .a))))
({a = ({a = (( \f: Unit .((f (fix (\x: Nat . true )) ) (fix (\x: Nat . false )) ) ) (\a: Bool .\b: Bool .b)) , b = (case <l = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero 0) )) )) }.b)
({a = (( \f: Bool .((f (( \f: Nat .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) ) (succ 0) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Unit .\y: Nat .y) ({a = (((\x: Nat .\y: Unit .x) 1 ) true) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) ) ({a = 1 , b = 0 }.b)) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (let u = (let u = ({a = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a)) , b = true }.b) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = (unfold [ Unit ] (fold [ Unit ] true )) }.b) ))) in (unfold [ Nat ] (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] (fix (\x: Nat . false )) )) ))) }.b)
(((\x: Nat .\y: Nat .y) (let u = (( \f: Nat .((f (( \f: Bool .((f (let u = true in 1) ) (pred 0) ) ) (\a: Bool .\b: Unit .a)) ) ({a = 1 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) in ({a = 1 , b = false }.b)) ) (let u = (pred (unfold [ Nat ] (fold [ Rec X. X ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ))) in u))
(( \f: Unit .((f (iszero (let u = ({a = 0 , b = false }.a) in u)) ) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Unit .y) ({a = 0 , b = false , c =  1 }.b) ) (let u = 1 in true)) ) (((\x: Unit .\y: Nat .x) ({a = 0 , b = true , c =  1 }.b) ) true)) ) ) (\a: Rec X. X .\b: Nat .b))
(succ (if ({a = (succ 1) , b = (let u = false in true) }.b) then (case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (succ 1) )) > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = (((\x: Unit .\y: Unit .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) true) in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )))))
(unfold [ Bool ] (fold [ Nat ] (fix (\x: Nat . (let u = (let u = ({a = false , b = 1 }.a) in u) in (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) then (iszero 1) else (if true then true else false))) )) ))
(unfold [ Rec X. X ] (fold [ Bool ] (( \f: Unit .((f (let u = (let u = false in 0) in ({a = true , b = (if false then false else true) }.b)) ) (((\x: Rec X. X .\y: Unit .y) false ) ({a = false , b = true }.b)) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(let u = ({a = ({a = (let u = ({a = 1 , b = true }.a) in u) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .y) false ) false) )) }.a) , b = (let u = (succ (((\x: Nat .\y: Rec X. X .y) (iszero 1) ) (fix (\x: Unit . 0 )))) in ({a = ({a = true , b = 1 }.a) , b = 0 }.a)) }.b) in (fix (\x: Bool . ({a = true , b = (((\x: Nat .\y: Bool .y) false ) 1) }.a) )))
(let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .b))) )) in ({a = (( \f: Unit .((f ({a = 1 , b = (succ 0) }.b) ) (((\x: Unit .\y: Bool .x) 0 ) true) ) ) (\a: Nat .\b: Nat .a)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) )) }.b))
(( \f: Bool .((f ({a = (case <l = (pred (((\x: Nat .\y: Nat .x) 1 ) true)) > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in true) )) , c = (((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Rec X. X .y) false ) true) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b))) }.c) ) ({a = ({a = (succ (case <l = (succ 1) > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = (iszero 0) }.a) }.b) , b = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Unit ] true ))) }.a) ) ) (\a: Unit .\b: Rec X. X .a))
(let u = ({a = (fix (\x: Bool . 0 )) , b = (unfold [ Nat ] (fold [ Unit ] true )) , c =  ({a = (if true then 1 else 1) , b = (pred 0) }.b) }.b) in (let u = ({a = 1 , b = true }.b) in (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) in u)))
(iszero (if (let u = (fix (\x: Bool . false )) in ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) then (((\x: Bool .\y: Unit .y) ({a = true , b = ({a = 0 , b = false }.a) }.a) ) (let u = 0 in u)) else (( \f: Unit .((f (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Bool .y) true ) 0) ) (if false then true else true)) ) (let u = 1 in u) ) ) (\a: Nat .\b: Unit .a))))
(((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Nat .x) (case <r = (((\x: Rec X. X .\y: Bool .y) true ) (iszero 0)) > as Unit of < l = x > => x | < r = y > => y) ) (iszero (pred 0))) ) (fix (\x: Bool . (let u = (iszero (pred 0)) in ({a = (((\x: Unit .\y: Rec X. X .y) false ) false) , b = (if ({a = 1 , b = false }.b) then 0 else (succ 1)) }.a)) )))
(((\x: Unit .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f ({a = 1 , b = true }.b) ) false ) ) (\a: Rec X. X .\b: Unit .b)) )) ) (((\x: Unit .\y: Rec X. X .x) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) , b = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.a) ) (( \f: Rec X. X .((f ({a = (iszero 1) , b = (let u = ({a = 0 , b = true , c =  1 }.b) in ({a = 0 , b = true , c =  1 }.b)) }.b) ) ({a = 0 , b = (((\x: Bool .\y: Rec X. X .x) false ) false) , c =  (succ 0) }.b) ) ) (\a: Unit .\b: Unit .a))))
({a = (if (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) then ({a = (((\x: Bool .\y: Nat .y) true ) false) , b = 1 }.b) else ({a = 1 , b = (((\x: Nat .\y: Unit .y) true ) true) }.a)) , b = (let u = ({a = true , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) }.b) in ({a = (iszero 1) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)) }.b)) , c = ({a = (((\x: Nat .\y: Unit .x) ({a = (let u = 0 in 0) , b = (((\x: Bool .\y: Rec X. X .x) 1 ) false) }.b) ) ({a = true , b = (let u = true in 0) }.a)) , b = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = ({a = (unfold [ Nat ] (fold [ Unit ] true )) , b = true }.b) , c =  ({a = false , b = 1 }.b) }.b) }.a) }.c)
({a = (let u = ({a = 1 , b = false }.a) in u) , b = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (succ 0) )) ) (((\x: Rec X. X .\y: Bool .y) false ) 1) ) ) (\a: Bool .\b: Nat .a)) }.b)
({a = (( \f: Rec X. X .((f (( \f: Unit .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) ) (let u = 1 in 0) ) ) (\a: Nat .\b: Bool .b)) ) (( \f: Unit .((f (pred 1) ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) )) > as Nat of < l = x > => x | < r = y > => y) , c =  (((\x: Rec X. X .\y: Unit .x) (succ (succ (unfold [ Nat ] (fold [ Bool ] 1 )))) ) (( \f: Bool .((f ({a = false , b = true }.b) ) (let u = 0 in false) ) ) (\a: Unit .\b: Nat .a))) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Unit .x) 1 ) (((\x: Unit .\y: Bool .x) true ) true)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 ))) ) (iszero (unfold [ Bool ] (fold [ Rec X. X ] 1 )))) ))
(case <r = (((\x: Nat .\y: Nat .x) (fix (\x: Nat . true )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] true )) ))) > as Bool of < l = x > => x | < r = y > => y)
(case <r = (iszero (pred ({a = 1 , b = false }.a))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = (((\x: Unit .\y: Bool .y) false ) true) , b = (succ 1) }.a) in (let u = (((\x: Unit .\y: Bool .y) false ) true) in (( \f: Bool .((f (let u = true in true) ) true ) ) (\a: Bool .\b: Unit .a)))) ) (case <r = (let u = (( \f: Bool .((f (let u = true in true) ) (let u = 1 in (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Unit .\b: Nat .a)) in u) > as Nat of < l = x > => x | < r = y > => y))
(let u = (pred (fix (\x: Bool . (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ))) in (fix (\x: Nat . ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) )))
(( \f: Nat .((f ({a = (if ({a = (if true then true else false) , b = false }.b) then ({a = 1 , b = true , c = 1 }.c) else (pred ({a = 0 , b = false }.a))) , b = (unfold [ Bool ] (fold [ Unit ] ({a = true , b = (let u = 1 in 1) }.b) )) }.b) ) (unfold [ Unit ] (fold [ Rec X. X ] (succ ({a = 1 , b = 0 }.b)) )) ) ) (\a: Unit .\b: Unit .a))
({a = (case <r = (let u = (let u = ({a = true , b = 1 }.a) in u) in u) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (pred 1) in u) )) }.a)
(fix (\x: Rec X. X . (((\x: Unit .\y: Bool .x) ({a = (((\x: Unit .\y: Rec X. X .y) true ) 1) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) (( \f: Rec X. X .((f (let u = 1 in (fix (\x: Bool . true ))) ) (if (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .a)) then (fix (\x: Bool . false )) else (iszero 1)) ) ) (\a: Nat .\b: Nat .a))) ))
(let u = (((\x: Nat .\y: Unit .y) (case <r = (let u = 0 in (((\x: Unit .\y: Unit .y) false ) false)) > as Nat of < l = x > => x | < r = y > => y) ) ({a = ({a = (if false then (let u = 1 in true) else true) , b = (let u = true in true) }.b) , b = ({a = (( \f: Bool .((f 0 ) (((\x: Rec X. X .\y: Unit .x) 1 ) true) ) ) (\a: Nat .\b: Unit .a)) , b = (( \f: Unit .((f true ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Bool .b)) , c = (pred ({a = true , b = 1 }.b)) }.c) }.b)) in (let u = (((\x: Unit .\y: Bool .x) (((\x: Nat .\y: Rec X. X .x) true ) (let u = true in false)) ) (case <r = (fix (\x: Bool . false )) > as Nat of < l = x > => x | < r = y > => y)) in ({a = (if true then 0 else 1) , b = ({a = 0 , b = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = 1 }.c) }.b)))
(fix (\x: Unit . ({a = (pred (pred ({a = 1 , b = 1 }.b))) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) , c = (let u = false in (unfold [ Nat ] (fold [ Nat ] 0 ))) }.c) ))
(( \f: Bool .((f (let u = (fix (\x: Rec X. X . ({a = 1 , b = false }.a) )) in (( \f: Rec X. X .((f ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) , b = (fix (\x: Unit . 0 )) }.b) ) (let u = (fix (\x: Rec X. X . (if false then false else false) )) in (let u = false in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )))) ) ) (\a: Nat .\b: Rec X. X .a))) ) (fix (\x: Bool . (( \f: Bool .((f (if false then 0 else 1) ) 1 ) ) (\a: Unit .\b: Bool .b)) )) ) ) (\a: Bool .\b: Nat .a))
({a = (( \f: Bool .((f ({a = false , b = 1 }.b) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) , b = (( \f: Nat .((f ({a = ({a = 0 , b = false }.a) , b = ({a = true , b = true }.b) , c =  (( \f: Unit .((f 0 ) (let u = false in 0) ) ) (\a: Nat .\b: Nat .b)) }.b) ) (fix (\x: Rec X. X . (let u = true in u) )) ) ) (\a: Bool .\b: Rec X. X .b)) }.a)
(fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) )) )) ))
({a = (iszero ({a = (( \f: Bool .((f 1 ) (fix (\x: Nat . 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (((\x: Unit .\y: Unit .y) true ) 0) }.b)) , b = ({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 1 )) , b = ({a = 1 , b = true , c = 0 }.c) }.b) , b = (case <l = (succ ({a = 0 , b = 1 }.b)) > as Unit of < l = x > => x | < r = y > => y) }.b) }.a)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (((\x: Nat .\y: Bool .y) ({a = 1 , b = false }.b) ) ({a = 0 , b = true }.a)) , b = (let u = (succ 0) in (( \f: Bool .((f ({a = 1 , b = true , c =  1 }.b) ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Bool .b))) , c = (case <l = (pred 1) > as Rec X. X of < l = x > => x | < r = y > => y) }.c) ))
(( \f: Unit .((f (let u = (((\x: Rec X. X .\y: Nat .y) (if (if false then true else false) then (unfold [ Bool ] (fold [ Unit ] true )) else true) ) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b))) in (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Unit .x) false ) true) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )))) ) (fix (\x: Nat . (let u = ({a = ({a = 1 , b = true }.a) , b = false , c = 1 }.c) in (fix (\x: Bool . ({a = 1 , b = true }.b) ))) )) ) ) (\a: Nat .\b: Unit .b))
(unfold [ Rec X. X ] (fold [ Bool ] (( \f: Rec X. X .((f (let u = 0 in (let u = true in true)) ) (( \f: Rec X. X .((f (iszero 1) ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Unit .b)) ))
(unfold [ Bool ] (fold [ Nat ] (case <r = ({a = (iszero 1) , b = ({a = ({a = 0 , b = true , c =  1 }.b) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.a) }.b) > as Nat of < l = x > => x | < r = y > => y) ))
(if (unfold [ Unit ] (fold [ Unit ] ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) , c =  ({a = 1 , b = (let u = 0 in false) , c = 1 }.c) }.b) )) then (let u = (let u = (pred (succ 0)) in ({a = true , b = (let u = true in u) }.b)) in u) else (fix (\x: Unit . (case <r = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) )))
(fix (\x: Nat . (fix (\x: Nat . (iszero (pred (((\x: Rec X. X .\y: Rec X. X .y) true ) 1))) )) ))
(fix (\x: Bool . ({a = (let u = ({a = ({a = true , b = 0 }.b) , b = 0 }.b) in u) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , c = ({a = (let u = 0 in true) , b = 0 }.b) }.c) ))
(if (if (let u = (((\x: Unit .\y: Nat .y) false ) true) in ({a = 0 , b = ({a = 0 , b = true , c =  1 }.b) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.b)) then ({a = 1 , b = false , c =  (fix (\x: Rec X. X . 0 )) }.b) else (if (( \f: Unit .((f false ) (((\x: Unit .\y: Rec X. X .x) true ) false) ) ) (\a: Unit .\b: Unit .b)) then ({a = true , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) }.b) else ({a = 1 , b = false , c =  0 }.b))) then (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) in u) else ({a = (succ ({a = 1 , b = true }.a)) , b = (( \f: Bool .((f (let u = false in u) ) (iszero ({a = 1 , b = 1 }.b)) ) ) (\a: Bool .\b: Unit .b)) , c = ({a = 1 , b = false , c = 0 }.c) }.c))
(let u = (if (if (if true then ({a = false , b = 0 }.a) else ({a = 1 , b = false }.b)) then (let u = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) in true) else (unfold [ Bool ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) ))) then (succ ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 0 in 0) }.b)) else (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Unit .x) 1 ) ({a = 0 , b = true }.b)) ))) in (let u = (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) (pred 0) ) ) (\a: Unit .\b: Nat .a)) in (let u = ({a = (((\x: Nat .\y: Nat .y) false ) false) , b = (let u = true in u) }.b) in u)))
(succ (if ({a = (pred 1) , b = (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then true else true) )) > as Unit of < l = x > => x | < r = y > => y) }.b) then ({a = (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Nat .x) 1 ) false) )) , b = (fix (\x: Bool . (let u = true in 1) )) }.b) else (((\x: Nat .\y: Bool .y) (fix (\x: Rec X. X . (case <r = (((\x: Nat .\y: Rec X. X .y) true ) true) > as Bool of < l = x > => x | < r = y > => y) )) ) ({a = (( \f: Unit .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b))))
({a = (((\x: Unit .\y: Nat .x) (( \f: Unit .((f ({a = 1 , b = true , c = 1 }.c) ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Unit .\y: Rec X. X .x) true ) (((\x: Bool .\y: Unit .y) false ) true))) , b = (((\x: Bool .\y: Rec X. X .x) (((\x: Bool .\y: Bool .x) (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) ) true) ) (( \f: Unit .((f ({a = 0 , b = true }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Bool .b))) }.b)
(unfold [ Nat ] (fold [ Nat ] ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) , b = true }.b) }.b) ))
(((\x: Unit .\y: Unit .y) ({a = ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) (if false then true else false)) , b = ({a = 0 , b = (let u = 1 in u) }.b) }.b) , b = (fix (\x: Rec X. X . ({a = 0 , b = true }.b) )) }.b) ) (let u = (unfold [ Nat ] (fold [ Bool ] ({a = true , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) }.b) )) in (let u = ({a = ({a = true , b = 0 }.a) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.b) in u)))
(unfold [ Bool ] (fold [ Bool ] (case <l = (let u = (((\x: Bool .\y: Bool .x) 0 ) (let u = false in false)) in u) > as Bool of < l = x > => x | < r = y > => y) ))
(unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Nat . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = ({a = 0 , b = true , c = 0 }.c) in u) )) )) ))
(if ({a = (case <r = (if false then true else true) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Unit .y) ({a = false , b = 1 }.a) ) 0) }.a) then (let u = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = (iszero 1) }.a) in (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )))) else (((\x: Nat .\y: Bool .x) ({a = (pred (let u = 1 in u)) , b = (let u = (((\x: Bool .\y: Rec X. X .x) 1 ) false) in 0) }.b) ) (case <r = ({a = 0 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) > as Bool of < l = x > => x | < r = y > => y)))
(unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f (pred (fix (\x: Nat . 1 ))) ) (case <l = (let u = false in 0) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)) ))
({a = (((\x: Nat .\y: Nat .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) ) ({a = (if true then 0 else 0) , b = false }.a)) , b = (if (let u = false in u) then (( \f: Unit .((f ({a = 1 , b = true , c =  0 }.b) ) ({a = 0 , b = false }.b) ) ) (\a: Unit .\b: Unit .b)) else (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in true)) , c = (( \f: Unit .((f (let u = (case <l = (let u = 0 in 0) > as Nat of < l = x > => x | < r = y > => y) in (case <l = (let u = 0 in 1) > as Nat of < l = x > => x | < r = y > => y)) ) (((\x: Unit .\y: Unit .y) (( \f: Unit .((f (unfold [ Bool ] (fold [ Nat ] true )) ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) (pred 0)) ) ) (\a: Bool .\b: Bool .a)) }.c)
(unfold [ Unit ] (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (if ({a = false , b = true }.b) then (let u = true in ({a = 0 , b = false }.a)) else (unfold [ Bool ] (fold [ Nat ] 0 ))) )) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .y) (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (let u = false in true) ) false ) ) (\a: Unit .\b: Nat .b))) ))
(((\x: Rec X. X .\y: Unit .y) ({a = (case <r = (((\x: Nat .\y: Nat .y) (iszero 1) ) false) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (((\x: Bool .\y: Unit .y) false ) 1) ) (let u = false in 0) ) ) (\a: Rec X. X .\b: Bool .b)) }.a) ) (iszero (fix (\x: Bool . 0 ))))
(pred (let u = (((\x: Rec X. X .\y: Bool .x) 0 ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) in u))
(let u = ({a = (let u = (let u = 0 in 1) in u) , b = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) , b = ({a = 0 , b = true }.b) }.a) }.b) in (if (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = false , c =  0 }.b) )) then (( \f: Bool .((f ({a = 0 , b = false , c =  1 }.b) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Unit .\b: Bool .b)) else (((\x: Unit .\y: Nat .y) false ) (let u = true in true))))
(let u = (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (pred 1) ))) in u)
(( \f: Bool .((f ({a = ({a = (iszero (let u = true in ({a = 1 , b = false }.a))) , b = (let u = 1 in ({a = 1 , b = true }.b)) }.b) , b = (fix (\x: Unit . ({a = 1 , b = (let u = true in true) }.a) )) }.b) ) (if ({a = (let u = false in false) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) }.b) then (case <l = (pred (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true)) > as Unit of < l = x > => x | < r = y > => y) else (( \f: Rec X. X .((f (fix (\x: Nat . 1 )) ) (if false then 0 else 0) ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Nat .\b: Nat .a))
(( \f: Nat .((f (( \f: Nat .((f (fix (\x: Nat . (let u = 0 in u) )) ) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in u) ) ) (\a: Bool .\b: Bool .b)) ) (if (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) (((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Rec X. X .y) false ) true) ) false)) then (if (let u = true in u) then (pred 0) else 0) else ({a = (case <l = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = false , c = (pred 1) }.c) }.b)) ) ) (\a: Rec X. X .\b: Nat .b))
(if (( \f: Rec X. X .((f ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in true) )) , b = (let u = 1 in u) }.a) ) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Unit . false )) ) true) , c =  (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) then ({a = (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) false ) 0) ) ({a = false , b = (let u = 0 in 0) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = (fix (\x: Nat . 1 )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , c =  (let u = 1 in 1) }.b) }.a) else (if (( \f: Nat .((f (iszero (( \f: Bool .((f 0 ) ({a = 1 , b = 1 }.b) ) ) (\a: Unit .\b: Nat .a))) ) (unfold [ Unit ] (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) ) ) (\a: Nat .\b: Rec X. X .b)) then (let u = (let u = true in false) in ({a = 1 , b = 0 }.b)) else ({a = (((\x: Unit .\y: Unit .y) (let u = true in u) ) 1) , b = (unfold [ Nat ] (fold [ Unit ] true )) }.a)))
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (let u = (( \f: Nat .((f true ) (let u = true in true) ) ) (\a: Bool .\b: Nat .b)) in ({a = true , b = 1 }.a)) in (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = true }.b) ))) ))
(((\x: Unit .\y: Nat .x) (if ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) then (( \f: Unit .((f (if true then ({a = 0 , b = true , c = 0 }.c) else (let u = 1 in 0)) ) (unfold [ Nat ] (fold [ Nat ] 1 )) ) ) (\a: Nat .\b: Bool .b)) else ({a = (((\x: Bool .\y: Unit .x) (let u = 0 in u) ) true) , b = (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in u) , c = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) }.c)) ) ({a = (((\x: Bool .\y: Rec X. X .x) (let u = false in (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .a))) ) (iszero 0)) , b = (let u = (if (iszero ({a = false , b = 1 }.b)) then ({a = true , b = 0 }.b) else (let u = 1 in 0)) in (if (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .a)) then (pred 0) else ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )))) }.a))
(let u = ({a = (let u = (fix (\x: Nat . 1 )) in false) , b = (pred 1) }.b) in u)
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] false )) ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ) (((\x: Bool .\y: Unit .x) ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) , b = (fix (\x: Rec X. X . 0 )) }.b) ) ({a = ({a = false , b = (((\x: Rec X. X .\y: Unit .x) 0 ) true) }.a) , b = ({a = 1 , b = ({a = 1 , b = false }.b) , c =  1 }.b) }.b)) ) ) (\a: Nat .\b: Unit .a))
(( \f: Unit .((f (let u = (unfold [ Bool ] (fold [ Nat ] 1 )) in ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = (unfold [ Unit ] (fold [ Bool ] true )) }.a)) ) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (if false then true else false) in ({a = true , b = ({a = 0 , b = true , c = 0 }.c) }.a)) , c = (unfold [ Unit ] (fold [ Rec X. X ] (succ (pred 1)) )) }.c) ) ) (\a: Rec X. X .\b: Unit .a))
(((\x: Bool .\y: Nat .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f false ) (iszero 0) ) ) (\a: Unit .\b: Rec X. X .b)) )) ) (( \f: Nat .((f ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) , b = (iszero 0) }.b) ) ({a = (((\x: Bool .\y: Unit .y) false ) 1) , b = (((\x: Bool .\y: Unit .y) true ) false) , c =  ({a = 0 , b = false , c = 1 }.c) }.b) ) ) (\a: Bool .\b: Nat .a)))
({a = (((\x: Unit .\y: Nat .x) (( \f: Nat .((f (let u = (if true then false else true) in 0) ) (let u = true in ({a = 0 , b = false , c = 0 }.c)) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Bool .\y: Nat .x) (iszero 1) ) false)) , b = (case <r = (fix (\x: Unit . (let u = 1 in true) )) > as Bool of < l = x > => x | < r = y > => y) , c = ({a = ({a = (if false then false else (if true then false else false)) , b = (( \f: Bool .((f 1 ) (((\x: Rec X. X .\y: Nat .x) 1 ) false) ) ) (\a: Bool .\b: Unit .b)) }.b) , b = (((\x: Bool .\y: Unit .x) false ) false) , c = ({a = (fix (\x: Unit . 0 )) , b = true , c = 0 }.c) }.c) }.c)
(( \f: Rec X. X .((f (let u = ({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u) , b = (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] true )) ) (let u = 1 in true) ) ) (\a: Unit .\b: Unit .a)) , c = ({a = true , b = 1 }.b) }.c) in u) ) (case <l = (( \f: Rec X. X .((f ({a = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .a)) , b = (let u = false in 0) }.b) ) (fix (\x: Unit . 0 )) ) ) (\a: Bool .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a))
(succ (pred (((\x: Rec X. X .\y: Bool .y) (fix (\x: Bool . (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) ) (( \f: Nat .((f (let u = true in ({a = false , b = 0 }.b)) ) (fix (\x: Bool . (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ) (\a: Rec X. X .\b: Unit .b)))))
(( \f: Nat .((f (if (if (( \f: Rec X. X .((f (iszero 1) ) (let u = 0 in true) ) ) (\a: Nat .\b: Rec X. X .b)) then ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = false , c =  1 }.b) else ({a = 1 , b = false }.b)) then (( \f: Bool .((f (((\x: Bool .\y: Unit .y) true ) (unfold [ Bool ] (fold [ Unit ] true ))) ) (let u = false in u) ) ) (\a: Unit .\b: Unit .a)) else (fix (\x: Nat . false ))) ) (case <r = (( \f: Nat .((f (((\x: Unit .\y: Nat .y) (let u = false in u) ) (((\x: Nat .\y: Rec X. X .y) true ) true)) ) ({a = 1 , b = (let u = 1 in true) , c =  0 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a))
({a = ({a = (( \f: Unit .((f (((\x: Unit .\y: Nat .x) false ) true) ) ({a = (((\x: Bool .\y: Unit .x) true ) true) , b = 0 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) }.b) , b = (pred (let u = (let u = 0 in 1) in u)) }.b)
(((\x: Nat .\y: Nat .x) (fix (\x: Bool . ({a = ({a = 1 , b = 1 }.b) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) , c =  (succ ({a = true , b = 1 }.b)) }.b) )) ) (( \f: Nat .((f (( \f: Rec X. X .((f ({a = ({a = 0 , b = false , c =  1 }.b) , b = (let u = ({a = 1 , b = true }.b) in 0) }.a) ) (unfold [ Nat ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = (unfold [ Nat ] (fold [ Bool ] 0 )) in (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .b))) ) ) (\a: Rec X. X .\b: Nat .a)))
(pred (let u = (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Unit .x) false ) true) ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b))) in (let u = (let u = 1 in u) in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))))
(succ (pred (( \f: Nat .((f (pred 1) ) 0 ) ) (\a: Unit .\b: Unit .a))))
(if (let u = (case <r = ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , b = (let u = true in u) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = ({a = (if false then 0 else 0) , b = (fix (\x: Nat . false )) , c =  0 }.b) , b = (iszero (pred 1)) }.b)) then (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = (succ 0) , b = false , c = (let u = 1 in 1) }.c) )) > as Unit of < l = x > => x | < r = y > => y) else (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = false in 1) )) in (if (((\x: Bool .\y: Bool .y) (fix (\x: Nat . true )) ) (((\x: Rec X. X .\y: Bool .x) true ) false)) then (fix (\x: Rec X. X . 1 )) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) )))))
(((\x: Unit .\y: Nat .x) (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) in ({a = ({a = 1 , b = true , c = 1 }.c) , b = 1 }.b)) ) (let u = ({a = (((\x: Nat .\y: Rec X. X .x) 0 ) true) , b = (let u = 1 in false) }.a) in ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then 0 else 0) )) }.a)))
({a = ({a = ({a = (fix (\x: Rec X. X . 1 )) , b = ({a = (fix (\x: Nat . 0 )) , b = false }.b) }.a) , b = (if (((\x: Rec X. X .\y: Nat .y) true ) false) then (((\x: Rec X. X .\y: Bool .x) 1 ) false) else (let u = 1 in (let u = false in 1))) }.b) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = true , b = 1 }.b) , b = ({a = 1 , b = (((\x: Rec X. X .\y: Nat .x) false ) false) , c =  (((\x: Bool .\y: Bool .x) 0 ) true) }.b) , c =  (((\x: Unit .\y: Unit .y) false ) 0) }.b) )) , c =  (let u = ({a = 0 , b = (let u = false in u) }.a) in u) }.b)
(fix (\x: Bool . (( \f: Nat .((f (let u = (let u = (unfold [ Unit ] (fold [ Nat ] ({a = 0 , b = false , c =  0 }.b) )) in (let u = false in (let u = true in 0))) in u) ) (((\x: Unit .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Nat ] (let u = 0 in false) )) ) ({a = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .a)) , b = (((\x: Nat .\y: Unit .x) 0 ) true) }.b)) ) ) (\a: Nat .\b: Bool .b)) ))
(((\x: Unit .\y: Nat .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = (fix (\x: Unit . (iszero (pred 1)) )) in ({a = false , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.a)) )) ) (case <r = ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .a)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
({a = (fix (\x: Unit . (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] true )) )) )) , b = (((\x: Bool .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . (succ 0) )) )) ) (fix (\x: Bool . (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .a)) ))) }.b)
(unfold [ Unit ] (fold [ Unit ] ({a = (succ ({a = 0 , b = true }.a)) , b = (((\x: Bool .\y: Rec X. X .y) ({a = false , b = false }.b) ) ({a = (((\x: Unit .\y: Nat .y) false ) 0) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  0 }.b)) , c =  (let u = (unfold [ Unit ] (fold [ Unit ] false )) in ({a = false , b = (let u = 0 in 1) }.b)) }.b) ))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (fix (\x: Nat . (if (unfold [ Nat ] (fold [ Bool ] true )) then 1 else 0) )) }.a)
(case <r = (iszero ({a = (((\x: Unit .\y: Rec X. X .y) false ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))) , b = ({a = false , b = false }.b) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <r = ({a = (let u = (( \f: Unit .((f (let u = (let u = 1 in u) in (let u = true in 1)) ) (pred 0) ) ) (\a: Nat .\b: Unit .b)) in (let u = (((\x: Nat .\y: Unit .y) false ) true) in 0)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = (let u = true in true) , b = 1 }.a) )) , c =  (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Bool .y) true ) 0) ) (if true then true else false)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(case <l = (pred (fix (\x: Unit . ({a = 1 , b = true }.a) ))) > as Nat of < l = x > => x | < r = y > => y)
(let u = (fix (\x: Rec X. X . ({a = (pred (let u = 1 in u)) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) (let u = true in true)) }.b) )) in (fix (\x: Rec X. X . (pred (succ ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )))) )))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Nat . ({a = (((\x: Rec X. X .\y: Unit .y) false ) false) , b = (let u = false in true) }.b) )) ))
({a = (if (((\x: Unit .\y: Rec X. X .y) ({a = 0 , b = (unfold [ Nat ] (fold [ Bool ] true )) , c =  0 }.b) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false ))) then (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .a)) else (case <r = false > as Nat of < l = x > => x | < r = y > => y)) , b = (pred ({a = (case <l = (let u = 0 in 1) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . false )) }.a)) }.a)
(( \f: Unit .((f (if (( \f: Bool .((f ({a = true , b = 0 }.a) ) true ) ) (\a: Bool .\b: Nat .a)) then (( \f: Rec X. X .((f true ) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .a)) else ({a = ({a = 0 , b = 1 }.b) , b = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.b)) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) (((\x: Rec X. X .\y: Unit .x) true ) true)) ) (if true then true else (((\x: Nat .\y: Unit .x) false ) true))) )) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (case <r = (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true ))) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = (((\x: Nat .\y: Unit .y) ({a = true , b = true }.b) ) ({a = 0 , b = true , c = 1 }.c)) in (( \f: Unit .((f (if false then 1 else 0) ) ({a = 1 , b = false }.a) ) ) (\a: Bool .\b: Bool .b))) )) }.a)
(unfold [ Rec X. X ] (fold [ Bool ] ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = false }.b) )) , c =  (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = false }.a) )) }.b) ))
(pred (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (fix (\x: Unit . false )) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) )) )))
(succ (pred (((\x: Rec X. X .\y: Bool .x) ({a = 0 , b = 1 }.b) ) (let u = false in u))))
(((\x: Nat .\y: Nat .y) (let u = (unfold [ Unit ] (fold [ Bool ] (let u = ({a = 1 , b = ({a = 1 , b = false , c =  0 }.b) }.a) in (let u = 1 in 0)) )) in (((\x: Nat .\y: Rec X. X .x) (if true then false else false) ) (((\x: Unit .\y: Rec X. X .x) true ) false))) ) (case <r = (iszero (((\x: Nat .\y: Unit .x) ({a = 1 , b = (succ 0) }.b) ) (let u = true in true))) > as Unit of < l = x > => x | < r = y > => y))
({a = (let u = (let u = (if (let u = false in true) then ({a = false , b = 0 }.a) else true) in (((\x: Nat .\y: Rec X. X .y) true ) 0)) in (let u = ({a = 1 , b = true , c = 1 }.c) in u)) , b = (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Unit ] (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .a)) )) )) }.a)
({a = ({a = ({a = (if false then (((\x: Rec X. X .\y: Nat .x) 0 ) true) else 1) , b = (if true then true else false) , c = (pred 1) }.c) , b = ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = true }.b) }.a) , b = (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = true , b = 0 }.b) ) ) (\a: Nat .\b: Bool .b)) ))) }.b)
({a = (let u = (if ({a = true , b = 0 }.a) then ({a = (((\x: Unit .\y: Bool .x) 1 ) false) , b = (unfold [ Nat ] (fold [ Bool ] true )) , c =  ({a = false , b = 1 }.b) }.b) else ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false ))) in u) , b = (let u = ({a = (((\x: Bool .\y: Bool .x) (unfold [ Unit ] (fold [ Nat ] false )) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (let u = (if true then 1 else 1) in ({a = 0 , b = 0 }.b)) }.a) in u) }.b)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Nat .\y: Unit .y) (let u = ({a = false , b = 1 }.a) in u) ) (let u = true in (let u = 1 in 1))) ))
(( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) )) ) (unfold [ Nat ] (fold [ Nat ] ({a = ({a = true , b = 1 }.b) , b = (let u = (let u = false in 0) in (let u = 1 in false)) , c =  (((\x: Unit .\y: Bool .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) 0) }.b) )) ) ) (\a: Nat .\b: Unit .a))
(let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (pred (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a))) )) in ({a = ({a = 1 , b = (unfold [ Nat ] (fold [ Bool ] true )) }.a) , b = ({a = true , b = 1 }.a) }.a))
({a = (let u = (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .y) false ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (if true then false else true) )) , b = ({a = (let u = false in false) , b = (((\x: Bool .\y: Rec X. X .x) true ) true) }.b) }.b)) , b = (unfold [ Bool ] (fold [ Bool ] (let u = (fix (\x: Nat . false )) in 1) )) }.a)
(let u = ({a = (let u = (((\x: Nat .\y: Bool .y) true ) true) in ({a = 1 , b = false , c = 1 }.c)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = 0 in true) )) )) }.a) in (let u = (( \f: Nat .((f (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] 0 )) )) ) (((\x: Bool .\y: Rec X. X .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )) ) true) ) ) (\a: Unit .\b: Bool .a)) in u))
(let u = (let u = (fix (\x: Nat . (let u = 1 in 1) )) in (let u = ({a = (fix (\x: Nat . false )) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) true) }.b) in u)) in ({a = ({a = (let u = false in false) , b = 0 }.b) , b = ({a = (let u = 1 in u) , b = true , c =  (fix (\x: Bool . 0 )) }.b) }.b))
(unfold [ Nat ] (fold [ Rec X. X ] ({a = (case <l = (let u = true in 0) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Nat .\y: Unit .y) true ) false) , b = (let u = (((\x: Unit .\y: Unit .y) true ) ({a = 0 , b = 1 }.b)) in (((\x: Bool .\y: Bool .y) true ) 1)) }.b) }.b) ))
({a = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f (fix (\x: Rec X. X . (iszero 1) )) ) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = 0 , b = true , c =  0 }.b) , c =  (((\x: Rec X. X .\y: Bool .x) 1 ) false) }.b) ) ) (\a: Bool .\b: Nat .a)) )) , b = (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) (( \f: Unit .((f false ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Unit .b))) ) (if (iszero (pred 0)) then (( \f: Bool .((f false ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Nat .b)) else (((\x: Bool .\y: Rec X. X .x) true ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)))) }.b)
(let u = (if (( \f: Bool .((f ({a = 0 , b = false }.b) ) (( \f: Bool .((f true ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .b)) then (( \f: Nat .((f (((\x: Unit .\y: Nat .y) true ) false) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = true }.b) )) ) ) (\a: Bool .\b: Bool .b)) else (( \f: Unit .((f (if true then true else true) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .b))) in (( \f: Unit .((f ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .y) true ) 0) )) , b = (let u = (fix (\x: Rec X. X . true )) in u) , c =  (let u = 1 in u) }.b) ) (( \f: Bool .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) (iszero (pred 0)) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .b)))
(iszero (case <l = (case <l = (( \f: Unit .((f (pred 0) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (if (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = ({a = 0 , b = true , c =  1 }.b) , c =  (((\x: Bool .\y: Rec X. X .y) true ) 0) }.b) )) )) then (((\x: Bool .\y: Rec X. X .x) (iszero (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true)) ) (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) in ({a = (fix (\x: Bool . true )) , b = 0 }.a))) else (case <r = (( \f: Bool .((f ({a = 1 , b = false , c =  0 }.b) ) ({a = false , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y)) in ({a = ({a = true , b = 0 }.a) , b = (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.b))
(let u = ({a = (((\x: Bool .\y: Unit .y) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (unfold [ Unit ] (fold [ Bool ] true ))) , b = (if (let u = false in u) then ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) else 1) }.a) in u)
(((\x: Nat .\y: Bool .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (let u = true in false) in u) )) ) ({a = ({a = 0 , b = false }.a) , b = (if (let u = true in u) then true else false) }.b))
(if (let u = (if ({a = false , b = 1 }.a) then (let u = false in u) else (((\x: Bool .\y: Unit .y) true ) true)) in u) then ({a = (case <l = ({a = (if false then 1 else 1) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (succ ({a = 0 , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b)) }.b) else (((\x: Bool .\y: Bool .y) ({a = (((\x: Nat .\y: Nat .x) 0 ) true) , b = ({a = true , b = 1 }.a) }.b) ) ({a = (pred ({a = 1 , b = 1 }.b)) , b = (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Rec X. X .y) false ) true) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false ))) }.a)))
({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = 1 , b = false , c = 0 }.c) ) ({a = (fix (\x: Rec X. X . 0 )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) }.a) ) ) (\a: Unit .\b: Unit .a)) ) (if ({a = 1 , b = true }.b) then (unfold [ Bool ] (fold [ Unit ] 0 )) else 1) ) ) (\a: Bool .\b: Unit .a)) , b = (unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .y) true ) true) )) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Nat .\b: Nat .a)) )) }.a)
(let u = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Bool .((f (let u = true in 1) ) (case <l = (if false then 0 else 1) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)) )) in u)
(unfold [ Bool ] (fold [ Nat ] (let u = (succ (succ 1)) in (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a))) ))
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = (let u = 1 in u) , b = (((\x: Bool .\y: Bool .x) 1 ) false) }.b) ) (fix (\x: Nat . 1 )) ) ) (\a: Rec X. X .\b: Nat .b)) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) ) (if false then 1 else 1) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Bool .a)) ))
({a = (( \f: Bool .((f (let u = (((\x: Rec X. X .\y: Bool .x) false ) true) in u) ) (case <r = (let u = (if true then true else false) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) , b = ({a = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in u) , b = (let u = ({a = ({a = false , b = 0 }.b) , b = false }.b) in (let u = false in u)) , c = ({a = (if false then 0 else 1) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , c = (( \f: Nat .((f (fix (\x: Bool . 1 )) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.c) }.c) }.b)
(( \f: Nat .((f ({a = (unfold [ Bool ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Bool .x) true ) true) ) (succ 1)) )) , b = (( \f: Unit .((f (let u = ({a = 1 , b = false , c =  1 }.b) in u) ) (case <r = ({a = ({a = false , b = 1 }.a) , b = ({a = false , b = 1 }.b) }.a) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) ({a = ({a = (fix (\x: Unit . 1 )) , b = false , c = 0 }.c) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.a) )) }.b) ) ) (\a: Bool .\b: Nat .b))
(let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (case <r = ({a = (((\x: Bool .\y: Rec X. X .y) false ) 0) , b = ({a = (let u = 1 in u) , b = true , c =  (let u = 0 in 0) }.b) , c =  (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) > as Unit of < l = x > => x | < r = y > => y) )) in (let u = (if (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) then (if false then true else false) else (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = true }.b) ))) in u))
(let u = ({a = (let u = ({a = (pred 0) , b = true , c =  ({a = 1 , b = 1 }.b) }.b) in (unfold [ Rec X. X ] (fold [ Nat ] (let u = 0 in 1) ))) , b = (((\x: Bool .\y: Bool .y) true ) (let u = true in u)) }.a) in u)
(case <r = ({a = (let u = true in 0) , b = (let u = true in u) , c =  (let u = (let u = 1 in 1) in u) }.b) > as Bool of < l = x > => x | < r = y > => y)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = ({a = (pred 1) , b = (let u = false in true) }.a) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) }.b) in ({a = (let u = (((\x: Nat .\y: Bool .x) false ) (let u = false in u)) in (succ 0)) , b = (( \f: Bool .((f (((\x: Nat .\y: Nat .y) false ) ({a = true , b = false }.b)) ) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Nat .b)) }.a)) ))
(pred (((\x: Rec X. X .\y: Nat .x) (succ (if false then ({a = false , b = 1 }.b) else (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))) ) (let u = (fix (\x: Nat . true )) in u)))
(if (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .x) (let u = (((\x: Unit .\y: Nat .y) false ) false) in u) ) (( \f: Nat .((f (fix (\x: Nat . true )) ) (iszero 0) ) ) (\a: Bool .\b: Unit .a))) ) (((\x: Unit .\y: Bool .x) (let u = (((\x: Bool .\y: Nat .y) true ) true) in u) ) ({a = (fix (\x: Unit . true )) , b = (let u = true in u) }.b)) ) ) (\a: Unit .\b: Bool .a)) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) else (let u = (((\x: Nat .\y: Bool .y) (let u = true in (if true then true else false)) ) (fix (\x: Unit . false ))) in ({a = (fix (\x: Bool . 1 )) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)) }.a)))
(((\x: Unit .\y: Unit .y) (case <r = (case <r = (iszero (fix (\x: Bool . 0 ))) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (let u = false in u)) ) (( \f: Rec X. X .((f (if true then false else false) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(pred ({a = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true )) in u) , b = (succ 0) }.b))
(case <l = (let u = ({a = (((\x: Nat .\y: Bool .y) true ) ({a = true , b = true }.b)) , b = (((\x: Unit .\y: Bool .x) 0 ) false) }.b) in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = false in 1) ))) > as Nat of < l = x > => x | < r = y > => y)
({a = (fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Nat ] 1 )) )) )) )) , b = (if (let u = ({a = ({a = false , b = 1 }.a) , b = ({a = false , b = 1 }.b) }.a) in (let u = ({a = true , b = (let u = 0 in 0) }.a) in u)) then ({a = (let u = 0 in u) , b = (( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] true )) ) true ) ) (\a: Rec X. X .\b: Unit .a)) , c =  ({a = ({a = false , b = ({a = 0 , b = false }.a) }.b) , b = (fix (\x: Unit . (((\x: Rec X. X .\y: Nat .y) true ) false) )) }.a) }.b) else ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Unit .x) false ) (((\x: Rec X. X .\y: Rec X. X .y) true ) false)) }.b)) , c = (let u = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Bool ] 1 )) ) (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Bool .b)) in u) }.c)
(if (((\x: Unit .\y: Unit .y) (let u = ({a = 0 , b = (iszero 1) , c =  1 }.b) in u) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (iszero 0) ))) then ({a = (if false then ({a = 0 , b = true , c =  1 }.b) else true) , b = (case <l = (let u = 1 in u) > as Nat of < l = x > => x | < r = y > => y) }.b) else (((\x: Nat .\y: Bool .y) ({a = ({a = 0 , b = false , c = 1 }.c) , b = (( \f: Nat .((f ({a = 1 , b = false , c =  1 }.b) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  (if (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) then 1 else (((\x: Nat .\y: Rec X. X .y) true ) 0)) }.b) ) (succ (let u = 0 in u))))
(if (( \f: Nat .((f ({a = true , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.a) ) (unfold [ Nat ] (fold [ Nat ] (((\x: Rec X. X .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a))) )) ) ) (\a: Rec X. X .\b: Unit .b)) then (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Rec X. X . (let u = 0 in u) )) )) else (case <l = (pred ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 ))) > as Unit of < l = x > => x | < r = y > => y))
(case <r = (if (fix (\x: Bool . (unfold [ Unit ] (fold [ Bool ] false )) )) then (((\x: Rec X. X .\y: Bool .x) (let u = false in true) ) (iszero 1)) else ({a = 1 , b = true , c =  (fix (\x: Bool . 0 )) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (((\x: Rec X. X .\y: Rec X. X .y) (if (((\x: Nat .\y: Rec X. X .x) ({a = true , b = true }.b) ) ({a = 0 , b = false , c =  1 }.b)) then (iszero 1) else (( \f: Bool .((f (((\x: Nat .\y: Bool .y) true ) false) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ) (\a: Unit .\b: Rec X. X .a))) ) (( \f: Rec X. X .((f (succ 1) ) (unfold [ Unit ] (fold [ Rec X. X ] 0 )) ) ) (\a: Nat .\b: Bool .a))) , b = (unfold [ Bool ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) )) }.a)
({a = (let u = (((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) 0) in ({a = (if false then 1 else 0) , b = ({a = 0 , b = true , c =  1 }.b) , c = ({a = ({a = 0 , b = true , c = 0 }.c) , b = (let u = 1 in true) }.a) }.c)) , b = ({a = (( \f: Rec X. X .((f (( \f: Unit .((f (succ 1) ) ({a = 1 , b = true }.a) ) ) (\a: Nat .\b: Nat .a)) ) ({a = (let u = ({a = 1 , b = true }.b) in ({a = 1 , b = false }.a)) , b = (let u = false in (((\x: Unit .\y: Unit .y) true ) true)) }.a) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = (let u = true in (fix (\x: Rec X. X . true ))) , b = (fix (\x: Unit . 0 )) }.a) , c = (if ({a = 0 , b = false }.b) then (let u = true in 0) else (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) }.c) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .x) (( \f: Bool .((f true ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .x) false ) true) ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)))) ))
({a = (( \f: Unit .((f (((\x: Nat .\y: Nat .x) (let u = 0 in u) ) ({a = 0 , b = true }.b)) ) (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) else (fix (\x: Bool . ({a = 0 , b = 0 }.b) ))) ) ) (\a: Unit .\b: Nat .b)) , b = ({a = (let u = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = ({a = true , b = false }.b) , c =  (let u = true in 1) }.b) in u) , b = (fix (\x: Bool . (if (unfold [ Bool ] (fold [ Nat ] false )) then ({a = 0 , b = false , c = 1 }.c) else (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ) 1 ) ) (\a: Nat .\b: Unit .b))) )) }.a) , c =  (if (let u = (unfold [ Nat ] (fold [ Bool ] (let u = (let u = false in u) in (let u = false in u)) )) in (let u = ({a = 1 , b = false }.a) in (((\x: Bool .\y: Nat .y) false ) true))) then (( \f: Nat .((f (pred 1) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ) (\a: Bool .\b: Bool .a)) else (unfold [ Nat ] (fold [ Bool ] (if true then 0 else 1) ))) }.b)
(unfold [ Unit ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (case <r = (unfold [ Rec X. X ] (fold [ Nat ] true )) > as Bool of < l = x > => x | < r = y > => y) )) ))
(case <l = (succ (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) ) ) (\a: Bool .\b: Rec X. X .a))) > as Unit of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (fix (\x: Rec X. X . (pred 1) )) , b = (case <l = (((\x: Rec X. X .\y: Bool .x) 1 ) false) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ))
(iszero (case <l = (( \f: Rec X. X .((f 1 ) (if false then 0 else 1) ) ) (\a: Rec X. X .\b: Unit .a)) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (let u = ({a = (fix (\x: Unit . 0 )) , b = (unfold [ Nat ] (fold [ Bool ] false )) }.a) in (iszero (pred (let u = 0 in 0)))) in (pred (((\x: Nat .\y: Rec X. X .y) true ) (((\x: Rec X. X .\y: Nat .x) 1 ) false))))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Nat .((f ({a = 0 , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) , c =  0 }.b) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Unit .b)) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = ({a = 0 , b = false , c =  1 }.b) }.b) ) ) (\a: Bool .\b: Unit .a)) ))
(let u = (let u = ({a = (((\x: Bool .\y: Unit .y) false ) false) , b = (let u = 1 in u) }.a) in u) in u)
(((\x: Bool .\y: Bool .y) (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) in (iszero ({a = 1 , b = true }.a))) ) (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) false ) true) )) ) (iszero (fix (\x: Nat . 1 ))) ) ) (\a: Rec X. X .\b: Bool .a)))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Unit . (iszero 0) )) )) , b = (unfold [ Nat ] (fold [ Nat ] ({a = (let u = (let u = (if true then false else true) in true) in (unfold [ Nat ] (fold [ Rec X. X ] false ))) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = false , c =  0 }.b) )) }.b) )) }.b)
({a = (unfold [ Bool ] (fold [ Bool ] (if ({a = (fix (\x: Rec X. X . 1 )) , b = (iszero 1) , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) then ({a = (pred 1) , b = (let u = 1 in false) }.b) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true ))) )) , b = (let u = (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = false , c =  1 }.b) )) in (fix (\x: Unit . (let u = (let u = false in 0) in (fix (\x: Nat . false ))) ))) }.b)
((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = 1 }.b) }.a) , b = (pred (let u = (fix (\x: Bool . true )) in (fix (\x: Rec X. X . 0 )))) }.b) ))
(iszero (( \f: Unit .((f (if (if (if false then false else false) then ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) else ({a = (((\x: Rec X. X .\y: Bool .x) true ) false) , b = (((\x: Nat .\y: Bool .x) true ) false) }.b)) then (let u = (unfold [ Bool ] (fold [ Nat ] false )) in (let u = 0 in 0)) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 ))) ) (((\x: Bool .\y: Rec X. X .y) (if true then (let u = false in u) else (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a))) ) ({a = (let u = 1 in true) , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
(let u = (fix (\x: Bool . (let u = (unfold [ Nat ] (fold [ Bool ] 0 )) in u) )) in (fix (\x: Nat . (let u = (if true then 1 else 1) in (succ 0)) )))
(((\x: Unit .\y: Nat .x) (let u = (if (unfold [ Bool ] (fold [ Unit ] false )) then (if (let u = true in u) then 1 else (let u = false in 0)) else (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in 0)) in (( \f: Rec X. X .((f (fix (\x: Unit . (fix (\x: Nat . 0 )) )) ) ({a = ({a = 0 , b = true }.a) , b = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 )) in (let u = 1 in 0)) }.b) ) ) (\a: Nat .\b: Nat .a))) ) ({a = (let u = (pred (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) in u) , b = (if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) then true else (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .b))) }.b))
(( \f: Nat .((f (( \f: Nat .((f (( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] (pred 1) )) ) (let u = (let u = (succ 0) in (((\x: Nat .\y: Unit .y) false ) 1)) in (succ 0)) ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Rec X. X .\y: Bool .y) (let u = 0 in (let u = true in u)) ) ({a = 0 , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) , c = (fix (\x: Nat . 1 )) }.c)) ) ) (\a: Bool .\b: Bool .a)) ) ({a = ({a = ({a = 0 , b = true , c =  0 }.b) , b = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) , b = (fix (\x: Rec X. X . 0 )) }.b) }.b) , b = ({a = (let u = ({a = ({a = false , b = 0 }.b) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) , c = (let u = 1 in 0) }.c) in (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = (pred 0) }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .a))
(case <l = (let u = (pred 1) in ({a = 0 , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Unit .x) (if (let u = ({a = 1 , b = false }.b) in u) then ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) , b = (((\x: Unit .\y: Bool .y) true ) true) }.b) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = false in true) ))) ) (((\x: Bool .\y: Unit .y) (fix (\x: Bool . (unfold [ Unit ] (fold [ Nat ] false )) )) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = true }.b) ))))
({a = (unfold [ Nat ] (fold [ Unit ] (pred (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) )) , b = (pred (pred (let u = true in 0))) }.b)
({a = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.b) , b = (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f ({a = (fix (\x: Unit . true )) , b = (fix (\x: Rec X. X . 0 )) }.b) ) (( \f: Nat .((f (let u = 1 in 0) ) (if true then 1 else 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Nat .a)) ) ({a = ({a = 1 , b = (fix (\x: Rec X. X . false )) , c =  (pred 1) }.b) , b = (( \f: Unit .((f (let u = false in false) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .a)) }.b)) }.b)
(if (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Unit .y) ({a = 0 , b = false }.b) ) (case <r = (let u = true in true) > as Nat of < l = x > => x | < r = y > => y)) ) (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)))) then (( \f: Unit .((f ({a = ({a = ({a = 0 , b = false , c =  1 }.b) , b = ({a = false , b = 0 }.b) }.b) , b = ({a = true , b = 0 }.a) , c = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) }.c) ) (((\x: Unit .\y: Nat .y) (if false then true else false) ) (((\x: Bool .\y: Nat .y) false ) 0)) ) ) (\a: Unit .\b: Nat .b)) else ({a = (((\x: Rec X. X .\y: Unit .y) (unfold [ Nat ] (fold [ Bool ] true )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 ))) , b = (((\x: Bool .\y: Unit .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) (((\x: Unit .\y: Nat .y) false ) false)) , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.c))
(case <l = (fix (\x: Bool . (if (case <r = ({a = 1 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) then (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = false }.a) ) true) else (pred ({a = 1 , b = true , c = 1 }.c))) )) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) )) ) ({a = (let u = 0 in u) , b = (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in true) }.b))
(iszero (if (if (iszero 0) then ({a = true , b = true }.b) else (let u = false in u)) then (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) in 0) else (((\x: Unit .\y: Bool .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .a)) ) (succ 0))))
({a = (if ({a = (unfold [ Nat ] (fold [ Nat ] ({a = false , b = 0 }.a) )) , b = (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Rec X. X .x) true ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )))) }.b) then (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f (((\x: Bool .\y: Nat .y) true ) 0) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Nat .b)) )) else (succ (if (fix (\x: Rec X. X . ({a = true , b = false }.b) )) then (unfold [ Rec X. X ] (fold [ Nat ] 0 )) else (let u = (if false then true else false) in ({a = 1 , b = false }.a))))) , b = (let u = (case <r = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) > as Unit of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (((\x: Bool .\y: Bool .y) ({a = 0 , b = false }.b) ) (((\x: Rec X. X .\y: Rec X. X .x) false ) true)) ) ) (\a: Rec X. X .\b: Unit .b))) }.b)
(( \f: Bool .((f (fix (\x: Rec X. X . ({a = (( \f: Rec X. X .((f 0 ) (if true then 0 else 0) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = false , b = (fix (\x: Unit . true )) }.b) }.b) )) ) (case <r = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = ({a = (((\x: Bool .\y: Unit .x) (fix (\x: Unit . true )) ) (((\x: Nat .\y: Nat .x) (let u = true in u) ) (iszero 0))) , b = (succ (( \f: Nat .((f (fix (\x: Nat . 0 )) ) (((\x: Bool .\y: Bool .x) 0 ) false) ) ) (\a: Nat .\b: Rec X. X .a))) }.b) in (if ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = ({a = (let u = false in 0) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  (((\x: Unit .\y: Bool .y) false ) 0) }.b) }.b) then (let u = ({a = (let u = true in u) , b = true }.b) in u) else (let u = (let u = false in (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .b))) in (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .a)))))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = (fix (\x: Bool . ({a = 1 , b = true }.b) )) , b = ({a = 0 , b = 0 }.b) }.a) , b = ({a = ({a = true , b = 0 }.b) , b = ({a = 0 , b = true }.b) }.a) }.a) )) ))
(case <l = (fix (\x: Rec X. X . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = (let u = ({a = (pred 1) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = false , c =  1 }.b) )) }.b) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = false in u) ))) in u)
({a = ({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = true , c = (let u = 1 in u) }.c) , b = (if true then ({a = 1 , b = true }.b) else (((\x: Unit .\y: Nat .y) true ) false)) , c =  (succ (((\x: Bool .\y: Rec X. X .y) (let u = 1 in false) ) 1)) }.b) , b = ({a = (let u = ({a = 1 , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) }.b) in u) , b = ({a = (pred (unfold [ Nat ] (fold [ Unit ] 1 ))) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = false , b = 1 }.a) )) }.b) , c = (fix (\x: Bool . (let u = 0 in u) )) }.c) }.b)
(iszero ({a = (fix (\x: Nat . (fix (\x: Nat . ({a = false , b = true }.b) )) )) , b = (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a)) ) (let u = 1 in 1)) }.b))
(fix (\x: Nat . (((\x: Bool .\y: Nat .y) (if ({a = false , b = 0 }.a) then (let u = true in u) else (fix (\x: Bool . false ))) ) (((\x: Bool .\y: Nat .y) true ) true)) ))
(fix (\x: Unit . ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = ({a = 1 , b = true , c =  (let u = 1 in 1) }.b) in u) )) ))
(((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in true) ) (iszero ({a = 0 , b = false }.a))) ) (let u = (fix (\x: Nat . 0 )) in (let u = (let u = true in u) in u)) ) ) (\a: Unit .\b: Rec X. X .a)) ) (let u = ({a = (pred 1) , b = ({a = 1 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  1 }.b) , c =  ({a = 1 , b = true , c = 1 }.c) }.b) in (let u = true in 0)))
({a = ({a = ({a = (unfold [ Bool ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] 1 )) )) , b = (fix (\x: Rec X. X . (iszero (let u = 0 in 1)) )) }.a) , b = ({a = (((\x: Nat .\y: Rec X. X .y) ({a = true , b = false }.b) ) (let u = (if true then 0 else 0) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)))) , b = (fix (\x: Rec X. X . false )) }.a) }.b) , b = ({a = (( \f: Rec X. X .((f ({a = 0 , b = false , c =  1 }.b) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = ({a = 0 , b = true , c = (fix (\x: Bool . 0 )) }.c) , b = (iszero 1) }.b) }.b) }.a)
(fix (\x: Rec X. X . (let u = (let u = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) in u) in (( \f: Rec X. X .((f (let u = 0 in 0) ) (if false then 1 else 0) ) ) (\a: Unit .\b: Unit .b))) in ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) ))) ))
({a = (((\x: Nat .\y: Unit .x) (let u = (if false then false else true) in u) ) (if ({a = 0 , b = true }.b) then true else (fix (\x: Rec X. X . true )))) , b = (let u = (fix (\x: Nat . ({a = (let u = false in 0) , b = false }.a) )) in (fix (\x: Rec X. X . ({a = 1 , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) , c = 0 }.c) ))) }.b)
(let u = (case <l = (succ (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b))) > as Nat of < l = x > => x | < r = y > => y) in u)
(pred ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Bool .y) true ) false) ) true) , b = ({a = false , b = 1 }.b) }.b) )))
(fix (\x: Bool . ({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) in (if false then 1 else 0)) , b = ({a = false , b = (iszero 0) }.b) , c = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.c) ))
(((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f (( \f: Unit .((f 1 ) (unfold [ Unit ] (fold [ Bool ] 1 )) ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = false , c = 0 }.c) ) (((\x: Nat .\y: Bool .x) (fix (\x: Rec X. X . true )) ) true)) ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = ({a = (let u = 1 in u) , b = (let u = (if false then false else false) in (fix (\x: Unit . false ))) }.b) in (let u = ({a = 1 , b = (if false then true else true) , c =  (((\x: Nat .\y: Nat .x) 1 ) true) }.b) in u)))
(succ (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = 0 }.b) )) ) (fix (\x: Bool . (fix (\x: Bool . (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) )) ) ) (\a: Bool .\b: Rec X. X .b)))
({a = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] 0 )) )) , b = (( \f: Nat .((f (fix (\x: Bool . false )) ) ({a = true , b = 1 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) , b = (fix (\x: Rec X. X . (let u = ({a = (((\x: Unit .\y: Unit .x) 1 ) true) , b = (let u = true in true) }.b) in (( \f: Bool .((f true ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .a))) )) }.b)
(case <l = (if (((\x: Rec X. X .\y: Bool .y) (let u = 1 in false) ) (if false then false else false)) then ({a = ({a = false , b = 0 }.a) , b = 0 }.b) else (fix (\x: Unit . ({a = (succ 0) , b = (let u = true in true) }.a) ))) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . (let u = (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = true , c = 0 }.c) ) (fix (\x: Nat . false ))) in (iszero (fix (\x: Bool . 0 )))) ))
({a = (pred (let u = ({a = (unfold [ Nat ] (fold [ Bool ] true )) , b = 0 }.b) in u)) , b = (case <r = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(let u = (succ ({a = (iszero (if false then 1 else 1)) , b = (let u = 1 in u) }.b)) in (( \f: Rec X. X .((f ({a = (let u = true in 0) , b = (let u = false in false) }.b) ) ({a = ({a = false , b = false }.b) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Nat .\b: Bool .a)))
(unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f (let u = (fix (\x: Unit . 0 )) in ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = ({a = true , b = false }.b) }.a)) ) (((\x: Unit .\y: Unit .x) (let u = (unfold [ Rec X. X ] (fold [ Unit ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) in ({a = false , b = 1 }.b)) ) (( \f: Nat .((f (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Nat .\b: Rec X. X .b)) ))
(((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) (let u = true in false)) ) (case <r = (let u = 1 in true) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)) ) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (if false then 1 else 1) )) , b = ({a = 1 , b = (if false then true else true) }.b) }.b))
({a = ({a = (if (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) in (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) then ({a = (if false then 0 else 1) , b = (unfold [ Rec X. X ] (fold [ Unit ] false )) }.a) else (if (iszero (((\x: Bool .\y: Rec X. X .x) 0 ) true)) then ({a = 1 , b = 0 }.b) else (fix (\x: Unit . (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )))) , b = (if (((\x: Nat .\y: Rec X. X .y) ({a = false , b = false }.b) ) false) then (((\x: Nat .\y: Nat .y) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .a)) ) ({a = 0 , b = true , c =  1 }.b)) else (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) in (case <r = true > as Bool of < l = x > => x | < r = y > => y))) , c = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Unit . 1 )) )) , b = (let u = 0 in u) }.b) }.c) , b = (((\x: Unit .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) (((\x: Rec X. X .\y: Nat .y) false ) false)) , c =  (((\x: Bool .\y: Rec X. X .y) ({a = (let u = 1 in false) , b = (let u = true in u) }.b) ) (((\x: Unit .\y: Nat .y) (((\x: Bool .\y: Unit .y) true ) (if true then false else false)) ) (let u = (fix (\x: Rec X. X . 0 )) in u))) }.b)
(if (((\x: Rec X. X .\y: Nat .y) (fix (\x: Bool . (( \f: Nat .((f (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Unit .y) false ) false) ) (unfold [ Nat ] (fold [ Rec X. X ] false ))) ) (let u = (((\x: Unit .\y: Rec X. X .y) true ) false) in true) ) ) (\a: Rec X. X .\b: Nat .a)) )) ) (let u = (let u = (let u = 1 in true) in 1) in (case <r = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y))) then (((\x: Rec X. X .\y: Bool .x) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) (((\x: Bool .\y: Unit .y) true ) (if false then true else false))) else (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .y) ({a = true , b = 0 }.a) ) (succ 1)) ) ({a = (let u = true in 1) , b = ({a = (if true then false else true) , b = (((\x: Nat .\y: Unit .x) false ) false) }.b) , c = (if ({a = 0 , b = true }.b) then ({a = true , b = 1 }.b) else 0) }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(case <r = (iszero (pred (let u = (let u = false in u) in (succ (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)))))) > as Nat of < l = x > => x | < r = y > => y)
({a = (( \f: Unit .((f (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f 0 ) ({a = 0 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) )) ) (((\x: Nat .\y: Nat .x) 0 ) (let u = 1 in false)) ) ) (\a: Rec X. X .\b: Bool .a)) ) (if ({a = 0 , b = false }.b) then (succ (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) else (fix (\x: Nat . (((\x: Nat .\y: Bool .x) 0 ) true) ))) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Nat .\y: Unit .x) ({a = ({a = (succ 1) , b = true , c = 1 }.c) , b = ({a = false , b = false }.b) , c = (succ 0) }.c) ) (if true then (let u = false in u) else ({a = false , b = false }.b))) }.b)
(let u = (if (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) then ({a = 1 , b = false , c =  (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) }.b) else ({a = 0 , b = false , c =  1 }.b)) in (((\x: Unit .\y: Nat .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (((\x: Nat .\y: Unit .x) true ) true) , b = (succ 0) }.a) )) ) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) in u)))
(((\x: Bool .\y: Rec X. X .y) (case <r = ({a = (fix (\x: Unit . false )) , b = ({a = ({a = false , b = false }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b) }.a) > as Unit of < l = x > => x | < r = y > => y) ) (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f true ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) )) > as Unit of < l = x > => x | < r = y > => y))
(let u = (case <l = ({a = ({a = 1 , b = ({a = 0 , b = true }.b) }.a) , b = ({a = false , b = 1 }.a) , c = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.c) > as Rec X. X of < l = x > => x | < r = y > => y) in (case <l = ({a = (pred (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a))) , b = ({a = 0 , b = 0 }.b) }.b) > as Nat of < l = x > => x | < r = y > => y))
(pred ({a = (if true then 0 else (fix (\x: Bool . 1 ))) , b = ({a = (pred 1) , b = ({a = true , b = 1 }.b) }.b) }.b))
({a = (let u = (let u = (((\x: Unit .\y: Unit .y) true ) 0) in u) in u) , b = (( \f: Nat .((f ({a = (((\x: Nat .\y: Bool .y) false ) 0) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) , c =  (case <l = (fix (\x: Bool . 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (iszero (fix (\x: Nat . (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ))) ) ) (\a: Rec X. X .\b: Unit .b)) , c =  (let u = (let u = (case <l = (((\x: Rec X. X .\y: Unit .x) 0 ) true) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Bool .((f 1 ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b))) in u) }.b)
(case <r = (unfold [ Rec X. X ] (fold [ Bool ] (let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (((\x: Unit .\y: Bool .y) true ) false) , c = 1 }.c) in (case <r = (if (let u = true in true) then (((\x: Nat .\y: Unit .y) false ) false) else (fix (\x: Nat . true ))) > as Rec X. X of < l = x > => x | < r = y > => y)) )) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Bool .x) (( \f: Bool .((f (let u = ({a = true , b = (((\x: Unit .\y: Bool .y) true ) true) }.b) in u) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) (let u = 1 in true) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) )) ) ) (\a: Nat .\b: Bool .a)) ) (fix (\x: Rec X. X . ({a = (let u = true in u) , b = (if true then true else false) }.b) )))
(case <l = (case <l = (unfold [ Nat ] (fold [ Bool ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (case <r = (( \f: Rec X. X .((f ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = false , c = 0 }.c) )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = true in u) )) , c =  ({a = false , b = 0 }.b) }.b) ) (fix (\x: Unit . ({a = 0 , b = false }.b) )) ) ) (\a: Rec X. X .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (iszero ({a = 0 , b = 0 }.b)) )) ) ) (\a: Bool .\b: Nat .a))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) ({a = ({a = true , b = true }.b) , b = (pred 0) }.b) ) ({a = (iszero 1) , b = (let u = false in u) }.b)) ))
(let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = (let u = 1 in 1) , b = (iszero 1) , c =  1 }.b) )) in u) in (((\x: Unit .\y: Nat .y) (let u = (let u = (((\x: Nat .\y: Rec X. X .y) false ) 1) in false) in u) ) (( \f: Bool .((f (let u = false in u) ) (((\x: Unit .\y: Bool .x) true ) false) ) ) (\a: Unit .\b: Bool .a))))
({a = ({a = ({a = (let u = (let u = true in u) in (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 1 , b = true }.a) }.b) }.a) , b = ({a = (succ 1) , b = (pred 1) }.b) }.a) , b = (succ (fix (\x: Unit . ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) ))) }.a)
(((\x: Unit .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Bool ] (case <r = (unfold [ Rec X. X ] (fold [ Bool ] true )) > as Nat of < l = x > => x | < r = y > => y) )) ) (case <r = (( \f: Unit .((f ({a = 1 , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) }.b) ) ({a = (fix (\x: Rec X. X . 0 )) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) , c =  1 }.b) ) ) (\a: Unit .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y))
(((\x: Bool .\y: Bool .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Rec X. X ] false )) )) ) (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then (( \f: Bool .((f (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) false ) ) (\a: Unit .\b: Nat .b)) else (( \f: Bool .((f (let u = false in u) ) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .b))))
(( \f: Unit .((f ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Nat .\y: Unit .x) 0 ) false) )) , b = (let u = (let u = false in u) in u) , c =  ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b) ) ({a = ({a = (let u = false in 1) , b = ({a = 0 , b = true , c = 0 }.c) }.b) , b = (let u = (unfold [ Unit ] (fold [ Bool ] ({a = true , b = 1 }.a) )) in u) }.b) ) ) (\a: Nat .\b: Unit .a))
({a = (((\x: Unit .\y: Nat .x) ({a = (let u = ({a = 0 , b = 1 }.b) in u) , b = (((\x: Unit .\y: Nat .x) false ) false) }.a) ) ({a = (let u = 1 in false) , b = 1 }.a)) , b = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f (fix (\x: Unit . 1 )) ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) )) , b = (((\x: Rec X. X .\y: Nat .x) (if ({a = 1 , b = false , c =  1 }.b) then (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .b)) else false) ) (((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) (((\x: Unit .\y: Bool .x) false ) false))) }.a) }.b)
(let u = (let u = (let u = (((\x: Unit .\y: Rec X. X .x) (let u = false in u) ) (iszero 0)) in u) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 1 in u) ))) in u)
(if (case <r = (case <r = (let u = 1 in false) > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) then (( \f: Unit .((f (iszero 1) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = ({a = true , b = true }.b) in false) )) ) ) (\a: Nat .\b: Unit .a)) else ({a = ({a = true , b = true }.b) , b = ({a = ({a = 1 , b = true }.b) , b = (((\x: Bool .\y: Rec X. X .x) 1 ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a))) }.b) }.a))
({a = (let u = (let u = (let u = 1 in u) in (if (let u = true in false) then true else (((\x: Unit .\y: Unit .x) false ) false))) in (succ 0)) , b = (( \f: Nat .((f (((\x: Unit .\y: Unit .x) (fix (\x: Bool . false )) ) (((\x: Unit .\y: Nat .x) true ) (((\x: Unit .\y: Rec X. X .y) true ) true))) ) (unfold [ Unit ] (fold [ Unit ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Nat .\b: Nat .a)) }.b)
(case <r = (case <r = (( \f: Nat .((f ({a = true , b = true }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(let u = (succ (( \f: Bool .((f (fix (\x: Rec X. X . 1 )) ) ({a = ({a = 0 , b = 1 }.b) , b = (let u = 1 in false) , c = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.c) ) ) (\a: Bool .\b: Bool .a))) in (case <l = (( \f: Nat .((f ({a = 1 , b = 1 }.b) ) (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y))
({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (let u = 1 in 1) }.b) , b = (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b))) }.b)
(fix (\x: Rec X. X . (let u = (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Rec X. X .y) (if true then (unfold [ Unit ] (fold [ Nat ] true )) else ({a = 1 , b = false }.b)) ) ({a = 1 , b = 0 }.b)) ) ({a = (unfold [ Rec X. X ] (fold [ Bool ] false )) , b = (if false then 1 else 1) }.a)) in (fix (\x: Bool . (if (let u = 1 in true) then (((\x: Nat .\y: Nat .x) 0 ) false) else (if true then (fix (\x: Unit . 0 )) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )))) ))) ))
(case <l = (( \f: Rec X. X .((f ({a = (succ ({a = false , b = 1 }.b)) , b = ({a = ({a = ({a = true , b = 1 }.b) , b = true }.a) , b = (iszero 1) , c =  ({a = 1 , b = 0 }.b) }.b) , c = (unfold [ Nat ] (fold [ Unit ] (fix (\x: Rec X. X . 0 )) )) }.c) ) (((\x: Rec X. X .\y: Bool .x) (fix (\x: Bool . (((\x: Nat .\y: Bool .x) 0 ) false) )) ) (if (let u = false in true) then (let u = false in u) else (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in (let u = true in u)))) ) ) (\a: Nat .\b: Rec X. X .a)) > as Bool of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (if ({a = ({a = true , b = false }.b) , b = false }.b) then ({a = false , b = ({a = 0 , b = 1 }.b) }.a) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ))) )) ))
(fix (\x: Bool . ({a = (case <l = (fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ({a = false , b = true }.b) ) (let u = (iszero 0) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) ) ) (\a: Bool .\b: Unit .b)) }.b) ))
({a = (iszero (pred ({a = 0 , b = false , c = (let u = 0 in u) }.c))) , b = (( \f: Bool .((f (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Bool ] 1 )) )) ) (((\x: Unit .\y: Unit .x) ({a = false , b = 1 }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Bool .b)) }.b)
(unfold [ Nat ] (fold [ Unit ] (let u = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = (fix (\x: Nat . false )) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) in u) ))
(let u = (let u = (let u = ({a = 1 , b = true , c = 1 }.c) in (((\x: Nat .\y: Bool .x) (if false then 0 else 0) ) false)) in u) in (let u = (case <l = (let u = 0 in 1) > as Nat of < l = x > => x | < r = y > => y) in u))
(let u = (pred (case <l = (succ 0) > as Nat of < l = x > => x | < r = y > => y)) in u)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) (let u = true in 1) ) ) (\a: Unit .\b: Rec X. X .a)) in u) )) ))
(pred (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then (fix (\x: Unit . ({a = 0 , b = true }.a) )) else (( \f: Bool .((f 1 ) ({a = 1 , b = true }.a) ) ) (\a: Rec X. X .\b: Unit .b))))
(pred ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Unit .((f 1 ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Nat .b)) ) (((\x: Rec X. X .\y: Bool .x) (let u = 0 in 1) ) (iszero 0)) ) ) (\a: Bool .\b: Unit .b)) )))
(((\x: Bool .\y: Unit .x) ({a = (case <r = (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Bool .y) true ) false) ) (let u = 0 in true)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (let u = true in 0) , b = (iszero ({a = 1 , b = false , c = 0 }.c)) , c = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.c) }.a) ) (case <r = ({a = (iszero 0) , b = ({a = 1 , b = true }.a) }.a) > as Bool of < l = x > => x | < r = y > => y))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (succ (pred (if true then 0 else 1))) ))
(case <r = (( \f: Rec X. X .((f (( \f: Nat .((f (iszero 1) ) (( \f: Bool .((f ({a = false , b = 1 }.a) ) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .a)) ) (case <r = (let u = 0 in true) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y)
(if (if ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) then ({a = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) else (let u = (((\x: Unit .\y: Unit .x) true ) false) in u)) then (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Nat . true )) ) (succ (let u = 1 in u))) else (let u = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .x) (let u = 1 in 0) ) ({a = true , b = 0 }.a)) }.b) in u))
(fix (\x: Unit . (pred (let u = (succ (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) in u)) ))
(((\x: Nat .\y: Bool .x) ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (succ 1) )) }.b) ) (let u = ({a = (unfold [ Unit ] (fold [ Unit ] ({a = (fix (\x: Nat . false )) , b = 0 }.b) )) , b = (let u = ({a = 1 , b = false }.a) in (let u = false in u)) }.a) in (if ({a = true , b = 1 }.a) then (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) else ({a = 1 , b = false , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.b))))
(succ (let u = (if ({a = ({a = false , b = 1 }.a) , b = true }.b) then (((\x: Rec X. X .\y: Nat .y) true ) 1) else ({a = true , b = 1 }.b)) in u))
(iszero (pred (( \f: Nat .((f (case <l = (succ 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) (succ 1) ) ) (\a: Rec X. X .\b: Bool .a))))
(((\x: Nat .\y: Unit .y) (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) )) in (((\x: Unit .\y: Rec X. X .x) true ) (iszero 0))) ) ({a = (let u = ({a = 0 , b = true }.b) in u) , b = (let u = ({a = 0 , b = false , c = (fix (\x: Rec X. X . 0 )) }.c) in (if false then true else true)) }.b))
(succ (let u = ({a = 1 , b = false , c = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.c) in (succ (let u = true in 0))))
({a = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , b = (((\x: Unit .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.b) , b = (succ (unfold [ Unit ] (fold [ Unit ] (case <l = (pred 0) > as Nat of < l = x > => x | < r = y > => y) ))) }.b)
(((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Unit .x) (let u = (succ 0) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true ))) ) (let u = (let u = 1 in (((\x: Unit .\y: Unit .y) false ) true)) in (let u = true in u))) ) (( \f: Bool .((f (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) in u) ) (let u = (let u = ({a = 1 , b = true }.a) in (( \f: Nat .((f (fix (\x: Rec X. X . 1 )) ) 1 ) ) (\a: Unit .\b: Unit .b))) in (iszero (if ({a = 1 , b = true }.b) then (let u = true in 1) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)))) ) ) (\a: Nat .\b: Nat .b)))
({a = (let u = (iszero (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)))) in (let u = (let u = true in u) in u)) , b = (if (((\x: Nat .\y: Nat .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] false )) ) ({a = 1 , b = false , c =  0 }.b)) then ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = true , b = 0 }.b) )) else (case <l = (unfold [ Bool ] (fold [ Unit ] 0 )) > as Nat of < l = x > => x | < r = y > => y)) }.b)
(fix (\x: Unit . (fix (\x: Unit . (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) (pred 1)) )) ))
({a = (((\x: Rec X. X .\y: Rec X. X .x) (let u = true in true) ) (if (if true then true else false) then (case <r = true > as Unit of < l = x > => x | < r = y > => y) else (let u = 1 in false))) , b = (( \f: Rec X. X .((f (fix (\x: Unit . (pred 1) )) ) (((\x: Unit .\y: Bool .y) ({a = ({a = true , b = 1 }.a) , b = (let u = 0 in u) }.a) ) ({a = 0 , b = false }.a)) ) ) (\a: Bool .\b: Unit .b)) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] (case <r = ({a = false , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) )) ))
(((\x: Unit .\y: Bool .x) (if (((\x: Bool .\y: Bool .y) ({a = true , b = true }.b) ) (if true then false else true)) then (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f 1 ) (if true then 1 else 0) ) ) (\a: Nat .\b: Rec X. X .b)) )) else (unfold [ Nat ] (fold [ Nat ] 0 ))) ) (let u = (((\x: Unit .\y: Unit .y) (( \f: Bool .((f ({a = 1 , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = 1 , b = true , c =  1 }.b)) in ({a = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) }.b)))
(( \f: Nat .((f (((\x: Nat .\y: Nat .y) (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) true ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true ))) ) (fix (\x: Nat . (fix (\x: Nat . false )) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (iszero 1) )) in (case <r = true > as Bool of < l = x > => x | < r = y > => y))) ) (( \f: Nat .((f (( \f: Bool .((f ({a = 0 , b = true }.b) ) (((\x: Nat .\y: Nat .x) true ) true) ) ) (\a: Unit .\b: Nat .b)) ) (fix (\x: Rec X. X . ({a = false , b = false }.b) )) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .a))
({a = (pred ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) (let u = true in u)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = 0 }.b) )) }.b)) , b = (fix (\x: Nat . ({a = ({a = 1 , b = true , c = 1 }.c) , b = (((\x: Rec X. X .\y: Nat .x) true ) false) , c =  (let u = ({a = 0 , b = true , c = 1 }.c) in u) }.b) )) }.a)
({a = ({a = ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) , b = (fix (\x: Bool . ({a = false , b = 1 }.b) )) }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) )) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Unit .y) true ) 1) )) }.c) , b = (let u = (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = ({a = 0 , b = false , c =  1 }.b) , b = ({a = 1 , b = true , c =  1 }.b) }.b)) in u) }.a)
(case <r = (((\x: Nat .\y: Unit .y) (let u = ({a = false , b = 0 }.a) in (((\x: Rec X. X .\y: Unit .x) true ) (case <r = false > as Unit of < l = x > => x | < r = y > => y))) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (if false then false else false) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) in (((\x: Nat .\y: Rec X. X .y) false ) (if false then true else true))) )) )) ))
(if (unfold [ Nat ] (fold [ Bool ] (((\x: Nat .\y: Nat .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .a))) )) then (let u = ({a = (fix (\x: Bool . 0 )) , b = (unfold [ Bool ] (fold [ Unit ] true )) }.a) in (((\x: Bool .\y: Bool .y) ({a = true , b = 1 }.a) ) (iszero 1))) else (unfold [ Rec X. X ] (fold [ Nat ] (let u = ({a = 1 , b = false }.b) in u) )))
({a = (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (let u = 0 in (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)))) )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (succ (pred 0)) )) }.a)
(let u = (fix (\x: Unit . ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) )) in ({a = (case <l = (let u = true in 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) }.b))
(iszero (((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Bool .x) (case <r = (((\x: Nat .\y: Unit .x) true ) true) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (iszero 1) , b = (let u = 0 in 1) }.a)) ) ({a = (pred 1) , b = (unfold [ Nat ] (fold [ Bool ] (let u = 1 in false) )) }.a)))
(case <l = (fix (\x: Rec X. X . (succ (((\x: Nat .\y: Bool .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) false)) )) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Rec X. X .((f ({a = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) then ({a = 1 , b = (((\x: Bool .\y: Bool .x) false ) false) }.a) else (unfold [ Nat ] (fold [ Bool ] 1 ))) , b = (if true then 0 else 0) }.b) ) (((\x: Nat .\y: Unit .y) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) , b = (iszero ({a = 0 , b = false , c = 0 }.c)) , c =  (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) ) ({a = (((\x: Unit .\y: Nat .y) false ) 0) , b = ({a = 0 , b = 0 }.b) }.b)) ) ) (\a: Nat .\b: Unit .b))
(if (let u = ({a = (let u = false in false) , b = ({a = 0 , b = 0 }.b) }.b) in ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Bool .y) ({a = true , b = 1 }.a) ) false) ))) then (iszero (( \f: Nat .((f (let u = 1 in u) ) (let u = false in 0) ) ) (\a: Unit .\b: Rec X. X .b))) else (case <r = (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f (((\x: Nat .\y: Bool .y) true ) false) ) (fix (\x: Unit . true )) ) ) (\a: Rec X. X .\b: Unit .a)) )) )) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f ({a = (fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] true )) )) , b = (succ (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y)) }.a) ) (( \f: Rec X. X .((f ({a = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .a)) , b = ({a = 0 , b = true }.b) }.b) ) ({a = true , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.a) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b))
(( \f: Rec X. X .((f (if (iszero 0) then (let u = false in u) else (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) (( \f: Bool .((f (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = true }.b) )) ) (( \f: Unit .((f (if false then false else true) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Bool .a))
(let u = (( \f: Rec X. X .((f ({a = ({a = 1 , b = true }.b) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) (pred (let u = 0 in (pred 1))) ) ) (\a: Rec X. X .\b: Nat .a)) in (let u = ({a = (((\x: Nat .\y: Rec X. X .x) ({a = 0 , b = true , c = 0 }.c) ) true) , b = ({a = false , b = ({a = 0 , b = true , c = 1 }.c) }.a) }.a) in u))
({a = (((\x: Bool .\y: Rec X. X .x) (let u = (let u = 1 in 0) in true) ) (( \f: Bool .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a)) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Nat .a))) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Unit ] (if (let u = true in u) then (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) else (pred 1)) )) ) (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 ))) ) ) (\a: Bool .\b: Unit .a)) }.a)
(let u = (let u = ({a = (((\x: Nat .\y: Bool .x) 0 ) false) , b = ({a = (fix (\x: Bool . true )) , b = 0 }.a) }.b) in u) in u)
({a = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = ({a = true , b = 0 }.a) }.a) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 ))) }.b) , b = (unfold [ Bool ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = true }.b) )) )) }.a)
({a = (let u = (((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .y) false ) 1) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) true)) in u) , b = (if ({a = (let u = 0 in u) , b = ({a = true , b = 0 }.a) }.b) then (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) in u) in u) else ({a = ({a = (fix (\x: Nat . 1 )) , b = (let u = true in false) }.a) , b = ({a = (if false then 1 else 1) , b = (((\x: Bool .\y: Unit .x) true ) true) }.b) }.b)) }.a)
(iszero (case <l = (pred (let u = 1 in u)) > as Unit of < l = x > => x | < r = y > => y))
(pred (let u = (let u = (let u = false in ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true ))) in (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )))) in (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Unit .\y: Bool .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) ) false))))
(let u = (iszero (if ({a = (pred 0) , b = false , c =  1 }.b) then (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) else (((\x: Nat .\y: Bool .x) (let u = 1 in u) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b))))) in (( \f: Rec X. X .((f ({a = (let u = 0 in u) , b = (if true then 1 else 1) }.b) ) (((\x: Unit .\y: Rec X. X .x) 0 ) true) ) ) (\a: Nat .\b: Bool .a)))
({a = (((\x: Unit .\y: Nat .x) (let u = ({a = true , b = false }.b) in (((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Nat .y) (unfold [ Nat ] (fold [ Nat ] false )) ) false) ) (((\x: Unit .\y: Bool .y) false ) false))) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .y) (iszero 0) ) false) ) (let u = 1 in false) ) ) (\a: Nat .\b: Unit .b))) , b = (if (fix (\x: Nat . ({a = (let u = false in 1) , b = true , c =  (pred 0) }.b) )) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) else ({a = ({a = 1 , b = true }.b) , b = (if false then 1 else 1) }.b)) }.b)
(let u = (unfold [ Nat ] (fold [ Rec X. X ] (if (let u = (let u = false in 1) in (unfold [ Unit ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) ))) then (case <l = (let u = false in 1) > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = (iszero 1) , b = (((\x: Bool .\y: Rec X. X .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) true) }.b)) )) in (let u = (case <r = (((\x: Unit .\y: Nat .y) (iszero 0) ) (let u = true in true)) > as Nat of < l = x > => x | < r = y > => y) in u))
(case <r = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) (let u = (let u = 0 in true) in (if true then false else false)) ) (( \f: Rec X. X .((f (if (if false then true else false) then false else true) ) (( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) ) (unfold [ Nat ] (fold [ Unit ] true )) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a))) ) ({a = ({a = (unfold [ Rec X. X ] (fold [ Unit ] true )) , b = ({a = 0 , b = false , c =  ({a = true , b = 0 }.b) }.b) }.b) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (((\x: Unit .\y: Bool .y) true ) false) )) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y)
(succ (unfold [ Unit ] (fold [ Unit ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (((\x: Nat .\y: Nat .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) )) )))
(((\x: Nat .\y: Bool .y) (let u = (let u = false in u) in (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) ) (let u = (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f ({a = 0 , b = true , c =  1 }.b) ) (((\x: Rec X. X .\y: Bool .y) false ) (if true then false else true)) ) ) (\a: Rec X. X .\b: Bool .a)) )) in (fix (\x: Bool . ({a = 1 , b = false , c =  1 }.b) ))))
(unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Unit . (((\x: Bool .\y: Bool .y) ({a = (let u = 0 in 1) , b = (unfold [ Unit ] (fold [ Nat ] true )) }.b) ) (let u = (((\x: Nat .\y: Unit .x) false ) true) in u)) )) ))
(((\x: Bool .\y: Unit .y) ({a = (unfold [ Unit ] (fold [ Bool ] (pred 0) )) , b = (let u = (fix (\x: Rec X. X . 0 )) in (iszero 1)) , c =  (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.b) ) (case <l = (unfold [ Unit ] (fold [ Unit ] 0 )) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) ({a = (((\x: Nat .\y: Unit .x) 0 ) false) , b = (case <r = ({a = 0 , b = false , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) ) (let u = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) in false) in u)) ) (unfold [ Unit ] (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) )) ) ) (\a: Bool .\b: Rec X. X .a))
(unfold [ Bool ] (fold [ Nat ] ({a = ({a = ({a = 0 , b = false }.a) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (let u = false in u) }.b) ))
(let u = (let u = (if (fix (\x: Unit . true )) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) else (((\x: Nat .\y: Unit .y) true ) false)) in (case <r = ({a = (( \f: Nat .((f 1 ) (((\x: Bool .\y: Bool .y) false ) 0) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .x) false ) false) )) , c =  ({a = 1 , b = false }.a) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) in (let u = ({a = (pred 1) , b = (let u = false in 0) }.b) in ({a = ({a = 1 , b = false }.a) , b = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) in ({a = 0 , b = false , c =  0 }.b)) , c =  (( \f: Rec X. X .((f 1 ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Nat .\b: Nat .a)) }.b)))
({a = (fix (\x: Nat . (pred (pred (let u = 0 in u))) )) , b = (let u = ({a = (pred 0) , b = (unfold [ Bool ] (fold [ Bool ] true )) }.b) in u) }.b)
(let u = (((\x: Nat .\y: Nat .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) (case <r = (let u = true in u) > as Bool of < l = x > => x | < r = y > => y)) in u)
({a = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y) )) , b = ({a = (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .x) 1 ) false) )) ) (((\x: Nat .\y: Bool .y) (( \f: Nat .((f (let u = 0 in true) ) true ) ) (\a: Unit .\b: Nat .a)) ) (( \f: Rec X. X .((f 1 ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Nat .b))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (let u = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ({a = true , b = (fix (\x: Unit . 1 )) }.a)) , c =  ({a = (let u = (let u = true in (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a))) in u) , b = ({a = (let u = 0 in u) , b = true }.b) }.a) }.b) }.b)
(((\x: Bool .\y: Unit .y) (( \f: Nat .((f ({a = (let u = 1 in u) , b = (fix (\x: Nat . true )) }.b) ) ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = true , c =  0 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (( \f: Bool .((f true ) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ) (\a: Nat .\b: Nat .a)) , b = (fix (\x: Rec X. X . ({a = (let u = 1 in u) , b = true }.a) )) }.a))
(if (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Nat ] (let u = ({a = true , b = 0 }.a) in (let u = false in false)) )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = true }.b) )) ) ) (\a: Unit .\b: Nat .b)) then (pred (((\x: Nat .\y: Bool .y) (let u = false in ({a = 0 , b = true }.b)) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) else ({a = ({a = (pred 0) , b = ({a = true , b = false }.b) }.a) , b = (unfold [ Unit ] (fold [ Unit ] (let u = false in 0) )) }.b))
(iszero (succ (((\x: Nat .\y: Bool .x) (((\x: Nat .\y: Unit .x) 1 ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .a))) ) (((\x: Rec X. X .\y: Rec X. X .x) false ) false))))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .y) (let u = (((\x: Unit .\y: Nat .x) (((\x: Unit .\y: Nat .x) false ) false) ) true) in u) ) (( \f: Bool .((f (( \f: Bool .((f ({a = false , b = 1 }.b) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Unit .a)) ) (fix (\x: Unit . 1 )) ) ) (\a: Bool .\b: Rec X. X .a))) ))
(( \f: Nat .((f (iszero ({a = (if ({a = true , b = false }.b) then (fix (\x: Unit . 1 )) else 1) , b = ({a = (if (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .a)) then (let u = 1 in 1) else ({a = false , b = 0 }.b)) , b = (fix (\x: Unit . false )) , c =  (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) }.b) }.a)) ) (unfold [ Bool ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Bool ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) )) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = (pred (((\x: Rec X. X .\y: Nat .y) (case <r = (let u = false in true) > as Bool of < l = x > => x | < r = y > => y) ) ({a = 1 , b = 1 }.b))) , b = (( \f: Nat .((f (iszero 0) ) (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = true in u) )) in ({a = true , b = 1 }.a)) ) ) (\a: Nat .\b: Nat .b)) , c =  (let u = ({a = 0 , b = false }.a) in u) }.b)
(succ (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .y) true ) 0) ) ({a = 0 , b = false , c =  1 }.b)) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) in u) ) ) (\a: Unit .\b: Rec X. X .a)))
(if (iszero (case <l = (((\x: Nat .\y: Nat .y) true ) (let u = 1 in u)) > as Rec X. X of < l = x > => x | < r = y > => y)) then (( \f: Rec X. X .((f ({a = 1 , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) }.b) ) (unfold [ Unit ] (fold [ Bool ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Rec X. X .a)) else ({a = ({a = 1 , b = (iszero 1) , c =  0 }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = 1 in true) )) }.b))
(( \f: Nat .((f (((\x: Nat .\y: Nat .y) (iszero ({a = (succ 0) , b = 1 }.b)) ) (let u = (succ (if false then 0 else 1)) in (((\x: Unit .\y: Rec X. X .x) ({a = false , b = 0 }.b) ) (iszero 1)))) ) (if (let u = ({a = 1 , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) }.b) in u) then (pred (let u = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = 1 in 1))) else ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) in (let u = ({a = false , b = true }.b) in (let u = 0 in 0))) , b = (fix (\x: Bool . 1 )) }.b)) ) ) (\a: Nat .\b: Unit .a))
({a = (fix (\x: Nat . ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = 1 , b = false }.a) , b = (let u = (unfold [ Rec X. X ] (fold [ Unit ] false )) in u) }.b) )) )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) in (let u = 1 in 0)) , b = (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then false else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , c = ({a = (let u = true in 0) , b = (iszero 0) , c = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) }.c) }.c) )) }.a)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (pred (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) ))
(unfold [ Nat ] (fold [ Unit ] (let u = (iszero ({a = ({a = (let u = true in 1) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = (((\x: Unit .\y: Unit .x) 0 ) true) }.b)) in u) ))
(( \f: Rec X. X .((f (succ (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) (if true then 0 else 0) ) ) (\a: Nat .\b: Unit .b))) ) (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) )) ) (( \f: Nat .((f (let u = false in 1) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .b))
(unfold [ Bool ] (fold [ Rec X. X ] (let u = ({a = (if true then true else true) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) in (( \f: Unit .((f (succ 0) ) (let u = (let u = (pred 0) in u) in u) ) ) (\a: Nat .\b: Nat .a))) ))
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if false then ({a = true , b = 0 }.a) else (if false then false else false)) )) , b = (((\x: Bool .\y: Unit .x) (let u = (case <l = (let u = true in 1) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = 1 , b = 1 }.b)) ) ({a = (case <r = (case <r = true > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = 0 in u) }.a)) }.a)
(fix (\x: Rec X. X . ({a = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (pred 1) }.b) , b = ({a = 1 , b = (iszero 1) }.b) }.b) ))
(let u = ({a = (if ({a = false , b = true }.b) then (let u = false in false) else (((\x: Rec X. X .\y: Rec X. X .y) false ) (iszero 1))) , b = (unfold [ Unit ] (fold [ Nat ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.b) in (let u = (( \f: Unit .((f ({a = ({a = 0 , b = false , c = 1 }.c) , b = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b)) }.a) ) (succ (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Unit .\b: Rec X. X .b)) in (iszero (let u = false in 0))))
(if ({a = (((\x: Nat .\y: Unit .y) (( \f: Bool .((f ({a = true , b = true }.b) ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) (succ (fix (\x: Nat . 1 )))) , b = (( \f: Unit .((f (let u = 0 in (let u = true in u)) ) ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = (iszero 1) , c =  0 }.b) ) ) (\a: Bool .\b: Unit .a)) }.b) then (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Rec X. X .x) ({a = true , b = ({a = 0 , b = false }.b) }.b) ) (((\x: Bool .\y: Rec X. X .y) false ) true)) ) (( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] false )) ) ({a = true , b = 1 }.a) ) ) (\a: Rec X. X .\b: Nat .b))) else (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Nat . true )) ) false) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (if true then true else false) ))) )))
({a = (let u = (succ 0) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ))) , b = (if (((\x: Unit .\y: Nat .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (if true then true else true) )) ) (let u = ({a = 1 , b = true , c = 1 }.c) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )))) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (unfold [ Nat ] (fold [ Bool ] true )) in ({a = 1 , b = true }.a)) )) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Rec X. X .((f (let u = 0 in u) ) (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) )) ) ) (\a: Rec X. X .\b: Nat .b)) ))) }.a)
(unfold [ Unit ] (fold [ Unit ] (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) (((\x: Nat .\y: Unit .x) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = 0 in true))) ) (let u = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = (fix (\x: Unit . false )) , c = (fix (\x: Bool . 1 )) }.c) in (succ 0)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
({a = (((\x: Bool .\y: Nat .y) ({a = ({a = ({a = 1 , b = false , c = 1 }.c) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a)) }.a) , b = (iszero 1) , c =  (let u = 1 in (let u = false in 0)) }.b) ) (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Nat .x) ({a = 0 , b = false }.b) ) (((\x: Bool .\y: Unit .y) false ) true)) ) ({a = 1 , b = false , c =  1 }.b)) ))) , b = ({a = (let u = (((\x: Bool .\y: Unit .x) 0 ) true) in (let u = 0 in u)) , b = (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , c =  (fix (\x: Unit . (pred 0) )) }.b) }.b)
(((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f (case <r = (let u = false in u) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (let u = (((\x: Unit .\y: Bool .y) true ) false) in (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Unit .a)) ) (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Unit .\y: Nat .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) ) (pred ({a = 1 , b = true }.a)) ) ) (\a: Bool .\b: Rec X. X .b)))
(((\x: Rec X. X .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) ({a = (iszero 0) , b = (( \f: Nat .((f (let u = 0 in false) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) ) (\a: Bool .\b: Bool .b)) }.b) ) (if (((\x: Unit .\y: Bool .x) true ) true) then (iszero ({a = 1 , b = true }.a)) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )))) ) (if (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Bool . (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) )) then ({a = (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .x) 1 ) false) ) (if true then (let u = 1 in 0) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = (pred 0) in (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b))) , c =  (if (((\x: Unit .\y: Nat .x) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (iszero 0)) then (((\x: Nat .\y: Nat .x) 1 ) (fix (\x: Nat . true ))) else (((\x: Bool .\y: Rec X. X .x) 1 ) true)) }.b) else (if (if ({a = 1 , b = true , c =  0 }.b) then (let u = false in false) else (unfold [ Rec X. X ] (fold [ Nat ] true ))) then (unfold [ Nat ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) )) else (( \f: Nat .((f (let u = true in u) ) (let u = true in u) ) ) (\a: Bool .\b: Unit .b)))))
({a = (let u = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (if false then ({a = 1 , b = false }.b) else false) }.b) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] (succ 0) )) ))) , b = (if (if (let u = false in u) then ({a = 1 , b = false , c =  0 }.b) else ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) then (((\x: Nat .\y: Nat .y) (let u = 1 in true) ) false) else (unfold [ Unit ] (fold [ Bool ] false ))) , c = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) }.c)
(((\x: Nat .\y: Bool .y) ({a = (((\x: Rec X. X .\y: Bool .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = true in true)) , b = (iszero 0) }.b) ) ({a = (let u = (((\x: Bool .\y: Nat .x) false ) false) in ({a = true , b = 0 }.b)) , b = (if (let u = false in false) then ({a = (let u = false in 0) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) , c =  1 }.b) else (((\x: Nat .\y: Bool .x) true ) true)) , c = (pred 1) }.c))
(let u = (( \f: Nat .((f (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .x) false ) ({a = 0 , b = true , c =  1 }.b)) ) (((\x: Unit .\y: Nat .y) (let u = 1 in true) ) false) ) ) (\a: Rec X. X .\b: Bool .b)) ) (unfold [ Bool ] (fold [ Bool ] (if (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .b)) then (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false , c =  0 }.b) ) false) else (let u = true in u)) )) ) ) (\a: Rec X. X .\b: Bool .a)) in (if ({a = ({a = 1 , b = false , c =  1 }.b) , b = (let u = false in false) }.b) then (fix (\x: Rec X. X . ({a = 1 , b = false }.a) )) else (( \f: Unit .((f ({a = 0 , b = (((\x: Nat .\y: Bool .y) true ) true) , c = 0 }.c) ) (((\x: Unit .\y: Unit .y) false ) 0) ) ) (\a: Rec X. X .\b: Rec X. X .b))))
({a = (((\x: Nat .\y: Rec X. X .x) ({a = (case <r = (if false then true else true) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . false )) }.b) ) (let u = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = true , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) in (let u = (iszero 0) in u))) , b = (((\x: Unit .\y: Rec X. X .x) ({a = (((\x: Bool .\y: Unit .y) (fix (\x: Bool . false )) ) 1) , b = (succ 1) }.b) ) ({a = 1 , b = true }.b)) }.b)
(succ ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) ({a = false , b = 0 }.b)) )))
(fix (\x: Nat . (if (if (iszero 1) then (let u = 1 in true) else (unfold [ Bool ] (fold [ Rec X. X ] true ))) then (fix (\x: Nat . true )) else (fix (\x: Nat . (let u = true in true) ))) ))
(if ({a = (( \f: Unit .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Bool .\y: Unit .y) true ) 1) ) ) (\a: Rec X. X .\b: Unit .a)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = true , b = 0 }.a) )) }.b) then (iszero (fix (\x: Rec X. X . ({a = (((\x: Bool .\y: Bool .x) true ) false) , b = 1 }.b) ))) else (case <r = ({a = (if false then false else true) , b = ({a = ({a = 0 , b = 1 }.b) , b = false , c =  ({a = 1 , b = true , c = 1 }.c) }.b) }.b) > as Unit of < l = x > => x | < r = y > => y))
(( \f: Nat .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = (((\x: Bool .\y: Unit .y) true ) 0) in u) )) ) (( \f: Rec X. X .((f ({a = ({a = ({a = 1 , b = false , c = 1 }.c) , b = false }.b) , b = (((\x: Bool .\y: Nat .y) false ) 1) }.b) ) (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (((\x: Unit .\y: Unit .x) 0 ) false) }.b) ) (( \f: Rec X. X .((f (if true then 0 else 0) ) (let u = true in 0) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(succ (let u = (((\x: Rec X. X .\y: Bool .y) (((\x: Bool .\y: Rec X. X .x) (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (if false then true else false)) ) (((\x: Nat .\y: Unit .y) false ) 0)) in u))
({a = (( \f: Rec X. X .((f (let u = (((\x: Bool .\y: Unit .y) ({a = 1 , b = false , c =  0 }.b) ) false) in u) ) (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in (((\x: Rec X. X .\y: Unit .y) true ) true)) )) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = (let u = (let u = ({a = false , b = false }.b) in (let u = (let u = 1 in false) in 1)) in ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.a)) in ({a = (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .x) (if true then true else true) ) false) ) (((\x: Bool .\y: Rec X. X .y) ({a = 0 , b = false , c =  0 }.b) ) false) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (case <l = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) }.a)
(let u = (let u = (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) in (( \f: Nat .((f (pred ({a = true , b = 0 }.b)) ) ({a = ({a = 1 , b = 1 }.b) , b = ({a = false , b = false }.b) , c = ({a = 0 , b = 1 }.b) }.c) ) ) (\a: Unit .\b: Nat .b))) in ({a = ({a = 0 , b = (let u = true in u) }.a) , b = (case <l = (case <l = ({a = true , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b))
(if ({a = (succ (let u = 0 in u)) , b = (let u = 1 in ({a = false , b = true }.b)) , c =  (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .y) false ) 0) ) (((\x: Bool .\y: Bool .y) false ) 0) ) ) (\a: Bool .\b: Nat .a)) }.b) then (iszero (fix (\x: Bool . (let u = (if true then 1 else 1) in u) ))) else (iszero ({a = 0 , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .b)) }.a)))
({a = ({a = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = ({a = false , b = 0 }.a) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.c) , b = (let u = (((\x: Nat .\y: Unit .y) true ) (unfold [ Bool ] (fold [ Bool ] true ))) in (let u = true in u)) , c = (unfold [ Nat ] (fold [ Rec X. X ] (succ 1) )) }.c) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (let u = (if false then 1 else 0) in ({a = 1 , b = (if false then true else false) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )) }.b)) )) ) (case <r = ({a = 0 , b = false , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) }.b)
(case <r = (let u = ({a = 1 , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) , c = (((\x: Rec X. X .\y: Bool .y) true ) 1) }.c) in ({a = (let u = false in u) , b = true }.b)) > as Unit of < l = x > => x | < r = y > => y)
(pred (pred (unfold [ Nat ] (fold [ Unit ] ({a = false , b = 1 }.b) ))))
(succ (succ ({a = (let u = 1 in 0) , b = (let u = false in u) }.a)))
(((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) (let u = (let u = true in false) in u) ) ({a = (((\x: Bool .\y: Bool .x) false ) true) , b = (let u = 1 in true) }.b)) ) (let u = (let u = (((\x: Nat .\y: Rec X. X .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) true) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = true in u) ))) in u))
(unfold [ Bool ] (fold [ Rec X. X ] (let u = (((\x: Unit .\y: Rec X. X .y) (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) in (if false then false else true)) ) (iszero (((\x: Nat .\y: Bool .x) 1 ) true))) in (let u = (let u = true in 0) in u)) ))
(let u = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = (((\x: Nat .\y: Nat .y) false ) 1) , b = (unfold [ Nat ] (fold [ Nat ] false )) , c =  1 }.b) )) ) ({a = (succ (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b))) , b = ({a = (let u = false in false) , b = (unfold [ Nat ] (fold [ Unit ] 1 )) }.a) , c =  ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = (((\x: Rec X. X .\y: Unit .y) true ) true) , c = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.c) }.b) ) ) (\a: Bool .\b: Bool .b)) in u)
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = 0 , b = true }.a) }.b) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.a) , b = (let u = (((\x: Nat .\y: Nat .x) 0 ) (let u = true in false)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ))) }.b) ))
(((\x: Nat .\y: Bool .y) ({a = (( \f: Bool .((f (let u = 1 in u) ) (succ (pred 1)) ) ) (\a: Nat .\b: Bool .b)) , b = (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 1 , b = false , c =  1 }.b) )) > as Bool of < l = x > => x | < r = y > => y) , c =  (succ (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b))) }.b) ) (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . (fix (\x: Unit . (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) )) )))
(((\x: Bool .\y: Bool .x) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = true , b = 1 }.a) )) , b = (((\x: Bool .\y: Bool .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 0 , b = true }.b) ))) }.b) ) (((\x: Unit .\y: Bool .x) ({a = (let u = true in u) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) , b = (((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Unit .y) true ) true) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) }.a) }.b) ) (( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] (let u = false in (((\x: Rec X. X .\y: Bool .x) true ) true)) )) ) ({a = false , b = (iszero 1) }.b) ) ) (\a: Rec X. X .\b: Bool .b))))
(((\x: Bool .\y: Nat .x) (case <l = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] 1 )) ) (let u = (((\x: Nat .\y: Nat .y) false ) 0) in u) ) ) (\a: Rec X. X .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero 1) )) ) (( \f: Unit .((f (((\x: Bool .\y: Bool .x) true ) false) ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .b)))
(iszero ({a = (if ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = ({a = (fix (\x: Nat . false )) , b = 1 }.a) }.b) then (iszero ({a = 1 , b = true , c = 1 }.c)) else ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.a)) , b = ({a = (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = (let u = 0 in u) , b = true }.a) }.b) }.b))
(( \f: Nat .((f ({a = (( \f: Rec X. X .((f (let u = 1 in (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .b))) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = ({a = (if (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .b)) then ({a = 1 , b = false }.a) else 1) , b = (iszero 0) , c = (succ 1) }.c) }.a) ) ({a = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) }.b) , b = (let u = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Nat . true )) )) in (let u = (((\x: Rec X. X .\y: Nat .x) true ) false) in false)) }.b) ) ) (\a: Nat .\b: Bool .b))
(iszero (succ (let u = (pred 1) in u)))
({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (if false then 0 else 1) )) in u) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) )) , c =  ({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Nat .y) (let u = true in u) ) true) )) in (let u = ({a = 1 , b = true }.a) in (pred ({a = 1 , b = false , c = 0 }.c)))) , b = (iszero ({a = (succ 0) , b = false }.a)) }.a) }.b)
(let u = (case <l = (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Bool .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) in (if (let u = (let u = ({a = 1 , b = 0 }.b) in u) in (iszero (let u = 0 in 1))) then ({a = (fix (\x: Nat . 1 )) , b = (((\x: Unit .\y: Unit .y) false ) 0) }.b) else ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ({a = (((\x: Bool .\y: Nat .y) false ) 0) , b = (fix (\x: Unit . 0 )) }.b) ))))
({a = (if ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = 0 in (if false then true else false)) )) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) else ({a = ({a = ({a = (((\x: Bool .\y: Bool .y) true ) 0) , b = 0 }.b) , b = ({a = 0 , b = true }.a) }.b) , b = (iszero (let u = 1 in u)) , c = (((\x: Unit .\y: Rec X. X .y) (let u = true in u) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) 1)) }.c)) , b = (if (fix (\x: Nat . (let u = (pred ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) in (iszero 1)) )) then ({a = ({a = ({a = true , b = 1 }.b) , b = 0 }.b) , b = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) }.b) else (( \f: Nat .((f ({a = false , b = ({a = 0 , b = true }.a) }.a) ) (((\x: Nat .\y: Unit .y) ({a = 0 , b = true }.b) ) ({a = false , b = 0 }.a)) ) ) (\a: Nat .\b: Bool .b))) , c =  (succ (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Bool . ({a = 0 , b = false }.a) )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Rec X. X . true )) )))) }.b)
(succ ({a = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) false ) true) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (((\x: Bool .\y: Rec X. X .x) (fix (\x: Bool . 0 )) ) ({a = false , b = 0 }.a)) }.b))
(((\x: Bool .\y: Bool .y) (((\x: Nat .\y: Rec X. X .y) (((\x: Nat .\y: Rec X. X .x) false ) false) ) (((\x: Rec X. X .\y: Unit .y) false ) ({a = 0 , b = true , c =  1 }.b))) ) (((\x: Unit .\y: Rec X. X .x) (( \f: Bool .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = false , b = 1 }.a) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Rec X. X .x) (let u = ({a = false , b = 0 }.b) in false) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = (let u = 0 in 1) in (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .b))) )))))
(fix (\x: Unit . (fix (\x: Nat . (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = 0 }.b) )) ) ({a = ({a = 0 , b = false }.b) , b = (let u = false in 1) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) )) ))
({a = (let u = (( \f: Rec X. X .((f (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ) ({a = 1 , b = ({a = 1 , b = true }.b) , c = 1 }.c) ) ) (\a: Rec X. X .\b: Bool .b)) in (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) in ({a = false , b = false }.b))) , b = ({a = (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f ({a = 0 , b = false }.b) ) (let u = true in true) ) ) (\a: Rec X. X .\b: Unit .a)) ) (((\x: Unit .\y: Unit .y) true ) (unfold [ Nat ] (fold [ Nat ] true )))) ) (((\x: Bool .\y: Nat .y) true ) 0)) , b = (case <l = (fix (\x: Nat . 0 )) > as Bool of < l = x > => x | < r = y > => y) }.b) }.b)
(if (if (((\x: Nat .\y: Rec X. X .y) (let u = true in true) ) (if false then false else true)) then (unfold [ Unit ] (fold [ Rec X. X ] ({a = false , b = false }.b) )) else ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (iszero 1) , c =  (unfold [ Unit ] (fold [ Bool ] 1 )) }.b)) then ({a = (unfold [ Bool ] (fold [ Unit ] (unfold [ Nat ] (fold [ Rec X. X ] false )) )) , b = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a))) )) }.b) else ({a = ({a = true , b = 0 }.b) , b = ({a = ({a = ({a = 1 , b = false }.b) , b = ({a = 0 , b = true , c = 1 }.c) }.b) , b = ({a = 0 , b = true , c =  0 }.b) , c =  (((\x: Unit .\y: Unit .x) 1 ) false) }.b) , c =  ({a = 0 , b = true }.a) }.b))
(case <l = (let u = (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = true }.b) )) in (let u = (((\x: Nat .\y: Unit .y) true ) true) in 0)) > as Unit of < l = x > => x | < r = y > => y)
({a = (succ (let u = (succ 1) in (let u = ({a = 1 , b = 1 }.b) in u))) , b = ({a = (((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Nat .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) ) false) ) (((\x: Unit .\y: Unit .x) ({a = true , b = 1 }.a) ) ({a = ({a = 0 , b = false }.a) , b = (unfold [ Bool ] (fold [ Unit ] false )) , c =  (let u = 1 in u) }.b))) , b = (let u = (let u = 0 in true) in ({a = false , b = 0 }.a)) , c =  (let u = (let u = (((\x: Rec X. X .\y: Nat .y) false ) 0) in (pred 0)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 ))) }.b) , c = (succ (let u = (let u = false in u) in ({a = false , b = 0 }.b))) }.c)
({a = ({a = (pred ({a = 1 , b = true }.a)) , b = (fix (\x: Rec X. X . (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , c =  (if true then 0 else 1) }.b) , b = (let u = (unfold [ Unit ] (fold [ Bool ] (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) false ) 0) )) )) in ({a = (let u = true in false) , b = 1 }.a)) }.b)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (let u = ({a = 0 , b = false , c = ({a = true , b = 1 }.b) }.c) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = true , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) }.a) }.a) ))
({a = ({a = (fix (\x: Nat . ({a = (((\x: Rec X. X .\y: Nat .y) false ) false) , b = (if true then 0 else 1) }.b) )) , b = (let u = (if (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) then false else true) in u) , c =  (unfold [ Bool ] (fold [ Unit ] (case <l = (pred (if false then 1 else 0)) > as Unit of < l = x > => x | < r = y > => y) )) }.b) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <l = (( \f: Nat .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (let u = 1 in 0) ) ) (\a: Unit .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) )) }.a)
(let u = (( \f: Unit .((f (( \f: Rec X. X .((f (if false then 1 else 0) ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Bool .x) false ) ({a = 1 , b = false }.b)) ) (pred 1)) ) ) (\a: Unit .\b: Nat .b)) in (let u = (( \f: Rec X. X .((f (let u = ({a = false , b = 1 }.a) in u) ) (let u = 1 in false) ) ) (\a: Nat .\b: Nat .a)) in u))
({a = (( \f: Nat .((f (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) in (iszero (pred 0))) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = ({a = false , b = 0 }.a) , c =  (((\x: Unit .\y: Unit .y) (fix (\x: Nat . true )) ) 1) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (if ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Bool . true )) )) , b = (unfold [ Nat ] (fold [ Bool ] (let u = true in u) )) }.b) then (if ({a = 1 , b = false }.b) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) else (unfold [ Rec X. X ] (fold [ Bool ] false ))) else (((\x: Unit .\y: Unit .x) (fix (\x: Unit . true )) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)))) }.b)
({a = ({a = (((\x: Bool .\y: Rec X. X .y) (if (let u = false in u) then (((\x: Nat .\y: Unit .x) false ) true) else (fix (\x: Nat . true ))) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f ({a = 0 , b = (let u = true in u) , c =  (if true then 1 else 0) }.b) ) (( \f: Unit .((f (iszero 0) ) true ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Nat .\b: Nat .a)) }.b) , b = (case <l = (((\x: Rec X. X .\y: Rec X. X .x) (if true then 1 else 1) ) true) > as Nat of < l = x > => x | < r = y > => y) }.b)
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Unit .y) false ) ({a = true , b = true }.b)) ) (unfold [ Nat ] (fold [ Bool ] 1 ))) , b = (iszero (let u = (let u = 0 in u) in u)) , c = (( \f: Unit .((f ({a = (if true then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else false) , b = (( \f: Rec X. X .((f 0 ) (fix (\x: Bool . 0 )) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) (succ (case <l = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .b)) }.c) ) (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = 1 }.b) )) in (case <r = (let u = ({a = 0 , b = true , c =  0 }.b) in (let u = true in u)) > as Unit of < l = x > => x | < r = y > => y)))
(((\x: Unit .\y: Rec X. X .y) (if ({a = (case <r = (let u = 1 in false) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if false then false else ({a = 1 , b = true , c =  0 }.b)) }.b) then (let u = (succ (succ 0)) in (fix (\x: Unit . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ))) else (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Bool ] false )) ))) ) (if ({a = ({a = ({a = 1 , b = false }.a) , b = true }.b) , b = (if (let u = 1 in false) then (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) else 0) }.a) then (((\x: Unit .\y: Rec X. X .x) (let u = 1 in 1) ) (if false then false else false)) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ))))
(let u = (((\x: Nat .\y: Bool .y) ({a = (let u = 1 in (let u = 0 in u)) , b = (let u = false in u) }.b) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ))) in u)
(iszero (case <l = (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a))) > as Bool of < l = x > => x | < r = y > => y))
(((\x: Rec X. X .\y: Bool .y) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] (let u = false in true) )) )) , b = (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .x) false ) (((\x: Rec X. X .\y: Unit .x) false ) true)) ) ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) , b = (let u = false in u) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c)) }.a) ) ({a = (let u = (((\x: Bool .\y: Unit .y) (fix (\x: Rec X. X . true )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .a)) ))) in (let u = (iszero (if false then 0 else 1)) in u)) , b = ({a = (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Bool .y) true ) 1) ) (let u = true in u)) , b = (let u = 0 in (((\x: Nat .\y: Rec X. X .x) 0 ) false)) }.b) }.b))
({a = (( \f: Bool .((f ({a = (case <l = (((\x: Unit .\y: Rec X. X .y) true ) 0) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true ))) , c = ({a = ({a = false , b = 1 }.b) , b = ({a = true , b = true }.b) , c = (pred 0) }.c) }.c) ) (( \f: Unit .((f (let u = ({a = 0 , b = 1 }.b) in (pred 0)) ) (unfold [ Unit ] (fold [ Nat ] (let u = (let u = 1 in u) in u) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Nat .b)) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) )) }.a)
(let u = (let u = (let u = (fix (\x: Bool . (succ 0) )) in ({a = ({a = (let u = 0 in 0) , b = ({a = true , b = 1 }.b) }.b) , b = (if true then true else false) }.b)) in (case <r = (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Unit .y) false ) false) ) false) > as Nat of < l = x > => x | < r = y > => y)) in u)
(case <r = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = (fix (\x: Nat . 1 )) }.b) )) in (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) in false)) > as Bool of < l = x > => x | < r = y > => y)
(let u = (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .x) ({a = (let u = 1 in 1) , b = (fix (\x: Unit . (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) }.b) ) (let u = ({a = 0 , b = false }.b) in u)) ) ({a = (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Nat .y) true ) true) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) , b = (((\x: Rec X. X .\y: Nat .x) true ) true) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u)
({a = (((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f ({a = 0 , b = false , c = 0 }.c) ) (succ 0) ) ) (\a: Unit .\b: Unit .a)) ) (case <r = ({a = 0 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.b) > as Bool of < l = x > => x | < r = y > => y)) , b = (fix (\x: Bool . (let u = (let u = false in false) in u) )) }.b)
({a = (let u = ({a = 0 , b = (let u = false in false) , c =  (if true then 1 else 0) }.b) in (( \f: Rec X. X .((f (let u = 1 in u) ) (unfold [ Bool ] (fold [ Unit ] 0 )) ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = (let u = ({a = 1 , b = false , c =  1 }.b) in (((\x: Nat .\y: Nat .y) false ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)))) , b = (( \f: Bool .((f (let u = false in false) ) (unfold [ Nat ] (fold [ Nat ] false )) ) ) (\a: Nat .\b: Nat .a)) }.b) , c = (fix (\x: Bool . (succ ({a = (unfold [ Nat ] (fold [ Rec X. X ] false )) , b = (succ 1) }.b)) )) }.c)
({a = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) )) in u) , b = (( \f: Bool .((f (if (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) then ({a = (if true then true else false) , b = ({a = 0 , b = (let u = false in u) }.a) }.a) else ({a = (pred 1) , b = (let u = false in u) , c =  ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.b)) ) (((\x: Bool .\y: Bool .y) ({a = (((\x: Bool .\y: Unit .x) false ) true) , b = 1 }.a) ) (( \f: Nat .((f (((\x: Nat .\y: Nat .x) (iszero 1) ) true) ) (iszero 1) ) ) (\a: Unit .\b: Nat .a))) ) ) (\a: Bool .\b: Rec X. X .a)) }.b)
(fix (\x: Rec X. X . ({a = (succ (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) }.b) ))
(fix (\x: Unit . (((\x: Rec X. X .\y: Bool .y) ({a = ({a = (((\x: Bool .\y: Unit .x) 0 ) true) , b = false }.a) , b = (let u = false in false) }.b) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] true )) ) (unfold [ Unit ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] true )) )) ) ) (\a: Unit .\b: Unit .b))) ))
(( \f: Nat .((f (let u = (let u = (( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] false )) ) true ) ) (\a: Rec X. X .\b: Nat .a)) in u) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) false ) false) )) ) ) (\a: Bool .\b: Bool .a))
(let u = (iszero (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] ({a = true , b = 0 }.b) )) ))) in (( \f: Bool .((f (iszero ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) , b = 0 }.b)) ) ({a = (let u = true in 0) , b = (if true then false else false) , c =  (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) }.b) ) ) (\a: Bool .\b: Bool .b)))
(((\x: Bool .\y: Rec X. X .y) (let u = (unfold [ Unit ] (fold [ Rec X. X ] (case <r = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) )) in u) ) (let u = ({a = (if false then true else ({a = false , b = true }.b)) , b = (fix (\x: Bool . 1 )) }.b) in (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) ({a = (((\x: Nat .\y: Rec X. X .x) 0 ) true) , b = (((\x: Unit .\y: Bool .y) false ) false) , c =  (((\x: Unit .\y: Bool .x) 1 ) true) }.b) ) (let u = false in u)) ) (let u = (let u = 1 in 0) in u))))
(( \f: Unit .((f (if (let u = ({a = 1 , b = 1 }.b) in (let u = (if false then false else false) in ({a = 1 , b = true }.b))) then (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = false in u) )) in (fix (\x: Nat . 0 ))) else ({a = 0 , b = (let u = 1 in u) }.b)) ) (pred ({a = (let u = 1 in true) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b)) ) ) (\a: Unit .\b: Bool .b))
(let u = (((\x: Rec X. X .\y: Bool .y) ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = ({a = false , b = 0 }.a) }.b) ) (let u = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) in (fix (\x: Rec X. X . true ))) in (case <r = ({a = false , b = (succ 0) }.a) > as Nat of < l = x > => x | < r = y > => y))) in u)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = false , b = (((\x: Bool .\y: Bool .y) false ) 0) }.a) ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Unit .a)) )) ) (fix (\x: Nat . (if (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .a)) then (( \f: Bool .((f ({a = true , b = false }.b) ) false ) ) (\a: Nat .\b: Bool .b)) else ({a = (((\x: Bool .\y: Unit .x) true ) ({a = 1 , b = true }.b)) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b)) )) ) ) (\a: Bool .\b: Bool .b))
(((\x: Unit .\y: Bool .x) (if (((\x: Rec X. X .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) ({a = 0 , b = true }.b) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) ({a = (if true then false else true) , b = ({a = true , b = 1 }.b) }.a)) then (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = true }.b) )) )) else (let u = (((\x: Bool .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) 1) in (let u = (let u = ({a = true , b = 1 }.a) in u) in (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in true)))) ) (let u = ({a = (let u = (succ 0) in false) , b = ({a = 1 , b = 1 }.b) }.a) in (case <r = ({a = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.a) > as Nat of < l = x > => x | < r = y > => y)))
(pred (unfold [ Bool ] (fold [ Rec X. X ] ({a = (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] true )) ) true ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = (let u = ({a = true , b = false }.b) in (iszero 0)) in (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) }.b) )))
(case <l = (case <l = (if (let u = 0 in false) then (( \f: Bool .((f 1 ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Unit .b)) else ({a = 1 , b = 1 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (let u = (let u = true in u) in ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , b = 1 }.b)) , b = (iszero (fix (\x: Unit . (((\x: Unit .\y: Unit .x) 0 ) false) ))) , c = (case <l = (unfold [ Unit ] (fold [ Bool ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) }.c) , b = ({a = (let u = (if true then ({a = 0 , b = false }.a) else 0) in (unfold [ Nat ] (fold [ Bool ] 1 ))) , b = ({a = ({a = false , b = 0 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = true }.b) ) true) }.b) }.b) }.a)
(let u = (case <l = (((\x: Rec X. X .\y: Rec X. X .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) 0) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = ({a = 0 , b = (((\x: Bool .\y: Unit .y) false ) false) , c =  (if false then 0 else 0) }.b) in ({a = ({a = 0 , b = false , c =  ({a = 0 , b = 0 }.b) }.b) , b = (pred 0) }.a)))
(( \f: Rec X. X .((f (iszero (let u = (let u = 1 in u) in u)) ) (if (if ({a = 0 , b = true }.b) then ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) else (fix (\x: Rec X. X . false ))) then ({a = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) , b = 1 }.a) else (fix (\x: Unit . (unfold [ Bool ] (fold [ Bool ] false )) ))) ) ) (\a: Nat .\b: Bool .a))
({a = (succ ({a = (succ 0) , b = (let u = ({a = 1 , b = false , c = 0 }.c) in 0) }.b)) , b = (let u = (let u = ({a = (let u = true in 0) , b = ({a = 1 , b = true , c =  1 }.b) }.b) in (let u = (unfold [ Unit ] (fold [ Unit ] 0 )) in (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)))) in u) , c = (fix (\x: Nat . (case <l = (((\x: Nat .\y: Nat .x) 1 ) true) > as Bool of < l = x > => x | < r = y > => y) )) }.c)
(let u = (unfold [ Unit ] (fold [ Bool ] (( \f: Nat .((f (if ({a = 0 , b = true , c =  0 }.b) then ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) else (iszero 1)) ) (let u = (let u = false in true) in ({a = ({a = 1 , b = 0 }.b) , b = true , c =  (succ 0) }.b)) ) ) (\a: Unit .\b: Unit .a)) )) in (((\x: Bool .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = true , c =  1 }.b) )) ) (((\x: Rec X. X .\y: Bool .x) (((\x: Rec X. X .\y: Bool .x) 1 ) true) ) (if true then false else false))))
({a = ({a = (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) (((\x: Nat .\y: Nat .y) false ) ({a = 0 , b = true }.b))) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .a)) }.a) , b = (iszero (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .y) true ) 1) ) (let u = 0 in 0) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Bool .\b: Rec X. X .a))) }.a)
((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f (let u = ({a = ({a = 0 , b = true , c = 1 }.c) , b = ({a = 1 , b = true , c = 1 }.c) }.b) in ({a = true , b = 0 }.a)) ) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Bool .\y: Nat .y) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) )) ) ) (\a: Bool .\b: Rec X. X .a)) ))
(let u = (succ ({a = ({a = 1 , b = false }.a) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.a)) in ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , b = ({a = 0 , b = ({a = 0 , b = true , c =  1 }.b) , c = (let u = 1 in u) }.c) }.b))
({a = (case <l = (( \f: Bool .((f (( \f: Unit .((f (((\x: Nat .\y: Bool .y) true ) 0) ) 0 ) ) (\a: Bool .\b: Unit .b)) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (pred (case <l = ({a = false , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y)) }.b)
(case <l = (let u = ({a = ({a = ({a = 0 , b = false }.b) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) , b = (let u = (let u = true in u) in ({a = 1 , b = true , c =  0 }.b)) }.a) in u) > as Bool of < l = x > => x | < r = y > => y)
(let u = (fix (\x: Bool . (let u = (((\x: Nat .\y: Bool .y) false ) (let u = false in true)) in (fix (\x: Rec X. X . false ))) )) in (if (iszero (fix (\x: Unit . 1 ))) then (case <l = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) > as Rec X. X of < l = x > => x | < r = y > => y) else (unfold [ Rec X. X ] (fold [ Unit ] (pred 1) ))))
(let u = (pred (let u = (((\x: Unit .\y: Unit .y) false ) 0) in (let u = (((\x: Nat .\y: Rec X. X .y) true ) false) in 0))) in (( \f: Rec X. X .((f ({a = (fix (\x: Nat . 0 )) , b = (((\x: Nat .\y: Bool .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .b)) ) false) , c =  ({a = false , b = 0 }.b) }.b) ) ({a = false , b = false }.b) ) ) (\a: Bool .\b: Nat .a)))
(((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Unit .x) (let u = ({a = 0 , b = (((\x: Nat .\y: Bool .y) true ) false) , c = 0 }.c) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true ))) ) (let u = ({a = 0 , b = true }.a) in false)) ) (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Nat . false )) )))
(case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (if (iszero (if true then 0 else (let u = false in 0))) then (( \f: Unit .((f (( \f: Rec X. X .((f (iszero 1) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) ) (\a: Rec X. X .\b: Nat .a)) else (((\x: Bool .\y: Unit .x) (iszero 0) ) true)) )) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = (let u = true in false) , b = (fix (\x: Unit . (let u = true in true) )) }.b) in ({a = ({a = (let u = (case <r = (fix (\x: Nat . true )) > as Rec X. X of < l = x > => x | < r = y > => y) in u) , b = (succ 1) }.b) , b = ({a = ({a = (let u = 0 in true) , b = (pred 1) }.b) , b = (if ({a = true , b = 0 }.a) then (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b)) else (fix (\x: Unit . (let u = true in true) ))) , c =  (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in (let u = (((\x: Bool .\y: Unit .y) false ) 1) in 0)) }.b) , c =  (((\x: Bool .\y: Bool .y) (case <r = ({a = 1 , b = true , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (let u = 1 in true) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y))) }.b))
({a = (( \f: Nat .((f (unfold [ Bool ] (fold [ Bool ] (( \f: Nat .((f (let u = true in u) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) ) ) (\a: Bool .\b: Unit .b)) )) ) ({a = ({a = (succ 0) , b = (((\x: Nat .\y: Rec X. X .y) true ) false) , c = 0 }.c) , b = (iszero 1) , c =  (succ (fix (\x: Rec X. X . 1 ))) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) ) (if true then false else true)) in u) }.a)
(let u = (succ (succ (let u = 1 in 0))) in u)
({a = ({a = (((\x: Unit .\y: Rec X. X .y) false ) ({a = 0 , b = false }.a)) , b = (fix (\x: Bool . ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .b)) , b = true }.b) )) , c = (pred 1) }.c) , b = (case <r = (fix (\x: Rec X. X . (let u = (let u = false in false) in (let u = false in u)) )) > as Bool of < l = x > => x | < r = y > => y) , c = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = 0 in u) )) ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Unit .\b: Unit .a)) }.c)
(((\x: Unit .\y: Nat .x) ({a = (let u = 1 in u) , b = (let u = false in u) }.a) ) (let u = ({a = (((\x: Nat .\y: Bool .y) false ) 1) , b = (if true then 0 else 0) }.b) in ({a = (case <l = (let u = 0 in 1) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = (if (iszero 1) then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (unfold [ Unit ] (fold [ Bool ] true ))) }.b) }.b)))
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) }.a) )) in u) ))
(((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Unit .y) (iszero ({a = 1 , b = false }.a)) ) (fix (\x: Rec X. X . (let u = (let u = 1 in false) in true) ))) ) (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Bool .y) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) (fix (\x: Bool . false ))) ) (( \f: Unit .((f (fix (\x: Nat . false )) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Bool .b))))
(fix (\x: Bool . (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) true ) false) ) ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = true , c =  0 }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ))
(let u = (if ({a = (iszero 1) , b = ({a = 0 , b = 1 }.b) }.a) then (pred (if ({a = 1 , b = false , c =  1 }.b) then (((\x: Nat .\y: Bool .x) 0 ) false) else (( \f: Bool .((f (succ 0) ) (if false then 0 else 1) ) ) (\a: Rec X. X .\b: Unit .a)))) else ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = true in ({a = false , b = true }.b)) , c = (if (unfold [ Bool ] (fold [ Bool ] false )) then ({a = 0 , b = 0 }.b) else 1) }.c)) in u)
(case <l = (((\x: Unit .\y: Bool .y) (let u = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (let u = 0 in false)) in (((\x: Bool .\y: Bool .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )))) ) (succ (( \f: Bool .((f (if false then 1 else 0) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Nat .a)))) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = (let u = ({a = (((\x: Nat .\y: Rec X. X .y) false ) false) , b = ({a = 0 , b = 0 }.b) }.b) in (case <l = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y)) , b = (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) > as Unit of < l = x > => x | < r = y > => y) }.b) in (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = true , b = false }.b) )) in (let u = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) in (fix (\x: Nat . (((\x: Nat .\y: Nat .y) true ) 0) )))))
(((\x: Rec X. X .\y: Unit .x) (case <l = (succ (let u = true in 1)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (let u = 1 in 0) in (((\x: Unit .\y: Nat .x) true ) true)))
({a = (iszero (pred (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) in ({a = 0 , b = 1 }.b)))) , b = (( \f: Bool .((f (if ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] 0 )) )) , b = ({a = true , b = 1 }.a) }.b) then ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = true in (let u = 0 in 0)) )) else ({a = 1 , b = 0 }.b)) ) (if (fix (\x: Unit . (if false then false else false) )) then (( \f: Rec X. X .((f (let u = 1 in u) ) (((\x: Rec X. X .\y: Bool .y) false ) 1) ) ) (\a: Unit .\b: Bool .b)) else (( \f: Unit .((f ({a = 0 , b = 1 }.b) ) (let u = 0 in u) ) ) (\a: Bool .\b: Unit .a))) ) ) (\a: Nat .\b: Unit .a)) }.b)
(case <r = (case <r = (((\x: Nat .\y: Nat .y) true ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .a))) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Bool ] (let u = ({a = 1 , b = false , c =  1 }.b) in u) )) ) (( \f: Nat .((f (if ({a = true , b = 1 }.a) then false else false) ) (((\x: Unit .\y: Nat .y) false ) true) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Nat .\b: Rec X. X .b)) ))
(let u = (((\x: Bool .\y: Nat .y) (let u = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) in (fix (\x: Rec X. X . (let u = false in false) ))) ) (let u = ({a = 1 , b = true , c =  0 }.b) in u)) in ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <r = ({a = true , b = 1 }.a) > as Bool of < l = x > => x | < r = y > => y) }.a))
(fix (\x: Nat . (let u = (let u = true in u) in (( \f: Bool .((f ({a = 1 , b = true , c =  1 }.b) ) ({a = false , b = 0 }.a) ) ) (\a: Unit .\b: Unit .b))) ))
(( \f: Bool .((f (( \f: Bool .((f (if ({a = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b)) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) then (( \f: Bool .((f true ) (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Nat .a)) else (let u = ({a = 1 , b = false }.b) in false)) ) (let u = ({a = (((\x: Unit .\y: Bool .x) 1 ) false) , b = true }.b) in (( \f: Unit .((f ({a = false , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) (( \f: Bool .((f (let u = true in u) ) (((\x: Rec X. X .\y: Unit .y) true ) true) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Unit .a))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (fix (\x: Rec X. X . (( \f: Bool .((f (if false then false else true) ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Nat .b)) )) ) ) (\a: Rec X. X .\b: Bool .b))
(if ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (fix (\x: Bool . true )) ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) , c =  ({a = ({a = 0 , b = 0 }.b) , b = ({a = 0 , b = true , c = 1 }.c) }.b) }.b) then (unfold [ Nat ] (fold [ Unit ] (let u = ({a = 0 , b = false , c =  1 }.b) in (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b))) )) else (( \f: Bool .((f (iszero (let u = 1 in ({a = 0 , b = true , c = 0 }.c))) ) (case <r = (fix (\x: Bool . ({a = 0 , b = true }.b) )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)))
({a = (unfold [ Rec X. X ] (fold [ Bool ] (succ ({a = 0 , b = true }.a)) )) , b = ({a = (( \f: Unit .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = 0 in 0) }.a) , c = (fix (\x: Unit . (case <l = ({a = 1 , b = true , c = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.c) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.c)
({a = ({a = (( \f: Rec X. X .((f ({a = 0 , b = 1 }.b) ) (( \f: Nat .((f ({a = 1 , b = 1 }.b) ) 0 ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Bool .((f (( \f: Unit .((f (let u = true in u) ) (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) in u) ) ) (\a: Rec X. X .\b: Bool .b)) ) (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) )) ) ) (\a: Unit .\b: Nat .a)) , c = (let u = (((\x: Unit .\y: Unit .x) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) ) true) in (((\x: Bool .\y: Unit .y) (unfold [ Unit ] (fold [ Bool ] true )) ) (let u = 0 in u))) }.c) , b = (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f false ) ({a = false , b = 1 }.a) ) ) (\a: Nat .\b: Unit .b)) )) }.a)
(((\x: Unit .\y: Unit .y) (let u = (iszero (pred 1)) in ({a = (( \f: Bool .((f ({a = 1 , b = 1 }.b) ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) , c =  (succ 0) }.b)) ) (((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) (pred ({a = 1 , b = true }.a))))
({a = (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (( \f: Unit .((f 0 ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Nat .a)) )) )) , b = ({a = (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Unit .y) true ) false) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) , b = (( \f: Rec X. X .((f ({a = 1 , b = 0 }.b) ) (let u = 0 in (let u = 1 in u)) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) }.b)
(fix (\x: Rec X. X . (case <r = (let u = (( \f: Rec X. X .((f (if true then false else false) ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .a)) in u) > as Nat of < l = x > => x | < r = y > => y) ))
(unfold [ Unit ] (fold [ Unit ] (if (if true then false else true) then (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) else (succ ({a = 0 , b = (let u = false in false) }.a))) ))
(fix (\x: Bool . (case <l = (if (let u = true in u) then (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) > as Unit of < l = x > => x | < r = y > => y) ))
(((\x: Unit .\y: Unit .x) ({a = (let u = ({a = 0 , b = false , c = 1 }.c) in (fix (\x: Rec X. X . 1 ))) , b = (if ({a = ({a = 0 , b = 0 }.b) , b = true }.b) then (let u = ({a = (fix (\x: Unit . false )) , b = 0 }.a) in u) else (let u = ({a = 0 , b = 1 }.b) in (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)))) , c =  (((\x: Unit .\y: Nat .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) in u)) }.b) ) (let u = ({a = (( \f: Nat .((f (((\x: Bool .\y: Bool .x) false ) true) ) false ) ) (\a: Nat .\b: Nat .b)) , b = (((\x: Unit .\y: Bool .y) (let u = false in true) ) 0) }.a) in (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (case <r = true > as Bool of < l = x > => x | < r = y > => y))))
({a = (let u = (((\x: Bool .\y: Unit .y) (( \f: Unit .((f (if true then true else false) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Nat .b)) ) (let u = ({a = 1 , b = true }.a) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)))) in ({a = ({a = true , b = 1 }.b) , b = (unfold [ Nat ] (fold [ Unit ] true )) , c =  (let u = ({a = 0 , b = false }.b) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) }.b)) , b = (( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) ) ({a = 1 , b = true }.b) ) ) (\a: Nat .\b: Bool .a)) }.b)
({a = (((\x: Rec X. X .\y: Unit .x) ({a = (succ 0) , b = (let u = 1 in u) }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (if false then false else true) ))) , b = (let u = (iszero (((\x: Nat .\y: Rec X. X .x) 1 ) (iszero 1))) in ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Unit . 0 )) )) , b = (let u = true in u) }.b)) , c =  (unfold [ Nat ] (fold [ Bool ] (pred ({a = 1 , b = (let u = false in false) }.a)) )) }.b)
(((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = false }.a) ) (let u = (( \f: Nat .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (((\x: Unit .\y: Nat .x) (succ 1) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (case <l = ({a = true , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Nat .((f ({a = 1 , b = false }.a) ) (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in u) ) ) (\a: Nat .\b: Nat .b)) , b = (fix (\x: Bool . false )) , c =  ({a = (if false then true else true) , b = ({a = ({a = 0 , b = true , c = 0 }.c) , b = (if true then true else false) , c = 1 }.c) }.b) }.b) , c =  (fix (\x: Unit . (((\x: Nat .\y: Nat .y) false ) 1) )) }.b))
(let u = (( \f: Bool .((f (( \f: Rec X. X .((f (fix (\x: Unit . (((\x: Bool .\y: Nat .y) true ) 0) )) ) (let u = 1 in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 ))) ) ) (\a: Nat .\b: Nat .a)) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = false in 0) )) ) ) (\a: Bool .\b: Nat .b)) in (((\x: Unit .\y: Unit .y) (let u = ({a = 1 , b = true }.b) in (let u = false in (unfold [ Rec X. X ] (fold [ Unit ] true )))) ) ({a = true , b = 0 }.b)))
(unfold [ Unit ] (fold [ Nat ] ({a = (unfold [ Bool ] (fold [ Unit ] (if ({a = 0 , b = true }.b) then (iszero 0) else true) )) , b = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) }.a) }.a) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Nat . (( \f: Unit .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) ) 1 ) ) (\a: Bool .\b: Bool .b)) )) ))
(if (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Nat .y) true ) true) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Bool .b))) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false ))) )) then (let u = (((\x: Nat .\y: Bool .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = true , b = false }.b)) in ({a = (if (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) then ({a = 0 , b = false }.a) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (( \f: Unit .((f true ) (((\x: Rec X. X .\y: Unit .x) true ) false) ) ) (\a: Nat .\b: Rec X. X .a)) , c =  ({a = 0 , b = false , c = 0 }.c) }.b)) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (if ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = true , c =  0 }.b) then (unfold [ Nat ] (fold [ Rec X. X ] (iszero 1) )) else (let u = false in true)) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (succ (let u = (let u = false in u) in ({a = false , b = 0 }.b))) ))
({a = (if (( \f: Unit .((f (let u = (fix (\x: Nat . false )) in (((\x: Bool .\y: Rec X. X .x) true ) true)) ) ({a = true , b = ({a = 0 , b = true }.a) }.a) ) ) (\a: Bool .\b: Rec X. X .b)) then (let u = (if true then 1 else (let u = true in 0)) in u) else (((\x: Rec X. X .\y: Unit .y) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (let u = (let u = 1 in u) in u))) , b = (((\x: Rec X. X .\y: Bool .y) (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Nat .x) (if true then true else false) ) (if false then true else false)) ) (iszero (unfold [ Bool ] (fold [ Rec X. X ] 1 )))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Rec X. X .x) (let u = 1 in true) ) false) ))) , c = (let u = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) )) in ({a = 1 , b = (let u = false in true) , c =  (pred 1) }.b)) in (succ (let u = 1 in u))) }.c)
(fix (\x: Bool . (case <l = (( \f: Unit .((f ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . 1 )) }.b) ) (let u = (pred 1) in u) ) ) (\a: Bool .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) ))
(((\x: Unit .\y: Rec X. X .y) ({a = ({a = (((\x: Nat .\y: Bool .y) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .a)) ) 1) , b = (let u = 0 in true) }.b) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) )) }.b) ) ({a = (pred (((\x: Bool .\y: Bool .x) 0 ) false)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .x) 0 ) false) )) }.b))
(( \f: Unit .((f (case <r = (if (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Bool .x) false ) false) )) then (((\x: Bool .\y: Bool .x) ({a = true , b = 0 }.a) ) false) else (let u = true in (if true then false else true))) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (( \f: Nat .((f (iszero 0) ) (fix (\x: Unit . false )) ) ) (\a: Unit .\b: Nat .a)) in u) ) ) (\a: Rec X. X .\b: Nat .b))
(iszero ({a = (fix (\x: Bool . (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) )) , b = ({a = ({a = 0 , b = true , c = 0 }.c) , b = false , c = 1 }.c) }.b))
({a = (((\x: Rec X. X .\y: Nat .x) (( \f: Unit .((f (((\x: Unit .\y: Nat .y) false ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) ) (let u = 1 in 0) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (if (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else true) , b = (if (let u = false in u) then (((\x: Nat .\y: Nat .x) 0 ) true) else (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) }.a)) , b = (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .x) (( \f: Unit .((f false ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Bool .y) (let u = false in false) ) (fix (\x: Rec X. X . true )))) ) ({a = (case <r = (((\x: Nat .\y: Rec X. X .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) , b = (succ 0) }.a) ) ) (\a: Bool .\b: Unit .a)) , c =  (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f (let u = true in true) ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) ) (case <l = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a))) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (if false then true else true) ))) }.b)
({a = ({a = (let u = false in (fix (\x: Unit . 0 ))) , b = (fix (\x: Unit . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) )) }.b) , b = ({a = ({a = (let u = true in u) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (let u = (fix (\x: Unit . 0 )) in false) }.b) }.b)
(fix (\x: Nat . (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .y) (if (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) then (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) else (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a))) ) (let u = 0 in u)) ) (succ ({a = false , b = 1 }.b)) ) ) (\a: Bool .\b: Bool .a)) ))
(let u = ({a = (let u = (fix (\x: Rec X. X . 0 )) in (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) true ) 1) ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.b) in (case <l = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = 1 in 0) )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) )) }.a) > as Unit of < l = x > => x | < r = y > => y))
(( \f: Bool .((f (fix (\x: Unit . (case <r = (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in u) )) > as Unit of < l = x > => x | < r = y > => y) )) ) ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Unit .\y: Nat .x) true ) ({a = 1 , b = true }.b)) , c =  (let u = (( \f: Nat .((f false ) (((\x: Bool .\y: Rec X. X .y) true ) false) ) ) (\a: Bool .\b: Rec X. X .b)) in (succ 1)) }.b) ) ) (\a: Bool .\b: Nat .a))
({a = (( \f: Rec X. X .((f ({a = ({a = true , b = true }.b) , b = 1 }.b) ) ({a = (if ({a = 0 , b = true }.b) then ({a = false , b = 1 }.b) else ({a = true , b = 0 }.b)) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) , c = ({a = true , b = 0 }.b) }.c) ) ) (\a: Bool .\b: Unit .b)) , b = (let u = (let u = (((\x: Bool .\y: Nat .y) false ) false) in u) in u) , c =  (fix (\x: Bool . (( \f: Unit .((f 0 ) (let u = false in 1) ) ) (\a: Rec X. X .\b: Nat .a)) )) }.b)
({a = (let u = (( \f: Unit .((f (( \f: Bool .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (( \f: Unit .((f ({a = 1 , b = 0 }.b) ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f true ) (iszero 0) ) ) (\a: Rec X. X .\b: Nat .b)) ))) , b = ({a = ({a = ({a = (((\x: Unit .\y: Nat .y) false ) 0) , b = ({a = 0 , b = false }.b) }.a) , b = (fix (\x: Nat . (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .a)) )) , c = (pred (let u = true in 1)) }.c) , b = (((\x: Unit .\y: Nat .y) (let u = (let u = 1 in 1) in (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) ) ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = true , c =  1 }.b)) }.a) }.a)
(iszero (( \f: Unit .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) (( \f: Bool .((f (succ 1) ) 1 ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .a)))
(let u = (( \f: Unit .((f (( \f: Unit .((f (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) ({a = 1 , b = true }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) (( \f: Nat .((f (((\x: Nat .\y: Nat .x) (if false then false else false) ) false) ) ({a = false , b = 0 }.a) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .a)) in (((\x: Unit .\y: Rec X. X .y) ({a = ({a = 0 , b = true , c = 0 }.c) , b = (((\x: Unit .\y: Unit .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) false) }.b) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)))
({a = (succ (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 )))) , b = (let u = (((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f (fix (\x: Rec X. X . false )) ) (if false then false else true) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (if (let u = 0 in false) then ({a = 1 , b = true , c =  1 }.b) else (let u = false in true))) in (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) false ) true) ) (((\x: Unit .\y: Rec X. X .x) true ) true) ) ) (\a: Nat .\b: Nat .a))) }.b)
({a = ({a = (let u = (let u = 0 in u) in u) , b = (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) true ) true) ) ({a = true , b = (let u = true in false) }.b) ) ) (\a: Unit .\b: Nat .a)) , c = (let u = (( \f: Unit .((f (((\x: Nat .\y: Unit .y) true ) false) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (let u = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Nat .b)) in (((\x: Rec X. X .\y: Bool .y) true ) 1))) }.c) , b = (let u = ({a = (((\x: Nat .\y: Bool .y) false ) 0) , b = ({a = 0 , b = (let u = 0 in u) }.b) }.b) in u) }.b)
({a = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .x) ({a = 0 , b = (if true then true else true) }.a) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true ))) )) , b = (fix (\x: Nat . (let u = (let u = 1 in true) in (unfold [ Unit ] (fold [ Unit ] true ))) )) }.b)
(((\x: Nat .\y: Rec X. X .y) (let u = (case <l = (( \f: Unit .((f (( \f: Nat .((f (((\x: Unit .\y: Bool .y) false ) 0) ) 0 ) ) (\a: Bool .\b: Unit .b)) ) (((\x: Rec X. X .\y: Unit .y) true ) 0) ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) in (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in (let u = 1 in true)) ))) ) (let u = (pred ({a = true , b = 1 }.b)) in (((\x: Bool .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Rec X. X .\y: Bool .x) true ) false) )) ) (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y))))
(iszero (((\x: Rec X. X .\y: Rec X. X .y) ({a = (((\x: Bool .\y: Nat .x) (fix (\x: Bool . true )) ) (iszero 1)) , b = (let u = 1 in ({a = false , b = 1 }.b)) }.a) ) (((\x: Bool .\y: Unit .x) (let u = true in 0) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )))))
(((\x: Rec X. X .\y: Rec X. X .y) (let u = ({a = (let u = (succ 1) in 1) , b = ({a = ({a = true , b = 0 }.b) , b = false , c =  (let u = 1 in 0) }.b) , c =  (succ 1) }.b) in u) ) (((\x: Nat .\y: Rec X. X .y) (case <r = ({a = 0 , b = true , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . (((\x: Bool .\y: Unit .x) true ) false) ))))
(( \f: Rec X. X .((f (let u = (let u = (let u = false in true) in ({a = 1 , b = true }.a)) in u) ) (pred (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Bool .y) true ) (if true then true else true)) ) (unfold [ Unit ] (fold [ Bool ] 1 )))) ) ) (\a: Bool .\b: Nat .a))
(( \f: Rec X. X .((f (fix (\x: Bool . (pred (let u = ({a = 0 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.a) in u)) )) ) (( \f: Unit .((f ({a = (((\x: Bool .\y: Bool .x) true ) false) , b = (case <l = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) > as Nat of < l = x > => x | < r = y > => y) }.b) ) (((\x: Bool .\y: Nat .y) false ) (if false then 0 else 0)) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .b))
({a = (( \f: Bool .((f ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = (if (((\x: Rec X. X .\y: Nat .x) true ) false) then ({a = 0 , b = false }.b) else (iszero 0)) }.a) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 1 in u) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = 1 , b = false , c =  0 }.b) , b = ({a = (pred 0) , b = false }.a) }.a) )) , c = (fix (\x: Unit . (if (case <r = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .a)) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = 1 , b = 0 }.b) else (((\x: Rec X. X .\y: Unit .y) true ) 0)) )) }.c)
({a = ({a = (( \f: Unit .((f (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = true in false) }.b) , b = (if (if (fix (\x: Bool . false )) then (let u = ({a = false , b = 1 }.a) in true) else (((\x: Unit .\y: Bool .y) false ) false)) then ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = false , c = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.c) else (let u = (((\x: Rec X. X .\y: Nat .y) false ) (((\x: Nat .\y: Bool .y) true ) 0)) in (( \f: Rec X. X .((f 0 ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) ) (\a: Bool .\b: Rec X. X .a)))) }.b)
(unfold [ Nat ] (fold [ Nat ] (fix (\x: Bool . (case <r = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) false ) false) ) true ) ) (\a: Nat .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y) )) ))
(fix (\x: Nat . (let u = (if (((\x: Nat .\y: Unit .y) false ) (((\x: Bool .\y: Bool .x) false ) false)) then (( \f: Unit .((f false ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) else (let u = true in u)) in (if (((\x: Unit .\y: Bool .x) false ) true) then (let u = false in 0) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)))) ))
({a = (case <l = ({a = (let u = 0 in u) , b = (((\x: Rec X. X .\y: Nat .y) false ) 0) }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . (fix (\x: Bool . (let u = (( \f: Bool .((f true ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .b)) in (iszero 0)) )) )) }.b)
(((\x: Nat .\y: Rec X. X .x) (case <l = ({a = (((\x: Unit .\y: Rec X. X .y) true ) (fix (\x: Unit . 0 ))) , b = (((\x: Nat .\y: Rec X. X .x) true ) true) , c = (fix (\x: Bool . 0 )) }.c) > as Unit of < l = x > => x | < r = y > => y) ) ({a = ({a = ({a = 0 , b = true }.b) , b = (((\x: Unit .\y: Bool .x) (iszero 1) ) (if true then true else false)) }.b) , b = (iszero (pred 0)) }.b))
({a = ({a = (( \f: Unit .((f (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) 1 ) true) ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) ) (pred 0) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = (let u = 1 in u) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) }.b) , b = (unfold [ Nat ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) true ) ({a = 0 , b = true }.a)) )) )) }.b)
(let u = ({a = (if true then 1 else 0) , b = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) true ) true) ) (let u = true in u) ) ) (\a: Bool .\b: Nat .b)) }.a) in ({a = (((\x: Bool .\y: Unit .y) (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = 1 , b = false }.b)) ) ({a = false , b = 0 }.b)) , b = (((\x: Bool .\y: Unit .x) (((\x: Nat .\y: Bool .y) false ) false) ) (if true then (case <r = true > as Nat of < l = x > => x | < r = y > => y) else (case <r = true > as Bool of < l = x > => x | < r = y > => y))) }.a))
({a = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = 1 }.b) ) true) in u) , b = (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) )) }.b) , b = ({a = (fix (\x: Unit . 0 )) , b = (((\x: Bool .\y: Rec X. X .x) (fix (\x: Nat . true )) ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b))) }.a) }.a)
(let u = (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (((\x: Bool .\y: Bool .y) false ) 0) in (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Nat .y) true ) false) ) (let u = false in u))) )) ) (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) false ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y)) in (let u = (( \f: Bool .((f (let u = (let u = 1 in true) in (let u = false in false)) ) (iszero 0) ) ) (\a: Nat .\b: Unit .a)) in ({a = (fix (\x: Unit . 1 )) , b = ({a = (((\x: Unit .\y: Nat .y) false ) true) , b = (((\x: Rec X. X .\y: Nat .y) false ) 0) }.a) }.a)))
(((\x: Unit .\y: Rec X. X .y) (case <r = (( \f: Rec X. X .((f ({a = 1 , b = true , c =  0 }.b) ) (unfold [ Bool ] (fold [ Bool ] false )) ) ) (\a: Bool .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (if (( \f: Unit .((f false ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .b)) then (succ (((\x: Unit .\y: Bool .y) false ) 1)) else ({a = 1 , b = true }.a)) , b = (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b))) , c =  (( \f: Bool .((f (fix (\x: Rec X. X . 1 )) ) 0 ) ) (\a: Bool .\b: Unit .b)) }.b))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = (( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .b)) in u) ))
(let u = (case <r = (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Unit .x) (if true then true else false) ) (let u = false in u)) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a))) ) (fix (\x: Rec X. X . ({a = false , b = 1 }.a) ))) > as Unit of < l = x > => x | < r = y > => y) in u)
(unfold [ Unit ] (fold [ Unit ] ({a = (let u = (case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )) > as Unit of < l = x > => x | < r = y > => y) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = ({a = false , b = ({a = 0 , b = 0 }.b) }.a) , b = (let u = 0 in 1) }.a) }.b) ))
(((\x: Nat .\y: Nat .y) (unfold [ Unit ] (fold [ Bool ] (((\x: Unit .\y: Bool .y) (iszero 1) ) false) )) ) (succ (( \f: Rec X. X .((f ({a = true , b = 0 }.b) ) (unfold [ Bool ] (fold [ Unit ] (let u = 1 in u) )) ) ) (\a: Nat .\b: Bool .b))))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = false , b = false }.b) )) in u) )) ))
(( \f: Unit .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = (let u = 1 in u) , b = (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Bool .y) true ) false) ) (((\x: Rec X. X .\y: Unit .y) true ) true)) }.b) )) ) (iszero (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) (unfold [ Bool ] (fold [ Nat ] false )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) ))) ) ) (\a: Nat .\b: Bool .b))
(case <l = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = (let u = 0 in true) , c =  0 }.b) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.b)) > as Nat of < l = x > => x | < r = y > => y)
({a = (let u = ({a = (((\x: Nat .\y: Bool .y) false ) false) , b = ({a = 1 , b = true , c = 0 }.c) }.b) in (fix (\x: Unit . (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ))) , b = (unfold [ Nat ] (fold [ Unit ] (let u = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .a)) in u) )) }.b)
(( \f: Bool .((f (case <r = (fix (\x: Unit . (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Nat .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .y) true ) false) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b))) }.b) )) ) ) (\a: Unit .\b: Nat .a))
({a = (case <l = (succ (let u = 0 in u)) > as Unit of < l = x > => x | < r = y > => y) , b = (if ({a = ({a = (((\x: Nat .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) 0) , b = (if false then false else (fix (\x: Nat . true ))) }.a) , b = ({a = 1 , b = true , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.b) , c =  (pred (fix (\x: Unit . 1 ))) }.b) then ({a = ({a = true , b = 0 }.a) , b = (((\x: Unit .\y: Rec X. X .y) true ) (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) }.a) else (let u = (if (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) then 0 else 1) in ({a = false , b = true }.b))) }.b)
(let u = (case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) )) > as Unit of < l = x > => x | < r = y > => y) in (case <r = ({a = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .a)) then ({a = false , b = 0 }.b) else 0) }.a) > as Unit of < l = x > => x | < r = y > => y))
(pred (if (let u = ({a = 1 , b = true , c =  0 }.b) in u) then (let u = 1 in 1) else ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = (if ({a = true , b = 0 }.a) then 0 else 1) }.b)))
(let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (if (if true then true else true) then (fix (\x: Bool . true )) else (((\x: Bool .\y: Nat .y) (iszero (let u = false in 1)) ) (((\x: Nat .\y: Unit .x) false ) false))) )) in u)
(fix (\x: Nat . ({a = (let u = (( \f: Bool .((f (let u = 1 in true) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) in (((\x: Unit .\y: Nat .x) ({a = 1 , b = false , c = 0 }.c) ) false)) , b = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero 0) )) in (let u = ({a = 0 , b = false , c =  1 }.b) in (iszero 1))) , c = ({a = 1 , b = 1 }.b) }.c) ))
(( \f: Bool .((f ({a = (if (((\x: Unit .\y: Unit .y) true ) false) then (let u = 0 in u) else (fix (\x: Nat . 0 ))) , b = (let u = (iszero 1) in u) , c =  (((\x: Rec X. X .\y: Bool .y) (fix (\x: Unit . ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = false , c =  1 }.b) )) ) ({a = (unfold [ Bool ] (fold [ Bool ] (if false then 0 else 1) )) , b = (((\x: Bool .\y: Bool .x) false ) false) , c = (let u = (let u = false in u) in 0) }.c)) }.b) ) (iszero (succ (case <l = (let u = true in 1) > as Unit of < l = x > => x | < r = y > => y))) ) ) (\a: Unit .\b: Unit .b))
(pred (( \f: Bool .((f (let u = (iszero ({a = 1 , b = 1 }.b)) in ({a = 1 , b = false , c = 0 }.c)) ) (case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) (fix (\x: Bool . 0 )) ) ) (\a: Unit .\b: Bool .b)) )) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a)))
(succ ({a = (unfold [ Nat ] (fold [ Bool ] ({a = (let u = 0 in 1) , b = true }.b) )) , b = (let u = (((\x: Nat .\y: Nat .y) false ) false) in ({a = 0 , b = false }.a)) }.b))
(if (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .y) true ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false ))) )) then (( \f: Bool .((f ({a = ({a = 0 , b = true }.b) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.a) ) (let u = true in u) ) ) (\a: Bool .\b: Rec X. X .a)) else ({a = ({a = (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (fix (\x: Unit . 0 )) , b = true }.b) }.a) , b = (if ({a = 1 , b = true , c =  0 }.b) then (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) else (((\x: Unit .\y: Unit .x) false ) (let u = true in u))) }.b))
({a = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) )) in (pred (let u = (((\x: Nat .\y: Bool .y) ({a = true , b = false }.b) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a))) in (if true then 0 else 0)))) , b = (((\x: Bool .\y: Nat .y) (let u = true in (let u = false in true)) ) (let u = (unfold [ Unit ] (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] 0 )) )) in ({a = 1 , b = false , c = 1 }.c))) }.b)
(((\x: Rec X. X .\y: Bool .x) (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) )) else (((\x: Unit .\y: Rec X. X .x) (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) in 0) ) (iszero 1))) ) (( \f: Unit .((f (if false then false else (((\x: Rec X. X .\y: Bool .x) true ) false)) ) ({a = (fix (\x: Rec X. X . 0 )) , b = false }.b) ) ) (\a: Bool .\b: Bool .b)))
(case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (if (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .b)) in u) then ({a = 0 , b = 0 }.b) else (let u = false in (if true then 1 else 0))) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(if (let u = (((\x: Unit .\y: Bool .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true ))) in (if true then false else true)) then (iszero ({a = (((\x: Unit .\y: Bool .x) true ) false) , b = (if false then 1 else 0) }.b)) else (let u = (if true then true else true) in u))
(let u = (let u = (let u = (fix (\x: Unit . (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) in (unfold [ Bool ] (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] 1 )) ))) in ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a)) in (iszero (let u = (case <l = (fix (\x: Nat . 0 )) > as Bool of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Nat .\y: Nat .y) (let u = false in false) ) (fix (\x: Nat . 0 ))) )))))
(succ (let u = (if ({a = true , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) then (((\x: Rec X. X .\y: Unit .x) 0 ) true) else (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) in u))
(( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] ({a = (let u = true in true) , b = ({a = 0 , b = true , c = 1 }.c) }.a) )) ) (iszero (case <l = (if (((\x: Unit .\y: Nat .x) true ) true) then 1 else 0) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .b))
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (( \f: Rec X. X .((f (let u = 0 in 0) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) ) (\a: Nat .\b: Nat .b)) in u) )) in (if (if (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .b)) ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Unit .a)) then (if (((\x: Unit .\y: Bool .y) true ) (unfold [ Unit ] (fold [ Rec X. X ] false ))) then ({a = 0 , b = true , c =  1 }.b) else ({a = 0 , b = false }.b)) else (( \f: Nat .((f (( \f: Rec X. X .((f (let u = 1 in true) ) (iszero 0) ) ) (\a: Rec X. X .\b: Bool .a)) ) (((\x: Bool .\y: Rec X. X .y) true ) true) ) ) (\a: Rec X. X .\b: Nat .a))) then (fix (\x: Unit . (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a)) )) else (let u = (((\x: Nat .\y: Unit .y) ({a = false , b = true }.b) ) ({a = false , b = true }.b)) in (case <r = (( \f: Bool .((f true ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Unit .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y))))
(let u = (let u = (let u = (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) (fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) )) ) ) (\a: Unit .\b: Rec X. X .a)) in (( \f: Unit .((f (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (fix (\x: Bool . true )) ) ) (\a: Bool .\b: Rec X. X .b)) ) (if true then true else true) ) ) (\a: Unit .\b: Unit .a))) in (case <l = (let u = 1 in u) > as Nat of < l = x > => x | < r = y > => y)) in u)
(((\x: Bool .\y: Nat .x) ({a = (let u = ({a = false , b = true }.b) in u) , b = ({a = (let u = (succ 0) in (((\x: Bool .\y: Bool .x) 0 ) false)) , b = ({a = 1 , b = 0 }.b) }.b) }.b) ) (iszero (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .y) true ) 1) ) 1 ) ) (\a: Rec X. X .\b: Unit .a))))
(let u = (fix (\x: Nat . (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 )) in u) )) in u)
(let u = (succ (let u = ({a = (let u = false in u) , b = (let u = 1 in 0) }.a) in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y))) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Bool .x) (fix (\x: Unit . false )) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) )) in (let u = (((\x: Rec X. X .\y: Nat .y) false ) true) in (fix (\x: Bool . false )))) )))
(( \f: Bool .((f (let u = (let u = true in (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b))) in ({a = ({a = 1 , b = true , c = 1 }.c) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) }.c)) ) (pred (( \f: Bool .((f (let u = (((\x: Nat .\y: Unit .y) true ) 0) in u) ) (succ ({a = (let u = true in 1) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = 0 }.c)) ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (succ (case <l = (((\x: Rec X. X .\y: Bool .x) 1 ) true) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .y) (((\x: Nat .\y: Rec X. X .y) true ) (fix (\x: Nat . false ))) ) (fix (\x: Rec X. X . (let u = false in u) ))) ) (( \f: Rec X. X .((f ({a = 1 , b = (fix (\x: Bool . true )) }.b) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Unit .a)) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Bool .((f (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) false ) false) ) ({a = 0 , b = false , c = 0 }.c)) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = false , c = 0 }.c) )) ) ) (\a: Bool .\b: Bool .a)) ))
(((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Unit ] (( \f: Bool .((f (let u = true in u) ) (((\x: Bool .\y: Rec X. X .y) false ) false) ) ) (\a: Bool .\b: Unit .a)) )) ) ({a = ({a = (let u = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) in (if false then true else true)) , b = (succ 1) }.a) , b = (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.a))
(( \f: Bool .((f (succ ({a = ({a = (case <l = ({a = 0 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y) , b = (succ (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b))) }.b) , b = (if (fix (\x: Rec X. X . false )) then ({a = 0 , b = true }.b) else (let u = true in u)) }.a)) ) ({a = ({a = (((\x: Rec X. X .\y: Bool .x) 1 ) true) , b = (fix (\x: Unit . true )) }.a) , b = ({a = ({a = true , b = 1 }.b) , b = (let u = 1 in false) , c =  (((\x: Nat .\y: Nat .y) true ) (((\x: Unit .\y: Bool .y) false ) 1)) }.b) }.a) ) ) (\a: Unit .\b: Nat .a))
(iszero (let u = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) , b = ({a = 1 , b = false }.b) }.a) in u))
((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = (let u = (((\x: Nat .\y: Unit .y) true ) false) in (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) in true)) in ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = ({a = (if true then 0 else 0) , b = 0 }.b) }.b)) ))
(((\x: Nat .\y: Nat .x) (( \f: Nat .((f (let u = (let u = 0 in 1) in u) ) (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in 0) ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = (if true then ({a = 0 , b = 0 }.b) else 0) , b = (( \f: Unit .((f (let u = 0 in false) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Bool .a)) , c =  ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = (if false then (pred 1) else 0) }.b) }.b))
(case <r = (case <r = (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) (if false then false else false) ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(if (case <r = ({a = (let u = true in (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a))) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.a) > as Unit of < l = x > => x | < r = y > => y) then ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . true )) , c = (((\x: Unit .\y: Nat .x) 0 ) (iszero 0)) }.c) else (case <l = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y))
(succ ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Bool .y) true ) 0) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) }.a))
(( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] (case <r = (if false then true else true) > as Nat of < l = x > => x | < r = y > => y) )) ) (fix (\x: Unit . (let u = (((\x: Nat .\y: Nat .y) false ) false) in u) )) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (((\x: Unit .\y: Rec X. X .y) (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) > as Bool of < l = x > => x | < r = y > => y) ) (iszero (fix (\x: Bool . 1 )))) in (let u = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) , b = (if (let u = true in u) then false else (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) in u))
({a = (((\x: Rec X. X .\y: Rec X. X .y) (let u = (if (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) then (case <r = false > as Unit of < l = x > => x | < r = y > => y) else (let u = true in true)) in (( \f: Rec X. X .((f (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) (if false then false else false) ) ) (\a: Unit .\b: Unit .b))) ) ({a = ({a = 0 , b = false }.a) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (pred 1) )) }.b)) , b = (iszero (fix (\x: Unit . ({a = 0 , b = false , c = 1 }.c) ))) }.a)
(( \f: Nat .((f (( \f: Unit .((f (let u = (fix (\x: Unit . 0 )) in (let u = (let u = 1 in false) in (let u = 0 in 0))) ) (case <l = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = true , c = (pred 1) }.c) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) ) (( \f: Bool .((f (( \f: Nat .((f 1 ) (let u = false in 0) ) ) (\a: Nat .\b: Unit .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in 1) )) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .b))
(if (((\x: Rec X. X .\y: Nat .y) ({a = false , b = (((\x: Bool .\y: Bool .x) true ) false) }.b) ) ({a = (let u = 1 in 1) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b)) then (((\x: Unit .\y: Nat .x) (( \f: Bool .((f 1 ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) , c =  (let u = (unfold [ Bool ] (fold [ Bool ] true )) in (if false then 1 else 1)) }.b)) else (let u = (let u = (let u = 0 in 1) in ({a = ({a = false , b = 0 }.a) , b = 1 }.a)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = 0 in u) ))))
(((\x: Rec X. X .\y: Nat .x) ({a = (unfold [ Unit ] (fold [ Bool ] (let u = false in 0) )) , b = (case <r = ({a = (iszero 0) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) }.a) > as Nat of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f (let u = 1 in (iszero 0)) ) (fix (\x: Nat . ({a = 1 , b = true }.b) )) ) ) (\a: Nat .\b: Nat .b)))
(( \f: Unit .((f (let u = (iszero ({a = 0 , b = true , c = ({a = 1 , b = true , c = 1 }.c) }.c)) in (let u = (( \f: Rec X. X .((f (let u = 1 in 1) ) ({a = false , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) in u)) ) (case <l = (if (let u = true in ({a = 0 , b = false , c =  1 }.b)) then ({a = 0 , b = 0 }.b) else (((\x: Rec X. X .\y: Unit .x) 1 ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b))
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Rec X. X . false )) )) )) ))
(case <r = (fix (\x: Unit . (( \f: Nat .((f (((\x: Bool .\y: Nat .y) true ) true) ) (unfold [ Unit ] (fold [ Bool ] true )) ) ) (\a: Nat .\b: Nat .a)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Bool ] (if (let u = (((\x: Nat .\y: Rec X. X .x) 0 ) true) in (if (((\x: Unit .\y: Nat .y) false ) false) then ({a = true , b = 1 }.a) else false)) then (unfold [ Unit ] (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) else (pred (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)))) ))
(pred (let u = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = (fix (\x: Nat . (let u = 1 in true) )) , c = (if true then 0 else 0) }.c) in ({a = (if false then (let u = false in 1) else 0) , b = (if true then 0 else 0) }.b)))
({a = ({a = (pred 1) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) , c =  (((\x: Nat .\y: Unit .x) (pred 0) ) (let u = ({a = 1 , b = false }.b) in u)) }.b) , b = ({a = (if ({a = ({a = 0 , b = 0 }.b) , b = true }.b) then (let u = 0 in 0) else (let u = ({a = 0 , b = true , c = 0 }.c) in u)) , b = (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f 1 ) (let u = true in 1) ) ) (\a: Bool .\b: Unit .a)) )) }.b) }.b)
(((\x: Bool .\y: Nat .y) (fix (\x: Unit . (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) false) ) (iszero (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b))) ) ) (\a: Unit .\b: Rec X. X .a)) )) ) (((\x: Rec X. X .\y: Bool .y) ({a = (let u = 0 in u) , b = false , c =  0 }.b) ) (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y)))
(( \f: Unit .((f (if (unfold [ Nat ] (fold [ Rec X. X ] (let u = (let u = 1 in false) in u) )) then (iszero ({a = 0 , b = 0 }.b)) else (let u = (if ({a = (let u = false in true) , b = 1 }.a) then (((\x: Rec X. X .\y: Bool .x) (if false then true else false) ) false) else (((\x: Unit .\y: Nat .y) false ) false)) in u)) ) ({a = (unfold [ Nat ] (fold [ Rec X. X ] (let u = 1 in 0) )) , b = (let u = ({a = false , b = 1 }.a) in u) }.b) ) ) (\a: Rec X. X .\b: Bool .a))
(let u = (let u = (let u = false in ({a = 1 , b = false , c =  1 }.b)) in (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = false }.b) ) (let u = true in (let u = 1 in false)))) in (iszero (let u = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) in (if (unfold [ Unit ] (fold [ Unit ] true )) then ({a = 0 , b = false , c = 1 }.c) else 1)) in u)))
({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f (let u = 1 in u) ) (let u = (let u = true in true) in 1) ) ) (\a: Bool .\b: Bool .a)) ) (((\x: Bool .\y: Rec X. X .x) ({a = ({a = 0 , b = true , c = (let u = 1 in u) }.c) , b = ({a = 1 , b = false , c = 1 }.c) }.b) ) ({a = ({a = true , b = 1 }.b) , b = false , c =  1 }.b)) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (case <r = ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) }.b)
(( \f: Unit .((f (((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f 0 ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Unit .\b: Nat .a)) ) (case <r = (( \f: Bool .((f true ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y)) ) (((\x: Bool .\y: Bool .y) (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = false }.b) )) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = 0 in true) }.a)) ) ) (\a: Rec X. X .\b: Unit .b))
(let u = (let u = (pred (unfold [ Nat ] (fold [ Nat ] 1 ))) in (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .y) false ) false) ) (let u = false in u) ) ) (\a: Bool .\b: Unit .a))) in u)
(case <l = (fix (\x: Bool . ({a = (fix (\x: Unit . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) )) , b = (((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Rec X. X .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) true) ) (if (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .b)) then true else true)) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (let u = ({a = ({a = (succ 1) , b = true }.b) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.b) in u) , b = (fix (\x: Unit . (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) )) > as Bool of < l = x > => x | < r = y > => y) )) }.b)
(let u = (pred (pred ({a = false , b = (fix (\x: Bool . 1 )) }.b))) in u)
(let u = (case <r = (((\x: Unit .\y: Nat .x) true ) ({a = true , b = true }.b)) > as Nat of < l = x > => x | < r = y > => y) in (case <l = ({a = ({a = 0 , b = true }.a) , b = (((\x: Bool .\y: Bool .x) 0 ) true) }.b) > as Unit of < l = x > => x | < r = y > => y))
(if (case <r = (((\x: Nat .\y: Unit .y) ({a = false , b = ({a = 0 , b = false , c = 1 }.c) }.a) ) (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Nat .y) true ) false) ) (((\x: Bool .\y: Bool .x) false ) true))) > as Bool of < l = x > => x | < r = y > => y) then (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) )) else (((\x: Unit .\y: Bool .y) (iszero (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) ) (let u = ({a = true , b = 0 }.a) in ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = true }.a))))
(if (((\x: Nat .\y: Unit .y) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 0 in u) )) , b = (fix (\x: Bool . ({a = false , b = false }.b) )) }.b) ) ({a = (succ 1) , b = (( \f: Rec X. X .((f ({a = true , b = false }.b) ) (((\x: Bool .\y: Unit .x) true ) false) ) ) (\a: Rec X. X .\b: Bool .a)) , c =  (let u = 0 in 0) }.b)) then (case <r = ({a = 1 , b = (fix (\x: Rec X. X . true )) , c =  (let u = 0 in 1) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) else (((\x: Nat .\y: Unit .y) (( \f: Nat .((f (( \f: Bool .((f (((\x: Bool .\y: Bool .y) (let u = true in true) ) (fix (\x: Rec X. X . true ))) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Bool .((f (let u = true in u) ) (( \f: Bool .((f true ) (let u = false in false) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .b)) ) (case <r = (let u = false in u) > as Bool of < l = x > => x | < r = y > => y)))
(unfold [ Nat ] (fold [ Unit ] ({a = (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .y) false ) 1) ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = (pred 1) in u) }.b) ))
({a = (let u = (case <l = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Bool .x) true ) false) , c = (succ 0) }.c) > as Rec X. X of < l = x > => x | < r = y > => y) in (fix (\x: Nat . (((\x: Nat .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ) (unfold [ Unit ] (fold [ Unit ] false ))) ))) , b = ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .y) false ) true) )) , c = (let u = 0 in u) }.c) }.b)
({a = (let u = ({a = ({a = 1 , b = true , c = 1 }.c) , b = (((\x: Rec X. X .\y: Bool .x) false ) false) }.b) in (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) (fix (\x: Nat . 0 )))) , b = (fix (\x: Bool . (((\x: Unit .\y: Unit .x) (pred (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a))) ) (unfold [ Nat ] (fold [ Unit ] (unfold [ Nat ] (fold [ Bool ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ))) )) }.b)
(((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Unit .y) ({a = ({a = 1 , b = 0 }.b) , b = false }.b) ) (((\x: Nat .\y: Unit .x) (let u = 1 in false) ) false)) ) (succ ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = (let u = false in u) in (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) ))))
(( \f: Unit .((f (case <r = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) > as Nat of < l = x > => x | < r = y > => y) ) ({a = ({a = (( \f: Nat .((f (pred 1) ) ({a = 1 , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (fix (\x: Bool . ({a = (pred 0) , b = (let u = 1 in true) }.a) )) }.b) , b = (fix (\x: Bool . (( \f: Unit .((f ({a = false , b = true }.b) ) false ) ) (\a: Nat .\b: Rec X. X .b)) )) , c =  (let u = ({a = 0 , b = false }.b) in (((\x: Nat .\y: Nat .y) (iszero 0) ) (if true then 1 else 1))) }.b) ) ) (\a: Bool .\b: Bool .b))
({a = (iszero (pred (if true then 1 else 0))) , b = (( \f: Unit .((f (if (if true then true else false) then (let u = 0 in 0) else 1) ) (((\x: Rec X. X .\y: Bool .x) (if false then 1 else 0) ) ({a = 1 , b = false }.b)) ) ) (\a: Bool .\b: Unit .b)) }.a)
({a = (((\x: Unit .\y: Bool .x) (let u = (let u = true in u) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 ))) ) (let u = ({a = (let u = false in u) , b = (((\x: Unit .\y: Nat .y) false ) true) }.b) in u)) , b = (fix (\x: Nat . (fix (\x: Nat . ({a = 1 , b = false }.b) )) )) }.a)
(((\x: Bool .\y: Bool .x) (fix (\x: Unit . (unfold [ Unit ] (fold [ Bool ] (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Bool of < l = x > => x | < r = y > => y) )) )) ) (iszero (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .x) 0 ) true) ) (fix (\x: Bool . 0 )) ) ) (\a: Rec X. X .\b: Nat .a))))
(( \f: Unit .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = 1 , b = 0 }.b) , b = ({a = 0 , b = true , c =  0 }.b) , c = (if (unfold [ Unit ] (fold [ Rec X. X ] true )) then (let u = 0 in u) else (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a))) }.c) )) ) (let u = (let u = (( \f: Bool .((f ({a = false , b = false }.b) ) true ) ) (\a: Unit .\b: Rec X. X .a)) in (fix (\x: Bool . 1 ))) in (fix (\x: Bool . ({a = (let u = 0 in u) , b = false , c = 1 }.c) ))) ) ) (\a: Unit .\b: Bool .b))
(unfold [ Nat ] (fold [ Rec X. X ] (( \f: Bool .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = 1 }.b) )) ) (let u = (unfold [ Bool ] (fold [ Nat ] 1 )) in u) ) ) (\a: Unit .\b: Unit .b)) ))
({a = (unfold [ Bool ] (fold [ Unit ] (let u = ({a = 1 , b = ({a = true , b = false }.b) }.a) in u) )) , b = (let u = (unfold [ Bool ] (fold [ Unit ] 0 )) in (case <r = (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) }.b)
(let u = (iszero ({a = ({a = false , b = 1 }.b) , b = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.a) , c = (fix (\x: Nat . 0 )) }.c)) in u)
(iszero (let u = (( \f: Rec X. X .((f (pred 1) ) (((\x: Bool .\y: Bool .y) true ) 0) ) ) (\a: Rec X. X .\b: Bool .b)) in (succ 1)))
(((\x: Bool .\y: Rec X. X .x) (((\x: Nat .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (iszero 0) )) )) ) (let u = (((\x: Bool .\y: Bool .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) in (unfold [ Bool ] (fold [ Bool ] false )))) ) (if (fix (\x: Bool . true )) then (( \f: Unit .((f ({a = 1 , b = true }.b) ) ({a = (pred 1) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) ))))
({a = (( \f: Bool .((f ({a = 1 , b = ({a = 0 , b = false }.b) , c = 1 }.c) ) (let u = ({a = true , b = 0 }.b) in (let u = 1 in 0)) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Bool .\y: Nat .y) ({a = ({a = false , b = false }.b) , b = 0 }.a) ) (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b))) }.a)
(( \f: Rec X. X .((f (( \f: Rec X. X .((f (case <r = (fix (\x: Unit . (let u = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) in u) )) > as Nat of < l = x > => x | < r = y > => y) ) ({a = ({a = (let u = 1 in 1) , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c =  ({a = 0 , b = true }.a) }.b) , b = (unfold [ Bool ] (fold [ Unit ] false )) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = (((\x: Nat .\y: Unit .x) ({a = 0 , b = false }.a) ) (let u = false in u)) , b = ({a = (if (((\x: Unit .\y: Rec X. X .x) true ) true) then (let u = 0 in false) else true) , b = (pred (let u = 0 in (let u = 1 in u))) }.a) , c =  (((\x: Unit .\y: Nat .y) ({a = false , b = false }.b) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) }.b) ) ) (\a: Rec X. X .\b: Unit .b))
(if (let u = (( \f: Unit .((f (let u = ({a = 0 , b = true , c =  1 }.b) in false) ) ({a = (if true then true else false) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 1 , b = true , c = 1 }.c) )) }.a) ) ) (\a: Unit .\b: Unit .b)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (if (fix (\x: Unit . false )) then false else (let u = 1 in true)) ))) then (((\x: Unit .\y: Bool .x) (let u = (( \f: Bool .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) 0 ) ) (\a: Bool .\b: Nat .a)) in ({a = 0 , b = (let u = false in 0) }.b)) ) ({a = (if false then (fix (\x: Unit . 1 )) else (((\x: Nat .\y: Unit .y) true ) 0)) , b = (iszero 0) , c =  ({a = true , b = 1 }.b) }.b)) else ({a = (case <l = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Bool . 0 )) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero (( \f: Bool .((f (let u = 1 in 1) ) 1 ) ) (\a: Bool .\b: Rec X. X .a))) , c = (( \f: Bool .((f (let u = ({a = 1 , b = false , c = 1 }.c) in ({a = false , b = 1 }.b)) ) (( \f: Rec X. X .((f (fix (\x: Bool . 0 )) ) ({a = (pred 1) , b = true , c = (succ 0) }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .b)) }.c))
({a = (((\x: Unit .\y: Rec X. X .y) (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ) (let u = ({a = 1 , b = false , c = (let u = 1 in u) }.c) in u)) , b = (case <r = (let u = 0 in true) > as Nat of < l = x > => x | < r = y > => y) }.a)
(let u = ({a = (pred 1) , b = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .x) false ) false) ) (let u = true in false)) , c =  (if (let u = true in false) then (((\x: Nat .\y: Nat .y) (((\x: Bool .\y: Nat .y) true ) true) ) (pred 1)) else (pred ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )))) }.b) in ({a = (let u = (unfold [ Bool ] (fold [ Nat ] true )) in (pred 1)) , b = (let u = (if ({a = 0 , b = false }.b) then 1 else (succ 1)) in (let u = true in u)) }.a))
(( \f: Nat .((f (pred (if (if false then true else true) then (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) else (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) in ({a = true , b = 0 }.b)))) ) (unfold [ Bool ] (fold [ Unit ] (let u = ({a = true , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .b)) }.b) in ({a = true , b = 1 }.b)) )) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (let u = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) , c =  (if (((\x: Rec X. X .\y: Rec X. X .y) true ) (let u = true in false)) then ({a = false , b = 1 }.b) else (((\x: Nat .\y: Nat .x) 1 ) true)) }.b) in u) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 0 , b = false , c =  0 }.b) ) (if (let u = true in u) then ({a = 1 , b = true }.b) else false)) , b = (let u = (( \f: Unit .((f 1 ) (pred 0) ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = 1 in u)) }.b) }.a)
(( \f: Unit .((f (( \f: Nat .((f (iszero ({a = 0 , b = false }.a)) ) ({a = (let u = 1 in false) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true )) }.b) ) ) (\a: Unit .\b: Bool .b)) ) ({a = (unfold [ Bool ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] 1 )) )) , b = (( \f: Bool .((f (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .b)) , c =  ({a = (if (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .b)) then (let u = 1 in u) else (if (if true then true else true) then (let u = 1 in u) else 0)) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) (let u = 0 in true) ) ) (\a: Bool .\b: Rec X. X .a)) }.a) }.b) ) ) (\a: Nat .\b: Nat .b))
(if (unfold [ Unit ] (fold [ Bool ] ({a = ({a = ({a = true , b = 0 }.a) , b = 1 }.a) , b = (((\x: Nat .\y: Nat .y) true ) 0) }.a) )) then (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (case <l = (succ 0) > as Bool of < l = x > => x | < r = y > => y) ))) else (let u = (unfold [ Bool ] (fold [ Bool ] (( \f: Nat .((f 1 ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .b)) )) in u))
(((\x: Bool .\y: Bool .x) (( \f: Unit .((f (((\x: Unit .\y: Bool .x) (if true then true else false) ) (let u = true in false)) ) (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) ) (unfold [ Nat ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Nat ] false )) )))
(case <r = ({a = (((\x: Nat .\y: Unit .x) (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) in true) ) (((\x: Rec X. X .\y: Nat .x) false ) false)) , b = (pred (let u = 1 in u)) }.a) > as Bool of < l = x > => x | < r = y > => y)
(if ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (succ 0) )) , b = (fix (\x: Rec X. X . ({a = true , b = true }.b) )) }.b) then (case <r = (let u = (iszero 0) in u) > as Bool of < l = x > => x | < r = y > => y) else ({a = ({a = ({a = 1 , b = (((\x: Unit .\y: Bool .y) false ) false) }.b) , b = (( \f: Nat .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.a) , b = (iszero (((\x: Bool .\y: Nat .x) 0 ) true)) }.b))
(fix (\x: Unit . ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .b)) }.b) , b = (let u = ({a = 1 , b = false , c = 0 }.c) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in 1) ))) }.a) )) ))
({a = (let u = (unfold [ Nat ] (fold [ Unit ] (let u = false in 1) )) in (pred (let u = 1 in 1))) , b = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Nat .((f (((\x: Bool .\y: Nat .x) (let u = true in u) ) (let u = true in u)) ) ({a = (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = true }.b) }.b) ) ) (\a: Unit .\b: Unit .b)) )) }.b)
(unfold [ Rec X. X ] (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = (fix (\x: Rec X. X . ({a = false , b = 1 }.a) )) , b = ({a = false , b = 1 }.b) }.b) )) ))
({a = (( \f: Unit .((f ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) 1 ) true) ) (((\x: Unit .\y: Nat .y) false ) 0) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) (((\x: Nat .\y: Rec X. X .y) (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) in u) ) (succ (let u = 0 in u))) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Nat . false )) )) }.a)
(( \f: Rec X. X .((f (let u = ({a = (fix (\x: Unit . true )) , b = (( \f: Bool .((f 1 ) ({a = false , b = 1 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) }.b) in (succ (let u = 0 in (fix (\x: Rec X. X . 0 ))))) ) ({a = (let u = (if false then (fix (\x: Bool . 1 )) else (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) in ({a = (iszero 1) , b = 0 }.b)) , b = (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Bool .x) ({a = 0 , b = true , c =  1 }.b) ) ({a = 0 , b = true , c =  1 }.b)) ) (unfold [ Unit ] (fold [ Bool ] 0 ))) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(let u = (let u = (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Rec X. X .y) true ) 0) ) (let u = true in u)) in (case <l = ({a = 1 , b = false , c = 0 }.c) > as Unit of < l = x > => x | < r = y > => y)) in ({a = (succ (let u = false in 0)) , b = (case <r = (let u = (let u = true in 1) in true) > as Rec X. X of < l = x > => x | < r = y > => y) }.a))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) (( \f: Bool .((f (((\x: Bool .\y: Unit .x) false ) true) ) true ) ) (\a: Nat .\b: Bool .a)) ) ({a = 0 , b = ({a = 0 , b = true , c =  0 }.b) , c =  (((\x: Unit .\y: Unit .y) false ) 0) }.b)) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = (case <r = (case <r = (fix (\x: Rec X. X . true )) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Unit .x) false ) false) , c =  (pred 1) }.b) }.b) )) ) ) (\a: Nat .\b: Rec X. X .a))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = (fix (\x: Rec X. X . true )) , b = (let u = 1 in 1) }.b) in (unfold [ Nat ] (fold [ Nat ] ({a = 0 , b = 0 }.b) ))) )) , b = (((\x: Nat .\y: Unit .x) ({a = ({a = 0 , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a)) }.b) , b = (((\x: Unit .\y: Nat .y) (unfold [ Nat ] (fold [ Bool ] true )) ) true) }.b) ) ({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in 1) , b = ({a = (fix (\x: Rec X. X . 0 )) , b = (let u = true in u) , c =  1 }.b) }.b)) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true ) ) (\a: Unit .\b: Bool .a)) , b = ({a = (((\x: Nat .\y: Unit .x) 1 ) false) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.a) ))
(let u = (case <l = ({a = (((\x: Nat .\y: Rec X. X .y) (iszero 0) ) (fix (\x: Bool . ({a = 0 , b = false }.a) ))) , b = (let u = ({a = true , b = 1 }.a) in u) , c = (fix (\x: Rec X. X . (let u = 0 in u) )) }.c) > as Unit of < l = x > => x | < r = y > => y) in ({a = (unfold [ Nat ] (fold [ Unit ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) )) , b = (iszero (let u = (let u = 1 in true) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )))) }.a))
(case <l = (((\x: Unit .\y: Nat .x) ({a = ({a = ({a = 1 , b = true }.b) , b = (case <l = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.b) , b = ({a = ({a = 0 , b = true }.b) , b = ({a = 1 , b = true }.b) }.b) , c = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) )) }.c) ) ({a = (((\x: Unit .\y: Unit .y) ({a = true , b = false }.b) ) 1) , b = ({a = 1 , b = false , c =  0 }.b) , c =  (pred 1) }.b)) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (unfold [ Bool ] (fold [ Bool ] (succ 0) )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.b) , b = (( \f: Bool .((f (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) in (pred 0)) ) (( \f: Nat .((f (fix (\x: Bool . 0 )) ) (pred 0) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Unit .a)) }.b)
(if (((\x: Unit .\y: Nat .x) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) ) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = false }.b)) then (fix (\x: Unit . (( \f: Nat .((f (let u = 0 in (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b))) ) (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) (if true then 1 else 1) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .a)) )) else (( \f: Bool .((f ({a = (let u = (let u = ({a = true , b = 1 }.b) in 1) in ({a = 0 , b = true }.a)) , b = ({a = ({a = 1 , b = 0 }.b) , b = (let u = false in u) }.b) }.a) ) (let u = (((\x: Rec X. X .\y: Nat .y) (let u = false in u) ) (((\x: Unit .\y: Nat .y) false ) ({a = 0 , b = 1 }.b))) in u) ) ) (\a: Unit .\b: Bool .a)))
(case <r = ({a = (let u = (iszero (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a))) in u) , b = (let u = (( \f: Nat .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (let u = ({a = 1 , b = false , c = 1 }.c) in u) ) ) (\a: Rec X. X .\b: Bool .a)) in (case <l = (((\x: Unit .\y: Nat .x) (unfold [ Nat ] (fold [ Nat ] 0 )) ) true) > as Bool of < l = x > => x | < r = y > => y)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(fix (\x: Nat . (case <r = (((\x: Nat .\y: Nat .x) (let u = (((\x: Bool .\y: Rec X. X .x) 0 ) false) in (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Nat .b))) ) (iszero 1)) > as Nat of < l = x > => x | < r = y > => y) ))
(iszero (succ (let u = (fix (\x: Bool . ({a = 0 , b = false , c = 0 }.c) )) in u)))
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (let u = ({a = 1 , b = false }.a) in u) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (succ 1) , b = (let u = 1 in false) , c = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.c) )) ) ) (\a: Bool .\b: Nat .b)) ))
(let u = (let u = (pred (fix (\x: Rec X. X . ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (let u = false in true) }.a) ))) in u) in u)
(let u = (case <l = (case <l = (((\x: Nat .\y: Nat .x) 1 ) true) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in u)
(( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Unit .x) false ) false) )) )) ) (case <r = ({a = (case <r = (((\x: Unit .\y: Nat .x) true ) false) > as Bool of < l = x > => x | < r = y > => y) , b = (iszero (if (let u = true in false) then (if true then 0 else 1) else 0)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .a))
(case <r = (( \f: Bool .((f (case <r = (fix (\x: Bool . false )) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (((\x: Unit .\y: Unit .x) 1 ) false) , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (((\x: Unit .\y: Unit .x) ({a = (case <r = (iszero 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in 1) }.b) ) ({a = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Nat .\y: Unit .x) (fix (\x: Nat . (let u = true in u) )) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) }.b)) , b = ({a = (fix (\x: Rec X. X . (let u = 1 in 0) )) , b = (unfold [ Bool ] (fold [ Bool ] (if true then true else false) )) , c =  (((\x: Rec X. X .\y: Bool .x) 0 ) true) }.b) }.a)
({a = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .y) true ) true) )) ) (let u = ({a = false , b = 0 }.a) in ({a = 1 , b = true , c =  0 }.b)) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = (let u = (let u = (succ 0) in u) in u) in u) }.b)
(unfold [ Rec X. X ] (fold [ Nat ] (if (( \f: Rec X. X .((f (let u = (if false then false else false) in (((\x: Rec X. X .\y: Rec X. X .y) true ) false)) ) (let u = true in true) ) ) (\a: Nat .\b: Rec X. X .b)) then (( \f: Unit .((f (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = false in u) ) ) (\a: Bool .\b: Nat .b)) else (case <r = ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) false) , b = (((\x: Nat .\y: Unit .x) false ) false) }.b) > as Bool of < l = x > => x | < r = y > => y)) ))
(((\x: Bool .\y: Unit .x) (iszero ({a = (pred 0) , b = (iszero (let u = 0 in u)) , c = (succ (let u = 1 in u)) }.c)) ) (unfold [ Nat ] (fold [ Rec X. X ] (let u = (( \f: Unit .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) in (unfold [ Rec X. X ] (fold [ Nat ] false ))) )))
(((\x: Unit .\y: Rec X. X .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = (let u = (((\x: Nat .\y: Nat .x) 0 ) false) in u) , b = ({a = ({a = 1 , b = true }.a) , b = (iszero 1) }.b) }.b) )) ) (((\x: Bool .\y: Bool .x) ({a = (let u = ({a = 1 , b = false , c = 1 }.c) in false) , b = (fix (\x: Unit . (let u = 0 in true) )) }.b) ) (if ({a = ({a = 0 , b = true , c = 1 }.c) , b = (iszero 0) , c =  ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.b) then (if true then true else false) else (iszero (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) in 0)))))
(let u = (( \f: Unit .((f (let u = (fix (\x: Rec X. X . true )) in u) ) (if ({a = false , b = false }.b) then (if true then false else false) else (let u = 0 in false)) ) ) (\a: Rec X. X .\b: Bool .b)) in (if (((\x: Rec X. X .\y: Bool .x) ({a = 0 , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) , c =  (pred 0) }.b) ) (unfold [ Unit ] (fold [ Unit ] false ))) then (unfold [ Bool ] (fold [ Unit ] (( \f: Nat .((f true ) (let u = false in true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) else ({a = (unfold [ Unit ] (fold [ Unit ] (let u = true in false) )) , b = (let u = ({a = 0 , b = false , c = 0 }.c) in u) }.a)))
({a = (( \f: Nat .((f ({a = (( \f: Nat .((f (fix (\x: Unit . 0 )) ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) , b = 1 }.a) , c = (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then ({a = 1 , b = 0 }.b) else (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) }.c) ) (let u = ({a = 1 , b = 0 }.b) in (if true then 1 else 0)) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = (let u = (let u = 0 in true) in (iszero (unfold [ Bool ] (fold [ Unit ] ({a = false , b = 1 }.b) )))) , b = (fix (\x: Unit . ({a = 1 , b = true , c = (pred 0) }.c) )) }.a) }.b)
(let u = ({a = (let u = (fix (\x: Nat . (let u = 1 in false) )) in u) , b = ({a = (((\x: Unit .\y: Rec X. X .y) (fix (\x: Rec X. X . true )) ) (let u = 0 in u)) , b = ({a = false , b = 0 }.b) }.b) }.b) in (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Rec X. X of < l = x > => x | < r = y > => y))
({a = (( \f: Bool .((f (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) )) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = (succ (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) , b = (( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .a)) )) ) (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Nat . true )) ) (iszero 1))) ) ) (\a: Bool .\b: Nat .b)) }.a) }.a)
(if ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = (let u = 1 in 1) }.a) , b = (if ({a = (if false then false else false) , b = (fix (\x: Bool . true )) }.b) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) else (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .b)) in false)) }.b) then ({a = (fix (\x: Unit . (((\x: Bool .\y: Rec X. X .x) 0 ) false) )) , b = (((\x: Bool .\y: Unit .x) false ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) , c = (( \f: Bool .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Rec X. X .b)) }.c) else (((\x: Unit .\y: Bool .y) ({a = (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ({a = false , b = true }.b) ))) , b = (fix (\x: Unit . (if true then false else false) )) }.b) ) (((\x: Bool .\y: Nat .x) (if (( \f: Unit .((f (fix (\x: Rec X. X . false )) ) true ) ) (\a: Nat .\b: Unit .a)) then (if false then 0 else 1) else ({a = 0 , b = true , c = 1 }.c)) ) ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) false) , b = (let u = false in u) }.b))))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (if (if (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) )) then (let u = 0 in false) else (fix (\x: Nat . ({a = false , b = 1 }.a) ))) then (let u = (let u = 0 in u) in (let u = true in 1)) else (((\x: Unit .\y: Unit .y) ({a = 1 , b = false }.b) ) (let u = ({a = true , b = true }.b) in (let u = 1 in u)))) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (( \f: Nat .((f (unfold [ Unit ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) ) ({a = ({a = 0 , b = false }.a) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .b)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(((\x: Unit .\y: Nat .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Unit .x) (let u = 1 in (unfold [ Nat ] (fold [ Rec X. X ] false ))) ) (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) true ) ) (\a: Nat .\b: Bool .b))) )) ) (let u = ({a = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) , b = ({a = 1 , b = false , c =  1 }.b) }.a) , b = (((\x: Rec X. X .\y: Unit .x) ({a = true , b = false }.b) ) false) }.a) in u))
(let u = ({a = (((\x: Rec X. X .\y: Nat .x) (succ 0) ) (case <r = (fix (\x: Rec X. X . true )) > as Unit of < l = x > => x | < r = y > => y)) , b = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) in ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = false , c =  1 }.b)) , c = (fix (\x: Unit . (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) }.c) in (unfold [ Unit ] (fold [ Unit ] (case <l = (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in 0) )) > as Nat of < l = x > => x | < r = y > => y) )))
({a = (fix (\x: Bool . ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = false in u) )) )) , b = (let u = (let u = (if false then true else false) in (( \f: Rec X. X .((f (let u = 0 in 0) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Unit .a))) in (case <r = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) , b = (case <r = ({a = 0 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b)
(((\x: Nat .\y: Unit .x) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) in u) )) , b = ({a = (succ 1) , b = false }.b) }.a) ) ({a = (let u = ({a = true , b = 1 }.b) in ({a = (let u = ({a = 0 , b = 1 }.b) in u) , b = (let u = false in u) , c = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.c)) , b = ({a = (iszero (((\x: Unit .\y: Nat .y) false ) 1)) , b = (unfold [ Nat ] (fold [ Unit ] 0 )) }.a) }.b))
(( \f: Bool .((f (pred (let u = ({a = 0 , b = true , c = 0 }.c) in u)) ) (let u = ({a = ({a = 1 , b = 0 }.b) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) }.a) in ({a = (pred ({a = (if false then 1 else 0) , b = false , c = (((\x: Bool .\y: Nat .x) 1 ) false) }.c)) , b = (unfold [ Nat ] (fold [ Bool ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) }.b)) ) ) (\a: Rec X. X .\b: Nat .a))
(((\x: Nat .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b)) )) ) (( \f: Rec X. X .((f (( \f: Unit .((f ({a = false , b = false }.b) ) true ) ) (\a: Nat .\b: Bool .b)) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Nat .\b: Nat .a)))
(( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] (let u = (if false then 0 else 1) in u) )) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (pred (succ (succ 1))) )) ) ) (\a: Unit .\b: Rec X. X .a))
({a = (let u = (( \f: Rec X. X .((f ({a = 1 , b = false , c =  1 }.b) ) (let u = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) in true) ) ) (\a: Rec X. X .\b: Bool .b)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) , b = (((\x: Nat .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Nat ] ({a = ({a = 0 , b = false , c =  1 }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.a) )) ) (((\x: Unit .\y: Bool .y) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )))) , c = (( \f: Bool .((f (pred (((\x: Bool .\y: Rec X. X .x) (pred 1) ) (((\x: Nat .\y: Nat .y) true ) false))) ) (( \f: Bool .((f (let u = 0 in u) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a)) }.c)
(((\x: Nat .\y: Bool .y) (unfold [ Unit ] (fold [ Bool ] (let u = (let u = (let u = true in u) in u) in u) )) ) (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) (iszero 0) ) false) ) (case <r = (let u = (unfold [ Unit ] (fold [ Unit ] true )) in u) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = (let u = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) false ) ) (\a: Rec X. X .\b: Nat .a)) in (((\x: Nat .\y: Unit .y) ({a = false , b = 1 }.a) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b)))) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(let u = (unfold [ Nat ] (fold [ Bool ] ({a = ({a = true , b = 0 }.b) , b = ({a = true , b = false }.b) }.a) )) in (((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f (pred 1) ) 1 ) ) (\a: Bool .\b: Bool .b)) ) ({a = (let u = false in false) , b = ({a = true , b = 1 }.a) }.b)))
(((\x: Rec X. X .\y: Nat .x) (if (let u = 0 in true) then (let u = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .b)) in u) else (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .a))) ) ({a = ({a = (let u = (unfold [ Rec X. X ] (fold [ Unit ] false )) in true) , b = (let u = false in true) }.b) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) in 0) )) }.a))
(( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f (let u = true in u) ) ({a = (let u = 1 in 0) , b = true , c =  0 }.b) ) ) (\a: Nat .\b: Nat .a)) , b = (let u = (let u = 0 in u) in u) }.b) ) (unfold [ Bool ] (fold [ Unit ] (succ (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) )) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (let u = ({a = ({a = 0 , b = false , c = 1 }.c) , b = (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] true )) ) (iszero 1) ) ) (\a: Rec X. X .\b: Unit .b)) , c = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.c) in (unfold [ Unit ] (fold [ Unit ] (iszero 1) ))) in u)
(case <r = (let u = (if (if true then true else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) then (let u = (fix (\x: Bool . 1 )) in (fix (\x: Unit . 0 ))) else ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .b)) , b = ({a = false , b = 1 }.b) }.b)) in (let u = ({a = 0 , b = false , c =  1 }.b) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )))) > as Bool of < l = x > => x | < r = y > => y)
({a = ({a = ({a = ({a = false , b = 0 }.a) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (((\x: Rec X. X .\y: Nat .x) false ) false) }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f (( \f: Nat .((f (succ 1) ) ({a = 0 , b = (fix (\x: Nat . 0 )) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (fix (\x: Nat . 1 )) , b = true }.a) ) ) (\a: Unit .\b: Rec X. X .a)) )) }.a)
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 1 , b = true , c = 1 }.c) }.b) )) , b = (iszero (let u = (let u = (((\x: Unit .\y: Bool .x) 0 ) true) in 0) in ({a = 1 , b = 1 }.b))) , c =  (pred (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = 0 }.b) ))) }.b)
(let u = (fix (\x: Nat . (if ({a = true , b = 0 }.a) then (case <r = false > as Bool of < l = x > => x | < r = y > => y) else true) )) in (unfold [ Rec X. X ] (fold [ Bool ] ({a = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) in (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) , b = (case <r = (let u = true in false) > as Nat of < l = x > => x | < r = y > => y) , c = (let u = (let u = (let u = 0 in 1) in 0) in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 1 ))) }.c) )))
(let u = ({a = ({a = (if false then 0 else 0) , b = (iszero 1) , c = 1 }.c) , b = ({a = true , b = false }.b) , c =  (((\x: Nat .\y: Unit .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) ) (unfold [ Bool ] (fold [ Nat ] 1 ))) }.b) in (let u = ({a = (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 ))) , b = (unfold [ Unit ] (fold [ Nat ] false )) }.a) in (let u = (unfold [ Nat ] (fold [ Rec X. X ] false )) in ({a = (let u = 0 in u) , b = ({a = false , b = true }.b) }.b))))
(let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (pred ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in 0) }.b)) )) in (pred ({a = (( \f: Unit .((f (fix (\x: Rec X. X . 1 )) ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.a) , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (succ 0) )) }.c)))
({a = (unfold [ Bool ] (fold [ Nat ] ({a = (fix (\x: Unit . 1 )) , b = ({a = 0 , b = true }.a) }.b) )) , b = (( \f: Rec X. X .((f ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) , b = (fix (\x: Bool . false )) }.b) ) (let u = (let u = 1 in u) in ({a = false , b = false }.b)) ) ) (\a: Nat .\b: Nat .a)) , c =  (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = false in false) )) in (fix (\x: Nat . ({a = true , b = 1 }.a) ))) )) in (unfold [ Bool ] (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) false ) 1) ))) }.b)
(let u = (case <r = (( \f: Bool .((f false ) (((\x: Rec X. X .\y: Bool .x) false ) false) ) ) (\a: Unit .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(( \f: Unit .((f (if (((\x: Bool .\y: Nat .y) (( \f: Bool .((f (let u = false in u) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (case <r = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y)) then (case <l = (succ ({a = 0 , b = false }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) else (unfold [ Bool ] (fold [ Unit ] (case <l = (fix (\x: Unit . 0 )) > as Bool of < l = x > => x | < r = y > => y) ))) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (if false then false else (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a))) )) in (((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Nat .y) false ) 1) ) (if ({a = false , b = false }.b) then false else (unfold [ Nat ] (fold [ Unit ] true ))))) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = (if ({a = ({a = (unfold [ Bool ] (fold [ Bool ] 0 )) , b = (((\x: Rec X. X .\y: Nat .x) false ) false) }.b) , b = (unfold [ Rec X. X ] (fold [ Bool ] (let u = (((\x: Rec X. X .\y: Bool .x) true ) false) in false) )) }.b) then ({a = (( \f: Rec X. X .((f (let u = 1 in u) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (iszero ({a = 0 , b = false , c = 0 }.c)) }.b) else (let u = ({a = true , b = false }.b) in u)) in (((\x: Bool .\y: Unit .y) (( \f: Bool .((f (if true then false else true) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Unit .a)) ) (fix (\x: Rec X. X . ({a = true , b = true }.b) ))))
(((\x: Unit .\y: Bool .y) (( \f: Nat .((f (((\x: Unit .\y: Bool .y) false ) true) ) (((\x: Unit .\y: Rec X. X .y) false ) false) ) ) (\a: Bool .\b: Bool .a)) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .y) (((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .a)) ) false) ) (iszero (( \f: Nat .((f (if true then 1 else 1) ) 1 ) ) (\a: Rec X. X .\b: Nat .b)))) )))
(let u = ({a = (let u = (let u = true in u) in u) , b = (succ (succ (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)))) }.a) in (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) in (let u = 0 in ({a = true , b = 1 }.b))))
(( \f: Rec X. X .((f (( \f: Rec X. X .((f ({a = (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = false }.b) )) , b = (unfold [ Bool ] (fold [ Nat ] (((\x: Bool .\y: Unit .x) 0 ) true) )) }.b) ) ({a = (((\x: Unit .\y: Rec X. X .y) false ) 0) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) (case <l = (( \f: Unit .((f (( \f: Unit .((f 0 ) (((\x: Unit .\y: Bool .y) true ) 1) ) ) (\a: Nat .\b: Bool .a)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a))
({a = (unfold [ Unit ] (fold [ Nat ] ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = ({a = 1 , b = false }.a) }.b) )) , b = (unfold [ Unit ] (fold [ Nat ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Unit ] ({a = false , b = 0 }.a) )) )) )) , c =  (( \f: Bool .((f (let u = (let u = false in (pred 0)) in u) ) (((\x: Unit .\y: Unit .y) ({a = true , b = false }.b) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a))) ) ) (\a: Nat .\b: Nat .b)) }.b)
({a = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) (iszero 1) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true ))) )) , b = ({a = (if (if ({a = true , b = false }.b) then (fix (\x: Bool . false )) else (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .a))) then (fix (\x: Unit . 0 )) else (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) > as Unit of < l = x > => x | < r = y > => y)) , b = (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = false in u) )) > as Bool of < l = x > => x | < r = y > => y) , c = (if ({a = 1 , b = true , c =  0 }.b) then (let u = (((\x: Unit .\y: Bool .y) true ) 1) in u) else (case <l = (let u = false in 1) > as Nat of < l = x > => x | < r = y > => y)) }.c) }.b)
({a = ({a = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] 0 )) )) in (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a))) , b = (fix (\x: Bool . (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) )) }.a) , b = (iszero (( \f: Unit .((f 0 ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Bool .b))) , c = (let u = (((\x: Rec X. X .\y: Rec X. X .y) (iszero 1) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 0 ))) in u) }.c)
({a = (pred (unfold [ Unit ] (fold [ Unit ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ))) , b = (let u = (((\x: Bool .\y: Unit .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = (pred 1) in ({a = true , b = false }.b))) in (iszero (((\x: Bool .\y: Bool .y) false ) 0))) , c =  (((\x: Nat .\y: Nat .y) (let u = ({a = (let u = 1 in true) , b = (succ 0) }.b) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false ))) ) (fix (\x: Nat . (((\x: Bool .\y: Unit .x) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Rec X. X .x) false ) false)) ))) }.b)
(let u = ({a = (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Unit .x) 1 ) false) )) , b = (case <r = (if false then true else true) > as Unit of < l = x > => x | < r = y > => y) , c =  (fix (\x: Rec X. X . ({a = (fix (\x: Rec X. X . 0 )) , b = (( \f: Unit .((f false ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) ) ) (\a: Unit .\b: Rec X. X .b)) , c = (((\x: Unit .\y: Unit .y) false ) 0) }.c) )) }.b) in u)
(case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = 0 , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) , c =  (((\x: Nat .\y: Nat .x) 1 ) false) }.b) in (((\x: Nat .\y: Nat .y) true ) false)) )) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) true ) 1) ) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = false , c = (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.c) ) ) (\a: Nat .\b: Rec X. X .a)) ))
(unfold [ Nat ] (fold [ Bool ] (fix (\x: Nat . (if (iszero 1) then (let u = 0 in u) else (((\x: Bool .\y: Nat .y) false ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )))) )) ))
(((\x: Nat .\y: Bool .y) (if ({a = (succ 1) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (let u = 1 in u) }.b) then (unfold [ Unit ] (fold [ Bool ] (let u = (if true then true else true) in u) )) else (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = false }.b) ))) ) (pred ({a = (let u = ({a = ({a = 1 , b = 1 }.b) , b = false }.b) in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.b)))
(unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) )) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (iszero 1) )) }.a) )) )) ))
({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] (case <l = (let u = 0 in u) > as Nat of < l = x > => x | < r = y > => y) )) , b = (case <r = (let u = 1 in (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b))) > as Unit of < l = x > => x | < r = y > => y) }.a) , b = ({a = (if (let u = false in (((\x: Rec X. X .\y: Rec X. X .y) false ) false)) then (( \f: Bool .((f ({a = (succ 0) , b = true , c = (pred 0) }.c) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .a)) else (((\x: Nat .\y: Unit .y) true ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )))) , b = (fix (\x: Unit . ({a = true , b = ({a = 0 , b = true }.b) }.b) )) }.b) , c =  ({a = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = 0 }.b) )) , b = (if false then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else (((\x: Nat .\y: Rec X. X .y) false ) false)) , c = ({a = 0 , b = false }.a) }.c) }.b)
(if (fix (\x: Unit . (let u = (( \f: Rec X. X .((f (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Unit .\b: Bool .a)) in (let u = false in false)) )) then (let u = (let u = (if ({a = 0 , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , c =  0 }.b) then (((\x: Unit .\y: Unit .y) true ) false) else ({a = true , b = 0 }.a)) in u) in ({a = (unfold [ Unit ] (fold [ Bool ] (((\x: Rec X. X .\y: Bool .y) false ) 1) )) , b = (((\x: Rec X. X .\y: Bool .x) ({a = ({a = 0 , b = true }.a) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) }.b) ) (let u = true in u)) , c =  (pred 0) }.b)) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (((\x: Unit .\y: Unit .x) 0 ) true) , b = true , c =  (fix (\x: Unit . 0 )) }.b) )))
({a = (((\x: Rec X. X .\y: Nat .x) (let u = ({a = 1 , b = 0 }.b) in (let u = 0 in true)) ) (iszero (((\x: Nat .\y: Rec X. X .y) true ) (let u = 0 in 1)))) , b = ({a = (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) (( \f: Bool .((f false ) (fix (\x: Bool . true )) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) in u) }.a) }.b)
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Nat .y) ({a = 0 , b = (if false then true else false) }.b) ) ({a = true , b = false }.b)) )) , b = (fix (\x: Unit . ({a = (if true then true else false) , b = 1 }.b) )) }.a)
(let u = (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Nat ] (let u = (fix (\x: Rec X. X . true )) in ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) )) )) in (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . 0 )) )) ) ({a = (let u = 1 in u) , b = (iszero (let u = 1 in 1)) , c = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.c) ) ) (\a: Unit .\b: Bool .a)))
(pred (unfold [ Unit ] (fold [ Nat ] ({a = (let u = 1 in u) , b = ({a = 0 , b = ({a = false , b = 0 }.b) }.b) }.b) )))
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) (let u = (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] 0 )) )) in (((\x: Nat .\y: Bool .x) (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .b)) ) true)) ) (let u = (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) ) 1 ) ) (\a: Unit .\b: Bool .b)) in ({a = false , b = 0 }.b))) ))
(let u = (fix (\x: Unit . (if (unfold [ Bool ] (fold [ Bool ] true )) then ({a = ({a = 1 , b = 0 }.b) , b = (iszero 0) , c =  1 }.b) else ({a = 0 , b = false , c =  1 }.b)) )) in ({a = ({a = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a)) , b = (((\x: Nat .\y: Unit .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) ) (iszero 1)) }.b) , b = (pred ({a = (pred 0) , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) }.a)) }.a))
(succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f (case <l = (if true then 0 else 1) > as Bool of < l = x > => x | < r = y > => y) ) (case <l = (let u = 1 in (let u = 1 in u)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )))
(( \f: Unit .((f (((\x: Nat .\y: Nat .y) (if (( \f: Bool .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) true ) ) (\a: Bool .\b: Rec X. X .b)) then (if true then true else false) else (let u = true in false)) ) (case <r = (let u = true in true) > as Nat of < l = x > => x | < r = y > => y)) ) (((\x: Rec X. X .\y: Nat .y) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = true , c =  1 }.b) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Bool .a))
(pred (((\x: Nat .\y: Nat .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (case <r = (iszero 1) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (case <l = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (if true then 0 else 1) )) > as Rec X. X of < l = x > => x | < r = y > => y)))
(let u = ({a = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = true , b = 0 }.b) )) , b = (let u = (let u = true in 0) in ({a = 0 , b = true , c =  1 }.b)) }.b) , b = ({a = ({a = (((\x: Unit .\y: Rec X. X .y) true ) ({a = 1 , b = false }.a)) , b = ({a = 1 , b = ({a = 0 , b = false }.a) }.b) }.b) , b = (let u = (let u = true in u) in (fix (\x: Nat . false ))) }.a) }.a) in u)
(((\x: Rec X. X .\y: Unit .y) ({a = (fix (\x: Bool . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) , b = (fix (\x: Nat . true )) }.b) ) (unfold [ Nat ] (fold [ Rec X. X ] (let u = true in ({a = 1 , b = true , c =  1 }.b)) )))
({a = (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .y) false ) 1) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = 0 }.b) )) ) ) (\a: Nat .\b: Nat .b)) , b = (let u = (let u = (fix (\x: Nat . 1 )) in false) in (((\x: Nat .\y: Rec X. X .y) true ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )))) , c =  (unfold [ Bool ] (fold [ Nat ] (((\x: Nat .\y: Unit .x) 1 ) true) )) }.b)
(( \f: Nat .((f (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) false ) (if false then true else false)) ) (( \f: Unit .((f ({a = false , b = 0 }.a) ) ({a = ({a = 0 , b = true }.a) , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Unit .a)) ) (case <r = (iszero (unfold [ Rec X. X ] (fold [ Nat ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = false }.a) )) ))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(( \f: Bool .((f ({a = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in (unfold [ Nat ] (fold [ Unit ] 0 ))) , b = (( \f: Unit .((f false ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Bool .\b: Bool .a)) }.b) ) (fix (\x: Bool . (((\x: Nat .\y: Nat .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . true ))) )) ) ) (\a: Unit .\b: Nat .a))
(fix (\x: Nat . (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) )) in (let u = (( \f: Nat .((f (pred 0) ) (((\x: Nat .\y: Bool .x) 0 ) true) ) ) (\a: Rec X. X .\b: Unit .a)) in u)) ))
(unfold [ Unit ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) (let u = (let u = false in 1) in u) ) (let u = (succ ({a = ({a = true , b = 0 }.b) , b = true , c = ({a = 1 , b = true , c = 1 }.c) }.c)) in ({a = 1 , b = true }.b))) ))
(let u = (case <l = (succ ({a = ({a = false , b = 0 }.b) , b = (((\x: Unit .\y: Nat .y) true ) true) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) in (if (iszero (pred 1)) then (( \f: Nat .((f (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) , b = ({a = false , b = 1 }.a) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) else ({a = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b)) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b)))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (fix (\x: Bool . (((\x: Unit .\y: Nat .y) false ) false) )) , b = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Bool . (let u = false in u) )) )) in u) }.b) ))
(iszero ({a = ({a = ({a = 1 , b = (if false then 1 else 1) }.b) , b = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (iszero 1) }.b) , c = ({a = ({a = ({a = 1 , b = true }.a) , b = false }.a) , b = (let u = false in false) , c = (fix (\x: Bool . 0 )) }.c) }.c) , b = (if (((\x: Rec X. X .\y: Bool .x) true ) true) then (fix (\x: Rec X. X . 0 )) else (let u = true in 0)) }.b))
(case <l = (( \f: Unit .((f (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) in (let u = ({a = false , b = 0 }.a) in 0)) ) ({a = 1 , b = true , c = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) }.c) ) ) (\a: Rec X. X .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (iszero (((\x: Unit .\y: Bool .y) false ) 1)) , b = (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in 1) }.b) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.b)
((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (if ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) , b = (((\x: Unit .\y: Unit .x) 1 ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false ))) }.a) then (fix (\x: Rec X. X . (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) else (let u = (( \f: Rec X. X .((f (succ 0) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) in u)) ))
(let u = (succ (((\x: Bool .\y: Rec X. X .x) ({a = (if true then 0 else 0) , b = 1 }.b) ) ({a = 1 , b = (iszero 1) }.b))) in u)
({a = ({a = (((\x: Rec X. X .\y: Nat .x) (iszero 1) ) (iszero 1)) , b = (let u = (unfold [ Nat ] (fold [ Bool ] 1 )) in true) }.b) , b = (((\x: Rec X. X .\y: Unit .x) ({a = ({a = true , b = true }.b) , b = (if true then 1 else 1) }.b) ) (((\x: Unit .\y: Bool .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero 0) )) ) ({a = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = 1 }.a))) }.b)
(case <r = (( \f: Bool .((f ({a = 0 , b = false }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .y) true ) false) )) ) ) (\a: Nat .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = ({a = ({a = false , b = 1 }.b) , b = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .a)) }.b) , b = (if true then (fix (\x: Bool . true )) else (case <r = false > as Bool of < l = x > => x | < r = y > => y)) }.b) , b = (let u = ({a = (succ ({a = true , b = 1 }.b)) , b = ({a = (if true then 0 else 1) , b = true }.b) }.a) in u) }.a)
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = ({a = false , b = false }.b) in (((\x: Nat .\y: Rec X. X .y) true ) 1)) )) , b = (let u = (if (iszero 1) then (unfold [ Unit ] (fold [ Bool ] 0 )) else (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .y) false ) 1) ))) in (let u = (let u = true in false) in (if false then true else false))) , c =  (if (let u = (if (let u = false in false) then (let u = false in u) else true) in u) then (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then ({a = 0 , b = (let u = 1 in false) }.a) else (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) else (if ({a = ({a = 1 , b = false }.b) , b = (unfold [ Bool ] (fold [ Unit ] 0 )) }.a) then (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) ) (succ 0) ) ) (\a: Bool .\b: Bool .a)) else (if true then (let u = true in 1) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))))) }.b)
(case <l = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (if true then ({a = 1 , b = true , c = 1 }.c) else (((\x: Rec X. X .\y: Unit .x) 0 ) true)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] ({a = ({a = (fix (\x: Unit . false )) , b = true }.b) , b = (( \f: Nat .((f (fix (\x: Unit . 1 )) ) ({a = (let u = true in 0) , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .a)) }.a) )) ) (iszero (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)))) ) ) (\a: Bool .\b: Nat .b))
(((\x: Bool .\y: Rec X. X .y) ({a = (let u = ({a = 1 , b = false }.a) in (fix (\x: Bool . false ))) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (case <r = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.b) ) ({a = (if (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Unit .x) (succ 1) ) (let u = true in u)) else (fix (\x: Unit . 1 ))) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) }.b))
(let u = (let u = (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Bool .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f (((\x: Bool .\y: Unit .y) true ) 0) ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Unit .b))) ) (( \f: Nat .((f (let u = false in true) ) true ) ) (\a: Nat .\b: Unit .b))) in (iszero (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) in (succ (if (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) then (if true then 1 else 1) else (((\x: Bool .\y: Bool .y) false ) 1))))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = ({a = ({a = 1 , b = true , c = 0 }.c) , b = (fix (\x: Nat . false )) , c =  (((\x: Bool .\y: Nat .x) 0 ) true) }.b) , b = (let u = ({a = 0 , b = true , c = 1 }.c) in (let u = 0 in 1)) }.a) ))
({a = ({a = (let u = (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) in u) , b = ({a = (((\x: Bool .\y: Nat .x) false ) (if false then true else true)) , b = ({a = 0 , b = false }.b) }.b) }.b) , b = (let u = (pred (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) in ({a = (let u = true in u) , b = ({a = 0 , b = false }.a) }.a)) }.b)
({a = (let u = (let u = (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) false) in (if true then ({a = 1 , b = true }.b) else ({a = 1 , b = false }.b))) in u) , b = ({a = (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .x) 0 ) ({a = 1 , b = true , c =  1 }.b)) ) (let u = 0 in u) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (if true then 0 else 1) , b = true , c =  0 }.b) , c =  ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b) }.b) }.b)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Unit .((f (let u = (succ (let u = 0 in 0)) in (let u = false in true)) ) (iszero (if true then (if true then 0 else 1) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)))) ) ) (\a: Rec X. X .\b: Unit .b)) ))
(((\x: Nat .\y: Unit .y) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Bool . true )) )) )) ) ({a = (( \f: Nat .((f ({a = 0 , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) , c =  0 }.b) ) (let u = (if true then true else false) in u) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = 0 }.b) )) , b = (((\x: Nat .\y: Bool .y) (let u = ({a = true , b = 0 }.a) in u) ) (let u = (let u = true in u) in u)) }.a) }.a))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (fix (\x: Nat . (let u = false in u) )) , b = (((\x: Nat .\y: Unit .y) (iszero (pred 1)) ) (fix (\x: Bool . 0 ))) }.b) ))
(( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))) ) ({a = (let u = 1 in 0) , b = (( \f: Unit .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) (fix (\x: Nat . (if false then true else true) )) ) ) (\a: Unit .\b: Unit .a)) }.b)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (pred 0) )) ) ) (\a: Unit .\b: Rec X. X .a))
({a = (let u = ({a = ({a = (if true then false else true) , b = false }.b) , b = (let u = false in 0) }.b) in (let u = ({a = false , b = false }.b) in ({a = true , b = 0 }.b))) , b = ({a = (( \f: Nat .((f (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = 1 in true) )) ) (if true then (if true then false else false) else true)) ) ({a = false , b = (((\x: Bool .\y: Nat .x) 0 ) true) }.a)) }.b) }.a)
(((\x: Bool .\y: Bool .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] (succ 1) )) )) ) (( \f: Rec X. X .((f (let u = 1 in (let u = 1 in false)) ) (( \f: Nat .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Bool .b)))
(( \f: Rec X. X .((f (( \f: Nat .((f (( \f: Rec X. X .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (if false then true else (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) in (( \f: Nat .((f 1 ) (if false then 1 else 0) ) ) (\a: Bool .\b: Unit .b))) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (let u = true in u) , b = (((\x: Unit .\y: Nat .y) true ) 1) }.b) ) ) (\a: Bool .\b: Unit .a)) ) ({a = ({a = (let u = true in 0) , b = (case <r = ({a = true , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (((\x: Unit .\y: Bool .y) ({a = ({a = true , b = 1 }.a) , b = ({a = (if true then 1 else 0) , b = false }.b) }.b) ) (( \f: Unit .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .a)) ) (iszero 1) ) ) (\a: Rec X. X .\b: Bool .a))) , c = (let u = (fix (\x: Unit . true )) in (case <l = (succ 1) > as Bool of < l = x > => x | < r = y > => y)) }.c) ) ) (\a: Bool .\b: Bool .b))
({a = (iszero (case <l = (if false then 1 else 1) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .a)) , b = (fix (\x: Bool . 0 )) }.b) ) (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) ) ) (\a: Nat .\b: Nat .b)) }.a)
({a = (( \f: Unit .((f (case <r = ({a = false , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <r = (let u = 1 in false) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (fix (\x: Unit . (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.b)
({a = (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = 1 }.b) )) )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .y) true ) false) ) (unfold [ Bool ] (fold [ Nat ] (let u = 1 in true) )) ) ) (\a: Unit .\b: Unit .b)) )) }.b)
(fix (\x: Nat . (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (let u = 1 in u) in ({a = 1 , b = 1 }.b)) )) in ({a = ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b)) ))
(((\x: Bool .\y: Unit .x) (iszero (pred (fix (\x: Unit . ({a = 1 , b = 0 }.b) )))) ) (if ({a = (if ({a = false , b = 0 }.a) then (let u = true in 1) else ({a = 1 , b = 1 }.b)) , b = (if (let u = 0 in (if false then true else true)) then ({a = 0 , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .b)) , c =  0 }.b) else (let u = false in u)) , c =  (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .x) 1 ) true) ) (let u = 1 in 1) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) then (case <r = ({a = 0 , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .a)) , c =  (let u = false in 0) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) else (( \f: Bool .((f ({a = false , b = (let u = false in false) }.b) ) (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a))))
(case <l = (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Unit .y) (let u = false in false) ) (let u = 0 in true)) ) ({a = (( \f: Unit .((f (if true then 1 else 0) ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = (let u = false in true) }.a)) > as Nat of < l = x > => x | < r = y > => y)
(let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .x) (let u = (((\x: Nat .\y: Nat .x) 1 ) false) in u) ) (iszero (succ 0))) )) in (case <r = ({a = (if false then false else false) , b = (let u = false in u) }.b) > as Nat of < l = x > => x | < r = y > => y))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (pred (( \f: Bool .((f 0 ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = (let u = 0 in u) , b = (( \f: Rec X. X .((f (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) (((\x: Bool .\y: Rec X. X .y) true ) true) ) ) (\a: Nat .\b: Bool .b)) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) )) , c =  (( \f: Nat .((f ({a = 1 , b = true }.a) ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) )) ))
({a = (((\x: Bool .\y: Bool .x) (( \f: Unit .((f (( \f: Bool .((f 1 ) (((\x: Nat .\y: Bool .x) 0 ) false) ) ) (\a: Rec X. X .\b: Bool .a)) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = (fix (\x: Unit . true )) in u)) , b = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) (((\x: Bool .\y: Rec X. X .x) true ) true)) in u) , b = ({a = (let u = 1 in 0) , b = (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) in u) }.b) }.b) , c =  (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) )) ) (( \f: Bool .((f (let u = 1 in 0) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Bool .\b: Unit .a)) }.b)
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (let u = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = false }.a) in (succ 1)) )) in (let u = (let u = (((\x: Nat .\y: Unit .x) false ) false) in (unfold [ Bool ] (fold [ Nat ] true ))) in u))
(((\x: Nat .\y: Unit .y) ({a = (fix (\x: Unit . ({a = (pred 1) , b = false }.a) )) , b = (fix (\x: Rec X. X . (if true then false else ({a = 1 , b = true }.b)) )) }.b) ) ({a = (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a))) , b = (iszero (( \f: Unit .((f (let u = 0 in u) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .a))) }.b))
(( \f: Nat .((f (let u = (( \f: Unit .((f true ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) in (case <r = (((\x: Rec X. X .\y: Unit .y) true ) true) > as Bool of < l = x > => x | < r = y > => y)) ) (let u = (case <r = (((\x: Unit .\y: Rec X. X .y) false ) false) > as Bool of < l = x > => x | < r = y > => y) in u) ) ) (\a: Bool .\b: Rec X. X .a))
(iszero (if ({a = (((\x: Bool .\y: Unit .y) false ) 0) , b = (let u = 1 in false) }.b) then (((\x: Bool .\y: Bool .x) (let u = 0 in 0) ) ({a = 0 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  ({a = 0 , b = true , c = 0 }.c) }.b)) else (case <l = (( \f: Nat .((f (((\x: Nat .\y: Bool .x) 1 ) true) ) ({a = 0 , b = 1 }.b) ) ) (\a: Nat .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y)))
(unfold [ Bool ] (fold [ Rec X. X ] (case <l = ({a = 1 , b = (let u = 1 in u) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = (((\x: Unit .\y: Unit .x) 0 ) true) , b = false , c = (pred 0) }.c) )) ) (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] (let u = true in 1) )) ) (((\x: Nat .\y: Unit .x) (succ 0) ) (unfold [ Nat ] (fold [ Unit ] true ))) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = (unfold [ Nat ] (fold [ Nat ] ({a = (let u = false in (let u = 1 in true)) , b = (case <l = ({a = 1 , b = false , c = 0 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) )) in (unfold [ Nat ] (fold [ Unit ] (unfold [ Bool ] (fold [ Unit ] (let u = 1 in true) )) )))
(let u = (( \f: Unit .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = (fix (\x: Rec X. X . 1 )) , b = ({a = false , b = true }.b) , c =  (unfold [ Unit ] (fold [ Rec X. X ] 0 )) }.b) ) ) (\a: Bool .\b: Bool .a)) in u)
({a = (fix (\x: Nat . (iszero (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) )) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = (let u = true in (((\x: Nat .\y: Nat .x) true ) true)) in u) ) (( \f: Bool .((f (fix (\x: Rec X. X . (fix (\x: Unit . 1 )) )) ) (((\x: Bool .\y: Nat .y) (let u = false in false) ) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = 1 in u) }.b)) ) ) (\a: Nat .\b: Unit .a))) }.b)
(((\x: Nat .\y: Bool .y) (let u = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) }.b) in ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) , b = false }.b)) ) (unfold [ Bool ] (fold [ Nat ] (iszero (let u = 0 in 0)) )))
(case <l = (unfold [ Unit ] (fold [ Rec X. X ] (let u = false in (let u = true in 1)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(iszero (let u = (let u = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = false in u) }.b) in ({a = (pred 0) , b = (unfold [ Rec X. X ] (fold [ Nat ] true )) , c =  (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) }.b)) in (let u = (let u = false in false) in (if false then 1 else 0))))
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = (fix (\x: Nat . (fix (\x: Unit . 1 )) )) in (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Bool .((f (succ (pred 0)) ) (if false then 1 else 1) ) ) (\a: Rec X. X .\b: Bool .b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )))) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (if (iszero ({a = false , b = 0 }.b)) then (if true then false else false) else (let u = 1 in true)) , b = (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) (let u = ({a = false , b = 0 }.a) in (let u = 1 in true)) ) (case <l = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) )) }.a) ))
({a = (let u = (let u = 1 in (if true then true else true)) in (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) ({a = 1 , b = true , c =  1 }.b) ) 1) ))) , b = (( \f: Bool .((f (fix (\x: Bool . (if true then true else true) )) ) (unfold [ Unit ] (fold [ Nat ] (unfold [ Nat ] (fold [ Unit ] true )) )) ) ) (\a: Bool .\b: Unit .a)) }.b)
(let u = (iszero ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = (((\x: Rec X. X .\y: Unit .x) 1 ) false) }.b)) in u)
(let u = (case <l = (((\x: Bool .\y: Rec X. X .x) (succ 0) ) (let u = (unfold [ Rec X. X ] (fold [ Unit ] false )) in u)) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Unit .x) (iszero (pred 0)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))) ) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = 1 }.b) )) , b = ({a = (let u = true in 0) , b = false }.b) , c =  ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (succ 1) )) }.b)))
(let u = (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) true ) ({a = 1 , b = true }.b)) )) in u)
(succ (unfold [ Nat ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) )) )))
(let u = (if ({a = (fix (\x: Bool . 0 )) , b = (let u = 1 in true) }.b) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (succ (let u = false in (let u = true in 1))) )) else (let u = (fix (\x: Nat . 1 )) in (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Bool .x) true ) true) ) (((\x: Unit .\y: Rec X. X .y) true ) 0)))) in u)
({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = ({a = 0 , b = 0 }.b) , b = (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = false }.b) ) (((\x: Unit .\y: Rec X. X .x) false ) false)) }.a) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = false }.b) ))) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = (if false then (if false then 0 else 0) else (succ 1)) in (fix (\x: Rec X. X . false ))) , b = (unfold [ Bool ] (fold [ Unit ] ({a = (let u = 0 in false) , b = (if false then true else false) }.b) )) }.b) )) , c =  ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = 1 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = 1 }.c) , b = (if false then 0 else 1) }.b) )) }.b)
(( \f: Rec X. X .((f (let u = (if (unfold [ Bool ] (fold [ Bool ] (if false then true else false) )) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = false , c = 1 }.c) )) else (let u = (unfold [ Unit ] (fold [ Nat ] false )) in 0)) in (( \f: Nat .((f 0 ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b))) ) (( \f: Bool .((f (pred 1) ) ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Nat .x) true ) false) , c = 0 }.c) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .b))
(((\x: Rec X. X .\y: Rec X. X .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (pred 1) )) )) ) (( \f: Nat .((f (let u = true in (let u = true in false)) ) (((\x: Rec X. X .\y: Nat .x) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . true ))) ) ) (\a: Rec X. X .\b: Nat .b)))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .x) (unfold [ Bool ] (fold [ Unit ] false )) ) (let u = 0 in (case <r = true > as Bool of < l = x > => x | < r = y > => y))) ))
(( \f: Unit .((f (succ ({a = ({a = (iszero 1) , b = (fix (\x: Unit . 1 )) }.a) , b = ({a = 0 , b = (unfold [ Nat ] (fold [ Nat ] false )) }.a) }.b)) ) (case <l = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) in u) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b))
(if (iszero (fix (\x: Nat . (((\x: Bool .\y: Rec X. X .x) 1 ) false) ))) then (if (((\x: Rec X. X .\y: Bool .x) ({a = true , b = true }.b) ) ({a = 0 , b = false , c =  1 }.b)) then (let u = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = true }.a) ))) in ({a = 1 , b = true }.b)) else ({a = (if true then (let u = 1 in 1) else 0) , b = (if (fix (\x: Nat . (let u = 1 in true) )) then ({a = 0 , b = true , c =  0 }.b) else ({a = ({a = 1 , b = true }.a) , b = true , c =  0 }.b)) , c =  (unfold [ Nat ] (fold [ Nat ] 1 )) }.b)) else (let u = (((\x: Unit .\y: Unit .y) false ) true) in u))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = (( \f: Unit .((f (( \f: Nat .((f false ) (let u = false in false) ) ) (\a: Rec X. X .\b: Bool .a)) ) (( \f: Bool .((f (if false then false else false) ) ({a = 0 , b = false , c =  (let u = 0 in 1) }.b) ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (( \f: Unit .((f ({a = 1 , b = ({a = 1 , b = true }.b) }.a) ) ({a = 0 , b = false }.a) ) ) (\a: Nat .\b: Unit .b))) ))
({a = (( \f: Bool .((f (( \f: Bool .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (case <l = (pred 1) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = ({a = (fix (\x: Nat . 1 )) , b = ({a = false , b = 0 }.a) , c =  (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) , b = ({a = 1 , b = (((\x: Nat .\y: Unit .y) false ) true) , c =  (succ 0) }.b) }.b) , c =  (fix (\x: Rec X. X . ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = ({a = 1 , b = 1 }.b) }.b) )) }.b)
(let u = (((\x: Nat .\y: Bool .y) ({a = true , b = ({a = 1 , b = true , c = 0 }.c) }.a) ) (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u)) in u)
(if (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.a) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b))) then (if (let u = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) in u) then ({a = (unfold [ Bool ] (fold [ Rec X. X ] true )) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (if false then 1 else 1) )) }.a) else (if (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) in u) then ({a = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) in 0) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) , c =  ({a = 1 , b = (let u = false in false) , c = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c) }.b) else ({a = (let u = (let u = true in u) in (((\x: Rec X. X .\y: Unit .y) false ) 1)) , b = ({a = 0 , b = true }.b) , c =  (let u = 0 in u) }.b))) else ({a = (let u = (let u = ({a = 1 , b = false , c = 0 }.c) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) in (let u = 1 in false)) , b = (case <l = (pred 1) > as Unit of < l = x > => x | < r = y > => y) }.a))
(let u = (if (let u = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .b)) in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) then (let u = (((\x: Nat .\y: Rec X. X .y) false ) (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) in u) else (( \f: Bool .((f (if false then 0 else 0) ) (((\x: Bool .\y: Rec X. X .x) 0 ) false) ) ) (\a: Nat .\b: Nat .b))) in u)
(( \f: Rec X. X .((f (((\x: Unit .\y: Bool .y) ({a = (unfold [ Nat ] (fold [ Rec X. X ] true )) , b = ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .b)) , b = 1 }.b) }.a) ) ({a = (fix (\x: Bool . 1 )) , b = ({a = 0 , b = true , c =  (let u = 1 in u) }.b) }.b)) ) (fix (\x: Nat . (fix (\x: Rec X. X . (let u = false in u) )) )) ) ) (\a: Rec X. X .\b: Nat .a))
(((\x: Unit .\y: Bool .x) (if ({a = (pred 0) , b = (if true then true else true) }.b) then (iszero (((\x: Rec X. X .\y: Bool .y) false ) 0)) else (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .x) true ) false) ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Bool .\b: Nat .a)) ))) ) (fix (\x: Unit . ({a = ({a = false , b = true }.b) , b = ({a = 0 , b = false }.b) }.b) )))
(fix (\x: Unit . (case <l = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) > as Bool of < l = x > => x | < r = y > => y) ))
(( \f: Unit .((f (if (let u = (((\x: Bool .\y: Unit .y) false ) 0) in ({a = (((\x: Bool .\y: Unit .y) false ) false) , b = (((\x: Nat .\y: Unit .y) true ) false) }.b)) then (let u = (( \f: Unit .((f (let u = true in 0) ) (pred (fix (\x: Unit . 0 ))) ) ) (\a: Nat .\b: Bool .b)) in (( \f: Unit .((f true ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .b))) else (fix (\x: Rec X. X . ({a = 1 , b = false }.b) ))) ) (((\x: Bool .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .y) ({a = false , b = 0 }.a) ) true) ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Unit .a)) )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if true then true else false) ))) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (((\x: Nat .\y: Nat .x) (let u = (let u = false in 0) in ({a = 0 , b = 1 }.b)) ) (if (if true then true else true) then (( \f: Rec X. X .((f (iszero 1) ) true ) ) (\a: Rec X. X .\b: Unit .b)) else (( \f: Bool .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)))) , b = ({a = (succ (((\x: Bool .\y: Rec X. X .x) (let u = 0 in 0) ) (iszero 1))) , b = (unfold [ Unit ] (fold [ Nat ] (let u = (((\x: Nat .\y: Bool .y) true ) true) in u) )) , c =  (((\x: Unit .\y: Bool .y) ({a = (let u = true in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (( \f: Bool .((f (let u = false in u) ) true ) ) (\a: Unit .\b: Bool .a)) , c =  (unfold [ Bool ] (fold [ Rec X. X ] 0 )) }.b) ) (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in (let u = 0 in (let u = 1 in 1)))) }.b) , c = (( \f: Unit .((f (let u = true in (succ 1)) ) (let u = 0 in u) ) ) (\a: Bool .\b: Bool .b)) }.c)
(fix (\x: Bool . ({a = (let u = (((\x: Bool .\y: Nat .x) 1 ) true) in (((\x: Nat .\y: Nat .x) 0 ) true)) , b = (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (((\x: Nat .\y: Rec X. X .y) true ) false) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ))
(( \f: Bool .((f (let u = ({a = (iszero 0) , b = ({a = 1 , b = 0 }.b) }.a) in (let u = (fix (\x: Nat . 1 )) in (fix (\x: Rec X. X . ({a = false , b = 0 }.a) )))) ) (let u = (iszero (unfold [ Nat ] (fold [ Bool ] (let u = 1 in u) ))) in u) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] (let u = (iszero 1) in u) )) ))
({a = (let u = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) true ) false) )) in (case <l = ({a = 1 , b = false , c = 0 }.c) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (( \f: Rec X. X .((f (let u = ({a = 1 , b = 0 }.b) in ({a = false , b = 0 }.b)) ) (((\x: Rec X. X .\y: Rec X. X .x) ({a = 0 , b = 0 }.b) ) (unfold [ Unit ] (fold [ Nat ] (if true then false else false) ))) ) ) (\a: Nat .\b: Unit .a)) }.b)
(iszero ({a = (fix (\x: Unit . (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) )) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = ({a = true , b = 1 }.b) }.c))
(( \f: Rec X. X .((f ({a = (if (( \f: Rec X. X .((f (fix (\x: Unit . false )) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Nat .\b: Nat .b)) then ({a = 0 , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.b) else (let u = (let u = 1 in 1) in u)) , b = (let u = (if false then 0 else (if false then 1 else 1)) in ({a = (((\x: Nat .\y: Bool .y) false ) 0) , b = ({a = 0 , b = true , c =  0 }.b) }.b)) }.b) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) true ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) ) (((\x: Unit .\y: Rec X. X .y) (if true then false else true) ) (iszero 0)) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Bool .a))
(case <l = (unfold [ Nat ] (fold [ Bool ] (fix (\x: Rec X. X . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) )) > as Unit of < l = x > => x | < r = y > => y)
(let u = (((\x: Nat .\y: Nat .x) ({a = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = true in u)) , b = (((\x: Bool .\y: Bool .x) 1 ) false) }.b) ) (let u = ({a = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = 0 }.b) , b = (fix (\x: Bool . true )) }.a) in (( \f: Unit .((f ({a = 1 , b = true }.b) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)))) in (((\x: Rec X. X .\y: Unit .y) (if ({a = 0 , b = true , c =  1 }.b) then (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .b)) else (unfold [ Rec X. X ] (fold [ Bool ] true ))) ) (fix (\x: Bool . ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Unit . 0 )) )) ))))
(((\x: Unit .\y: Nat .x) (( \f: Unit .((f (( \f: Bool .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (let u = true in u) , b = (let u = (((\x: Bool .\y: Nat .x) 1 ) true) in u) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (((\x: Nat .\y: Nat .x) (( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] (let u = true in u) )) ) (fix (\x: Rec X. X . true )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = (((\x: Unit .\y: Nat .x) false ) true) , b = (let u = 1 in u) }.a)))
(iszero (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Unit .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = 0 }.b)) ) (((\x: Bool .\y: Unit .y) (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 0 )) in (((\x: Rec X. X .\y: Bool .y) true ) (iszero 1))) ) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .a)))))
(( \f: Bool .((f (fix (\x: Nat . (( \f: Nat .((f false ) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .a)) )) ) ({a = ({a = (pred ({a = 0 , b = false , c = 0 }.c)) , b = (let u = true in u) }.b) , b = (case <r = (let u = (fix (\x: Nat . true )) in ({a = 0 , b = (let u = true in u) , c =  1 }.b)) > as Unit of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Nat .b))
(((\x: Rec X. X .\y: Unit .x) ({a = ({a = 0 , b = (((\x: Unit .\y: Bool .y) true ) true) }.a) , b = (( \f: Bool .((f false ) ({a = false , b = 1 }.a) ) ) (\a: Unit .\b: Nat .a)) , c = (( \f: Bool .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Bool .a)) }.c) ) (((\x: Rec X. X .\y: Nat .x) (fix (\x: Unit . ({a = 1 , b = false , c =  0 }.b) )) ) (( \f: Nat .((f (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b))))
({a = (((\x: Bool .\y: Rec X. X .y) (( \f: Unit .((f ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) , c =  (pred 0) }.b) ) (let u = (if false then true else false) in u) ) ) (\a: Unit .\b: Unit .b)) ) (fix (\x: Bool . (if true then true else (((\x: Nat .\y: Rec X. X .x) false ) false)) ))) , b = (pred (((\x: Unit .\y: Bool .y) (let u = true in u) ) ({a = (fix (\x: Nat . 0 )) , b = ({a = 1 , b = false , c = 0 }.c) }.b))) }.b)
(let u = (case <l = (fix (\x: Rec X. X . (let u = ({a = 1 , b = 1 }.b) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 ))) )) > as Bool of < l = x > => x | < r = y > => y) in (if (( \f: Bool .((f ({a = 1 , b = true }.b) ) (fix (\x: Bool . false )) ) ) (\a: Nat .\b: Nat .a)) then ({a = 0 , b = true , c = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) }.c) else ({a = false , b = (fix (\x: Unit . 0 )) }.b)))
(if (if (fix (\x: Rec X. X . (if false then true else (iszero 1)) )) then (( \f: Bool .((f (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in u) ) (iszero 1) ) ) (\a: Rec X. X .\b: Nat .b)) else (let u = (((\x: Nat .\y: Bool .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .b)) ) 1) in (case <r = true > as Bool of < l = x > => x | < r = y > => y))) then (((\x: Nat .\y: Nat .x) ({a = ({a = true , b = 1 }.b) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.b) ) (let u = (( \f: Bool .((f (succ 1) ) (fix (\x: Bool . 0 )) ) ) (\a: Bool .\b: Nat .b)) in (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)))) else (let u = ({a = ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = 0 }.a) , b = (if (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) then false else (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.b) in u))
(case <r = (( \f: Rec X. X .((f (( \f: Unit .((f (unfold [ Unit ] (fold [ Rec X. X ] true )) ) (let u = false in u) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (succ 0) , b = (let u = 0 in true) }.b) ) ) (\a: Rec X. X .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y)
(succ ({a = (let u = (((\x: Rec X. X .\y: Bool .y) false ) 1) in u) , b = ({a = (let u = false in 0) , b = (((\x: Unit .\y: Rec X. X .x) true ) false) , c =  (if true then 0 else 0) }.b) }.a))
(unfold [ Nat ] (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) )) ))
({a = (( \f: Bool .((f (let u = (let u = false in u) in (iszero 1)) ) (if false then false else (fix (\x: Nat . false ))) ) ) (\a: Unit .\b: Nat .a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (case <l = (case <l = (( \f: Rec X. X .((f ({a = 1 , b = false }.a) ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) )) }.b)
(unfold [ Bool ] (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ))
({a = (fix (\x: Unit . (let u = ({a = (if true then 1 else 1) , b = 1 }.b) in (fix (\x: Bool . false ))) )) , b = ({a = (succ (if (if false then false else false) then 1 else 0)) , b = ({a = (let u = (((\x: Nat .\y: Unit .x) 0 ) (if false then true else true)) in u) , b = (( \f: Bool .((f 0 ) (if true then 0 else 1) ) ) (\a: Unit .\b: Bool .b)) }.b) }.b) }.a)
(((\x: Bool .\y: Rec X. X .x) ({a = (( \f: Unit .((f ({a = 1 , b = 0 }.b) ) (succ 1) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Rec X. X .((f ({a = (fix (\x: Rec X. X . 0 )) , b = true }.b) ) (( \f: Unit .((f (iszero 0) ) true ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (((\x: Bool .\y: Rec X. X .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) true) }.c) ) (fix (\x: Unit . (let u = ({a = false , b = 1 }.a) in ({a = 0 , b = false }.b)) )))
((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Rec X. X .x) (if (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) then (let u = false in true) else (unfold [ Bool ] (fold [ Bool ] (fix (\x: Bool . false )) ))) ) (let u = (case <l = (let u = 1 in 0) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) in u))) ))
({a = (fix (\x: Unit . ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = false }.b) ) false) , b = (((\x: Unit .\y: Rec X. X .x) (fix (\x: Bool . 0 )) ) (let u = (let u = true in u) in false)) }.a) )) , b = (case <r = (((\x: Bool .\y: Nat .y) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (unfold [ Nat ] (fold [ Bool ] true ))) > as Unit of < l = x > => x | < r = y > => y) }.b)
(((\x: Unit .\y: Bool .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Bool . (((\x: Nat .\y: Rec X. X .x) false ) true) )) )) ) ({a = (( \f: Rec X. X .((f (let u = 0 in 0) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) , b = (( \f: Unit .((f (let u = false in false) ) (fix (\x: Unit . true )) ) ) (\a: Unit .\b: Unit .b)) , c =  ({a = ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) , b = (((\x: Nat .\y: Rec X. X .y) true ) true) }.a) , b = (iszero 0) , c = (succ 1) }.c) }.b))
(( \f: Nat .((f (case <r = (fix (\x: Bool . (let u = (iszero 1) in ({a = 0 , b = false , c =  1 }.b)) )) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Nat ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred 0) )) , b = (iszero 0) }.b) )) ) ) (\a: Nat .\b: Rec X. X .a))
(fix (\x: Bool . ({a = (case <r = ({a = 1 , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .a)) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (case <l = (succ 1) > as Nat of < l = x > => x | < r = y > => y) }.b) ))
(iszero ({a = ({a = ({a = 1 , b = true , c =  0 }.b) , b = (iszero 1) }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = 1 in (((\x: Rec X. X .\y: Nat .y) false ) 0)) )) }.b))
(let u = (case <l = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (if true then true else (((\x: Bool .\y: Unit .x) false ) true)) }.a) > as Nat of < l = x > => x | < r = y > => y) in u)
({a = ({a = ({a = (( \f: Bool .((f (if false then 1 else 1) ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = false in (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b))) }.b) , b = ({a = 1 , b = (let u = false in u) , c =  (fix (\x: Nat . 0 )) }.b) , c = (((\x: Bool .\y: Bool .y) false ) (let u = 1 in u)) }.c) , b = ({a = (( \f: Bool .((f (( \f: Rec X. X .((f (let u = 1 in 0) ) (((\x: Rec X. X .\y: Nat .x) 1 ) true) ) ) (\a: Unit .\b: Bool .b)) ) ({a = ({a = 0 , b = true }.a) , b = (fix (\x: Unit . (iszero 1) )) , c = (if true then (if false then 0 else 1) else (unfold [ Nat ] (fold [ Bool ] 1 ))) }.c) ) ) (\a: Unit .\b: Bool .b)) , b = ({a = ({a = (pred 0) , b = ({a = 0 , b = true , c = 1 }.c) }.b) , b = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Unit . false )) )) }.b) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .x) 0 ) ({a = false , b = 0 }.a)) )) }.b) , c = (( \f: Rec X. X .((f (let u = (((\x: Rec X. X .\y: Bool .x) 1 ) true) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) ) (pred (( \f: Nat .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Rec X. X .a))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.c)
({a = (let u = (( \f: Rec X. X .((f (fix (\x: Bool . (((\x: Bool .\y: Bool .x) 1 ) false) )) ) (( \f: Rec X. X .((f (case <l = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (let u = 1 in true) in 0) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .b)) in (let u = (if (let u = false in false) then ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) )) else ({a = 1 , b = true , c =  1 }.b)) in (let u = ({a = 1 , b = 0 }.b) in u))) , b = (( \f: Rec X. X .((f ({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) in true) , b = ({a = ({a = true , b = 0 }.b) , b = false }.b) }.b) ) ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Rec X. X .x) false ) false) , c =  (((\x: Bool .\y: Rec X. X .x) (case <l = (let u = 0 in 0) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Bool .x) false ) false)) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) , c = ({a = (case <l = (if (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) false ) false) )) then (pred 1) else ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 ))) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = ({a = 0 , b = true , c = (let u = 1 in u) }.c) in (case <r = (let u = 1 in false) > as Unit of < l = x > => x | < r = y > => y)) }.a) }.c)
(let u = (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .y) (( \f: Nat .((f true ) (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b)) ) (succ (((\x: Nat .\y: Bool .y) false ) 1))) )) in u)
(let u = (let u = (((\x: Nat .\y: Bool .y) (let u = true in u) ) (( \f: Nat .((f true ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Rec X. X .b))) in (let u = (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) )) in ({a = (succ 0) , b = (let u = false in u) }.a))) in u)
(fix (\x: Rec X. X . (iszero (case <l = (unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Nat .x) 1 ) true) )) > as Bool of < l = x > => x | < r = y > => y)) ))
(let u = (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) true ) true) )) ) (fix (\x: Bool . false ))) in (let u = (((\x: Nat .\y: Unit .y) (case <r = (unfold [ Bool ] (fold [ Nat ] true )) > as Nat of < l = x > => x | < r = y > => y) ) ({a = ({a = false , b = 0 }.b) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , c =  1 }.b)) in u))
({a = (pred (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) in (( \f: Unit .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (pred 0) ) ) (\a: Unit .\b: Bool .b)))) , b = ({a = (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in false) , b = (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Bool .b)) in u) }.b) }.b)
(((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f ({a = (let u = 1 in u) , b = ({a = 1 , b = false , c =  1 }.b) , c = (pred 0) }.c) ) (if (let u = ({a = (if false then 1 else 1) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b) in ({a = true , b = false }.b)) then (succ 0) else ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) ) ) (\a: Rec X. X .\b: Unit .a)) ) (if ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = (succ 1) , b = true , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b) )) then (let u = (((\x: Bool .\y: Rec X. X .y) false ) 0) in ({a = 0 , b = false }.b)) else ({a = (((\x: Rec X. X .\y: Unit .y) false ) false) , b = ({a = 0 , b = true , c =  0 }.b) }.b)))
({a = (pred ({a = (pred (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (pred (succ 0)) }.b)) , b = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) )) ) ({a = ({a = 1 , b = false , c = 1 }.c) , b = ({a = 0 , b = true }.b) , c =  (succ 1) }.b) ) ) (\a: Bool .\b: Nat .a)) , c =  (let u = (((\x: Unit .\y: Unit .x) (((\x: Unit .\y: Bool .y) ({a = false , b = 0 }.a) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) (fix (\x: Rec X. X . ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ))) in (pred (let u = 1 in (pred 0)))) }.b)
({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Bool .y) (((\x: Unit .\y: Rec X. X .x) true ) true) ) (let u = false in ({a = 0 , b = false }.a))) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Rec X. X . (( \f: Unit .((f true ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Nat .a)) )) )) }.b)
(let u = ({a = (case <l = (case <l = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . (let u = (let u = true in u) in u) )) , c = ({a = (((\x: Bool .\y: Bool .y) true ) false) , b = ({a = 1 , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) , c = (((\x: Unit .\y: Rec X. X .y) false ) 1) }.c) }.b) }.c) in u)
({a = (iszero (let u = (fix (\x: Nat . 0 )) in u)) , b = (case <r = (( \f: Nat .((f (iszero (pred (((\x: Unit .\y: Unit .x) 0 ) false))) ) (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Nat .y) false ) false) ) ({a = 0 , b = false , c =  0 }.b)) ) ) (\a: Bool .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y) }.b)
(((\x: Unit .\y: Bool .x) ({a = (succ ({a = (fix (\x: Rec X. X . 0 )) , b = false }.a)) , b = (((\x: Rec X. X .\y: Bool .x) (let u = 1 in true) ) ({a = 0 , b = false }.b)) }.a) ) (( \f: Bool .((f ({a = (let u = 0 in (if false then false else false)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = ({a = true , b = 0 }.a) in u) )) }.b) ) (fix (\x: Nat . (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Rec X. X .y) true ) (let u = 1 in true)) ) ({a = 0 , b = false }.b)) )) ) ) (\a: Nat .\b: Nat .a)))
({a = (succ (pred (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) true ) 1) )))) , b = (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Nat .x) ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = true }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a))) ) ({a = (((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) (unfold [ Bool ] (fold [ Nat ] 0 ))) , b = (( \f: Bool .((f ({a = (let u = 1 in u) , b = (let u = 0 in true) }.b) ) (((\x: Unit .\y: Nat .x) true ) true) ) ) (\a: Bool .\b: Nat .a)) , c =  ({a = (( \f: Unit .((f (if true then 0 else 1) ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (iszero 0) , c = (if false then 0 else 0) }.c) }.b)) }.b)
(if ({a = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = true , c =  1 }.b) )) in u) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) )) }.a) then (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Unit .((f 1 ) (let u = 0 in 1) ) ) (\a: Unit .\b: Unit .a)) )) in u) else (let u = (let u = ({a = 1 , b = false }.b) in (let u = false in 0)) in (((\x: Nat .\y: Bool .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) (let u = ({a = 1 , b = false , c = 1 }.c) in u))))
(fix (\x: Unit . ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) , b = 1 }.b) , b = (fix (\x: Unit . (((\x: Nat .\y: Unit .x) (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) ) false) )) }.b) ))
(let u = (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = ({a = true , b = 0 }.a) , b = (if true then ({a = 1 , b = 0 }.b) else (unfold [ Unit ] (fold [ Bool ] 0 ))) }.a) )) > as Nat of < l = x > => x | < r = y > => y) in (let u = (fix (\x: Nat . false )) in (let u = ({a = (iszero 1) , b = (iszero 1) }.b) in u)))
(unfold [ Nat ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = 1 in false) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.a) )) ))
(pred (( \f: Nat .((f ({a = ({a = ({a = 0 , b = 1 }.b) , b = false }.a) , b = (( \f: Bool .((f ({a = false , b = 1 }.a) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.a) ) (( \f: Rec X. X .((f ({a = 1 , b = true }.a) ) (if true then 0 else 0) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .a)))
(let u = (((\x: Bool .\y: Nat .x) ({a = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) (fix (\x: Bool . ({a = (if (let u = false in u) then (succ 0) else 0) , b = ({a = false , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b) }.b) ))) in u)
({a = ({a = (fix (\x: Unit . (succ 1) )) , b = (((\x: Nat .\y: Unit .x) (unfold [ Bool ] (fold [ Bool ] false )) ) true) }.a) , b = ({a = (case <r = ({a = (let u = 0 in 1) , b = (if true then true else true) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ({a = ({a = 0 , b = true }.a) , b = (iszero 1) }.a) ) (pred 1) ) ) (\a: Unit .\b: Nat .a)) }.a) , c =  ({a = (iszero (succ 0)) , b = (((\x: Rec X. X .\y: Unit .y) (unfold [ Unit ] (fold [ Nat ] true )) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a))) }.b) }.b)
(let u = ({a = (( \f: Bool .((f ({a = false , b = 1 }.b) ) (pred 0) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Bool .((f ({a = true , b = 0 }.a) ) (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) )) ) ) (\a: Bool .\b: Rec X. X .b)) , c = (succ (((\x: Nat .\y: Bool .y) false ) 1)) }.c) in ({a = ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) in u) , b = ({a = (let u = 1 in u) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , c =  ({a = 0 , b = 0 }.b) }.b) }.a) , b = ({a = (( \f: Rec X. X .((f false ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Bool .b)) , b = (let u = false in u) }.b) , c = (fix (\x: Unit . (pred ({a = true , b = 1 }.b)) )) }.c))
({a = ({a = (if (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .a)) then ({a = true , b = 1 }.b) else (((\x: Bool .\y: Unit .y) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Unit .\y: Bool .x) 1 ) false))) , b = (iszero 0) }.b) , b = (let u = (let u = (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a))) in ({a = (let u = 1 in u) , b = false , c =  1 }.b)) in (let u = ({a = (let u = false in false) , b = false }.b) in (let u = 1 in (let u = false in 1)))) }.b)
(pred ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = false }.b) , c =  (((\x: Unit .\y: Bool .x) ({a = 1 , b = 1 }.b) ) true) }.b) , b = (succ (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a))) }.b))
(if (case <r = (let u = ({a = 0 , b = false , c =  1 }.b) in u) > as Bool of < l = x > => x | < r = y > => y) then (((\x: Nat .\y: Nat .y) (unfold [ Bool ] (fold [ Rec X. X ] (let u = 1 in true) )) ) (unfold [ Bool ] (fold [ Nat ] (( \f: Unit .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) 0 ) ) (\a: Unit .\b: Unit .a)) ))) else (fix (\x: Rec X. X . (( \f: Nat .((f (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 ))) ) (pred 1) ) ) (\a: Nat .\b: Nat .b)) )))
(((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = (let u = true in true) , b = 1 }.a) ) (if (let u = false in u) then true else false)) in u) ) ({a = (let u = 0 in true) , b = (((\x: Unit .\y: Unit .x) 1 ) true) }.a) ) ) (\a: Bool .\b: Nat .a)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = (let u = true in true) , b = (fix (\x: Bool . false )) }.b) )))
(( \f: Bool .((f ({a = (unfold [ Nat ] (fold [ Unit ] ({a = false , b = (((\x: Rec X. X .\y: Bool .y) false ) 0) }.a) )) , b = (let u = ({a = 1 , b = ({a = true , b = 0 }.a) , c =  0 }.b) in (succ ({a = 1 , b = 0 }.b))) }.a) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) (let u = 1 in 1) ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (( \f: Unit .((f (if ({a = false , b = true }.b) then false else false) ) (( \f: Rec X. X .((f true ) (iszero 0) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Bool .\b: Rec X. X .a)) , c =  (unfold [ Bool ] (fold [ Rec X. X ] (let u = 0 in 0) )) }.b) ) ) (\a: Bool .\b: Rec X. X .a))
(case <l = (fix (\x: Nat . (((\x: Nat .\y: Nat .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) )) > as Nat of < l = x > => x | < r = y > => y)
(let u = (let u = (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = 0 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) in (unfold [ Bool ] (fold [ Bool ] 1 ))) in u)
(pred (let u = (let u = (((\x: Unit .\y: Bool .y) true ) true) in ({a = (if false then 0 else 1) , b = 0 }.b)) in u))
(fix (\x: Rec X. X . ({a = (( \f: Unit .((f (succ 1) ) (((\x: Bool .\y: Unit .x) 1 ) false) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Bool .((f 0 ) (if false then 1 else 0) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ))
(( \f: Bool .((f (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) false ) true) )) in (fix (\x: Unit . (let u = false in false) ))) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = (( \f: Nat .((f true ) (if false then false else true) ) ) (\a: Nat .\b: Nat .a)) , b = (( \f: Nat .((f true ) (fix (\x: Rec X. X . true )) ) ) (\a: Bool .\b: Bool .b)) }.b) )) ) ) (\a: Unit .\b: Bool .a))
(( \f: Unit .((f ({a = (if ({a = 0 , b = true , c =  0 }.b) then true else false) , b = (let u = false in u) }.b) ) (let u = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in 1) in (( \f: Bool .((f (let u = false in u) ) (((\x: Rec X. X .\y: Bool .y) true ) true) ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Bool .\b: Rec X. X .b))
(((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = false }.a) , b = (let u = false in ({a = 0 , b = true , c =  0 }.b)) , c =  ({a = false , b = 0 }.b) }.b) )) ) (if (((\x: Nat .\y: Unit .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) (iszero 0)) then ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .a)) , c = (( \f: Bool .((f 1 ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) }.c) else ({a = (if (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .b)) then ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.a) else (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) 0)) , b = ({a = ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = true , c =  (((\x: Unit .\y: Unit .x) 1 ) true) }.b) , b = (((\x: Nat .\y: Unit .y) true ) 0) }.a) , c = (fix (\x: Bool . (((\x: Nat .\y: Bool .y) false ) 0) )) }.c)))
({a = (let u = (succ (succ (let u = true in (let u = false in 0)))) in ({a = (( \f: Rec X. X .((f 0 ) (let u = false in 0) ) ) (\a: Unit .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Nat .x) false ) true) }.b)) , b = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] 0 )) ) (let u = (if true then 1 else 1) in (fix (\x: Rec X. X . 1 ))) ) ) (\a: Bool .\b: Unit .b)) }.a)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (( \f: Bool .((f (iszero ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in u) ))) ) (iszero (fix (\x: Rec X. X . 1 ))) ) ) (\a: Nat .\b: Bool .a)) ))
(let u = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .x) false ) true) ) true ) ) (\a: Nat .\b: Bool .b)) )) ) (( \f: Rec X. X .((f (if false then false else true) ) (let u = true in true) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Bool .b)) in ({a = (fix (\x: Nat . 1 )) , b = ({a = true , b = true }.b) }.a))
(succ (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) ({a = false , b = 0 }.a) ) (pred 0)) )))
({a = (unfold [ Unit ] (fold [ Unit ] ({a = (let u = (let u = 0 in false) in true) , b = (fix (\x: Bool . (( \f: Unit .((f 1 ) (((\x: Nat .\y: Nat .x) 0 ) true) ) ) (\a: Unit .\b: Nat .a)) )) }.b) )) , b = (unfold [ Rec X. X ] (fold [ Nat ] (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) )) , c =  (let u = ({a = ({a = false , b = 1 }.b) , b = (let u = true in u) , c =  (( \f: Unit .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) 0 ) ) (\a: Nat .\b: Nat .b)) }.b) in ({a = (if true then 1 else 0) , b = (let u = 1 in false) }.a)) }.b)
(pred (pred (( \f: Unit .((f ({a = (let u = 1 in u) , b = (((\x: Rec X. X .\y: Nat .y) false ) false) }.a) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Unit .a))))
(((\x: Nat .\y: Rec X. X .x) (let u = (let u = ({a = false , b = 0 }.a) in u) in (let u = ({a = (iszero (let u = 0 in u)) , b = (if true then 0 else 0) }.a) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (pred 0) )))) ) (let u = (((\x: Unit .\y: Bool .y) false ) ({a = 0 , b = true }.b)) in (let u = 0 in (((\x: Nat .\y: Unit .x) true ) true))))
(unfold [ Bool ] (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f (fix (\x: Rec X. X . 0 )) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) false ) 0) )) ) ) (\a: Unit .\b: Unit .b)) ) ({a = ({a = 1 , b = true }.a) , b = (fix (\x: Unit . true )) }.b)) ))
({a = ({a = ({a = 1 , b = false , c =  0 }.b) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = ({a = 0 , b = true , c =  (let u = 1 in 0) }.b) , c =  (((\x: Nat .\y: Bool .y) true ) 1) }.b) }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (iszero ({a = (fix (\x: Nat . 0 )) , b = (let u = false in 0) }.b)) )) }.b)
(let u = (unfold [ Unit ] (fold [ Unit ] ({a = (succ (succ 1)) , b = ({a = false , b = 1 }.a) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.b) )) in (let u = (((\x: Nat .\y: Nat .x) 0 ) (fix (\x: Nat . true ))) in (if (let u = false in ({a = true , b = false }.b)) then (fix (\x: Unit . 1 )) else (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)))))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (let u = (let u = 0 in u) in ({a = 0 , b = true }.b)) , c = (unfold [ Nat ] (fold [ Bool ] (pred 0) )) }.c) , b = (let u = 1 in false) }.b) ))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ({a = (iszero (let u = false in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) , b = (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) 0 ) true) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) , b = (( \f: Unit .((f (fix (\x: Unit . true )) ) (fix (\x: Bool . (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) ))
({a = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = (let u = 1 in (((\x: Nat .\y: Bool .y) false ) false)) > as Unit of < l = x > => x | < r = y > => y) )) , b = (case <l = (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) }.a)
(iszero ({a = (((\x: Nat .\y: Bool .y) ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = (let u = (let u = 0 in false) in (if false then 1 else 1)) }.a) ) (case <r = (let u = false in false) > as Nat of < l = x > => x | < r = y > => y)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) )) }.b))
(let u = (pred (((\x: Rec X. X .\y: Bool .x) (let u = 0 in 1) ) ({a = 1 , b = (iszero 0) }.b))) in u)
(( \f: Rec X. X .((f (fix (\x: Unit . (((\x: Unit .\y: Bool .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .b)) ))) )) ) (if (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true ))) then (fix (\x: Nat . (if false then (iszero 0) else false) )) else ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) (let u = 1 in true) ) false) ))) ) ) (\a: Unit .\b: Unit .b))
(((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Nat .x) (let u = false in (((\x: Unit .\y: Unit .y) true ) true)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (if true then false else true) ))) ) (((\x: Unit .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) false ) true) ) false) )) ) (unfold [ Unit ] (fold [ Unit ] false ))))
(let u = (case <r = (case <r = (((\x: Bool .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .x) false ) false) ) (case <r = (if true then false else false) > as Unit of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (if (unfold [ Nat ] (fold [ Bool ] (let u = 0 in false) )) then (let u = (let u = true in 1) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) else (let u = 0 in true)) )))
(case <r = (iszero (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then 0 else ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )))) > as Rec X. X of < l = x > => x | < r = y > => y)
(iszero (( \f: Rec X. X .((f (let u = false in 1) ) (( \f: Unit .((f (let u = 0 in 0) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Nat .b)))
(((\x: Unit .\y: Rec X. X .x) ({a = ({a = (let u = 0 in u) , b = false }.b) , b = (((\x: Nat .\y: Nat .x) 1 ) (((\x: Rec X. X .\y: Unit .y) true ) false)) }.b) ) (if (let u = (let u = ({a = true , b = false }.b) in (let u = false in false)) in (unfold [ Nat ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) false ) false) ))) then (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) in ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = true }.b)) else (( \f: Unit .((f (let u = true in u) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) ) ) (\a: Unit .\b: Rec X. X .b))))
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = ({a = false , b = false }.b) in ({a = true , b = 1 }.b)) )) , b = (let u = (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) )) in (case <r = ({a = true , b = 1 }.a) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b)
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Bool ] 0 )) )) )) , b = (let u = (( \f: Nat .((f ({a = (unfold [ Nat ] (fold [ Nat ] 0 )) , b = (iszero 1) }.a) ) (pred 0) ) ) (\a: Nat .\b: Rec X. X .b)) in u) }.b)
(if (((\x: Unit .\y: Bool .x) (let u = (((\x: Unit .\y: Rec X. X .y) (if false then true else true) ) true) in (iszero 0)) ) (fix (\x: Nat . (if (let u = 1 in true) then (let u = 1 in true) else (iszero 1)) ))) then (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Bool .a)) )) else (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Nat .((f (let u = 0 in true) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) else (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) ))))
(((\x: Rec X. X .\y: Rec X. X .x) (if (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) then (if (let u = true in u) then ({a = 0 , b = (let u = false in true) , c = 1 }.c) else (let u = true in 1)) else ({a = 1 , b = (fix (\x: Unit . false )) }.a)) ) ({a = (let u = (let u = 1 in 1) in (if false then false else false)) , b = (iszero (( \f: Rec X. X .((f ({a = 1 , b = 1 }.b) ) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ) ) (\a: Nat .\b: Unit .b))) }.b))
(let u = ({a = (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (let u = (let u = true in 0) in u) }.b) in (if (let u = (let u = true in u) in u) then (if (unfold [ Unit ] (fold [ Bool ] true )) then (fix (\x: Rec X. X . 1 )) else (let u = true in 0)) else (unfold [ Nat ] (fold [ Rec X. X ] 0 ))))
({a = (((\x: Bool .\y: Bool .y) (let u = ({a = 0 , b = true }.b) in u) ) ({a = ({a = (pred 1) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) , c =  1 }.b) , b = (iszero 1) }.b)) , b = (let u = (let u = ({a = (if true then 0 else 1) , b = (((\x: Rec X. X .\y: Nat .y) true ) true) , c =  1 }.b) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))) in u) }.b)
(let u = (unfold [ Nat ] (fold [ Unit ] (unfold [ Unit ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) )) )) in (if ({a = ({a = (pred 0) , b = true }.b) , b = ({a = 0 , b = 1 }.b) }.a) then ({a = (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 )) )) , b = (unfold [ Rec X. X ] (fold [ Unit ] false )) }.b) else (case <r = (case <r = (if true then false else false) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)))
(( \f: Bool .((f (if ({a = ({a = ({a = 0 , b = 0 }.b) , b = false , c = 1 }.c) , b = (unfold [ Bool ] (fold [ Nat ] true )) }.b) then (fix (\x: Bool . (let u = 0 in u) )) else (pred (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)))) ) ({a = (if ({a = false , b = 1 }.a) then (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) else (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) , b = (pred (((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Nat .x) false ) true) ) (fix (\x: Nat . 1 )))) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(((\x: Nat .\y: Rec X. X .x) (if (((\x: Unit .\y: Nat .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) ) (fix (\x: Unit . false ))) then (let u = 0 in 1) else ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = 0 in 0) ))) ) (let u = (pred (( \f: Rec X. X .((f ({a = 1 , b = true }.a) ) 1 ) ) (\a: Nat .\b: Rec X. X .b))) in (((\x: Nat .\y: Rec X. X .y) (( \f: Unit .((f (unfold [ Bool ] (fold [ Unit ] false )) ) (unfold [ Bool ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) )) ) ) (\a: Bool .\b: Nat .a)) ) ({a = ({a = true , b = true }.b) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b))))
(fix (\x: Unit . ({a = (fix (\x: Nat . ({a = ({a = 1 , b = false }.a) , b = ({a = 1 , b = false }.a) }.b) )) , b = (let u = ({a = (unfold [ Bool ] (fold [ Unit ] true )) , b = (if true then false else false) }.b) in u) , c =  (fix (\x: Rec X. X . ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b) )) }.b) ))
(((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Rec X. X .y) (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Bool ] true )) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) ({a = false , b = 0 }.a) ) false) ))) ) (((\x: Rec X. X .\y: Unit .y) (iszero (succ 0)) ) ({a = ({a = 0 , b = false }.a) , b = false }.a)))
(((\x: Nat .\y: Unit .y) ({a = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , b = (iszero 0) }.b) ) (((\x: Unit .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Nat .y) ({a = 1 , b = false , c =  1 }.b) ) false) )) ) (((\x: Rec X. X .\y: Unit .x) (let u = true in u) ) (let u = (((\x: Rec X. X .\y: Bool .x) 0 ) false) in (((\x: Nat .\y: Rec X. X .x) false ) false)))))
({a = (unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f (let u = true in false) ) ({a = false , b = true }.b) ) ) (\a: Unit .\b: Unit .b)) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <l = ({a = false , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) )) }.a)
(if (( \f: Rec X. X .((f ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) )) , b = (if (let u = false in false) then false else (let u = true in true)) }.b) ) (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in (let u = ({a = false , b = false }.b) in u)) ) ) (\a: Bool .\b: Bool .b)) then ({a = (((\x: Rec X. X .\y: Unit .x) (let u = 0 in 1) ) (if true then (if true then true else true) else false)) , b = (let u = (let u = 0 in 0) in (iszero 0)) }.b) else (let u = (let u = (unfold [ Unit ] (fold [ Bool ] true )) in u) in u))
(let u = (((\x: Nat .\y: Unit .x) (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) false ) false) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Unit .a)) ) (let u = 1 in true)) in (let u = (succ 1) in (((\x: Bool .\y: Rec X. X .x) (fix (\x: Nat . ({a = 1 , b = true }.b) )) ) (let u = 0 in false))))
({a = ({a = (succ 0) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = ({a = false , b = 1 }.b) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = (case <l = ({a = 0 , b = true , c = 0 }.c) > as Bool of < l = x > => x | < r = y > => y) }.c) }.b) , b = (let u = ({a = (((\x: Nat .\y: Unit .y) false ) true) , b = 0 }.a) in ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = 1 , b = 0 }.b) ))) }.b)
(let u = ({a = (( \f: Nat .((f (let u = ({a = true , b = true }.b) in false) ) (let u = ({a = (((\x: Rec X. X .\y: Nat .x) false ) false) , b = 1 }.b) in (fix (\x: Nat . (fix (\x: Bool . false )) ))) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (let u = (((\x: Nat .\y: Bool .y) true ) 0) in u) }.a) in (( \f: Rec X. X .((f (let u = (case <r = ({a = true , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Bool .x) (if false then true else (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .a))) ) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a))) ) (( \f: Unit .((f true ) (iszero 0) ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Bool .\b: Nat .b)))
({a = (let u = (let u = 0 in u) in u) , b = (fix (\x: Unit . (((\x: Nat .\y: Bool .x) ({a = (let u = 0 in (pred 0)) , b = (((\x: Rec X. X .\y: Nat .y) false ) 1) }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) )) }.b)
(let u = ({a = ({a = (if false then 1 else 1) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , c = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.c) , b = ({a = (pred 0) , b = (( \f: Nat .((f (let u = false in true) ) true ) ) (\a: Unit .\b: Unit .a)) }.b) }.b) in (((\x: Unit .\y: Nat .x) (( \f: Unit .((f ({a = 1 , b = false }.b) ) (((\x: Unit .\y: Nat .y) false ) (unfold [ Rec X. X ] (fold [ Nat ] true ))) ) ) (\a: Bool .\b: Unit .b)) ) (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y)))
(fix (\x: Unit . (let u = (( \f: Bool .((f ({a = (let u = false in 0) , b = (((\x: Rec X. X .\y: Nat .x) true ) true) , c =  0 }.b) ) (((\x: Nat .\y: Unit .x) ({a = true , b = true }.b) ) false) ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = (let u = false in u) in u)) ))
(((\x: Nat .\y: Rec X. X .y) (if (iszero ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 ))) then (let u = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] false )) )) in u) else ({a = (let u = 0 in false) , b = (let u = true in u) }.b)) ) (let u = (((\x: Bool .\y: Bool .x) (iszero (let u = true in 1)) ) (let u = true in true)) in u))
({a = (( \f: Unit .((f ({a = (fix (\x: Bool . false )) , b = 1 }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Bool . (((\x: Rec X. X .\y: Bool .x) 0 ) true) )) )) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = (( \f: Rec X. X .((f (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in (unfold [ Nat ] (fold [ Bool ] 1 ))) ) (let u = 1 in u) ) ) (\a: Bool .\b: Unit .a)) in ({a = (((\x: Nat .\y: Nat .x) 1 ) true) , b = (let u = 1 in false) , c =  (((\x: Unit .\y: Bool .x) 1 ) true) }.b)) }.a)
(succ (( \f: Nat .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (if (( \f: Nat .((f false ) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Bool .\b: Rec X. X .b)) then (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = 0 in u)) ) ) (\a: Nat .\b: Bool .b)))
({a = (( \f: Bool .((f ({a = (let u = ({a = 0 , b = 0 }.b) in (succ 1)) , b = (fix (\x: Rec X. X . (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) }.b) ) (let u = (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 )) in 1) in (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = (if (iszero 1) then (( \f: Bool .((f 1 ) (if true then 0 else 0) ) ) (\a: Nat .\b: Unit .a)) else (((\x: Rec X. X .\y: Nat .x) 0 ) true)) in (unfold [ Unit ] (fold [ Bool ] (iszero 0) ))) }.b)
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.b) in (unfold [ Unit ] (fold [ Bool ] (let u = true in u) ))) ))
({a = (if (iszero (if false then 1 else 0)) then (let u = 1 in 0) else (( \f: Rec X. X .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )) ) (let u = 0 in u) ) ) (\a: Nat .\b: Bool .b))) , b = ({a = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = (((\x: Unit .\y: Bool .y) true ) 1) }.b) , b = (let u = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .b)) in (iszero 1)) , c = (if (unfold [ Unit ] (fold [ Rec X. X ] false )) then (let u = 1 in u) else ({a = 1 , b = false }.a)) }.c) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (if (( \f: Unit .((f ({a = true , b = 0 }.a) ) (if true then (let u = false in false) else (if true then true else true)) ) ) (\a: Nat .\b: Rec X. X .a)) then ({a = (((\x: Nat .\y: Nat .x) false ) false) , b = ({a = ({a = 1 , b = true , c = 1 }.c) , b = ({a = true , b = false }.b) , c = (((\x: Unit .\y: Nat .x) 1 ) false) }.c) }.b) else (case <l = (if false then 0 else 1) > as Unit of < l = x > => x | < r = y > => y)) ))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (if (let u = 1 in (let u = 1 in false)) then (let u = (if true then 1 else 1) in (fix (\x: Unit . 1 ))) else (pred ({a = 1 , b = true , c = 1 }.c))) in (((\x: Bool .\y: Nat .x) ({a = false , b = 0 }.b) ) (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))))) ))
(fix (\x: Bool . (( \f: Nat .((f ({a = 0 , b = false }.b) ) (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) ))
(pred (let u = (pred (let u = ({a = 0 , b = true , c = 1 }.c) in u)) in u))
({a = ({a = (let u = ({a = true , b = 0 }.b) in u) , b = (iszero (let u = 1 in 1)) }.a) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Nat .\y: Nat .y) true ) true)) ) (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) )) }.a)
(let u = (let u = (case <r = (iszero (let u = false in 0)) > as Bool of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .x) ({a = ({a = 0 , b = true }.b) , b = (let u = true in u) }.b) ) ({a = 1 , b = (let u = false in u) , c =  (let u = 0 in 1) }.b))) in u)
(case <l = (if (let u = (((\x: Rec X. X .\y: Nat .x) false ) true) in u) then (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (fix (\x: Rec X. X . 1 ))) else (((\x: Bool .\y: Unit .y) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) , b = false , c =  (let u = false in 1) }.b) ) (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) 1 ) ) (\a: Unit .\b: Bool .b)))) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (let u = (((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Nat .y) true ) false) ) (fix (\x: Unit . true ))) in (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = true , c = 1 }.c) ))) , b = (((\x: Nat .\y: Unit .y) (if (if true then false else false) then false else (let u = false in u)) ) (iszero ({a = 1 , b = 0 }.b))) }.a) , b = (let u = (((\x: Unit .\y: Bool .y) false ) (((\x: Nat .\y: Rec X. X .x) 1 ) false)) in (unfold [ Bool ] (fold [ Unit ] (let u = true in false) ))) }.b)
(case <r = (let u = (((\x: Unit .\y: Bool .x) (unfold [ Bool ] (fold [ Bool ] 0 )) ) false) in (iszero (((\x: Rec X. X .\y: Rec X. X .y) true ) 0))) > as Bool of < l = x > => x | < r = y > => y)
(case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] (if true then false else false) )) )) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (( \f: Unit .((f (if ({a = (((\x: Nat .\y: Bool .y) false ) false) , b = 1 }.a) then (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true) ) (((\x: Rec X. X .\y: Rec X. X .y) false ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) ) ) (\a: Unit .\b: Rec X. X .b)) else ({a = (if false then true else true) , b = (let u = 0 in false) }.b)) ) (iszero ({a = ({a = 1 , b = true , c =  1 }.b) , b = (((\x: Nat .\y: Unit .x) 0 ) false) }.b)) ) ) (\a: Nat .\b: Unit .a)) ) ({a = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (pred 0) else (unfold [ Nat ] (fold [ Nat ] 0 ))) , b = ({a = (((\x: Nat .\y: Nat .x) 1 ) false) , b = true }.b) , c =  ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = ({a = true , b = true }.b) }.a) }.b) ) ) (\a: Bool .\b: Unit .a))
(((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .x) ({a = (((\x: Unit .\y: Bool .y) true ) 0) , b = true , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) }.b) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b))) )) ) ({a = (fix (\x: Bool . true )) , b = (if false then false else false) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (let u = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) in (let u = true in true)) in u))
(( \f: Unit .((f (((\x: Unit .\y: Unit .x) (let u = ({a = false , b = true }.b) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) ) (if ({a = true , b = false }.b) then ({a = 1 , b = false }.b) else (if false then false else true))) ) (let u = ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.a) in u) ) ) (\a: Unit .\b: Nat .a))
(case <r = (((\x: Unit .\y: Nat .x) (if (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] false )) ) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Nat .\b: Bool .a)) then (iszero (succ 0)) else ({a = (succ 1) , b = (iszero 0) , c =  ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) }.b)) ) ({a = (unfold [ Unit ] (fold [ Nat ] true )) , b = (let u = (let u = false in u) in (((\x: Unit .\y: Unit .y) false ) false)) }.b)) > as Nat of < l = x > => x | < r = y > => y)
(let u = (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) )) ) (succ (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u)
(pred (((\x: Bool .\y: Nat .y) ({a = (case <r = ({a = 1 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) (fix (\x: Bool . 1 )) ) ) (\a: Nat .\b: Unit .b)) }.a) ) (succ (if true then 0 else 0))))
(let u = (unfold [ Unit ] (fold [ Nat ] (let u = (unfold [ Nat ] (fold [ Bool ] true )) in (if false then true else true)) )) in u)
({a = (let u = ({a = ({a = 0 , b = true }.a) , b = ({a = 1 , b = true }.a) }.b) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Nat .x) false ) false) ) (fix (\x: Unit . 0 ))) ))) , b = (let u = (let u = 1 in (let u = true in true)) in (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) in (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)))) , c =  (fix (\x: Nat . ({a = 0 , b = (((\x: Bool .\y: Rec X. X .y) false ) false) , c = 1 }.c) )) }.b)
(((\x: Nat .\y: Bool .x) (let u = (fix (\x: Bool . (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) )) in u) ) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Unit .x) false ) true) ) true) )))
(if (case <r = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = (( \f: Nat .((f ({a = 1 , b = (let u = false in true) , c =  (((\x: Unit .\y: Bool .y) false ) 1) }.b) ) ({a = 1 , b = ({a = false , b = 1 }.a) , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) in (( \f: Nat .((f ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = (((\x: Rec X. X .\y: Bool .x) false ) true) , c =  (((\x: Bool .\y: Rec X. X .x) 0 ) true) }.b) ) (( \f: Nat .((f false ) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .a))) else ({a = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in (unfold [ Bool ] (fold [ Rec X. X ] true ))) , b = (( \f: Unit .((f ({a = 1 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = 1 }.c) ) (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f 1 ) (if true then 0 else 0) ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = false , b = true }.b)) ) ) (\a: Nat .\b: Bool .b)) }.a))
(iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Nat . (let u = (((\x: Rec X. X .\y: Rec X. X .x) (let u = 0 in 0) ) true) in ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.a)) )) )))
(let u = (let u = (((\x: Nat .\y: Bool .x) ({a = true , b = 0 }.b) ) ({a = ({a = 1 , b = false , c = 0 }.c) , b = false , c =  (fix (\x: Rec X. X . 0 )) }.b)) in ({a = (succ ({a = true , b = 1 }.b)) , b = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) , b = (unfold [ Unit ] (fold [ Unit ] false )) , c = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = true , c = 1 }.c) }.c) }.b)) in ({a = (succ (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) , b = ({a = (let u = 0 in u) , b = (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in ({a = false , b = (iszero 0) }.b)) }.b) , c = (case <l = ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) true) , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) }.c))
(case <r = (let u = ({a = (let u = (let u = 1 in u) in (let u = 0 in 1)) , b = (((\x: Bool .\y: Unit .x) (let u = 0 in true) ) true) , c = (((\x: Bool .\y: Unit .y) true ) 0) }.c) in (((\x: Unit .\y: Nat .y) (unfold [ Nat ] (fold [ Nat ] (if true then false else false) )) ) (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in u) ) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .b))))) > as Nat of < l = x > => x | < r = y > => y)
({a = (((\x: Nat .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) false ) true) )) ) (succ 0)) , b = (((\x: Bool .\y: Rec X. X .x) (case <r = ({a = (((\x: Nat .\y: Unit .y) (if true then false else false) ) 1) , b = (fix (\x: Unit . false )) , c =  (((\x: Nat .\y: Rec X. X .y) false ) (fix (\x: Rec X. X . 1 ))) }.b) > as Unit of < l = x > => x | < r = y > => y) ) (if (unfold [ Bool ] (fold [ Rec X. X ] false )) then ({a = (let u = 1 in true) , b = true }.b) else (((\x: Bool .\y: Rec X. X .y) ({a = 0 , b = true }.b) ) true))) }.a)
(case <l = (case <l = (( \f: Rec X. X .((f ({a = 0 , b = true }.a) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) ) (\a: Rec X. X .\b: Nat .a)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (let u = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = false }.b) in u) , b = ({a = (succ (pred 0)) , b = (unfold [ Rec X. X ] (fold [ Unit ] false )) , c = (if false then 1 else 0) }.c) }.a) , b = ({a = (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) in (((\x: Nat .\y: Unit .x) 1 ) false)) , b = (let u = 1 in false) }.b) }.b)
(let u = (case <r = (case <r = (fix (\x: Nat . true )) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) in ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = (if (((\x: Rec X. X .\y: Rec X. X .y) true ) true) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) else (fix (\x: Unit . true ))) , c =  (succ (fix (\x: Unit . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) ))) }.b))
(case <r = (let u = (let u = (fix (\x: Nat . ({a = 0 , b = true }.b) )) in u) in (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) (fix (\x: Nat . (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) )) ) ) (\a: Nat .\b: Nat .b))) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (fix (\x: Rec X. X . (fix (\x: Nat . (let u = 0 in true) )) )) ) (((\x: Bool .\y: Unit .x) (if (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = false , c =  0 }.b) )) then (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then (unfold [ Rec X. X ] (fold [ Unit ] true )) else (((\x: Nat .\y: Unit .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (let u = true in true))) else (let u = false in u)) ) (( \f: Bool .((f (let u = 0 in (((\x: Bool .\y: Bool .y) true ) true)) ) ({a = (let u = false in u) , b = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = false , c =  0 }.b) }.b) ) ) (\a: Unit .\b: Bool .a))) ) ) (\a: Unit .\b: Rec X. X .a))
(( \f: Nat .((f (( \f: Nat .((f (((\x: Nat .\y: Bool .x) (( \f: Nat .((f (if false then false else false) ) (let u = false in u) ) ) (\a: Nat .\b: Nat .b)) ) ({a = (( \f: Unit .((f ({a = false , b = 0 }.a) ) true ) ) (\a: Nat .\b: Rec X. X .a)) , b = (fix (\x: Bool . false )) }.b)) ) (let u = (let u = ({a = false , b = 1 }.b) in u) in (((\x: Rec X. X .\y: Rec X. X .y) true ) (let u = true in u))) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in u) )) , b = ({a = true , b = false }.b) , c =  (if false then ({a = false , b = 1 }.b) else 0) }.b) ) ) (\a: Nat .\b: Nat .a))
(succ ({a = ({a = ({a = 1 , b = true }.a) , b = (if (let u = false in u) then (let u = true in false) else (fix (\x: Unit . true ))) , c = (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then 0 else 0) }.c) , b = (( \f: Bool .((f (if true then false else true) ) (unfold [ Nat ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Bool .b)) }.a))
(( \f: Unit .((f (let u = (( \f: Nat .((f ({a = false , b = 1 }.b) ) (pred (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Bool .b)) in u) ) (let u = (pred (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) in u) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Unit . (pred 0) )) )) , b = (iszero (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = true }.a) ))) , c =  ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .y) false ) 1) )) }.b)
({a = (( \f: Bool .((f (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Bool ] (let u = 1 in false) )) ) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Bool .b)) ) (((\x: Nat .\y: Bool .x) (fix (\x: Rec X. X . ({a = true , b = true }.b) )) ) (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = true in true))) ) ) (\a: Unit .\b: Bool .a)) , b = (pred ({a = 0 , b = ({a = true , b = 1 }.a) , c = (let u = 1 in 0) }.c)) }.b)
(fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Bool ] (succ 0) )) ))
(let u = (case <l = (unfold [ Unit ] (fold [ Nat ] (let u = 0 in u) )) > as Nat of < l = x > => x | < r = y > => y) in ({a = ({a = (((\x: Unit .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .x) false ) true) ) false) , b = (( \f: Bool .((f ({a = 0 , b = 0 }.b) ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) }.a) , b = (( \f: Bool .((f ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .a)) , c = 0 }.c) ) ({a = ({a = 0 , b = (let u = true in u) }.b) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b) ) ) (\a: Nat .\b: Unit .b)) }.a))
(( \f: Nat .((f (((\x: Rec X. X .\y: Nat .y) (let u = ({a = 1 , b = false , c =  1 }.b) in u) ) (((\x: Bool .\y: Unit .y) (let u = 0 in true) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)))) ) (( \f: Unit .((f (succ (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a))) ) (let u = (let u = true in u) in 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Nat .a))
(( \f: Bool .((f (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = ({a = false , b = 0 }.a) in u) )) then (fix (\x: Rec X. X . ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (succ 0) }.b) )) else (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .a))) ) ({a = (pred (fix (\x: Unit . 0 ))) , b = (((\x: Unit .\y: Bool .y) ({a = (fix (\x: Unit . 0 )) , b = (iszero 0) , c =  (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (let u = false in u) in ({a = 1 , b = false }.b)) ))) }.a) ) ) (\a: Unit .\b: Nat .a))
(case <l = (if (case <r = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) then ({a = true , b = 0 }.b) else (succ (pred 1))) > as Bool of < l = x > => x | < r = y > => y)
(let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = (pred 1) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) ) false ) ) (\a: Unit .\b: Bool .a)) }.b) ) (let u = ({a = 0 , b = 1 }.b) in (case <r = (((\x: Nat .\y: Nat .y) true ) true) > as Nat of < l = x > => x | < r = y > => y))) in (let u = ({a = ({a = 1 , b = false }.a) , b = ({a = true , b = 1 }.a) }.a) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (case <l = ({a = 0 , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (iszero 1) in (case <r = ({a = 1 , b = false , c =  0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) }.a) ))
(let u = (fix (\x: Bool . ({a = (succ (((\x: Unit .\y: Rec X. X .y) false ) 0)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (succ 1) )) }.b) )) in u)
(fix (\x: Rec X. X . (( \f: Nat .((f ({a = ({a = 0 , b = 0 }.b) , b = ({a = 1 , b = (let u = true in u) , c =  1 }.b) , c = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.c) ) ({a = (pred 1) , b = (let u = 1 in u) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ))
({a = (let u = ({a = (let u = 0 in false) , b = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then false else ({a = 0 , b = false , c =  0 }.b)) }.b) in (fix (\x: Bool . (let u = (( \f: Nat .((f (((\x: Nat .\y: Bool .x) 1 ) false) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ))) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (if false then true else false)) , b = ({a = ({a = 0 , b = true }.a) , b = (if (if false then false else true) then (let u = false in true) else ({a = false , b = 1 }.a)) , c = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (fix (\x: Nat . false )) }.a) }.c) }.b) }.a)
({a = (case <l = (let u = (pred 1) in u) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = (let u = 1 in 1) , b = false , c = 1 }.c) in (let u = (( \f: Unit .((f 0 ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Nat .b)) in u)) }.b)
(( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) (fix (\x: Rec X. X . (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .b)) )) ) (let u = (pred 0) in false)) ) (case <r = (if true then ({a = true , b = 1 }.a) else ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b))
(( \f: Bool .((f (succ (let u = ({a = ({a = true , b = 1 }.a) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) in u)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = (let u = false in 1) in u) )) ) ) (\a: Bool .\b: Rec X. X .b))
(fix (\x: Nat . ({a = ({a = (iszero 1) , b = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) }.b) , b = (((\x: Nat .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] true )) )) ) (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) else (iszero 0))) , c = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = (let u = 0 in true) }.a) }.c) ))
(((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Bool .x) ({a = (let u = ({a = 1 , b = 1 }.b) in u) , b = ({a = (succ 1) , b = ({a = 0 , b = true }.b) }.b) }.b) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) false ) true) ) (fix (\x: Unit . true )) ) ) (\a: Nat .\b: Unit .b))) ) (let u = ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = (let u = 1 in false) }.a) in (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) ({a = true , b = false }.b) ) true) ))))
({a = (case <r = (unfold [ Rec X. X ] (fold [ Bool ] ({a = 0 , b = true , c =  (let u = 1 in 0) }.b) )) > as Nat of < l = x > => x | < r = y > => y) , b = (if (((\x: Unit .\y: Bool .y) (let u = 0 in false) ) (let u = true in true)) then (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) else (unfold [ Nat ] (fold [ Unit ] (if true then 0 else 0) ))) }.b)
({a = (( \f: Unit .((f (fix (\x: Rec X. X . ({a = 0 , b = false , c = 1 }.c) )) ) (case <l = (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) , b = (let u = (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Nat .y) true ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a))) ) (unfold [ Rec X. X ] (fold [ Bool ] false ))) in (fix (\x: Bool . (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ))) }.b)
(succ (unfold [ Bool ] (fold [ Nat ] (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a))) )))
(let u = (let u = (succ (let u = (fix (\x: Rec X. X . 0 )) in u)) in u) in (if (fix (\x: Nat . true )) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = 0 }.b) )) )) else (let u = ({a = (iszero 0) , b = 0 }.a) in ({a = false , b = 0 }.b))))
(((\x: Rec X. X .\y: Bool .x) (fix (\x: Bool . (( \f: Unit .((f (( \f: Unit .((f ({a = true , b = 0 }.a) ) ({a = false , b = 1 }.a) ) ) (\a: Nat .\b: Unit .b)) ) (if false then false else true) ) ) (\a: Rec X. X .\b: Bool .a)) )) ) (iszero ({a = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) true ) false) )) , b = (succ (((\x: Nat .\y: Unit .x) ({a = 0 , b = 1 }.b) ) true)) }.b)))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = (((\x: Rec X. X .\y: Nat .y) false ) (let u = 1 in false)) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = false in true) )) , c =  (let u = ({a = 1 , b = 1 }.b) in u) }.b) ))
(let u = (((\x: Unit .\y: Nat .y) (if (let u = (unfold [ Bool ] (fold [ Unit ] false )) in u) then (let u = true in u) else (let u = false in true)) ) ({a = (succ (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 1 }.b) ) false)) , b = (let u = true in 1) }.b)) in (( \f: Unit .((f (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) ) (fix (\x: Bool . (iszero 1) )) ) ) (\a: Rec X. X .\b: Unit .a)))
(( \f: Unit .((f ({a = (fix (\x: Nat . ({a = false , b = true }.b) )) , b = (let u = (let u = (let u = 0 in 0) in (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a))) in (let u = (pred 1) in (unfold [ Bool ] (fold [ Unit ] 0 )))) }.a) ) ({a = ({a = ({a = ({a = 0 , b = true }.b) , b = 0 }.a) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f (fix (\x: Unit . 0 )) ) 1 ) ) (\a: Bool .\b: Nat .b)) )) }.a) , b = ({a = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) true ) false) )) , c =  (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b) , b = (((\x: Bool .\y: Unit .y) (fix (\x: Rec X. X . ({a = 0 , b = false , c =  1 }.b) )) ) ({a = false , b = true }.b)) }.b) }.b) ) ) (\a: Rec X. X .\b: Unit .b))
(let u = (let u = (succ ({a = (if true then 0 else 1) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.b)) in (let u = (( \f: Rec X. X .((f (let u = 1 in u) ) 0 ) ) (\a: Unit .\b: Unit .a)) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )))) in (fix (\x: Rec X. X . ({a = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) , b = (((\x: Bool .\y: Unit .y) false ) 1) }.a) )))
({a = ({a = (( \f: Rec X. X .((f (succ 1) ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (fix (\x: Unit . (fix (\x: Nat . false )) )) }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = true }.b) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.b) )) }.b)
(((\x: Rec X. X .\y: Nat .y) (fix (\x: Rec X. X . (let u = (((\x: Nat .\y: Nat .x) true ) (let u = true in u)) in ({a = true , b = false }.b)) )) ) (((\x: Nat .\y: Nat .y) (fix (\x: Nat . ({a = 1 , b = true }.b) )) ) (let u = (case <l = ({a = 1 , b = true , c = 0 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = (fix (\x: Rec X. X . false )) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.a))))
(case <r = (( \f: Unit .((f (unfold [ Nat ] (fold [ Nat ] (if true then true else false) )) ) ({a = (succ 1) , b = (let u = 0 in true) , c =  ({a = ({a = true , b = 0 }.a) , b = 0 }.b) }.b) ) ) (\a: Unit .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (succ (if (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .a)) then (let u = ({a = false , b = 0 }.a) in (let u = false in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) else (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)))) ) (( \f: Rec X. X .((f (let u = ({a = 0 , b = true }.a) in u) ) (((\x: Unit .\y: Rec X. X .x) (fix (\x: Bool . (if true then 1 else 0) )) ) ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = false }.b)) ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Rec X. X .a))
(( \f: Unit .((f ({a = ({a = (((\x: Bool .\y: Nat .x) 1 ) false) , b = (if false then true else false) }.a) , b = (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .x) false ) true) )) , c =  (let u = (let u = false in u) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) }.b) ) (( \f: Bool .((f (( \f: Bool .((f (iszero 1) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Unit .a)) ) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Nat .b))
(case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (( \f: Nat .((f 0 ) (unfold [ Unit ] (fold [ Nat ] 1 )) ) ) (\a: Nat .\b: Bool .b)) , b = (( \f: Unit .((f ({a = true , b = 0 }.b) ) (pred (unfold [ Bool ] (fold [ Bool ] 1 ))) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
(iszero (( \f: Unit .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Nat .\y: Unit .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .b)))
(unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) true ) true) ) true ) ) (\a: Nat .\b: Nat .a)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b)) in 0) ))) ))
({a = (case <l = (( \f: Bool .((f ({a = (succ (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (let u = true in u) }.a) ) (case <l = (unfold [ Bool ] (fold [ Nat ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (let u = (((\x: Unit .\y: Rec X. X .x) ({a = 1 , b = 0 }.b) ) true) in u) , b = ({a = (let u = true in u) , b = false }.b) }.b) , c = (let u = (((\x: Bool .\y: Nat .x) (pred 1) ) (((\x: Unit .\y: Rec X. X .x) true ) false)) in u) }.c)
({a = (pred ({a = (let u = 1 in false) , b = ({a = 0 , b = true , c = 1 }.c) }.b)) , b = (let u = ({a = (( \f: Nat .((f (( \f: Rec X. X .((f (if false then false else false) ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Nat .b)) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (((\x: Nat .\y: Rec X. X .y) true ) (iszero 0)) )) }.b) in u) , c = (((\x: Rec X. X .\y: Bool .y) ({a = ({a = (((\x: Nat .\y: Rec X. X .x) false ) true) , b = 0 }.b) , b = ({a = 0 , b = true }.b) , c =  (( \f: Nat .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) ) (let u = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) in ({a = (if false then 0 else 1) , b = true , c = (fix (\x: Unit . 1 )) }.c))) }.c)
(if (((\x: Nat .\y: Bool .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (iszero 0) )) ) (let u = (let u = false in false) in u)) then (( \f: Unit .((f (pred ({a = 1 , b = 1 }.b)) ) (pred (pred 0)) ) ) (\a: Bool .\b: Bool .a)) else ({a = ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .a)) , b = ({a = true , b = true }.b) }.b) , b = (if ({a = 1 , b = true }.b) then ({a = 0 , b = true }.a) else 1) }.b))
(iszero (((\x: Unit .\y: Unit .x) (case <l = (unfold [ Unit ] (fold [ Unit ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .y) (let u = ({a = 1 , b = true }.a) in true) ) (let u = 0 in true))))
(succ (let u = (( \f: Nat .((f (((\x: Bool .\y: Bool .y) (let u = 1 in false) ) (if false then (pred 0) else ({a = 0 , b = 0 }.b))) ) (( \f: Nat .((f (fix (\x: Bool . 0 )) ) (pred 0) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) in u))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (succ (( \f: Bool .((f 0 ) (fix (\x: Unit . 0 )) ) ) (\a: Nat .\b: Unit .b))) in (succ (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)))) ))
({a = (((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ))) , b = (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = (fix (\x: Rec X. X . false )) , b = (((\x: Nat .\y: Bool .y) true ) 1) }.a) )) > as Nat of < l = x > => x | < r = y > => y) }.b)
(((\x: Rec X. X .\y: Bool .x) (let u = ({a = (((\x: Rec X. X .\y: Bool .y) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) false) , b = (if false then 1 else 1) }.a) in u) ) (unfold [ Bool ] (fold [ Rec X. X ] ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a)) }.b) )))
(case <l = (((\x: Unit .\y: Unit .x) (fix (\x: Unit . ({a = ({a = true , b = 1 }.a) , b = (if false then 1 else 1) }.b) )) ) (((\x: Bool .\y: Bool .y) true ) (if false then false else false))) > as Nat of < l = x > => x | < r = y > => y)
(pred (((\x: Unit .\y: Bool .x) ({a = (pred 1) , b = (((\x: Rec X. X .\y: Unit .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = 0 in u)) }.b) ) (iszero (unfold [ Bool ] (fold [ Nat ] (pred 0) )))))
(succ ({a = (( \f: Nat .((f (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) ) ({a = 0 , b = (((\x: Bool .\y: Unit .y) false ) false) , c = (fix (\x: Rec X. X . 1 )) }.c) ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Nat .\y: Rec X. X .x) true ) true) }.a))
(((\x: Bool .\y: Nat .y) (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (iszero 1) )) then (if (fix (\x: Bool . true )) then (((\x: Unit .\y: Nat .x) ({a = false , b = false }.b) ) (let u = true in u)) else (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b))) else (let u = (let u = 1 in 0) in (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)))) ) ({a = (iszero ({a = 0 , b = true }.a)) , b = (fix (\x: Nat . (fix (\x: Unit . false )) )) }.b))
(let u = ({a = (( \f: Unit .((f (((\x: Nat .\y: Bool .y) ({a = 1 , b = true }.b) ) false) ) (let u = (let u = (((\x: Bool .\y: Nat .y) false ) true) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) in u) ) ) (\a: Unit .\b: Bool .b)) , b = ({a = ({a = 0 , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) }.b) , b = (((\x: Unit .\y: Unit .y) false ) 0) }.a) }.b) in ({a = (let u = (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) > as Unit of < l = x > => x | < r = y > => y) in ({a = 1 , b = false , c = 1 }.c)) , b = (unfold [ Bool ] (fold [ Nat ] true )) , c =  ({a = 1 , b = (let u = true in 1) }.b) }.b))
(if (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Rec X. X .y) true ) true) )) ) (let u = (fix (\x: Unit . (let u = 0 in u) )) in (let u = false in u)) ) ) (\a: Bool .\b: Bool .b)) then (( \f: Bool .((f ({a = 1 , b = (((\x: Unit .\y: Nat .x) true ) true) }.a) ) (fix (\x: Bool . 1 )) ) ) (\a: Rec X. X .\b: Nat .a)) else (((\x: Bool .\y: Rec X. X .y) (let u = (( \f: Bool .((f ({a = 0 , b = false }.b) ) false ) ) (\a: Rec X. X .\b: Bool .b)) in (((\x: Rec X. X .\y: Rec X. X .y) false ) false)) ) (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in 0) ))))
({a = (let u = ({a = (((\x: Bool .\y: Bool .y) true ) false) , b = ({a = (let u = false in u) , b = (pred 1) }.b) }.a) in (let u = (let u = (if true then false else true) in u) in u)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (pred ({a = (let u = 1 in 0) , b = (let u = 1 in false) }.a)) )) }.a)
(( \f: Bool .((f (fix (\x: Bool . ({a = ({a = 1 , b = false }.b) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) true ) false) ) false ) ) (\a: Nat .\b: Rec X. X .b)) }.b) )) ) (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (iszero 1) , b = 1 }.b) ))) ) ) (\a: Nat .\b: Unit .b))
(let u = ({a = (((\x: Unit .\y: Nat .y) (if ({a = false , b = 1 }.a) then true else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) ) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Bool .\b: Nat .b))) , b = (let u = (((\x: Unit .\y: Bool .y) true ) 0) in u) }.b) in (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ) (((\x: Unit .\y: Bool .x) (fix (\x: Rec X. X . true )) ) (((\x: Unit .\y: Bool .y) ({a = 0 , b = true , c =  1 }.b) ) false))) )))
({a = (((\x: Nat .\y: Unit .y) ({a = (((\x: Unit .\y: Rec X. X .x) ({a = false , b = false }.b) ) true) , b = (((\x: Unit .\y: Unit .x) (fix (\x: Nat . false )) ) (iszero 0)) }.b) ) ({a = (((\x: Unit .\y: Nat .x) 0 ) false) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true )) }.b)) , b = (let u = ({a = ({a = (let u = true in u) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) }.b) , b = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) , b = (let u = ({a = 1 , b = false }.b) in u) }.b) }.b) in (let u = ({a = true , b = 1 }.a) in u)) }.b)
(if (( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = false }.b) )) ) (let u = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] false )) , b = 1 }.a) in ({a = (let u = true in u) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) then (pred (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) else ({a = (fix (\x: Nat . (let u = (iszero 0) in (((\x: Bool .\y: Nat .y) true ) 0)) )) , b = (case <r = ({a = true , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) , c = (let u = (pred ({a = 0 , b = false }.a)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ))) }.c))
(let u = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , b = ({a = 1 , b = false , c =  (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) }.b) }.b) in ({a = (let u = (((\x: Nat .\y: Rec X. X .x) true ) false) in (((\x: Bool .\y: Unit .x) 0 ) false)) , b = (let u = (succ 1) in (fix (\x: Nat . false ))) }.b))
(((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Unit .x) (if ({a = ({a = 0 , b = (((\x: Nat .\y: Bool .y) false ) false) , c =  1 }.b) , b = ({a = 1 , b = 1 }.b) }.a) then (((\x: Rec X. X .\y: Bool .y) (case <r = ({a = false , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (if true then (iszero 0) else false)) else (let u = false in u)) ) (unfold [ Nat ] (fold [ Bool ] (case <r = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) ))) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .x) true ) true) )) ) ({a = ({a = 1 , b = 1 }.b) , b = ({a = 1 , b = false , c =  1 }.b) , c =  (((\x: Bool .\y: Bool .x) 1 ) (unfold [ Bool ] (fold [ Unit ] false ))) }.b)) ) (unfold [ Unit ] (fold [ Unit ] (let u = (let u = true in 1) in (let u = true in false)) )) ) ) (\a: Unit .\b: Nat .a)))
(case <r = ({a = ({a = 1 , b = false }.b) , b = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) in u) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (fix (\x: Rec X. X . (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f ({a = false , b = 1 }.a) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a)) )) )) )) , b = ({a = (succ ({a = 0 , b = false }.a)) , b = ({a = (let u = (unfold [ Nat ] (fold [ Bool ] 1 )) in u) , b = (let u = 0 in true) , c =  ({a = (pred 1) , b = ({a = false , b = 0 }.b) }.b) }.b) }.b) }.b)
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = (( \f: Nat .((f (let u = true in ({a = 0 , b = false }.b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Rec X. X .a)) in u) )) in u)
({a = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) (pred ({a = ({a = 0 , b = 1 }.b) , b = true }.a)) ) (let u = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .a)) in u)) ) ({a = (((\x: Bool .\y: Nat .x) ({a = 0 , b = true , c = 1 }.c) ) (let u = true in u)) , b = (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Rec X. X .y) false ) false) ) false) , c = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) , b = ({a = false , b = 1 }.a) , c = (pred 0) }.c) }.c) ) ) (\a: Nat .\b: Nat .b)) , b = (succ (((\x: Rec X. X .\y: Unit .x) 1 ) true)) }.b)
(case <l = (succ (((\x: Bool .\y: Unit .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) ({a = 1 , b = false , c =  0 }.b))) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = true , b = 1 }.b) )) , b = (let u = (let u = true in 0) in true) }.b) ))
({a = (case <r = (( \f: Unit .((f true ) ({a = false , b = true }.b) ) ) (\a: Nat .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = ({a = ({a = 1 , b = true , c = 1 }.c) , b = (fix (\x: Unit . 1 )) }.b) , b = ({a = ({a = ({a = 1 , b = true }.a) , b = false }.b) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) , c = (((\x: Nat .\y: Nat .x) (pred 1) ) (let u = ({a = false , b = true }.b) in u)) }.c) }.a)
(let u = (fix (\x: Bool . (fix (\x: Nat . ({a = 1 , b = true , c = 0 }.c) )) )) in (let u = (let u = (((\x: Nat .\y: Unit .y) true ) ({a = true , b = true }.b)) in (( \f: Nat .((f true ) (iszero 0) ) ) (\a: Bool .\b: Rec X. X .a))) in (( \f: Rec X. X .((f (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . (let u = 1 in true) )) ) ) (\a: Bool .\b: Unit .b))))
(if (unfold [ Nat ] (fold [ Nat ] ({a = ({a = 1 , b = true }.a) , b = ({a = 1 , b = true , c =  1 }.b) }.b) )) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f true ) (iszero 1) ) ) (\a: Nat .\b: Rec X. X .b)) )) else (let u = (( \f: Bool .((f (succ 1) ) ({a = 1 , b = 1 }.b) ) ) (\a: Nat .\b: Unit .a)) in ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = true }.b) }.b)))
(unfold [ Unit ] (fold [ Nat ] (pred ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ))) ))
(pred (((\x: Nat .\y: Rec X. X .y) (( \f: Nat .((f (let u = true in false) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Unit .\b: Bool .a)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = true , c = (if false then 0 else 0) }.c) ))))
({a = (fix (\x: Nat . (let u = (((\x: Bool .\y: Nat .y) false ) true) in ({a = 0 , b = 0 }.b)) )) , b = ({a = (succ ({a = true , b = (if false then 0 else 0) }.b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (if ({a = 0 , b = (((\x: Unit .\y: Bool .y) false ) false) , c =  1 }.b) then ({a = true , b = true }.b) else (let u = true in true)) )) , c =  (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) 1 ) false) )) }.b) }.b)
(fix (\x: Unit . ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = false in false) )) }.b) ))
(pred (((\x: Rec X. X .\y: Rec X. X .y) (iszero (pred (pred (let u = false in 0)))) ) ({a = (let u = false in (pred 0)) , b = (unfold [ Nat ] (fold [ Nat ] (let u = false in false) )) , c = ({a = (fix (\x: Nat . 0 )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) , c = (let u = ({a = false , b = true }.b) in 0) }.c) }.c)))
(case <l = (( \f: Bool .((f (unfold [ Unit ] (fold [ Bool ] ({a = true , b = 1 }.b) )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Unit . 1 )) )) ) ) (\a: Rec X. X .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Unit .a)) ) ({a = true , b = false }.b)) , c =  (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b) , b = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = ({a = true , b = 0 }.b) , b = true }.a) }.b) }.b) , b = (( \f: Unit .((f (case <r = (((\x: Bool .\y: Rec X. X .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Rec X. X .x) (iszero 1) ) (fix (\x: Nat . false ))) ) ) (\a: Rec X. X .\b: Bool .b)) }.b)
(((\x: Rec X. X .\y: Bool .x) (succ (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )))) ) (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Rec X. X . (((\x: Bool .\y: Bool .y) true ) false) )) )))
(fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .y) (case <r = (( \f: Nat .((f ({a = 1 , b = false , c =  0 }.b) ) true ) ) (\a: Bool .\b: Rec X. X .a)) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (let u = (let u = 1 in true) in u) , b = (succ 0) }.b)) ))
(( \f: Unit .((f ({a = (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Bool .y) true ) true) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b))) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) )) }.a) ) (((\x: Bool .\y: Unit .x) (case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero 0) )) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) ))) ) ) (\a: Bool .\b: Unit .b))
(( \f: Bool .((f (if (let u = (((\x: Unit .\y: Rec X. X .x) true ) true) in ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false ))) then ({a = (((\x: Unit .\y: Unit .y) (let u = false in true) ) false) , b = ({a = 0 , b = 1 }.b) }.a) else (if ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) then (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a)) else ({a = 1 , b = false , c =  0 }.b))) ) (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Nat .y) (if false then false else false) ) ({a = (let u = 0 in false) , b = ({a = false , b = true }.b) }.b)) ) (if ({a = 0 , b = true }.b) then (let u = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) in u) else (fix (\x: Nat . false )))) ) ) (\a: Bool .\b: Rec X. X .a))
(unfold [ Nat ] (fold [ Bool ] (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (if true then false else true) )) in (iszero (((\x: Nat .\y: Nat .x) 0 ) true))) ))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f false ) (fix (\x: Rec X. X . true )) ) ) (\a: Rec X. X .\b: Nat .b)) )) ))
(iszero (( \f: Bool .((f (((\x: Bool .\y: Unit .y) true ) (((\x: Nat .\y: Bool .y) false ) 0)) ) ({a = 1 , b = true }.a) ) ) (\a: Nat .\b: Bool .a)))
(((\x: Unit .\y: Unit .y) (case <r = (( \f: Rec X. X .((f true ) ({a = true , b = 1 }.a) ) ) (\a: Rec X. X .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (fix (\x: Nat . ({a = 1 , b = false }.b) )) in (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = true }.b) ))))
({a = (fix (\x: Rec X. X . ({a = 1 , b = true }.a) )) , b = (((\x: Bool .\y: Rec X. X .x) (succ ({a = true , b = 0 }.b)) ) ({a = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) true) ) ({a = false , b = 0 }.b)) , b = ({a = (((\x: Nat .\y: Bool .y) false ) false) , b = (if (let u = false in true) then true else false) }.b) }.b)) }.b)
(( \f: Nat .((f (case <r = (if (if false then false else true) then ({a = 1 , b = true }.b) else (unfold [ Rec X. X ] (fold [ Bool ] false ))) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (case <r = (( \f: Nat .((f false ) (let u = false in true) ) ) (\a: Nat .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) ) (if true then ({a = 0 , b = true , c =  0 }.b) else true) ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .b))
(( \f: Unit .((f (fix (\x: Unit . (iszero (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) )) ) ({a = (( \f: Unit .((f ({a = (unfold [ Bool ] (fold [ Bool ] true )) , b = 0 }.a) ) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Nat .((f (fix (\x: Nat . (pred 1) )) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) ) ) (\a: Nat .\b: Bool .a))
(if (( \f: Nat .((f (( \f: Nat .((f ({a = 1 , b = true }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) ) ({a = 0 , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) }.b) ) ) (\a: Nat .\b: Rec X. X .a)) then (( \f: Bool .((f (((\x: Bool .\y: Nat .x) 0 ) true) ) (((\x: Unit .\y: Rec X. X .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (iszero 1) )) ) ({a = 1 , b = 1 }.b)) ) ) (\a: Nat .\b: Bool .b)) else (((\x: Rec X. X .\y: Nat .y) (let u = (((\x: Unit .\y: Bool .y) false ) false) in u) ) (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) in u)))
(fix (\x: Nat . (iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (((\x: Bool .\y: Bool .x) (pred 0) ) (fix (\x: Bool . true ))) in (if false then (((\x: Nat .\y: Rec X. X .y) false ) 1) else 1)) ))) ))
(( \f: Unit .((f (let u = (let u = false in 0) in (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .x) 0 ) true) ) ({a = 1 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .y) ({a = 1 , b = false , c =  1 }.b) ) (( \f: Unit .((f 0 ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) ) (\a: Unit .\b: Nat .a))) )) ) ) (\a: Nat .\b: Bool .a))
(( \f: Nat .((f (let u = (let u = true in u) in (((\x: Unit .\y: Nat .y) false ) false)) ) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = (if ({a = true , b = true }.b) then (((\x: Nat .\y: Bool .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = 0 in true)) else ({a = (fix (\x: Unit . false )) , b = false }.b)) }.b) ) ) (\a: Rec X. X .\b: Nat .a))
(let u = (((\x: Nat .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Nat ] ({a = (((\x: Nat .\y: Rec X. X .y) false ) false) , b = (unfold [ Unit ] (fold [ Unit ] false )) }.b) )) ) (iszero (if (case <r = (iszero 1) > as Nat of < l = x > => x | < r = y > => y) then (let u = (unfold [ Rec X. X ] (fold [ Unit ] true )) in 0) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))))) in ({a = ({a = (case <l = ({a = 1 , b = true }.a) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) }.a) , b = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) true ) false) )) }.a))
({a = (unfold [ Bool ] (fold [ Bool ] ({a = true , b = false }.b) )) , b = ({a = (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) in (unfold [ Nat ] (fold [ Nat ] false ))) , b = (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) ({a = 1 , b = false , c =  0 }.b) ) ({a = 0 , b = (fix (\x: Bool . false )) , c = 1 }.c)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Bool .y) false ) 1) )) ) ) (\a: Nat .\b: Bool .a)) }.a) }.b)
(let u = (let u = (( \f: Unit .((f (if false then true else true) ) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) ) (\a: Bool .\b: Nat .b)) in (if (((\x: Nat .\y: Unit .y) (if false then false else false) ) (if false then true else true)) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )))) in (case <r = (let u = (fix (\x: Bool . false )) in u) > as Bool of < l = x > => x | < r = y > => y))
(let u = (case <r = (((\x: Bool .\y: Bool .y) ({a = (let u = 1 in false) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) }.a) ) (let u = false in u)) > as Bool of < l = x > => x | < r = y > => y) in ({a = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . true )) }.b) , b = ({a = 0 , b = false , c = (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.c) }.a))
({a = (let u = (((\x: Rec X. X .\y: Bool .x) (((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) ) ({a = 1 , b = true , c =  0 }.b)) ) (let u = 0 in true)) in (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y)) , b = (((\x: Bool .\y: Rec X. X .x) ({a = (let u = 0 in u) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , c = (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = true , c = 0 }.c) )) }.c) ) (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Nat ] false )) ))) }.b)
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = (iszero 0) in u) )) , b = ({a = (succ ({a = 1 , b = false , c = 1 }.c)) , b = (fix (\x: Unit . (iszero (succ 0)) )) , c =  (pred (let u = 1 in u)) }.b) }.b)
(( \f: Rec X. X .((f (iszero (let u = 1 in u)) ) (if ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = (iszero 1) }.b) )) then (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = false in u) )) )) else (case <r = (fix (\x: Bool . (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Unit .a))
({a = (if (((\x: Nat .\y: Bool .x) (if true then true else true) ) (let u = 1 in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] false )))) then (( \f: Nat .((f (iszero 1) ) (if false then ({a = true , b = 0 }.a) else true) ) ) (\a: Rec X. X .\b: Bool .a)) else ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) , b = (if true then 0 else 0) }.a)) , b = (( \f: Unit .((f ({a = (let u = 1 in (pred 0)) , b = (( \f: Bool .((f true ) (if false then true else false) ) ) (\a: Nat .\b: Rec X. X .a)) , c = ({a = (let u = ({a = true , b = false }.b) in (succ 1)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.b) }.c) ) (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .a)) }.a)
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = 1 }.b) )) , b = ({a = ({a = (( \f: Nat .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = (if false then 0 else 0) }.b) , b = (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (( \f: Unit .((f (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) (( \f: Unit .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .b))) , c =  (fix (\x: Bool . ({a = (unfold [ Unit ] (fold [ Nat ] (succ 1) )) , b = ({a = 1 , b = false }.b) }.a) )) }.b) }.a)
(( \f: Rec X. X .((f ({a = (((\x: Rec X. X .\y: Bool .y) (let u = true in ({a = false , b = true }.b)) ) (fix (\x: Bool . 1 ))) , b = (case <r = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) , c = ({a = ({a = false , b = ({a = 1 , b = false , c = 1 }.c) }.a) , b = ({a = 0 , b = true , c = 0 }.c) }.b) }.c) ) (( \f: Bool .((f (succ ({a = (let u = false in 0) , b = false }.a)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) in u) )) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .a))
(pred (let u = ({a = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) , b = ({a = 0 , b = 0 }.b) }.b) in (( \f: Rec X. X .((f ({a = (let u = true in 1) , b = (if false then false else false) , c = (succ 0) }.c) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = 0 , b = false }.a) )) ) ) (\a: Unit .\b: Bool .b))))
(pred ({a = (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a))) , b = ({a = (unfold [ Bool ] (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) )) , b = ({a = true , b = (if false then 1 else 0) }.a) , c = (let u = (succ 1) in 1) }.c) }.b))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (if (( \f: Nat .((f ({a = 0 , b = false , c =  1 }.b) ) false ) ) (\a: Nat .\b: Nat .a)) then (((\x: Unit .\y: Unit .x) ({a = 0 , b = false , c = 1 }.c) ) (let u = 1 in false)) else (if (iszero 1) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) else 0)) ))
({a = (((\x: Unit .\y: Unit .x) (iszero (if true then 0 else (let u = false in 1))) ) (iszero ({a = (((\x: Rec X. X .\y: Bool .x) 1 ) false) , b = (succ 1) }.b))) , b = (let u = (unfold [ Unit ] (fold [ Unit ] (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = false in 0) )) in u) )) in (let u = (let u = false in u) in (succ ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 ))))) }.b)
(let u = ({a = (( \f: Unit .((f (((\x: Nat .\y: Nat .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) ) ({a = true , b = true }.b)) ) (((\x: Nat .\y: Nat .x) true ) (if false then false else false)) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = (if false then (let u = false in u) else (let u = false in true)) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) , b = 1 }.b) }.a) }.b) in u)
(let u = ({a = (let u = (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Bool .y) true ) false) ) ({a = true , b = 0 }.a)) in u) , b = (let u = (succ 0) in ({a = 0 , b = ({a = 0 , b = true , c =  1 }.b) , c =  1 }.b)) }.b) in (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in u))
(((\x: Nat .\y: Bool .y) (let u = ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , b = (succ 0) }.a) in u) ) ({a = (if (((\x: Nat .\y: Bool .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (let u = false in u)) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) else (let u = 1 in u)) , b = (if false then false else true) }.a))
(( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Nat .y) (unfold [ Bool ] (fold [ Unit ] ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) )) ) (((\x: Nat .\y: Rec X. X .y) true ) 1)) )) ) (let u = (((\x: Rec X. X .\y: Unit .x) (succ 0) ) true) in ({a = (let u = 0 in u) , b = (let u = 1 in u) }.b)) ) ) (\a: Nat .\b: Rec X. X .b))
(unfold [ Bool ] (fold [ Nat ] (succ ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) , b = false }.a)) ))
(if ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] false )) )) then (( \f: Rec X. X .((f ({a = ({a = true , b = 0 }.b) , b = (iszero 1) }.a) ) ({a = ({a = (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b)) , c = (let u = 0 in 1) }.c) , b = (((\x: Nat .\y: Nat .y) (let u = 1 in true) ) ({a = true , b = false }.b)) , c = ({a = 0 , b = ({a = 1 , b = true , c = 0 }.c) }.b) }.c) ) ) (\a: Rec X. X .\b: Bool .b)) else (((\x: Rec X. X .\y: Nat .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (succ 0) )) ) (((\x: Nat .\y: Unit .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = true , b = true }.b))))
({a = (( \f: Rec X. X .((f (let u = (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) in u) ) (case <l = (((\x: Rec X. X .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) ({a = 0 , b = false }.b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) , b = (( \f: Rec X. X .((f (fix (\x: Nat . 0 )) ) ({a = 0 , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Unit .b)) }.a) ) ) (\a: Unit .\b: Bool .a)) }.b)
({a = ({a = (pred (( \f: Rec X. X .((f 0 ) (((\x: Bool .\y: Nat .x) 1 ) false) ) ) (\a: Bool .\b: Nat .a))) , b = (pred (( \f: Bool .((f 0 ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Nat .b))) }.b) , b = (( \f: Bool .((f ({a = false , b = 0 }.a) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a)
(unfold [ Unit ] (fold [ Bool ] (fix (\x: Rec X. X . ({a = (( \f: Unit .((f (fix (\x: Rec X. X . true )) ) (unfold [ Nat ] (fold [ Unit ] true )) ) ) (\a: Bool .\b: Unit .a)) , b = (unfold [ Nat ] (fold [ Rec X. X ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.a) )) ))
(case <r = (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) true ) 1) ) 0 ) ) (\a: Bool .\b: Bool .b)) ))) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Rec X. X .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (succ ({a = (((\x: Nat .\y: Rec X. X .y) true ) false) , b = ({a = 1 , b = 0 }.b) }.b)) )) ) ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.a))
(if (iszero (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Bool .x) ({a = 0 , b = 0 }.b) ) (((\x: Bool .\y: Nat .y) false ) true)) ) (iszero 0))) then ({a = (((\x: Nat .\y: Unit .x) ({a = 1 , b = true }.b) ) ({a = false , b = 0 }.a)) , b = (let u = true in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) }.a) else (let u = ({a = (( \f: Nat .((f (if false then 0 else 1) ) (((\x: Nat .\y: Bool .y) false ) 0) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = true , b = 0 }.a) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) }.b) in u))
(unfold [ Nat ] (fold [ Bool ] (if ({a = (let u = 1 in u) , b = (let u = 1 in false) }.b) then (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) else (let u = true in u)) ))
(unfold [ Unit ] (fold [ Bool ] (succ (fix (\x: Nat . (( \f: Nat .((f 0 ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .a)) ))) ))
(( \f: Nat .((f (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .b)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) in ({a = (((\x: Rec X. X .\y: Bool .y) ({a = false , b = 1 }.a) ) false) , b = ({a = false , b = 1 }.b) }.a)) ) (( \f: Rec X. X .((f (( \f: Unit .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (let u = false in true) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = (( \f: Nat .((f (let u = false in u) ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .a)) , b = (((\x: Unit .\y: Unit .x) false ) true) }.b) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Bool .a))
(( \f: Nat .((f (iszero (case <l = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = ({a = ({a = 1 , b = 0 }.b) , b = (if true then 0 else 0) }.b) , b = (if (((\x: Unit .\y: Rec X. X .y) false ) (if false then true else false)) then (fix (\x: Nat . true )) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) }.b) )) ) ) (\a: Bool .\b: Rec X. X .b))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = false , b = 0 }.a) , b = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) ) (if false then true else true)) }.b) ))
(case <l = (((\x: Nat .\y: Unit .y) ({a = (if false then 0 else 1) , b = true }.b) ) (let u = false in (unfold [ Rec X. X ] (fold [ Nat ] 0 )))) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (if (((\x: Rec X. X .\y: Rec X. X .y) true ) false) then false else false) , c =  (succ 0) }.b) )) , b = (((\x: Bool .\y: Bool .y) (( \f: Unit .((f (let u = false in (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .b))) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .a)) ) (fix (\x: Bool . (fix (\x: Nat . (let u = true in false) )) ))) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f (fix (\x: Unit . ({a = 1 , b = 1 }.b) )) ) ({a = ({a = 1 , b = true }.a) , b = (let u = false in u) }.a) ) ) (\a: Nat .\b: Rec X. X .b)) ))
({a = (let u = (let u = (case <r = (fix (\x: Rec X. X . true )) > as Bool of < l = x > => x | < r = y > => y) in (let u = false in 1)) in u) , b = ({a = (let u = ({a = 1 , b = false , c = 0 }.c) in u) , b = (((\x: Unit .\y: Unit .x) ({a = (((\x: Unit .\y: Bool .y) true ) true) , b = 1 }.a) ) ({a = 0 , b = false , c =  (let u = false in 0) }.b)) }.b) , c =  (( \f: Unit .((f (let u = (fix (\x: Rec X. X . (succ 1) )) in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) )) ) ) (\a: Unit .\b: Bool .a)) }.b)
(( \f: Bool .((f ({a = (if false then true else (let u = true in u)) , b = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) in (( \f: Bool .((f (let u = 1 in true) ) false ) ) (\a: Bool .\b: Bool .a))) }.b) ) (((\x: Rec X. X .\y: Bool .x) ({a = (if true then 0 else 1) , b = true }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Unit ] false )) ))) ) ) (\a: Nat .\b: Rec X. X .b))
({a = ({a = ({a = ({a = (succ 0) , b = true , c = (let u = 0 in u) }.c) , b = (if false then 0 else (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b))) }.b) , b = (( \f: Bool .((f ({a = false , b = true }.b) ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) , b = (let u = ({a = (let u = 0 in true) , b = ({a = 0 , b = false , c = 0 }.c) }.b) in (( \f: Rec X. X .((f (fix (\x: Unit . 1 )) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a))) }.a)
(if (if (case <r = (((\x: Bool .\y: Rec X. X .y) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = (iszero 0) , b = (((\x: Unit .\y: Nat .y) true ) false) }.b) else ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = false }.b)) then (if ({a = ({a = 1 , b = false , c =  1 }.b) , b = false }.b) then (let u = true in false) else (case <r = ({a = false , b = true }.b) > as Bool of < l = x > => x | < r = y > => y)) else (case <r = ({a = (((\x: Bool .\y: Unit .x) 0 ) false) , b = (fix (\x: Nat . false )) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
(let u = (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in u) in u)
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = (fix (\x: Unit . ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) )) , b = (iszero 1) }.b) in ({a = ({a = ({a = 1 , b = 0 }.b) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b) , b = (((\x: Unit .\y: Nat .x) true ) false) , c =  (( \f: Nat .((f ({a = true , b = 0 }.b) ) ({a = 0 , b = false }.a) ) ) (\a: Rec X. X .\b: Nat .b)) }.b)) ))
(succ ({a = (((\x: Unit .\y: Rec X. X .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (let u = 0 in false)) , b = (let u = (unfold [ Bool ] (fold [ Unit ] 0 )) in (fix (\x: Rec X. X . ({a = false , b = true }.b) ))) }.a))
(case <r = (let u = (unfold [ Unit ] (fold [ Unit ] (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .a)) )) in u) > as Nat of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (succ 0) , b = (fix (\x: Nat . (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) }.a) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = (if ({a = 1 , b = true }.b) then ({a = 0 , b = false , c =  0 }.b) else false) in u) , b = (if ({a = (if true then true else false) , b = (let u = ({a = false , b = false }.b) in (unfold [ Bool ] (fold [ Unit ] 1 ))) }.a) then (( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] 0 )) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Unit .\b: Rec X. X .a)) else ({a = 0 , b = ({a = false , b = 0 }.a) , c = 0 }.c)) }.a) ))
(let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = ({a = true , b = true }.b) , b = 1 }.b) ) (iszero (succ 0))) in (((\x: Unit .\y: Rec X. X .y) (((\x: Unit .\y: Nat .y) true ) true) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) (((\x: Rec X. X .\y: Unit .x) false ) true) ) true) ))))
(iszero (if (fix (\x: Nat . (if (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Nat ] false ))) then ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = ({a = 0 , b = false }.a) }.a) else ({a = true , b = 0 }.a)) )) then (succ ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] 1 )) ))) else (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Unit .x) (succ 1) ) (let u = 0 in true)) ))))
({a = (unfold [ Nat ] (fold [ Unit ] (fix (\x: Bool . (iszero 1) )) )) , b = (((\x: Rec X. X .\y: Bool .y) (let u = (iszero (let u = false in 1)) in ({a = (let u = 0 in false) , b = ({a = 1 , b = false }.b) }.b)) ) (case <l = (let u = false in 0) > as Nat of < l = x > => x | < r = y > => y)) }.b)
(if (let u = (iszero (((\x: Unit .\y: Rec X. X .x) 1 ) false)) in u) then (( \f: Bool .((f ({a = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Bool . true )) ) (let u = false in u)) , b = (unfold [ Nat ] (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) )) }.a) ) (iszero ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) ))) ) ) (\a: Bool .\b: Bool .b)) else ({a = (let u = (((\x: Nat .\y: Bool .y) ({a = 1 , b = false , c =  1 }.b) ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b))) in ({a = ({a = 0 , b = true , c = 1 }.c) , b = (((\x: Bool .\y: Bool .x) true ) true) }.b)) , b = ({a = (let u = false in 1) , b = (if true then (unfold [ Unit ] (fold [ Unit ] 1 )) else 1) }.b) }.a))
(( \f: Rec X. X .((f (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) (if (let u = 1 in true) then 1 else (let u = 0 in u)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false ))) ) (((\x: Nat .\y: Rec X. X .x) 1 ) true) ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Nat .((f (case <l = (let u = 1 in 1) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . ({a = false , b = 0 }.b) )) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a))
(let u = (let u = (pred (if ({a = true , b = true }.b) then ({a = false , b = 1 }.b) else ({a = 0 , b = 0 }.b))) in u) in (if ({a = (if true then true else false) , b = false }.b) then (pred ({a = 1 , b = false , c = 0 }.c)) else (let u = ({a = 0 , b = true }.b) in ({a = 1 , b = (let u = true in u) }.a))))
(unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) (let u = (let u = (let u = true in 1) in ({a = 0 , b = true , c = 0 }.c)) in (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b))) ) ({a = (( \f: Rec X. X .((f (( \f: Bool .((f (if false then 1 else 0) ) 1 ) ) (\a: Nat .\b: Nat .b)) ) (((\x: Unit .\y: Rec X. X .y) false ) 0) ) ) (\a: Nat .\b: Bool .a)) , b = (((\x: Rec X. X .\y: Unit .y) ({a = 0 , b = false }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero 1) ))) , c =  ({a = (((\x: Bool .\y: Unit .y) true ) true) , b = 0 }.b) }.b)) ))
(let u = (let u = (let u = (fix (\x: Unit . 1 )) in (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b))) in (unfold [ Bool ] (fold [ Rec X. X ] (case <r = (unfold [ Nat ] (fold [ Bool ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) ))) in ({a = (iszero (( \f: Nat .((f (pred 0) ) 1 ) ) (\a: Bool .\b: Rec X. X .b))) , b = ({a = ({a = ({a = (iszero 0) , b = (((\x: Unit .\y: Nat .y) false ) true) }.b) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.a) , b = (( \f: Bool .((f ({a = 0 , b = true }.b) ) (let u = false in u) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) }.b))
({a = ({a = (pred (( \f: Rec X. X .((f ({a = 0 , b = false }.a) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .b))) , b = (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) in (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 1 )) in (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)))) }.a) , b = (let u = ({a = (( \f: Nat .((f ({a = false , b = false }.b) ) true ) ) (\a: Bool .\b: Unit .a)) , b = (let u = (let u = 0 in 0) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a))) }.a) in (case <r = (iszero 1) > as Bool of < l = x > => x | < r = y > => y)) }.a)
(let u = (case <r = ({a = (let u = false in (let u = 0 in u)) , b = (let u = true in u) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) }.b) > as Nat of < l = x > => x | < r = y > => y) in ({a = (iszero ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = 0 }.b)) , b = (let u = (unfold [ Rec X. X ] (fold [ Unit ] (unfold [ Unit ] (fold [ Bool ] 1 )) )) in (((\x: Unit .\y: Nat .y) false ) 0)) }.b))
({a = (if ({a = true , b = ({a = 0 , b = false }.a) }.a) then ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = true }.a) else ({a = (fix (\x: Bool . true )) , b = (let u = (fix (\x: Rec X. X . 0 )) in 0) }.b)) , b = (unfold [ Unit ] (fold [ Bool ] (let u = (let u = 0 in true) in u) )) , c = (((\x: Rec X. X .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) 0 ) false) ) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , b = 1 }.a)) }.c)
(let u = ({a = (let u = (let u = 1 in u) in u) , b = (let u = ({a = 1 , b = false , c =  1 }.b) in u) , c =  (( \f: Nat .((f (((\x: Bool .\y: Nat .x) 1 ) true) ) (fix (\x: Nat . 0 )) ) ) (\a: Bool .\b: Unit .a)) }.b) in u)
(iszero (((\x: Unit .\y: Nat .y) (( \f: Rec X. X .((f (iszero 1) ) (if true then true else true) ) ) (\a: Rec X. X .\b: Nat .b)) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a))))
(( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (fix (\x: Bool . 1 )) , b = ({a = false , b = false }.b) }.b) )) ) ({a = (fix (\x: Nat . (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) )) , b = (iszero 0) }.b) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Rec X. X .\y: Nat .x) ({a = (( \f: Unit .((f ({a = ({a = 0 , b = false }.a) , b = false , c =  ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) }.b) ) (iszero 1) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Nat .\y: Unit .x) (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) in u) ) ({a = (((\x: Unit .\y: Bool .x) false ) true) , b = 0 }.a)) }.b) ) (unfold [ Nat ] (fold [ Nat ] ({a = ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = ({a = false , b = 1 }.a) , c =  (if false then 0 else 1) }.b) , b = (((\x: Bool .\y: Bool .x) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) false) }.b) )))
({a = ({a = (let u = (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) )) in u) , b = ({a = ({a = 0 , b = true }.a) , b = ({a = 1 , b = true }.b) , c =  (((\x: Rec X. X .\y: Unit .x) 1 ) (((\x: Bool .\y: Nat .x) false ) true)) }.b) , c = (pred (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a))) }.c) , b = ({a = ({a = (let u = false in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (if ({a = ({a = (let u = true in true) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.b) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) then ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = true , c = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) }.c) )) else ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 ))) }.a) , c = (((\x: Rec X. X .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = (let u = false in u) , b = (((\x: Bool .\y: Nat .y) false ) 1) }.a) )) ) (( \f: Bool .((f (succ (pred 0)) ) (let u = (let u = true in false) in 1) ) ) (\a: Bool .\b: Rec X. X .b))) }.c)
(fix (\x: Unit . (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = ({a = 0 , b = false , c = 1 }.c) , b = true , c = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) }.c) ))) ))
(((\x: Bool .\y: Rec X. X .x) ({a = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = ({a = true , b = 1 }.b) }.a) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) 1 ) false) ) (if ({a = false , b = false }.b) then (pred 0) else 1) ) ) (\a: Nat .\b: Bool .b)) }.a) ) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in true) )) in u))
(unfold [ Unit ] (fold [ Unit ] (let u = ({a = ({a = 0 , b = false , c = ({a = true , b = 1 }.b) }.c) , b = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) in u) }.b) in (unfold [ Bool ] (fold [ Nat ] (((\x: Nat .\y: Nat .y) (let u = false in u) ) (iszero 0)) ))) ))
(((\x: Bool .\y: Unit .x) (fix (\x: Bool . (((\x: Bool .\y: Unit .x) (let u = true in u) ) ({a = false , b = ({a = 0 , b = true , c =  1 }.b) }.b)) )) ) (let u = (let u = (let u = 1 in 0) in ({a = true , b = 0 }.b)) in (( \f: Nat .((f (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] true )) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .a))))
(let u = (if (( \f: Rec X. X .((f ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = true , c =  1 }.b) ) (let u = false in u) ) ) (\a: Unit .\b: Bool .a)) then (( \f: Unit .((f ({a = false , b = true }.b) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Nat .\b: Unit .a)) else ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if false then (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) else true) , c =  (fix (\x: Rec X. X . ({a = 0 , b = false , c = 1 }.c) )) }.b)) in ({a = (( \f: Bool .((f (let u = 0 in 1) ) (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (((\x: Rec X. X .\y: Nat .x) (if true then false else (fix (\x: Unit . true ))) ) (case <r = (let u = false in u) > as Bool of < l = x > => x | < r = y > => y)) }.b))
({a = (if (case <r = (fix (\x: Bool . true )) > as Nat of < l = x > => x | < r = y > => y) then ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = (let u = (pred 0) in u) }.b) else (if ({a = (let u = 0 in 1) , b = false , c =  ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b) then (succ 1) else (( \f: Unit .((f 0 ) ({a = 1 , b = true }.a) ) ) (\a: Nat .\b: Bool .a)))) , b = (if (unfold [ Bool ] (fold [ Nat ] (( \f: Bool .((f false ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) )) then (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) (if false then 0 else 1) ) ) (\a: Nat .\b: Bool .a)) else ({a = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in (let u = 0 in u)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = ({a = false , b = 0 }.a) }.b) )) }.a)) }.b)
(let u = (let u = (let u = ({a = 0 , b = false }.a) in u) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in u)
(case <r = (((\x: Unit .\y: Nat .y) ({a = (if (((\x: Rec X. X .\y: Rec X. X .x) true ) true) then (((\x: Bool .\y: Rec X. X .x) true ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a))) else (let u = (let u = false in true) in u)) , b = (((\x: Nat .\y: Rec X. X .x) (if (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) then (let u = 0 in true) else true) ) (( \f: Unit .((f ({a = true , b = true }.b) ) false ) ) (\a: Nat .\b: Nat .b))) }.b) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) , b = (let u = true in u) , c =  (let u = (((\x: Unit .\y: Bool .y) false ) false) in (pred 1)) }.b)) > as Nat of < l = x > => x | < r = y > => y)
(let u = (if (let u = (( \f: Bool .((f (let u = 0 in u) ) (let u = false in 1) ) ) (\a: Unit .\b: Unit .a)) in ({a = (let u = false in false) , b = (iszero 0) }.b)) then (fix (\x: Unit . (succ 0) )) else (pred (succ 0))) in ({a = (case <l = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (succ 1) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ({a = 0 , b = false }.b)) , b = (case <r = ({a = false , b = 1 }.a) > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = 0 in ({a = 1 , b = 0 }.b)) }.b) }.b))
(((\x: Rec X. X .\y: Unit .y) (fix (\x: Rec X. X . ({a = 1 , b = true }.b) )) ) (unfold [ Nat ] (fold [ Bool ] (pred (unfold [ Unit ] (fold [ Bool ] 1 ))) )))
({a = (pred (let u = ({a = false , b = 1 }.a) in (pred 1))) , b = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Nat . ({a = (pred 0) , b = (((\x: Bool .\y: Bool .x) true ) false) }.b) )) )) , c =  (pred (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.b)
({a = ({a = (let u = 0 in u) , b = ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = ({a = true , b = 0 }.a) }.b) }.a) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Nat .x) (if ({a = 0 , b = true , c =  1 }.b) then (let u = true in u) else (((\x: Bool .\y: Unit .y) false ) false)) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) (let u = (((\x: Bool .\y: Unit .y) false ) false) in u)) )) }.a)
({a = ({a = ({a = (if ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) then true else (((\x: Bool .\y: Nat .x) true ) false)) , b = ({a = (succ (pred 0)) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) , c = (( \f: Nat .((f (let u = false in 1) ) (fix (\x: Unit . 1 )) ) ) (\a: Bool .\b: Unit .b)) }.c) }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = (unfold [ Unit ] (fold [ Bool ] false )) in ({a = true , b = false }.b)) )) }.a) , b = (( \f: Unit .((f (( \f: Nat .((f (iszero 1) ) (unfold [ Rec X. X ] (fold [ Nat ] (let u = 1 in true) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (if (let u = true in u) then (case <r = ({a = 1 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) else (let u = false in u)) ) ) (\a: Unit .\b: Rec X. X .b)) , c = (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y) }.c)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (((\x: Bool .\y: Nat .x) (( \f: Bool .((f 1 ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Bool .b)) ) (((\x: Unit .\y: Bool .y) false ) false)) in (((\x: Bool .\y: Bool .x) (let u = (if true then false else true) in false) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)))) ))
({a = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) false ) (((\x: Unit .\y: Unit .y) true ) 0)) ) (((\x: Bool .\y: Bool .x) (pred 0) ) (if true then false else false)) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) ({a = 1 , b = true , c =  1 }.b)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ) (\a: Nat .\b: Nat .a)) , c = (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Bool . (let u = (((\x: Bool .\y: Nat .x) false ) false) in (((\x: Bool .\y: Rec X. X .y) true ) 0)) )) )) }.c)
(pred (if ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . true )) }.b) then ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = true in u) }.a) else (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) in u)))
(( \f: Nat .((f (( \f: Unit .((f (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) true ) false) )) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = true }.b) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = true , c =  1 }.b) )) ) (( \f: Rec X. X .((f ({a = false , b = true }.b) ) ({a = (fix (\x: Unit . true )) , b = true }.b) ) ) (\a: Rec X. X .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Unit .a)) ) (case <r = (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) true) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b))
(((\x: Nat .\y: Unit .x) (let u = (let u = true in ({a = true , b = true }.b)) in (case <l = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) > as Bool of < l = x > => x | < r = y > => y)) ) (if ({a = (fix (\x: Rec X. X . (( \f: Unit .((f ({a = false , b = 0 }.b) ) 0 ) ) (\a: Nat .\b: Unit .a)) )) , b = (fix (\x: Bool . ({a = 1 , b = true , c =  0 }.b) )) , c =  (pred (if false then 0 else (((\x: Rec X. X .\y: Bool .x) 0 ) false))) }.b) then (fix (\x: Nat . (let u = false in true) )) else (( \f: Rec X. X .((f (let u = ({a = 0 , b = true }.b) in u) ) (case <r = ({a = false , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a))))
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) (fix (\x: Nat . ({a = 1 , b = true , c =  0 }.b) )) ) (unfold [ Nat ] (fold [ Nat ] ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = (pred 1) }.b) ))) )) ))
(let u = (let u = ({a = (iszero 0) , b = (((\x: Unit .\y: Nat .y) true ) true) }.b) in u) in u)
({a = (pred ({a = 0 , b = (iszero 0) , c = 1 }.c)) , b = (unfold [ Nat ] (fold [ Unit ] ({a = (if false then false else true) , b = (iszero 1) }.b) )) }.b)
(iszero (unfold [ Nat ] (fold [ Bool ] (case <l = (pred 0) > as Nat of < l = x > => x | < r = y > => y) )))
(fix (\x: Bool . ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] 1 )) )) , b = ({a = (iszero (((\x: Unit .\y: Rec X. X .y) true ) 1)) , b = ({a = false , b = 0 }.b) }.a) , c = (((\x: Unit .\y: Unit .y) (iszero 1) ) (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) }.c) ))
(fix (\x: Bool . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 1 , b = true }.a) )) )) ))
({a = (((\x: Rec X. X .\y: Bool .y) ({a = (succ 1) , b = (iszero (((\x: Bool .\y: Nat .x) 0 ) false)) , c =  ({a = 1 , b = false , c = 0 }.c) }.b) ) ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (iszero 0) , c =  ({a = 0 , b = false }.a) }.b)) , b = (case <r = (unfold [ Unit ] (fold [ Unit ] (((\x: Bool .\y: Nat .x) ({a = false , b = 0 }.a) ) false) )) > as Nat of < l = x > => x | < r = y > => y) }.b)
({a = (let u = ({a = (( \f: Unit .((f (let u = (let u = true in true) in u) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) true ) true) )) ) ) (\a: Nat .\b: Bool .b)) , b = ({a = false , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 1 )) }.b) }.b) in u) , b = ({a = (let u = (((\x: Unit .\y: Bool .x) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Nat .y) false ) false)) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false ))) , b = (if (if true then ({a = 0 , b = false , c =  1 }.b) else true) then (let u = (let u = false in false) in (((\x: Unit .\y: Unit .x) ({a = 1 , b = false }.a) ) true)) else (case <l = ({a = 1 , b = false , c = 1 }.c) > as Bool of < l = x > => x | < r = y > => y)) }.a) , c = (succ (unfold [ Bool ] (fold [ Bool ] 0 ))) }.c)
(( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Unit ] (iszero ({a = false , b = 0 }.b)) )) ) ({a = (((\x: Nat .\y: Nat .y) ({a = (let u = 0 in true) , b = false }.b) ) (((\x: Unit .\y: Unit .x) true ) true)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.a) ) ) (\a: Nat .\b: Nat .b))
(fix (\x: Nat . (let u = (( \f: Nat .((f (let u = (let u = true in u) in u) ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Bool .b)) in (if (let u = 1 in false) then (case <l = (let u = true in 0) > as Nat of < l = x > => x | < r = y > => y) else (pred 0))) ))
(if (let u = ({a = (let u = 0 in u) , b = (let u = true in u) }.b) in u) then (case <r = ({a = (let u = false in true) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.a) > as Unit of < l = x > => x | < r = y > => y) else ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (succ 1) )) )) , b = (( \f: Unit .((f (let u = false in false) ) (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .a))) ) ) (\a: Bool .\b: Nat .a)) }.b))
(( \f: Bool .((f (let u = (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Unit .y) true ) true) ) (((\x: Unit .\y: Nat .x) 0 ) false)) in (let u = (let u = false in u) in u)) ) (((\x: Unit .\y: Nat .y) (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b))) ) ({a = ({a = false , b = (((\x: Rec X. X .\y: Unit .y) false ) true) }.b) , b = (unfold [ Nat ] (fold [ Nat ] ({a = false , b = true }.b) )) }.b)) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (( \f: Nat .((f (( \f: Unit .((f ({a = ({a = 0 , b = true , c =  0 }.b) , b = ({a = false , b = 0 }.b) }.b) ) (( \f: Nat .((f 1 ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f ({a = false , b = 1 }.b) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Unit .\b: Nat .b)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ))) ) ) (\a: Unit .\b: Unit .b)) , b = ({a = (if (let u = 0 in true) then ({a = false , b = (if true then 1 else 0) }.b) else (if false then 0 else 0)) , b = (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) , c =  ({a = ({a = false , b = 1 }.b) , b = (let u = false in u) , c = (let u = 1 in u) }.c) }.b) }.b)
(((\x: Nat .\y: Nat .y) ({a = (( \f: Nat .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .x) false ) true) ) false ) ) (\a: Unit .\b: Bool .b)) }.b) ) (((\x: Rec X. X .\y: Bool .y) (let u = (fix (\x: Unit . false )) in u) ) (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) true ) true) ))))
({a = ({a = (succ ({a = 1 , b = false }.a)) , b = (iszero ({a = true , b = 0 }.b)) , c =  (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = 0 }.b) )) }.b) , b = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) ({a = (if false then true else true) , b = 1 }.a) ) (let u = (let u = false in u) in u)) ) (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ))) }.b)
({a = ({a = (succ (((\x: Nat .\y: Unit .y) (let u = true in u) ) (((\x: Bool .\y: Rec X. X .y) false ) 0))) , b = (((\x: Rec X. X .\y: Rec X. X .x) (let u = 1 in true) ) (iszero 0)) }.b) , b = (succ (case <l = (((\x: Nat .\y: Rec X. X .x) 1 ) false) > as Nat of < l = x > => x | < r = y > => y)) }.a)
(((\x: Rec X. X .\y: Unit .x) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in u) )) , b = (iszero (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) , c =  (( \f: Unit .((f ({a = (if true then false else true) , b = 1 }.b) ) (if (iszero 0) then (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) else (unfold [ Nat ] (fold [ Bool ] 0 ))) ) ) (\a: Bool .\b: Bool .a)) }.b) ) ({a = (let u = ({a = (let u = 0 in 1) , b = false , c = (succ 1) }.c) in u) , b = ({a = (let u = true in (let u = false in true)) , b = (let u = ({a = 0 , b = true }.b) in u) }.b) , c =  (((\x: Bool .\y: Bool .y) (if true then true else true) ) (unfold [ Bool ] (fold [ Bool ] 0 ))) }.b))
({a = (pred (((\x: Nat .\y: Rec X. X .x) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in (let u = 1 in u)) ) (iszero (((\x: Unit .\y: Rec X. X .y) true ) 0)))) , b = (unfold [ Bool ] (fold [ Unit ] (let u = (let u = true in u) in (((\x: Rec X. X .\y: Bool .x) true ) true)) )) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (case <l = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y) )) }.c)
(fix (\x: Unit . (((\x: Nat .\y: Rec X. X .y) (( \f: Nat .((f (let u = (if true then 0 else 0) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.a) ))) ) (let u = 1 in (((\x: Bool .\y: Bool .x) true ) true)) ) ) (\a: Unit .\b: Bool .a)) ) (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] 0 )) )))) ))
({a = (( \f: Nat .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (let u = false in false) )) ) (case <r = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Bool ] ({a = ({a = ({a = 0 , b = true , c = 0 }.c) , b = (let u = false in u) , c =  (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) , b = (if false then ({a = 1 , b = false }.a) else (let u = 1 in u)) }.b) )) }.a)
(let u = (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] false )) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) ) (( \f: Nat .((f true ) (((\x: Unit .\y: Nat .x) true ) false) ) ) (\a: Bool .\b: Bool .b))) in (let u = (let u = (succ 1) in u) in ({a = (( \f: Bool .((f (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) (let u = false in 0) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (unfold [ Bool ] (fold [ Nat ] false )) , c =  ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c = (((\x: Rec X. X .\y: Bool .x) 1 ) true) }.c) }.b)))
(if ({a = (let u = ({a = 0 , b = false , c = 0 }.c) in false) , b = (fix (\x: Nat . (fix (\x: Rec X. X . 1 )) )) }.a) then (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Nat .\y: Nat .y) ({a = (((\x: Nat .\y: Unit .x) false ) false) , b = ({a = 0 , b = 1 }.b) }.a) ) (let u = 1 in false)) )) else ({a = ({a = (if false then 1 else 1) , b = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) in 0) }.b) , b = ({a = false , b = true }.b) }.b))
(unfold [ Unit ] (fold [ Bool ] ({a = (fix (\x: Bool . (let u = 0 in u) )) , b = (let u = (let u = true in 0) in (( \f: Rec X. X .((f false ) ({a = 1 , b = true , c =  0 }.b) ) ) (\a: Rec X. X .\b: Unit .a))) , c = (pred (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b))) }.c) ))
({a = ({a = (let u = (fix (\x: Unit . (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) )) in (let u = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)) in false)) , b = ({a = ({a = 1 , b = (let u = false in 0) }.b) , b = (fix (\x: Unit . ({a = 0 , b = true , c =  1 }.b) )) , c = (( \f: Unit .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Nat .a)) }.c) }.a) , b = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (case <r = (let u = 1 in true) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (succ (fix (\x: Bool . 0 ))) }.c) }.b)
(let u = (( \f: Nat .((f (fix (\x: Nat . 1 )) ) (((\x: Bool .\y: Bool .y) (((\x: Bool .\y: Nat .x) true ) false) ) (((\x: Unit .\y: Nat .y) false ) 1)) ) ) (\a: Bool .\b: Rec X. X .b)) in (if (iszero ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) ))) then (if ({a = (fix (\x: Nat . ({a = false , b = true }.b) )) , b = (let u = true in u) }.b) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if false then 0 else 0) )) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] 0 )) ))))
(( \f: Rec X. X .((f ({a = (let u = (( \f: Rec X. X .((f false ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Nat .\b: Nat .b)) in (let u = (((\x: Nat .\y: Nat .x) false ) true) in (if true then 0 else 1))) , b = ({a = (let u = (((\x: Unit .\y: Nat .x) 0 ) true) in 0) , b = (let u = false in 1) }.b) }.b) ) (((\x: Bool .\y: Bool .y) (let u = (succ (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) in (let u = false in ({a = 1 , b = false , c =  0 }.b))) ) ({a = (((\x: Bool .\y: Nat .y) (let u = 1 in false) ) (if false then 1 else (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)))) , b = (if (unfold [ Nat ] (fold [ Rec X. X ] false )) then ({a = 1 , b = true , c =  0 }.b) else ({a = true , b = 1 }.a)) , c = (case <l = (if false then 0 else 0) > as Bool of < l = x > => x | < r = y > => y) }.c)) ) ) (\a: Rec X. X .\b: Unit .a))
(((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) }.b) ) (let u = 1 in (let u = false in u))) ) (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (let u = 0 in false) )) in (((\x: Nat .\y: Unit .y) (fix (\x: Nat . false )) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (((\x: Bool .\y: Unit .y) ({a = 0 , b = false , c =  1 }.b) ) 1) , b = (iszero (fix (\x: Nat . 1 ))) }.b))
({a = ({a = (let u = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = true }.b) in (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) , c = (let u = (case <r = false > as Unit of < l = x > => x | < r = y > => y) in 0) }.c) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Rec X. X . 1 )) )) , b = ({a = 0 , b = false , c =  0 }.b) , c =  (if false then 0 else 0) }.b) )) , c =  (let u = (( \f: Nat .((f (let u = 0 in u) ) (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a))) ) ) (\a: Rec X. X .\b: Unit .b)) in (let u = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) in (unfold [ Bool ] (fold [ Rec X. X ] 1 )))) }.b)
(let u = (let u = (((\x: Unit .\y: Bool .y) true ) ({a = 1 , b = true , c =  1 }.b)) in u) in (pred (let u = (( \f: Unit .((f (((\x: Nat .\y: Bool .x) true ) true) ) (let u = false in true) ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = (iszero 0) in (let u = 1 in 1)))))
({a = ({a = (if (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) then (let u = 0 in (let u = 0 in 1)) else ({a = false , b = ({a = 1 , b = 0 }.b) }.b)) , b = ({a = ({a = false , b = false }.b) , b = (( \f: Bool .((f false ) (if true then false else true) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) }.a) , b = ({a = (( \f: Nat .((f (( \f: Unit .((f ({a = false , b = (let u = false in u) }.b) ) ({a = false , b = ({a = 0 , b = false }.b) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = (iszero 0) in u) ) ) (\a: Unit .\b: Unit .a)) , b = (((\x: Bool .\y: Bool .x) (( \f: Bool .((f true ) (((\x: Rec X. X .\y: Nat .x) false ) false) ) ) (\a: Rec X. X .\b: Unit .a)) ) (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .b))) }.b) }.a)
(let u = (let u = (pred ({a = 1 , b = 1 }.b)) in u) in u)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Rec X. X .x) false ) true) ) (((\x: Unit .\y: Nat .x) false ) false)) in (pred (let u = (let u = true in false) in (succ 0)))) ))
(((\x: Bool .\y: Rec X. X .x) (case <r = (( \f: Bool .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .x) true ) true) )) ) ) (\a: Rec X. X .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) in u))
(let u = (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .a)) , b = (let u = 1 in 1) }.b) )) )) in (case <r = (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = (if true then true else false) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) true ) false) ))) > as Nat of < l = x > => x | < r = y > => y))
({a = (let u = (let u = false in (let u = 1 in u)) in ({a = ({a = false , b = 0 }.b) , b = ({a = true , b = true }.b) , c =  ({a = 0 , b = (iszero 0) }.a) }.b)) , b = (case <l = (succ 1) > as Nat of < l = x > => x | < r = y > => y) }.a)
(iszero ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = 1 , b = false }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) }.b) )) , b = ({a = ({a = (unfold [ Bool ] (fold [ Bool ] 0 )) , b = (((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Bool .y) true ) false) ) (unfold [ Bool ] (fold [ Rec X. X ] false ))) }.a) , b = (((\x: Unit .\y: Nat .y) false ) 1) }.b) }.b))
(( \f: Nat .((f (case <r = (unfold [ Bool ] (fold [ Bool ] (if true then false else false) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <r = (let u = (fix (\x: Nat . (((\x: Nat .\y: Nat .x) false ) true) )) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a))
(let u = (fix (\x: Bool . (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Nat .x) (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) false) ) (let u = true in u)) )) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f false ) (iszero 0) ) ) (\a: Unit .\b: Unit .a)) ) ({a = true , b = 0 }.a)) )))
(let u = ({a = ({a = (fix (\x: Rec X. X . 1 )) , b = 0 }.b) , b = ({a = ({a = true , b = 1 }.a) , b = true }.b) }.b) in (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Nat .y) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = true , b = false }.b) )) ) (((\x: Bool .\y: Nat .y) ({a = 0 , b = false , c =  0 }.b) ) true)) ) ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Nat .x) ({a = 1 , b = false }.a) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) }.a)))
({a = (let u = (let u = (if false then (let u = false in 0) else ({a = 1 , b = 1 }.b)) in u) in ({a = ({a = (((\x: Unit .\y: Bool .y) true ) 1) , b = (let u = 1 in u) }.b) , b = (let u = 0 in true) }.b)) , b = (let u = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) , b = (succ 0) }.b) in u) }.a)
(let u = ({a = (((\x: Bool .\y: Unit .x) (unfold [ Bool ] (fold [ Unit ] 0 )) ) ({a = (((\x: Nat .\y: Unit .x) false ) false) , b = 1 }.a)) , b = (((\x: Bool .\y: Nat .x) ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) }.b) ) ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = ({a = false , b = 1 }.a) , c =  ({a = 0 , b = 0 }.b) }.b)) , c = (succ (( \f: Rec X. X .((f ({a = (fix (\x: Bool . 1 )) , b = (let u = 0 in false) , c = (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.c) ) (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Rec X. X .x) true ) false) ) ({a = 1 , b = true }.a)) ) ) (\a: Unit .\b: Unit .a))) }.c) in (case <r = (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Nat .x) true ) (fix (\x: Unit . false ))) ) ({a = 1 , b = (fix (\x: Unit . true )) }.b)) > as Nat of < l = x > => x | < r = y > => y))
(fix (\x: Nat . (( \f: Nat .((f (pred (let u = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) in ({a = 0 , b = 0 }.b))) ) (( \f: Unit .((f (((\x: Bool .\y: Bool .x) 0 ) true) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .b)) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (fix (\x: Nat . (if ({a = ({a = 0 , b = 1 }.b) , b = ({a = true , b = false }.b) }.b) then (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) true ) ) (\a: Bool .\b: Bool .b)) else (((\x: Unit .\y: Bool .x) (iszero 0) ) true)) )) ))
({a = (let u = (( \f: Nat .((f ({a = 1 , b = true }.a) ) 0 ) ) (\a: Unit .\b: Nat .b)) in u) , b = ({a = (fix (\x: Bool . ({a = false , b = 0 }.b) )) , b = (fix (\x: Nat . true )) , c = (fix (\x: Unit . 1 )) }.c) }.b)
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (((\x: Nat .\y: Bool .x) (let u = (let u = 1 in false) in true) ) (fix (\x: Unit . false ))) , b = (succ 0) }.a) ))
(( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] (if true then ({a = true , b = 0 }.a) else (let u = 1 in true)) )) ) ({a = (let u = (let u = 1 in u) in ({a = false , b = ({a = 1 , b = 0 }.b) }.b)) , b = ({a = (unfold [ Rec X. X ] (fold [ Nat ] (let u = 0 in false) )) , b = (( \f: Rec X. X .((f true ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) ) ) (\a: Nat .\b: Nat .a)) }.b) }.b) ) ) (\a: Rec X. X .\b: Nat .b))
(pred ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (if false then false else true) in (fix (\x: Bool . (unfold [ Nat ] (fold [ Unit ] 0 )) ))) )))
(if (let u = (( \f: Bool .((f (let u = (let u = true in u) in u) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) in ({a = (unfold [ Unit ] (fold [ Rec X. X ] false )) , b = (iszero 0) }.b)) then ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = (let u = true in 1) in ({a = 0 , b = false , c =  1 }.b)) )) , b = (unfold [ Unit ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) }.b) )) }.b) else (( \f: Rec X. X .((f (( \f: Unit .((f ({a = 1 , b = (((\x: Unit .\y: Nat .y) true ) true) , c =  1 }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = ({a = true , b = 0 }.b) , b = true , c =  (((\x: Nat .\y: Unit .x) 1 ) false) }.b) ) ) (\a: Unit .\b: Nat .b)))
({a = (pred (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f (succ 0) ) (let u = 0 in u) ) ) (\a: Unit .\b: Rec X. X .b)) ))) , b = (let u = (fix (\x: Bool . ({a = ({a = false , b = 0 }.b) , b = ({a = true , b = 0 }.a) }.b) )) in u) }.b)
({a = (((\x: Nat .\y: Nat .x) ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = 1 }.a) ) ({a = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) }.a) , b = ({a = 1 , b = false }.b) }.b)) , b = (let u = (if ({a = false , b = true }.b) then (fix (\x: Unit . (let u = 0 in 1) )) else (let u = ({a = false , b = true }.b) in (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)))) in (((\x: Rec X. X .\y: Unit .x) (((\x: Rec X. X .\y: Unit .y) false ) 1) ) true)) }.a)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Nat .x) (let u = true in true) ) false) ) (((\x: Bool .\y: Rec X. X .y) true ) ({a = true , b = true }.b))) , b = (( \f: Nat .((f (let u = ({a = 1 , b = false , c = 0 }.c) in ({a = 0 , b = true , c = 1 }.c)) ) (let u = false in (pred 0)) ) ) (\a: Nat .\b: Unit .b)) }.a) ))
(fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] ({a = ({a = 0 , b = 1 }.b) , b = false , c =  0 }.b) )) ))
(let u = ({a = (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = false }.a) ) ({a = (let u = 1 in u) , b = (unfold [ Rec X. X ] (fold [ Bool ] false )) , c =  ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) }.b)) , b = (iszero (fix (\x: Rec X. X . ({a = 1 , b = (let u = true in true) }.a) ))) , c =  ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (pred 1) , b = (((\x: Nat .\y: Nat .x) false ) true) }.a) )) }.b) in (let u = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) , b = (fix (\x: Nat . true )) }.b) in u))
(let u = ({a = (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) in (((\x: Unit .\y: Bool .y) false ) 1)) , b = (let u = (if (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) )) then ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) else (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .b))) in (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) in false)) , c =  (( \f: Bool .((f (((\x: Rec X. X .\y: Nat .x) (if true then 1 else 1) ) ({a = 1 , b = true , c =  0 }.b)) ) (unfold [ Unit ] (fold [ Bool ] (( \f: Rec X. X .((f 0 ) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) ) ) (\a: Nat .\b: Bool .b)) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) in u)
(let u = (fix (\x: Unit . ({a = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) then (let u = 1 in false) else (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .b))) , b = (((\x: Unit .\y: Unit .x) false ) false) }.b) )) in u)
(case <l = (( \f: Unit .((f (( \f: Nat .((f (fix (\x: Nat . 1 )) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Unit .\b: Bool .a)) ) (let u = (if (let u = 1 in true) then 1 else 1) in u) ) ) (\a: Unit .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y)
(succ (if ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in true) , c =  (if false then 1 else (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.b) then (case <l = (((\x: Unit .\y: Rec X. X .x) 1 ) false) > as Bool of < l = x > => x | < r = y > => y) else ({a = (fix (\x: Nat . true )) , b = 1 }.b)))
(fix (\x: Unit . (( \f: Unit .((f (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in u) ) (let u = (((\x: Nat .\y: Bool .y) false ) (if true then 0 else 0)) in (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Rec X. X .\b: Nat .b)) ))
({a = (((\x: Rec X. X .\y: Nat .x) (let u = (((\x: Rec X. X .\y: Unit .x) 1 ) true) in (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) ) (( \f: Bool .((f (((\x: Nat .\y: Unit .x) false ) true) ) (let u = false in u) ) ) (\a: Unit .\b: Rec X. X .b))) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (fix (\x: Bool . false )) , b = (iszero 0) }.b) )) }.b)
(( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in u) )) )) ) (let u = (let u = ({a = false , b = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) }.b) in (if false then 0 else 1)) in ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b)) ) ) (\a: Rec X. X .\b: Nat .b))
({a = (iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) ))) , b = (( \f: Unit .((f (((\x: Unit .\y: Unit .x) ({a = 0 , b = false , c = 0 }.c) ) (fix (\x: Bool . true ))) ) (if (((\x: Rec X. X .\y: Unit .x) false ) true) then ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = false }.a) else (let u = 0 in u)) ) ) (\a: Nat .\b: Bool .b)) }.a)
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .y) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) }.b) ) (( \f: Nat .((f (let u = ({a = false , b = 1 }.a) in u) ) (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) in (((\x: Nat .\y: Nat .y) false ) true)) ) ) (\a: Rec X. X .\b: Bool .b))) ))
(((\x: Bool .\y: Unit .y) (fix (\x: Nat . (if (( \f: Nat .((f false ) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Nat .b)) then (( \f: Unit .((f (let u = false in false) ) true ) ) (\a: Nat .\b: Rec X. X .a)) else ({a = 0 , b = (let u = 0 in false) }.b)) )) ) (case <l = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in (let u = 1 in 1)) > as Bool of < l = x > => x | < r = y > => y))
((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (pred (((\x: Nat .\y: Nat .y) (if true then false else false) ) (let u = false in 1))) , b = (iszero ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.b) ))) , c = ({a = (let u = true in false) , b = (let u = (let u = false in u) in (pred 1)) }.b) }.c) ))
(let u = (let u = ({a = (pred (if true then 0 else 0)) , b = ({a = false , b = 1 }.a) }.b) in (((\x: Nat .\y: Nat .x) (unfold [ Bool ] (fold [ Unit ] (let u = false in true) )) ) ({a = (((\x: Unit .\y: Rec X. X .y) true ) 0) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) , c =  (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b))) in (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (pred 1) , b = (if true then false else false) }.b) )) > as Nat of < l = x > => x | < r = y > => y))
({a = (let u = (((\x: Bool .\y: Rec X. X .y) false ) (if true then true else true)) in ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) }.a)) , b = (pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) ))) }.b)
({a = (let u = ({a = ({a = 1 , b = false }.a) , b = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .a)) }.b) in (let u = ({a = 0 , b = 0 }.b) in u)) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) )) in ({a = ({a = (if true then 0 else 0) , b = (let u = 0 in true) , c = (((\x: Bool .\y: Bool .x) 0 ) false) }.c) , b = (((\x: Nat .\y: Unit .y) false ) false) , c = ({a = (if false then 0 else 0) , b = (((\x: Unit .\y: Nat .y) false ) 1) }.b) }.c)) }.b)
(unfold [ Nat ] (fold [ Bool ] (( \f: Nat .((f (let u = (let u = 0 in u) in (( \f: Rec X. X .((f ({a = 1 , b = true , c =  0 }.b) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (((\x: Nat .\y: Unit .x) ({a = 1 , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) , c =  1 }.b) ) ({a = false , b = 0 }.a)) ) ) (\a: Unit .\b: Nat .b)) ))
({a = (case <l = (((\x: Rec X. X .\y: Bool .y) (let u = (let u = 1 in u) in false) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) , b = (if ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .y) false ) false) )) then ({a = (((\x: Unit .\y: Unit .x) 0 ) false) , b = (((\x: Bool .\y: Unit .y) true ) false) , c =  (((\x: Rec X. X .\y: Nat .x) 1 ) false) }.b) else ({a = ({a = false , b = 0 }.a) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) }.b)) , c = (succ (pred (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in u))) }.c)
(( \f: Bool .((f (( \f: Rec X. X .((f (let u = (( \f: Nat .((f (let u = ({a = 1 , b = 1 }.b) in true) ) (let u = 0 in (let u = 0 in true)) ) ) (\a: Nat .\b: Nat .a)) in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (iszero (fix (\x: Bool . 0 ))) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = 1 , b = true , c = 1 }.c) in ({a = 1 , b = true , c =  0 }.b)) )) ) ) (\a: Bool .\b: Unit .b))
(((\x: Unit .\y: Rec X. X .x) ({a = ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = (fix (\x: Unit . true )) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (succ ({a = 1 , b = 1 }.b)) }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Nat ] true )) )))
(unfold [ Rec X. X ] (fold [ Unit ] (let u = (unfold [ Rec X. X ] (fold [ Bool ] (pred 1) )) in ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = true , c =  1 }.b) ) (( \f: Unit .((f true ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Nat .a))) , c =  (pred 1) }.b)) ))
(if (let u = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false ))) then (let u = (fix (\x: Bool . (if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) then (let u = false in u) else false) )) in (let u = (unfold [ Nat ] (fold [ Unit ] false )) in u)) else ({a = (pred ({a = ({a = false , b = 1 }.b) , b = (((\x: Nat .\y: Nat .x) false ) true) }.a)) , b = ({a = (((\x: Unit .\y: Rec X. X .y) false ) 0) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  (let u = 1 in u) }.b) }.b))
(( \f: Bool .((f ({a = ({a = (let u = 0 in false) , b = ({a = 1 , b = true }.b) }.b) , b = (((\x: Unit .\y: Bool .y) (unfold [ Bool ] (fold [ Nat ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) )) ) ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = (unfold [ Unit ] (fold [ Bool ] true )) , c = (((\x: Bool .\y: Rec X. X .y) true ) 0) }.c)) }.b) ) (((\x: Unit .\y: Rec X. X .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (unfold [ Unit ] (fold [ Unit ] true )) in (iszero 0)) )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (succ 1) ))) ) ) (\a: Rec X. X .\b: Unit .a))
(iszero (pred ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = ({a = 1 , b = false }.a) }.b)))
(pred ({a = (( \f: Bool .((f (( \f: Nat .((f (((\x: Nat .\y: Unit .x) 1 ) true) ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (fix (\x: Bool . ({a = (pred 1) , b = (((\x: Bool .\y: Unit .x) false ) (((\x: Unit .\y: Nat .y) false ) true)) , c =  (let u = false in (if false then 0 else 0)) }.b) )) , c = ({a = (((\x: Bool .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Bool ] false )) ) ({a = 0 , b = true }.b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b) }.c))
({a = (((\x: Bool .\y: Unit .x) (( \f: Bool .((f (if ({a = false , b = 0 }.a) then 0 else (((\x: Unit .\y: Bool .x) 1 ) false)) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = ({a = (iszero 0) , b = 0 }.a) , b = ({a = 1 , b = false , c =  1 }.b) }.b)) , b = (unfold [ Unit ] (fold [ Rec X. X ] (iszero 1) )) }.b)
(( \f: Bool .((f ({a = (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) then ({a = 0 , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) , c =  1 }.b) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) , b = (let u = (case <l = ({a = true , b = 0 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.a) ) (let u = (if (let u = ({a = 1 , b = false }.b) in u) then (let u = false in u) else (iszero (if true then 1 else 1))) in u) ) ) (\a: Rec X. X .\b: Unit .b))
(let u = (let u = (let u = ({a = 0 , b = true }.b) in u) in u) in (let u = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (iszero (succ 0))) in u))
((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = (( \f: Bool .((f ({a = 1 , b = false }.a) ) (if false then 1 else 1) ) ) (\a: Bool .\b: Rec X. X .a)) in (fix (\x: Rec X. X . true ))) ))
(let u = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) , b = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in 1) }.a) in u)
({a = (((\x: Rec X. X .\y: Nat .y) (let u = false in (unfold [ Bool ] (fold [ Rec X. X ] false ))) ) (((\x: Unit .\y: Unit .x) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.a) ) (if false then (let u = true in true) else true))) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) false ) ({a = false , b = 0 }.a)) )) }.b)
(unfold [ Bool ] (fold [ Bool ] ({a = (( \f: Nat .((f (let u = 1 in u) ) (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in 0) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = ({a = 1 , b = false , c = 0 }.c) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) }.b) ))
(((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = false }.b) )) ) (if (( \f: Rec X. X .((f (if true then false else true) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Bool .a)) then (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Unit ] 1 )) )) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false ))) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) ))))
(if (if (if (case <r = (((\x: Nat .\y: Bool .y) true ) true) > as Bool of < l = x > => x | < r = y > => y) then (let u = true in true) else ({a = false , b = 1 }.a)) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) true ) false) )) else ({a = (pred (let u = true in 0)) , b = ({a = 0 , b = true }.b) , c =  ({a = (fix (\x: Rec X. X . 0 )) , b = 1 }.b) }.b)) then ({a = ({a = (if false then 1 else 1) , b = (( \f: Rec X. X .((f ({a = 0 , b = true , c = 1 }.c) ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b) , b = (let u = ({a = 0 , b = false , c =  1 }.b) in ({a = true , b = ({a = true , b = false }.b) }.b)) , c =  (pred 0) }.b) else (((\x: Unit .\y: Nat .x) (let u = ({a = (fix (\x: Rec X. X . true )) , b = (((\x: Bool .\y: Nat .x) 0 ) true) }.b) in (let u = (iszero 0) in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )))) ) (( \f: Rec X. X .((f ({a = 0 , b = (((\x: Nat .\y: Bool .x) false ) false) }.b) ) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .a))))
(((\x: Unit .\y: Nat .x) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) ) (if true then true else true) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if false then (((\x: Bool .\y: Bool .x) 0 ) false) else ({a = 1 , b = true , c = 0 }.c)) )) }.b) ) (let u = (iszero (( \f: Unit .((f ({a = 1 , b = 1 }.b) ) 0 ) ) (\a: Unit .\b: Nat .a))) in u))
({a = (case <r = (case <r = ({a = (let u = 1 in u) , b = false , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (( \f: Nat .((f (let u = false in ({a = false , b = false }.b)) ) (((\x: Bool .\y: Bool .y) false ) false) ) ) (\a: Bool .\b: Rec X. X .a)) )) }.b)
(( \f: Bool .((f ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = false , b = true }.b) )) , b = (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.a) ) (if (( \f: Nat .((f ({a = true , b = true }.b) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) , b = true , c =  (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b) ) ) (\a: Nat .\b: Nat .a)) then ({a = (let u = 0 in 0) , b = ({a = (let u = false in u) , b = false }.b) , c =  (fix (\x: Rec X. X . 1 )) }.b) else (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = 1 }.a) ) ({a = 1 , b = true , c =  0 }.b))) ) ) (\a: Rec X. X .\b: Bool .b))
({a = ({a = (case <l = (succ 0) > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Bool ] (let u = true in u) )) }.a) , b = (unfold [ Unit ] (fold [ Rec X. X ] (iszero 1) )) }.a)
(unfold [ Nat ] (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Unit .y) (let u = 1 in ({a = 1 , b = false , c =  0 }.b)) ) ({a = (fix (\x: Bool . 1 )) , b = ({a = 1 , b = (fix (\x: Rec X. X . false )) }.b) , c = (((\x: Rec X. X .\y: Unit .y) false ) 1) }.c)) )) ))
({a = ({a = (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (succ 0) ))) , b = ({a = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) in u) , b = (fix (\x: Nat . (let u = true in true) )) }.b) , c = (( \f: Unit .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) ) (((\x: Bool .\y: Bool .x) 1 ) true) ) ) (\a: Unit .\b: Unit .a)) }.c) , b = (let u = (let u = (let u = true in false) in u) in ({a = (succ 1) , b = true , c = (let u = 1 in u) }.c)) }.b)
(let u = (( \f: Unit .((f (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ) (if (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) then 0 else (((\x: Bool .\y: Rec X. X .y) false ) 1)) ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = (( \f: Unit .((f true ) ({a = false , b = true }.b) ) ) (\a: Unit .\b: Nat .b)) in (( \f: Rec X. X .((f (let u = 0 in false) ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .a))))
(case <r = ({a = (let u = (let u = false in u) in ({a = (((\x: Unit .\y: Unit .y) true ) true) , b = 0 }.b)) , b = (let u = (let u = 0 in u) in (let u = ({a = 1 , b = false , c = 0 }.c) in (if false then false else false))) }.b) > as Unit of < l = x > => x | < r = y > => y)
(let u = (let u = (let u = (let u = (let u = true in true) in u) in ({a = ({a = ({a = 1 , b = false , c = 0 }.c) , b = 0 }.b) , b = (( \f: Nat .((f (fix (\x: Nat . false )) ) (iszero 1) ) ) (\a: Bool .\b: Nat .b)) , c =  (( \f: Rec X. X .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)) in (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Unit .y) (let u = false in u) ) false) )) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Bool .a))) in (let u = (fix (\x: Rec X. X . (let u = (iszero 0) in u) )) in u))
(let u = ({a = (let u = (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Unit .x) false ) true) )) in (pred 1)) , b = (let u = (iszero (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b))) in (( \f: Bool .((f (let u = false in 1) ) 1 ) ) (\a: Nat .\b: Unit .b))) }.b) in (if (iszero 0) then (let u = true in (((\x: Nat .\y: Rec X. X .x) 1 ) false)) else (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .x) 0 ) (fix (\x: Bool . false ))) ) (let u = 0 in 0) ) ) (\a: Nat .\b: Bool .a))))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (fix (\x: Nat . (let u = (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) (pred 0))) )) ))
({a = ({a = ({a = (if false then 1 else 1) , b = (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Rec X. X .a)) }.a) , b = (let u = (case <r = (fix (\x: Unit . false )) > as Bool of < l = x > => x | < r = y > => y) in ({a = 0 , b = false , c = 1 }.c)) }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Unit . (if true then true else true) )) )) }.b)
(((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Nat .y) (( \f: Nat .((f (let u = 0 in false) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (if ({a = true , b = 0 }.a) then (let u = 0 in u) else (let u = 0 in 0))) ) ({a = (((\x: Unit .\y: Unit .x) false ) (let u = false in true)) , b = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) , b = 0 }.b) }.a))
(case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Nat ] true )) )) in (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .y) false ) true) ))) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Bool .\y: Nat .y) ({a = ({a = ({a = false , b = false }.b) , b = ({a = ({a = 0 , b = false }.a) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .b)) , c = 1 }.c) }.a) , b = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (( \f: Bool .((f (unfold [ Unit ] (fold [ Unit ] 0 )) ) 0 ) ) (\a: Unit .\b: Unit .b)) else (succ 0)) }.a) ) (case <l = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Nat .x) 1 ) true) )) , b = (case <r = (((\x: Unit .\y: Rec X. X .x) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) > as Bool of < l = x > => x | < r = y > => y))
(((\x: Bool .\y: Unit .x) (let u = (( \f: Nat .((f (fix (\x: Unit . 0 )) ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Bool .a)) in ({a = (let u = (if true then 1 else 0) in u) , b = (let u = 0 in true) }.b)) ) ({a = (((\x: Bool .\y: Nat .y) true ) false) , b = (let u = 0 in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) }.b))
({a = (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) , b = (let u = 0 in false) }.a) in (unfold [ Unit ] (fold [ Bool ] 1 ))) , b = ({a = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) in u) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if false then 0 else 0) )) }.b) }.b)
(let u = (let u = (((\x: Nat .\y: Bool .x) (let u = 0 in u) ) (((\x: Bool .\y: Unit .y) true ) false)) in ({a = (case <l = (fix (\x: Nat . 0 )) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 0 in false) }.b)) in ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] 0 )) )) , b = (iszero (if false then 1 else 0)) }.b))
(pred (case <l = ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = (((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) 0) }.b) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Bool .((f (let u = (( \f: Rec X. X .((f (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Unit .a)) in (let u = (if true then true else true) in u)) ) (let u = (( \f: Bool .((f true ) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .a)) in u) ) ) (\a: Bool .\b: Bool .a))
({a = (let u = (case <l = (let u = 0 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Rec X. X .\y: Nat .x) (((\x: Rec X. X .\y: Unit .x) false ) true) ) (((\x: Bool .\y: Rec X. X .x) true ) false))) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) )) }.a)
(( \f: Nat .((f (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) ) (let u = (((\x: Bool .\y: Unit .x) ({a = 0 , b = 1 }.b) ) true) in (( \f: Bool .((f 1 ) (let u = 1 in 0) ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Bool .\y: Bool .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) )) ) ({a = (case <r = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = ({a = true , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (case <l = (((\x: Nat .\y: Bool .y) (iszero 1) ) (let u = false in 0)) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Unit .a)) ) (if (iszero 0) then (let u = 1 in u) else (succ 0)) ) ) (\a: Unit .\b: Bool .a)) }.b)
(iszero (case <l = (unfold [ Rec X. X ] (fold [ Bool ] ({a = (let u = 0 in u) , b = (let u = true in true) , c = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.c) )) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f (( \f: Nat .((f (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) (pred 1) ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = (((\x: Bool .\y: Nat .y) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = false , b = true }.b) }.b) ) (if false then 1 else 1)) in u) ) ) (\a: Unit .\b: Rec X. X .a))
(( \f: Bool .((f (let u = ({a = (let u = (((\x: Unit .\y: Rec X. X .x) 1 ) false) in u) , b = (let u = (let u = 0 in 0) in (((\x: Unit .\y: Unit .x) 0 ) true)) }.b) in (( \f: Bool .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) (let u = 1 in ({a = 0 , b = false }.a)) ) ) (\a: Unit .\b: Unit .b))) ) ({a = (fix (\x: Nat . (( \f: Unit .((f (succ 1) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) , b = (( \f: Bool .((f (if (((\x: Nat .\y: Bool .y) true ) ({a = true , b = false }.b)) then (iszero 0) else (((\x: Unit .\y: Unit .x) false ) true)) ) (let u = (let u = (pred 1) in true) in u) ) ) (\a: Bool .\b: Rec X. X .a)) , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (pred 1) )) }.c) ) ) (\a: Unit .\b: Bool .a))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (if (if (fix (\x: Nat . (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) then (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Bool .x) false ) false) ) false) else ({a = ({a = 1 , b = false }.b) , b = (let u = false in false) }.b)) then ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = (let u = false in u) > as Unit of < l = x > => x | < r = y > => y) )) else ({a = (fix (\x: Nat . false )) , b = (((\x: Unit .\y: Bool .x) 0 ) true) }.a)) ))
(succ (((\x: Nat .\y: Rec X. X .x) (fix (\x: Rec X. X . (succ 1) )) ) (let u = (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)) in u) in u)))
({a = (pred (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Nat .x) 1 ) false) )) in u)) , b = (((\x: Rec X. X .\y: Unit .y) (if (((\x: Unit .\y: Bool .y) true ) true) then (((\x: Bool .\y: Bool .x) (let u = 0 in true) ) (unfold [ Unit ] (fold [ Nat ] false ))) else (let u = false in false)) ) (fix (\x: Bool . ({a = 0 , b = false }.b) ))) , c = (fix (\x: Unit . ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .a)) )) , b = (fix (\x: Nat . (let u = 0 in 1) )) }.b) )) }.c)
({a = ({a = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) in (pred 1)) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ({a = true , b = true }.b) ) ) (\a: Unit .\b: Unit .a)) , c = ({a = (let u = 0 in (if false then 0 else 0)) , b = (( \f: Bool .((f 0 ) (succ 0) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) }.c) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f (let u = (pred 1) in (((\x: Rec X. X .\y: Nat .x) true ) true)) ) (iszero (pred 1)) ) ) (\a: Unit .\b: Rec X. X .b)) )) }.a)
({a = (fix (\x: Nat . (let u = (succ 0) in (pred 0)) )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = (let u = true in 1) , b = (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.b) )) }.b)
({a = ({a = (let u = ({a = 0 , b = false }.b) in ({a = true , b = 1 }.b)) , b = (let u = (( \f: Unit .((f (let u = true in 1) ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in (case <r = (let u = false in u) > as Unit of < l = x > => x | < r = y > => y)) , c =  ({a = ({a = 0 , b = false }.a) , b = (pred 1) }.b) }.b) , b = (let u = (let u = ({a = 0 , b = ({a = 0 , b = 1 }.b) }.b) in (pred 1)) in (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) in u)) }.b)
(((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f (fix (\x: Unit . (((\x: Nat .\y: Nat .x) false ) false) )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = 0 , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c =  (fix (\x: Bool . 0 )) }.b) )) ) ) (\a: Nat .\b: Bool .b)) ) (pred (pred ({a = true , b = 0 }.b))))
({a = (succ (pred ({a = (let u = 1 in 0) , b = 1 }.b))) , b = (( \f: Unit .((f (fix (\x: Nat . 1 )) ) (((\x: Rec X. X .\y: Rec X. X .y) (let u = true in u) ) 0) ) ) (\a: Bool .\b: Nat .a)) }.b)
(let u = (pred (( \f: Nat .((f 1 ) (if false then 1 else 1) ) ) (\a: Unit .\b: Unit .b))) in (succ ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in u) )) , b = (((\x: Unit .\y: Rec X. X .y) ({a = false , b = (((\x: Nat .\y: Nat .x) 0 ) true) }.a) ) ({a = true , b = 1 }.a)) }.a)))
({a = (((\x: Rec X. X .\y: Bool .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Rec X. X . (((\x: Unit .\y: Nat .x) true ) false) )) )) ) (( \f: Unit .((f (fix (\x: Nat . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) )) ) (((\x: Bool .\y: Unit .x) (fix (\x: Rec X. X . true )) ) false) ) ) (\a: Bool .\b: Rec X. X .a))) , b = (( \f: Rec X. X .((f (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in u) ) (let u = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) in u) ) ) (\a: Nat .\b: Nat .b)) }.b)
(let u = ({a = (let u = (if (((\x: Unit .\y: Unit .y) false ) false) then 0 else ({a = 0 , b = false , c = 0 }.c)) in ({a = 0 , b = 1 }.b)) , b = (let u = (case <l = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a))) , c =  (( \f: Bool .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Bool ] (fold [ Rec X. X ] 0 )) , b = (let u = 0 in 0) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) in ({a = ({a = ({a = 1 , b = (if true then false else false) , c = 0 }.c) , b = (iszero ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = false }.a)) , c =  (( \f: Nat .((f (fix (\x: Bool . 0 )) ) 1 ) ) (\a: Nat .\b: Nat .a)) }.b) , b = (((\x: Rec X. X .\y: Unit .x) (let u = 0 in (pred 1)) ) ({a = true , b = false }.b)) }.b))
({a = (fix (\x: Rec X. X . (let u = 0 in false) )) , b = ({a = (let u = ({a = false , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .a)) }.b) in ({a = 0 , b = 1 }.b)) , b = (((\x: Bool .\y: Nat .x) (iszero 0) ) (let u = ({a = true , b = true }.b) in u)) }.b) }.b)
(fix (\x: Bool . (let u = (iszero (if true then (let u = 1 in u) else (if true then 0 else 1))) in u) ))
(( \f: Nat .((f ({a = (if ({a = 0 , b = false }.b) then (let u = (let u = true in u) in false) else (( \f: Nat .((f (fix (\x: Rec X. X . false )) ) false ) ) (\a: Nat .\b: Rec X. X .b))) , b = (( \f: Nat .((f (( \f: Rec X. X .((f ({a = 0 , b = true , c = 0 }.c) ) 1 ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Unit .\y: Unit .y) false ) 1) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) (if (unfold [ Unit ] (fold [ Rec X. X ] false )) then (((\x: Rec X. X .\y: Unit .x) ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = 1 }.b) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = true , c =  0 }.b) ))) else (let u = (let u = true in true) in 1)) ) ) (\a: Rec X. X .\b: Bool .a))
({a = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) false ) false) )) , c = (if (case <r = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) > as Nat of < l = x > => x | < r = y > => y) then (if true then 0 else 1) else ({a = 1 , b = 1 }.b)) }.c) , b = ({a = (succ ({a = true , b = 0 }.b)) , b = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) (unfold [ Bool ] (fold [ Bool ] 1 ))) }.b) }.b)
(((\x: Nat .\y: Rec X. X .y) (let u = (let u = (fix (\x: Rec X. X . true )) in ({a = (succ 0) , b = ({a = 0 , b = false , c =  0 }.b) , c =  1 }.b)) in u) ) (fix (\x: Unit . (unfold [ Nat ] (fold [ Bool ] (let u = false in 0) )) )))
((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (if (( \f: Bool .((f (let u = (if true then false else false) in u) ) (((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = true in u)) ) ) (\a: Nat .\b: Bool .a)) then (( \f: Bool .((f ({a = false , b = false }.b) ) (( \f: Unit .((f (iszero 0) ) true ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Bool .b)) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (if false then false else true) ))) ))
({a = (( \f: Unit .((f (( \f: Bool .((f ({a = 1 , b = false , c = 0 }.c) ) 1 ) ) (\a: Unit .\b: Unit .a)) ) (fix (\x: Unit . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Nat .a)) , b = (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) (let u = (fix (\x: Bool . false )) in ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false ))) ) (iszero (pred 0))) )) , c = ({a = ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (let u = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.a) }.c)
({a = (let u = (let u = (case <l = (if false then 1 else 1) > as Bool of < l = x > => x | < r = y > => y) in (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) in 0)) in ({a = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Nat .a)) , b = ({a = (((\x: Unit .\y: Rec X. X .x) 0 ) false) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , c = 1 }.c) }.a)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] true )) )) , b = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = (iszero 1) }.b) }.b) )) }.b)
(unfold [ Nat ] (fold [ Unit ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .y) false ) ({a = 0 , b = true }.b)) )) ))
(( \f: Bool .((f (pred ({a = (let u = true in true) , b = 1 }.b)) ) (( \f: Bool .((f (( \f: Unit .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] 0 )) )) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = (let u = 1 in u) , b = false }.a) ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Bool .b))
(pred ({a = (let u = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) , b = (let u = 0 in u) }.a) in (let u = (unfold [ Bool ] (fold [ Bool ] 1 )) in (let u = false in true))) , b = ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.c) }.b))
(case <l = ({a = (( \f: Bool .((f (pred 1) ) (fix (\x: Bool . 0 )) ) ) (\a: Nat .\b: Unit .a)) , b = (fix (\x: Unit . (( \f: Bool .((f true ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) )) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Unit .((f ({a = (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] false )) )) , b = ({a = (fix (\x: Rec X. X . (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) )) , b = ({a = false , b = 0 }.a) }.a) }.a) ) (let u = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (let u = false in u) , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) , c =  (( \f: Unit .((f (fix (\x: Rec X. X . 1 )) ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) in ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) }.b)) ) ) (\a: Unit .\b: Rec X. X .a))
(let u = (iszero (((\x: Bool .\y: Nat .x) 0 ) false)) in u)
({a = (case <l = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = 1 , b = true }.a) , b = false , c = 1 }.c) )) > as Bool of < l = x > => x | < r = y > => y) , b = (if (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) (let u = (((\x: Unit .\y: Unit .x) true ) false) in false) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) ) (if (let u = true in false) then (if true then true else true) else (let u = ({a = 0 , b = 1 }.b) in (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a))))) then ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = true , b = true }.b) )) else (let u = (let u = (if false then 1 else 1) in true) in (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b))))) , c =  (( \f: Unit .((f (let u = (let u = false in u) in (let u = false in 1)) ) (succ (succ ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
(let u = ({a = ({a = (((\x: Bool .\y: Bool .x) 0 ) false) , b = ({a = 0 , b = false , c =  1 }.b) , c = ({a = false , b = 1 }.b) }.c) , b = (let u = (let u = true in true) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) }.a) in (((\x: Unit .\y: Rec X. X .x) (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) in (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .b))) ) (if (( \f: Bool .((f ({a = true , b = 1 }.a) ) (let u = false in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] true )) else (((\x: Rec X. X .\y: Nat .y) false ) true))))
(let u = (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) ) (case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) in (let u = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) , b = true , c = (succ 0) }.c) in (succ (if false then ({a = 0 , b = true , c = 0 }.c) else ({a = 0 , b = false }.a)))))
(if (((\x: Rec X. X .\y: Unit .y) ({a = ({a = (let u = false in true) , b = ({a = 1 , b = 1 }.b) }.b) , b = ({a = 1 , b = false }.b) }.b) ) ({a = (iszero 1) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b)) then (if (fix (\x: Bool . (unfold [ Unit ] (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) true ) true) )) )) then (((\x: Bool .\y: Nat .y) ({a = 1 , b = false }.b) ) true) else (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = true , b = 1 }.a) else ({a = (if true then true else true) , b = false }.b))) else (if (let u = (( \f: Unit .((f true ) (let u = false in false) ) ) (\a: Bool .\b: Bool .b)) in (unfold [ Bool ] (fold [ Bool ] (( \f: Rec X. X .((f false ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ))) then (fix (\x: Unit . (((\x: Nat .\y: Nat .x) false ) (if false then true else true)) )) else ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) true) , b = (fix (\x: Nat . false )) }.b)))
({a = (if (let u = (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) ) ) (\a: Nat .\b: Rec X. X .a)) in (( \f: Unit .((f false ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Bool .\b: Rec X. X .b))) then ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = (if ({a = true , b = 0 }.a) then false else false) }.a) else (let u = (if (let u = true in true) then 0 else 1) in u)) , b = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] (if true then false else false) )) )) in u) , c = (( \f: Nat .((f ({a = (let u = 1 in true) , b = (succ 1) }.b) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (pred 1) )) ) ) (\a: Unit .\b: Unit .b)) }.c)
({a = (fix (\x: Rec X. X . (fix (\x: Bool . (if true then 0 else 0) )) )) , b = ({a = (let u = (unfold [ Bool ] (fold [ Bool ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) in (if (((\x: Nat .\y: Rec X. X .x) false ) false) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) else ({a = 1 , b = (let u = 1 in false) }.b))) , b = (let u = ({a = (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Nat ] 1 )) )) , b = (let u = false in u) }.a) in ({a = (let u = false in 1) , b = (( \f: Bool .((f true ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) }.b)) }.b) }.b)
(let u = (if ({a = ({a = (succ 0) , b = ({a = 1 , b = false }.b) , c =  ({a = 0 , b = false }.a) }.b) , b = ({a = (let u = 1 in 1) , b = (let u = 1 in true) , c =  0 }.b) }.b) then (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Bool .y) (((\x: Nat .\y: Nat .y) (let u = 0 in true) ) true) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true ))) ) (let u = ({a = 1 , b = false }.b) in u)) else (let u = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) in (((\x: Bool .\y: Bool .x) true ) true)) in u)) in ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = 1 in 0) )) , b = (let u = ({a = ({a = false , b = false }.b) , b = (fix (\x: Unit . 0 )) }.a) in (let u = (let u = false in false) in true)) , c =  (((\x: Rec X. X .\y: Nat .x) (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) ) (let u = false in u)) }.b))
(succ (if (iszero (((\x: Nat .\y: Bool .x) 0 ) false)) then (( \f: Rec X. X .((f (if ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) false) , b = false }.b) then ({a = ({a = false , b = 0 }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) , c = 1 }.c) else (if false then 1 else 1)) ) ({a = (pred ({a = 1 , b = 1 }.b)) , b = (succ 1) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) else (unfold [ Unit ] (fold [ Rec X. X ] (if ({a = true , b = 1 }.a) then ({a = 1 , b = true , c = 1 }.c) else 0) ))))
(iszero ({a = (let u = (( \f: Rec X. X .((f (pred 1) ) (let u = false in 0) ) ) (\a: Rec X. X .\b: Unit .b)) in u) , b = (let u = (fix (\x: Rec X. X . true )) in 0) }.b))
({a = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) )) in (if (iszero (pred 1)) then (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) (if false then (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) else false)) else ({a = (let u = true in 1) , b = false , c =  (let u = 0 in 1) }.b))) , b = (let u = (((\x: Bool .\y: Rec X. X .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Unit .x) true ) false)) in (((\x: Bool .\y: Bool .x) (((\x: Nat .\y: Bool .y) false ) false) ) (iszero 1))) }.b)
(case <r = (if (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Unit . false )) )) then (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) else ({a = ({a = false , b = 1 }.a) , b = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in true) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Unit ] (let u = (((\x: Unit .\y: Bool .x) (if (fix (\x: Rec X. X . ({a = 1 , b = true , c =  1 }.b) )) then ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = (((\x: Bool .\y: Nat .x) true ) true) }.b) else (let u = (((\x: Unit .\y: Rec X. X .x) true ) true) in u)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Nat .x) true ) true) ))) in u) ))
({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (succ 0) )) , b = (case <r = (if false then false else (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a))) > as Unit of < l = x > => x | < r = y > => y) , c = (((\x: Nat .\y: Nat .x) (unfold [ Nat ] (fold [ Nat ] 0 )) ) (iszero (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) }.c) , b = (let u = (case <l = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (fix (\x: Nat . 0 )) in u) )) > as Unit of < l = x > => x | < r = y > => y) in (( \f: Bool .((f ({a = ({a = 0 , b = false }.a) , b = false , c =  0 }.b) ) (let u = (fix (\x: Nat . false )) in true) ) ) (\a: Bool .\b: Nat .b))) }.a)
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero (( \f: Unit .((f ({a = true , b = 1 }.b) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))) ))
(if ({a = (( \f: Bool .((f ({a = 1 , b = false }.a) ) ({a = false , b = ({a = 0 , b = false }.a) }.b) ) ) (\a: Bool .\b: Nat .a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) (iszero 1)) )) , c =  (( \f: Bool .((f (let u = true in 0) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) then (fix (\x: Unit . ({a = (fix (\x: Nat . (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) )) , b = (((\x: Rec X. X .\y: Unit .y) ({a = 1 , b = false , c =  0 }.b) ) ({a = false , b = true }.b)) }.b) )) else ({a = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = (((\x: Bool .\y: Bool .y) false ) false) , c =  1 }.b) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .a)) in (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a))) }.b))
(case <l = (fix (\x: Nat . (fix (\x: Rec X. X . ({a = (let u = 1 in false) , b = (pred 1) }.b) )) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(succ ({a = ({a = (( \f: Rec X. X .((f (let u = false in u) ) (iszero 0) ) ) (\a: Unit .\b: Nat .a)) , b = (if (let u = ({a = 1 , b = false , c = 1 }.c) in (if false then true else true)) then ({a = 0 , b = true , c =  ({a = true , b = 1 }.b) }.b) else (( \f: Unit .((f ({a = true , b = 0 }.a) ) (fix (\x: Rec X. X . false )) ) ) (\a: Bool .\b: Unit .a))) }.b) , b = (((\x: Bool .\y: Unit .x) ({a = ({a = 1 , b = (fix (\x: Bool . 0 )) }.b) , b = (let u = true in u) }.a) ) (((\x: Bool .\y: Unit .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) true))) }.b))
(let u = ({a = (fix (\x: Bool . (( \f: Bool .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) in (unfold [ Nat ] (fold [ Nat ] false ))) ) ) (\a: Unit .\b: Rec X. X .b)) )) , b = (case <l = ({a = (succ 1) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) true) }.a) > as Bool of < l = x > => x | < r = y > => y) }.a) in u)
(unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Rec X. X ] ({a = (let u = true in 0) , b = ({a = 1 , b = false , c =  ({a = 1 , b = 0 }.b) }.b) , c = (let u = false in 1) }.c) )) ))
(succ (fix (\x: Bool . ({a = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) , b = (case <l = ({a = 1 , b = true , c = 1 }.c) > as Nat of < l = x > => x | < r = y > => y) }.b) )))
(fix (\x: Nat . (( \f: Bool .((f ({a = (if true then false else true) , b = (if (if false then true else true) then false else (((\x: Rec X. X .\y: Bool .x) true ) false)) }.b) ) (unfold [ Unit ] (fold [ Unit ] false )) ) ) (\a: Bool .\b: Unit .a)) ))
(let u = (((\x: Bool .\y: Bool .y) (unfold [ Bool ] (fold [ Nat ] (let u = false in u) )) ) (iszero 0)) in (unfold [ Bool ] (fold [ Unit ] (let u = ({a = false , b = 1 }.a) in (if false then true else false)) )))
(let u = (fix (\x: Nat . (fix (\x: Rec X. X . (case <l = ({a = 1 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) )) )) in ({a = (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = false }.b) )) , b = (let u = 1 in 0) }.a))
(if (((\x: Unit .\y: Rec X. X .x) (if (if false then true else true) then (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .b)) else ({a = 0 , b = false }.b)) ) (( \f: Unit .((f ({a = ({a = ({a = true , b = true }.b) , b = (fix (\x: Nat . 1 )) }.a) , b = (( \f: Nat .((f (iszero 1) ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) (( \f: Nat .((f (let u = ({a = true , b = false }.b) in u) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .a))) then (((\x: Unit .\y: Unit .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (if true then 0 else 0) , b = true , c =  (let u = true in 0) }.b) )) ) ({a = true , b = true }.b)) else (if (let u = (fix (\x: Rec X. X . (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) in ({a = 0 , b = true }.b)) then (let u = (((\x: Bool .\y: Unit .y) true ) 1) in (case <r = (let u = 1 in false) > as Bool of < l = x > => x | < r = y > => y)) else (iszero 0)))
({a = ({a = (let u = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = false }.a) in ({a = 0 , b = true , c = ({a = true , b = 1 }.b) }.c)) , b = ({a = ({a = true , b = true }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) }.a) , c = (pred ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = 0 in u) ))) }.c) , b = (pred ({a = ({a = 1 , b = 0 }.b) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = ({a = 0 , b = false , c =  1 }.b) }.b) , c = (succ 0) }.c)) }.b)
(((\x: Rec X. X .\y: Rec X. X .y) (let u = (let u = ({a = 0 , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) , c =  (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) in u) in u) ) ({a = (pred (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) , b = (((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a)) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.b))
(let u = ({a = (let u = (( \f: Bool .((f 1 ) (let u = 1 in u) ) ) (\a: Nat .\b: Unit .a)) in (unfold [ Rec X. X ] (fold [ Nat ] 0 ))) , b = (if (((\x: Unit .\y: Bool .y) false ) false) then ({a = true , b = 1 }.a) else (unfold [ Unit ] (fold [ Bool ] false ))) , c = (( \f: Rec X. X .((f (pred (let u = true in 0)) ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Bool .a)) }.c) in (((\x: Nat .\y: Rec X. X .y) ({a = ({a = false , b = 1 }.a) , b = ({a = false , b = true }.b) }.b) ) (( \f: Bool .((f ({a = true , b = false }.b) ) (fix (\x: Rec X. X . false )) ) ) (\a: Bool .\b: Bool .a))))
(let u = (let u = (pred (let u = (let u = 1 in 1) in u)) in u) in (((\x: Unit .\y: Rec X. X .x) ({a = ({a = false , b = (let u = true in 1) }.a) , b = (fix (\x: Bool . 0 )) }.b) ) (if true then false else (if false then true else true))))
(((\x: Rec X. X .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = ({a = false , b = false }.b) }.b) )) ) (if ({a = ({a = false , b = 1 }.b) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) , c =  (( \f: Bool .((f (let u = 0 in u) ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Unit .b)) }.b) then ({a = ({a = false , b = false }.b) , b = (unfold [ Bool ] (fold [ Unit ] false )) }.b) else ({a = (iszero 1) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a)))
(let u = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Nat .((f 0 ) (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .b)) }.a) in u)
(unfold [ Unit ] (fold [ Nat ] (if (let u = (((\x: Bool .\y: Unit .x) true ) false) in (iszero 1)) then (( \f: Rec X. X .((f (fix (\x: Rec X. X . (if true then true else false) )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) else (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b))) ))
(case <l = ({a = (fix (\x: Nat . ({a = 1 , b = 1 }.b) )) , b = (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) > as Nat of < l = x > => x | < r = y > => y) }.a) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (iszero (((\x: Bool .\y: Bool .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . 0 )))) ) (( \f: Unit .((f (case <r = ({a = 1 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Bool ] ({a = false , b = 1 }.a) )) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Bool .\b: Rec X. X .b))
(pred (let u = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = 1 , b = true , c = 0 }.c) )) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) in (case <l = (if (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = true }.b) )) then (unfold [ Bool ] (fold [ Rec X. X ] 0 )) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 ))) > as Rec X. X of < l = x > => x | < r = y > => y)))
(( \f: Bool .((f (case <l = (let u = (unfold [ Nat ] (fold [ Bool ] 1 )) in ({a = true , b = 0 }.b)) > as Unit of < l = x > => x | < r = y > => y) ) (pred (case <l = (((\x: Rec X. X .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) (let u = 0 in u)) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .a))
({a = (let u = (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = false }.a) )) in (let u = (fix (\x: Unit . false )) in u)) , b = ({a = (iszero ({a = (succ 1) , b = (fix (\x: Rec X. X . 0 )) }.b)) , b = (((\x: Rec X. X .\y: Unit .y) (iszero (let u = 0 in (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)))) ) (succ (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)))) }.a) }.b)
(((\x: Rec X. X .\y: Nat .x) (if (iszero (succ 1)) then (((\x: Unit .\y: Bool .x) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .b)) ) (let u = true in u)) else (( \f: Bool .((f true ) (if true then true else true) ) ) (\a: Unit .\b: Nat .b))) ) (((\x: Bool .\y: Nat .x) (let u = false in true) ) ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) true) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = 1 , b = false }.a) }.b)))
(((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) (( \f: Rec X. X .((f (fix (\x: Rec X. X . true )) ) (iszero 0) ) ) (\a: Nat .\b: Unit .b)) ) (( \f: Rec X. X .((f false ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Nat .\b: Bool .a))) ) (let u = (iszero ({a = (let u = true in u) , b = (((\x: Bool .\y: Rec X. X .x) 1 ) false) }.b)) in (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true )) in (unfold [ Unit ] (fold [ Unit ] false )))) ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (if (fix (\x: Nat . (iszero 1) )) then ({a = 1 , b = true }.b) else ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) , c =  1 }.b)) , b = ({a = (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (case <r = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b))
(fix (\x: Bool . (unfold [ Nat ] (fold [ Bool ] (case <r = (( \f: Rec X. X .((f true ) (((\x: Unit .\y: Unit .x) true ) true) ) ) (\a: Nat .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) )) ))
(pred ({a = ({a = (let u = 0 in u) , b = (((\x: Unit .\y: Unit .y) false ) false) }.a) , b = ({a = (case <r = (unfold [ Bool ] (fold [ Rec X. X ] true )) > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Bool . false )) )) }.b) }.a))
(( \f: Unit .((f (((\x: Unit .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Unit ] ({a = true , b = (pred 1) }.a) )) ) (let u = (((\x: Bool .\y: Rec X. X .y) false ) true) in u)) ) (fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Nat .\y: Rec X. X .x) false ) true) ) ({a = false , b = true }.b)) )) ) ) (\a: Nat .\b: Bool .a))
(((\x: Rec X. X .\y: Bool .x) ({a = ({a = (unfold [ Unit ] (fold [ Nat ] (let u = 0 in u) )) , b = (if false then 0 else 0) }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Bool ] false )) )) , c =  (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .x) 1 ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] false ))) ) (( \f: Nat .((f ({a = 0 , b = false , c = 1 }.c) ) 1 ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) in ({a = false , b = false }.b)) > as Nat of < l = x > => x | < r = y > => y) )))
(fix (\x: Bool . (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) false ) (((\x: Unit .\y: Unit .x) false ) false)) )) ))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (pred (( \f: Unit .((f ({a = false , b = 1 }.b) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Bool .b))) ))
({a = (if (iszero ({a = (let u = 1 in 1) , b = true }.a)) then (succ (if (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .b)) then (let u = 0 in u) else 0)) else (succ (if ({a = 0 , b = ({a = false , b = 1 }.a) , c =  1 }.b) then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else (unfold [ Nat ] (fold [ Rec X. X ] 0 ))))) , b = ({a = (let u = (((\x: Rec X. X .\y: Unit .x) 1 ) true) in (let u = true in 1)) , b = (unfold [ Nat ] (fold [ Bool ] ({a = false , b = 1 }.a) )) }.b) , c =  (let u = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) false) )) in (pred ({a = 0 , b = 0 }.b))) }.b)
({a = (((\x: Bool .\y: Unit .x) (let u = (let u = false in false) in (let u = true in true)) ) (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = (((\x: Nat .\y: Unit .y) false ) true) }.b) ) ({a = (((\x: Rec X. X .\y: Bool .x) false ) false) , b = (if true then false else true) }.b))) , b = ({a = (case <r = (((\x: Rec X. X .\y: Nat .y) ({a = true , b = 1 }.a) ) (( \f: Unit .((f false ) (if true then false else false) ) ) (\a: Nat .\b: Bool .b))) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (pred ({a = true , b = 0 }.b)) }.a) }.b)
(let u = (((\x: Nat .\y: Bool .x) ({a = ({a = 1 , b = false , c =  0 }.b) , b = 1 }.a) ) (((\x: Rec X. X .\y: Bool .y) ({a = false , b = 1 }.a) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 1 , b = true }.b) )))) in ({a = (let u = (let u = false in 1) in true) , b = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) }.b))
(succ (fix (\x: Unit . (case <l = (let u = (iszero 0) in (unfold [ Nat ] (fold [ Bool ] 0 ))) > as Bool of < l = x > => x | < r = y > => y) )))
(( \f: Bool .((f ({a = ({a = (((\x: Rec X. X .\y: Bool .x) 1 ) false) , b = (fix (\x: Unit . false )) }.b) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.a) ) (((\x: Bool .\y: Nat .y) (( \f: Bool .((f (if (((\x: Bool .\y: Rec X. X .y) false ) false) then true else (unfold [ Rec X. X ] (fold [ Nat ] true ))) ) (let u = true in u) ) ) (\a: Rec X. X .\b: Unit .a)) ) (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Unit .b))
(((\x: Rec X. X .\y: Bool .y) (let u = (fix (\x: Unit . (let u = ({a = false , b = 0 }.a) in (let u = false in false)) )) in u) ) (let u = (pred (((\x: Unit .\y: Unit .y) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .b)) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)))) in (succ 0)))
(let u = (let u = (let u = (fix (\x: Unit . 1 )) in u) in (case <r = ({a = 0 , b = false }.b) > as Bool of < l = x > => x | < r = y > => y)) in ({a = (if (case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = false in 1) else (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) , b = ({a = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a)) , b = (iszero 1) }.b) }.b))
(let u = (( \f: Bool .((f (( \f: Nat .((f ({a = 1 , b = true , c = 1 }.c) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in 1) )) ) ) (\a: Nat .\b: Bool .b)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = true in 0) )) ) ) (\a: Unit .\b: Rec X. X .b)) in (let u = (pred ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .y) false ) 1) ))) in u))
(((\x: Unit .\y: Unit .x) (iszero (pred 0)) ) (if ({a = (let u = 0 in false) , b = 1 }.a) then (( \f: Nat .((f (let u = 1 in true) ) false ) ) (\a: Unit .\b: Bool .a)) else (fix (\x: Unit . (iszero 0) ))))
(( \f: Nat .((f (if (fix (\x: Rec X. X . (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .a)) )) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) 1) )) else ({a = (((\x: Nat .\y: Bool .x) false ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) }.b)) ) (let u = (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) in ({a = 1 , b = ({a = false , b = true }.b) , c = 1 }.c)) ) ) (\a: Unit .\b: Rec X. X .a))
(let u = (let u = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = false , b = 1 }.b) in u) }.b) in u) in (( \f: Unit .((f (((\x: Unit .\y: Nat .y) (iszero ({a = 0 , b = true }.a)) ) (pred (let u = true in 1))) ) (((\x: Rec X. X .\y: Nat .y) ({a = false , b = 0 }.a) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Rec X. X .a)))
(if ({a = (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] ({a = true , b = 1 }.a) )) )) , b = ({a = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (((\x: Nat .\y: Bool .y) false ) false) }.b) , b = ({a = false , b = 1 }.b) }.a) }.b) then (let u = (unfold [ Rec X. X ] (fold [ Unit ] (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in ({a = 1 , b = true , c =  0 }.b)) )) in (((\x: Unit .\y: Bool .x) ({a = 1 , b = false }.a) ) ({a = true , b = 0 }.a))) else (let u = ({a = (( \f: Nat .((f ({a = 1 , b = false , c = 0 }.c) ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = (unfold [ Bool ] (fold [ Unit ] false )) }.a) in u))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .x) (iszero (( \f: Nat .((f (if (((\x: Nat .\y: Nat .x) false ) true) then ({a = 1 , b = 0 }.b) else (((\x: Unit .\y: Bool .y) true ) 1)) ) (if false then 0 else 1) ) ) (\a: Bool .\b: Bool .b))) ) (let u = (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) in (let u = (fix (\x: Nat . false )) in u))) ))
(if (((\x: Rec X. X .\y: Rec X. X .x) ({a = (( \f: Rec X. X .((f 0 ) (let u = false in 1) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = 0 , b = true , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) }.b) ) (let u = (if (((\x: Rec X. X .\y: Rec X. X .y) false ) false) then (iszero 0) else (if (((\x: Bool .\y: Bool .y) false ) true) then false else (iszero 0))) in (unfold [ Bool ] (fold [ Rec X. X ] (let u = 0 in true) )))) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) )) else (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) ({a = true , b = false }.b) ) (case <r = (case <r = true > as Nat of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)) ) (case <r = (unfold [ Rec X. X ] (fold [ Bool ] false )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)))
(( \f: Unit .((f ({a = (case <l = ({a = 0 , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) }.b) ) (let u = (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = ({a = 0 , b = true }.b) }.a) ) (let u = (((\x: Nat .\y: Bool .x) 1 ) true) in (((\x: Nat .\y: Rec X. X .x) true ) true))) in u) ) ) (\a: Bool .\b: Bool .a))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a)) then (pred (fix (\x: Unit . 0 ))) else (unfold [ Bool ] (fold [ Bool ] 0 ))) in (succ (((\x: Bool .\y: Nat .x) ({a = true , b = 0 }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))))) ))
(unfold [ Nat ] (fold [ Bool ] (let u = ({a = ({a = (unfold [ Unit ] (fold [ Bool ] 0 )) , b = (let u = 1 in false) , c = (let u = 1 in u) }.c) , b = (( \f: Unit .((f 1 ) (succ 1) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) in ({a = 0 , b = true , c = 1 }.c)) ))
(if ({a = (fix (\x: Unit . ({a = (let u = 0 in 0) , b = 0 }.b) )) , b = (fix (\x: Bool . (((\x: Bool .\y: Unit .x) true ) false) )) }.b) then (if (( \f: Bool .((f (fix (\x: Unit . false )) ) (((\x: Rec X. X .\y: Nat .x) (iszero 1) ) false) ) ) (\a: Bool .\b: Unit .a)) then (( \f: Nat .((f (((\x: Bool .\y: Nat .y) (let u = false in false) ) true) ) (let u = false in false) ) ) (\a: Nat .\b: Nat .b)) else (let u = (let u = false in true) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )))) else (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) true ) false) )) in (((\x: Nat .\y: Bool .y) (iszero 0) ) (let u = ({a = true , b = true }.b) in (let u = 1 in true)))))
({a = (case <l = (((\x: Bool .\y: Nat .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) ({a = 0 , b = false }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] (let u = true in u) )) )) , c =  ({a = (fix (\x: Nat . (succ 0) )) , b = (let u = (( \f: Nat .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) in (fix (\x: Nat . 0 ))) }.b) }.b)
(iszero (let u = (((\x: Unit .\y: Nat .x) 1 ) (let u = false in u)) in u))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f ({a = (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = true }.b) )) , b = (unfold [ Unit ] (fold [ Bool ] (let u = 1 in u) )) }.a) ) (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Nat .\y: Unit .y) false ) true) )) ) (fix (\x: Unit . (case <r = (((\x: Nat .\y: Unit .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Bool .a)) ))
({a = ({a = (( \f: Rec X. X .((f (case <l = (unfold [ Bool ] (fold [ Bool ] (let u = 1 in u) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = false , b = (succ 1) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (if ({a = false , b = 1 }.a) then (let u = true in true) else ({a = true , b = 0 }.a)) , c =  (succ (unfold [ Nat ] (fold [ Bool ] 1 ))) }.b) , b = (( \f: Bool .((f (fix (\x: Nat . (((\x: Nat .\y: Nat .x) (fix (\x: Nat . 1 )) ) ({a = true , b = 0 }.a)) )) ) (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = 1 }.b) )) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(fix (\x: Bool . (let u = (fix (\x: Unit . (fix (\x: Unit . ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) )) )) in u) ))
(case <r = (unfold [ Nat ] (fold [ Unit ] (if (unfold [ Unit ] (fold [ Nat ] false )) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) else true) )) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Nat .y) ({a = (((\x: Rec X. X .\y: Unit .y) (let u = false in u) ) (case <r = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y)) , b = (iszero 0) }.b) ) (case <l = (pred (let u = 0 in u)) > as Bool of < l = x > => x | < r = y > => y))
(fix (\x: Unit . (let u = (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u) in (case <l = (if (if false then false else false) then 1 else 0) > as Rec X. X of < l = x > => x | < r = y > => y)) ))
({a = (case <l = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] 1 )) )) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (if (let u = false in false) then (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) else (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = (((\x: Bool .\y: Unit .y) (let u = 0 in true) ) (let u = ({a = 0 , b = true }.b) in u)) in ({a = (pred 0) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .b)) }.a)) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)
(((\x: Bool .\y: Rec X. X .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (let u = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) }.b) in (((\x: Bool .\y: Unit .x) (iszero 1) ) ({a = (((\x: Nat .\y: Rec X. X .y) false ) false) , b = 0 }.a))) )) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (fix (\x: Rec X. X . (succ 1) )) in (((\x: Rec X. X .\y: Bool .x) false ) false)) )))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = 0 , b = 0 }.b) , b = false }.a) )) , b = ({a = ({a = 1 , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (fix (\x: Bool . true )) in (pred (let u = 1 in u))) ))
(let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) ({a = false , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a)) }.b) ) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a))) )) in u)
({a = (( \f: Rec X. X .((f ({a = ({a = 0 , b = true }.b) , b = 1 }.b) ) (fix (\x: Unit . (let u = 0 in 1) )) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (let u = (iszero 0) in u) }.b)
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) , b = (((\x: Rec X. X .\y: Nat .y) false ) false) }.b) in (fix (\x: Rec X. X . ({a = (let u = 1 in u) , b = 0 }.b) ))) ))
({a = (((\x: Unit .\y: Rec X. X .y) (iszero 0) ) (let u = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (if true then 1 else 0) )))) , b = (( \f: Unit .((f ({a = 1 , b = true }.b) ) (if ({a = (fix (\x: Nat . true )) , b = false }.b) then (let u = false in u) else ({a = false , b = true }.b)) ) ) (\a: Bool .\b: Nat .a)) }.b)
(let u = (let u = (let u = (fix (\x: Unit . true )) in (((\x: Bool .\y: Bool .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true )) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)))) in (let u = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = (let u = 1 in u) }.b) in (pred 0))) in u)
(((\x: Unit .\y: Nat .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f 1 ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Bool .a)) )) ) ({a = (((\x: Unit .\y: Rec X. X .x) (if true then false else false) ) (( \f: Rec X. X .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ({a = true , b = 1 }.a) ) ) (\a: Nat .\b: Nat .a))) , b = (((\x: Rec X. X .\y: Bool .x) (let u = 0 in u) ) (case <r = ({a = false , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y)) }.a))
(case <l = (let u = (let u = 1 in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) in (if (iszero 0) then (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) else (fix (\x: Unit . 1 )))) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) ({a = (((\x: Bool .\y: Unit .y) true ) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .a))) , b = (if (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) then ({a = 0 , b = false }.a) else 1) }.a) ) ({a = (let u = true in 0) , b = ({a = (let u = 1 in false) , b = ({a = 1 , b = false }.a) }.a) }.b)) ) (((\x: Nat .\y: Rec X. X .x) (if (let u = (let u = true in u) in u) then (( \f: Bool .((f (let u = false in true) ) (((\x: Bool .\y: Nat .y) true ) true) ) ) (\a: Nat .\b: Rec X. X .b)) else (unfold [ Unit ] (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] false )) ))) ) (( \f: Unit .((f (fix (\x: Nat . false )) ) (((\x: Unit .\y: Nat .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = false }.b) )) ) (let u = false in true)) ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Unit .\b: Unit .a))
(fix (\x: Bool . (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Rec X. X . ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = 0 }.b) )) )) )) ))
(pred (( \f: Nat .((f (( \f: Nat .((f (fix (\x: Unit . (unfold [ Nat ] (fold [ Rec X. X ] 1 )) )) ) ({a = (((\x: Bool .\y: Unit .y) (iszero 1) ) (unfold [ Bool ] (fold [ Unit ] 0 ))) , b = (fix (\x: Rec X. X . false )) }.a) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (succ (let u = 1 in 1)) , b = (( \f: Rec X. X .((f (pred 0) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) ) (\a: Nat .\b: Unit .b)) }.b) ) ) (\a: Unit .\b: Rec X. X .a)))
(succ (((\x: Unit .\y: Bool .y) (( \f: Bool .((f (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .a)) ) (case <r = (((\x: Rec X. X .\y: Nat .x) false ) true) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) ) (((\x: Unit .\y: Nat .y) ({a = false , b = false }.b) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)))))
({a = (( \f: Unit .((f (unfold [ Bool ] (fold [ Nat ] (((\x: Unit .\y: Unit .y) false ) false) )) ) (let u = 1 in (let u = 0 in false)) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = (case <r = ({a = true , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) in u) }.b)
(unfold [ Nat ] (fold [ Nat ] (let u = (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] 0 )) )) in (unfold [ Bool ] (fold [ Unit ] (fix (\x: Bool . 0 )) ))) ))
(iszero (pred ({a = (let u = true in (let u = true in false)) , b = (case <l = (let u = 0 in 1) > as Unit of < l = x > => x | < r = y > => y) }.b)))
({a = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = ({a = ({a = true , b = 1 }.b) , b = true }.b) , b = (pred 1) }.b) )) , b = (case <r = (case <r = true > as Bool of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , c = (let u = (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y) in u) }.c) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .y) (fix (\x: Nat . (let u = 1 in true) )) ) (((\x: Unit .\y: Unit .y) false ) false)) )) }.b)
(succ (((\x: Rec X. X .\y: Nat .y) (let u = (( \f: Bool .((f (((\x: Bool .\y: Nat .x) true ) false) ) true ) ) (\a: Unit .\b: Rec X. X .b)) in u) ) (case <l = (((\x: Nat .\y: Rec X. X .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) (if true then 0 else 0)) > as Unit of < l = x > => x | < r = y > => y)))
(case <l = (((\x: Unit .\y: Unit .x) (((\x: Rec X. X .\y: Unit .x) (let u = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) in (((\x: Unit .\y: Nat .y) false ) ({a = false , b = 0 }.b))) ) (if (((\x: Nat .\y: Bool .x) false ) ({a = true , b = 1 }.a)) then ({a = true , b = true }.b) else (let u = 0 in false))) ) ({a = (let u = ({a = true , b = 0 }.a) in u) , b = (( \f: Bool .((f 1 ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a)) > as Bool of < l = x > => x | < r = y > => y)
(let u = ({a = (let u = (( \f: Nat .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Nat .\y: Nat .y) true ) ({a = 0 , b = true , c = 0 }.c)) ) ) (\a: Bool .\b: Rec X. X .b)) in u) , b = (( \f: Nat .((f ({a = false , b = (let u = true in 0) }.a) ) (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) true ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true ))) ) (((\x: Rec X. X .\y: Bool .x) true ) ({a = 0 , b = true , c =  0 }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .a)) }.a) in ({a = ({a = 1 , b = ({a = 0 , b = false , c =  1 }.b) , c = ({a = 1 , b = 0 }.b) }.c) , b = (unfold [ Nat ] (fold [ Nat ] (succ 1) )) }.b))
({a = (case <r = ({a = (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true ))) , b = (iszero (let u = false in 0)) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = false in 1)) )) }.b)
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = (fix (\x: Bool . false )) , b = (if false then 0 else 1) }.a) )) ))
({a = (( \f: Unit .((f (fix (\x: Rec X. X . 0 )) ) (case <l = ({a = (let u = 1 in u) , b = ({a = false , b = true }.b) }.a) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (let u = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Unit .y) false ) 0) )) , b = (( \f: Unit .((f (let u = true in true) ) (let u = 1 in true) ) ) (\a: Bool .\b: Bool .b)) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 1 )) }.b) in ({a = (fix (\x: Bool . 0 )) , b = (fix (\x: Unit . true )) }.b)) }.b)
({a = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f (succ 0) ) (let u = 1 in 1) ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] true )) in (if true then 0 else 1)) in u) }.b) , b = (((\x: Unit .\y: Nat .y) ({a = (((\x: Unit .\y: Nat .x) true ) true) , b = (if ({a = 1 , b = false , c =  0 }.b) then ({a = 1 , b = false , c =  0 }.b) else true) }.b) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b))) }.b)
(if (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 1 , b = (let u = true in false) }.b) )) in u) then (((\x: Rec X. X .\y: Nat .x) (succ ({a = 1 , b = 1 }.b)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) true ) false) ))) else ({a = ({a = (unfold [ Bool ] (fold [ Bool ] 0 )) , b = ({a = 0 , b = false , c =  1 }.b) , c =  ({a = 1 , b = 1 }.b) }.b) , b = ({a = ({a = 0 , b = 0 }.b) , b = true }.a) }.b))
(pred ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = (unfold [ Bool ] (fold [ Bool ] true )) , c = ({a = 0 , b = 1 }.b) }.c) )) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .y) false ) 0) ) (fix (\x: Bool . 0 )) ) ) (\a: Nat .\b: Bool .a)) }.c))
(let u = ({a = ({a = (let u = 1 in 1) , b = true }.a) , b = (let u = (let u = 1 in 0) in (let u = 1 in true)) }.b) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (succ 0) )))
(case <r = (( \f: Rec X. X .((f (fix (\x: Unit . (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) )) ) (fix (\x: Bool . (fix (\x: Bool . (let u = true in u) )) )) ) ) (\a: Rec X. X .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y)
(let u = (let u = (case <r = (((\x: Unit .\y: Nat .y) ({a = false , b = 1 }.a) ) (iszero 1)) > as Unit of < l = x > => x | < r = y > => y) in (succ (pred ({a = 0 , b = true }.a)))) in u)
(unfold [ Unit ] (fold [ Bool ] ({a = (let u = false in u) , b = (((\x: Unit .\y: Unit .x) ({a = ({a = 0 , b = true , c = 1 }.c) , b = false , c = ({a = 1 , b = true , c = 0 }.c) }.c) ) ({a = 1 , b = true , c =  0 }.b)) }.b) ))
(pred (let u = (case <l = (fix (\x: Nat . (let u = 0 in u) )) > as Unit of < l = x > => x | < r = y > => y) in ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = 1 in 0) }.b)))
(fix (\x: Unit . ({a = (pred (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) , b = (( \f: Unit .((f ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = 0 }.a) ) (( \f: Nat .((f ({a = 1 , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) , c =  1 }.b) ) (let u = (let u = true in u) in u) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .a)) }.a) ))
(fix (\x: Unit . (case <r = (if (if false then false else true) then true else false) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(fix (\x: Rec X. X . (if (iszero (if true then (((\x: Nat .\y: Nat .x) 1 ) false) else ({a = 1 , b = false }.a))) then (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) in u) else ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = (case <r = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) }.a)) ))
(fix (\x: Nat . (case <r = (((\x: Bool .\y: Bool .x) (case <r = (( \f: Nat .((f ({a = 1 , b = true , c =  1 }.b) ) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) ) (if ({a = false , b = 1 }.a) then (unfold [ Unit ] (fold [ Bool ] false )) else (((\x: Unit .\y: Nat .y) true ) true))) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(unfold [ Nat ] (fold [ Unit ] (let u = (let u = ({a = true , b = 0 }.a) in (((\x: Unit .\y: Bool .x) false ) true)) in ({a = false , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.a)) ))
(if (( \f: Nat .((f (let u = true in u) ) ({a = ({a = 0 , b = (((\x: Rec X. X .\y: Unit .x) true ) false) }.b) , b = (succ 1) }.a) ) ) (\a: Bool .\b: Bool .a)) then (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Nat . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in false) )) )) )) else (( \f: Nat .((f ({a = ({a = 1 , b = true , c = 1 }.c) , b = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)) }.b) ) ({a = (pred 1) , b = (if true then false else ({a = false , b = 0 }.a)) , c =  (let u = 1 in 0) }.b) ) ) (\a: Rec X. X .\b: Bool .b)))
({a = (let u = (if (let u = 0 in false) then (succ 1) else (( \f: Nat .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Bool .\b: Unit .a))) in u) , b = ({a = (pred (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (iszero ({a = 0 , b = true , c = 0 }.c)) }.b) , c =  (if (unfold [ Nat ] (fold [ Unit ] ({a = (((\x: Bool .\y: Bool .y) false ) true) , b = (succ 1) }.a) )) then ({a = (let u = true in 0) , b = (if false then false else true) , c = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.c) else (let u = (((\x: Unit .\y: Bool .y) true ) 1) in u)) }.b)
({a = (iszero (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) (let u = false in 0) ) ) (\a: Rec X. X .\b: Nat .b))) , b = ({a = (pred (case <l = ({a = 1 , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y)) , b = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Rec X. X .y) (if true then true else false) ) (let u = 0 in true)) )) , c = (( \f: Bool .((f (if (if true then false else true) then (succ 0) else 1) ) (pred 0) ) ) (\a: Unit .\b: Bool .a)) }.c) }.a)
({a = (if ({a = (if (unfold [ Nat ] (fold [ Unit ] false )) then (pred 0) else ({a = 1 , b = false , c = 0 }.c)) , b = (fix (\x: Nat . false )) , c =  (pred ({a = ({a = 0 , b = false }.a) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) }.b) then ({a = ({a = false , b = 0 }.b) , b = (fix (\x: Nat . true )) }.a) else (let u = ({a = ({a = 0 , b = false , c =  1 }.b) , b = 1 }.a) in ({a = (((\x: Unit .\y: Unit .x) false ) true) , b = (let u = true in 1) }.b))) , b = (unfold [ Bool ] (fold [ Nat ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) , c =  (succ (((\x: Nat .\y: Bool .x) 1 ) true)) }.b) )) }.a)
(let u = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = 1 in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.b) in (iszero ({a = 0 , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b)))
(let u = (if (((\x: Bool .\y: Nat .x) (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] false )) )) ) (let u = true in u)) then (((\x: Nat .\y: Rec X. X .y) (let u = true in false) ) ({a = (iszero 1) , b = (((\x: Bool .\y: Bool .y) false ) true) }.b)) else (((\x: Unit .\y: Unit .x) (fix (\x: Bool . true )) ) ({a = ({a = false , b = false }.b) , b = true }.b))) in u)
({a = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (iszero 1) ) 0) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .x) (fix (\x: Nat . false )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))) )) }.a) , b = (let u = (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Bool ] 0 )) ) (iszero (if true then 1 else 0))) in u) }.b)
(let u = (let u = ({a = ({a = ({a = 0 , b = false , c = 1 }.c) , b = true }.a) , b = (((\x: Bool .\y: Nat .y) true ) false) }.a) in (( \f: Bool .((f (( \f: Nat .((f 1 ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = (pred ({a = false , b = 0 }.b)) in (if (unfold [ Nat ] (fold [ Bool ] true )) then 1 else 0)) ) ) (\a: Bool .\b: Rec X. X .a))) in u)
(fix (\x: Unit . (if ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = false }.b) then (let u = (let u = 1 in true) in ({a = false , b = true }.b)) else (fix (\x: Bool . (if true then true else false) ))) ))
(pred (pred (let u = ({a = 1 , b = true }.a) in (pred 1))))
(unfold [ Rec X. X ] (fold [ Bool ] ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) )) ))
(fix (\x: Rec X. X . (fix (\x: Nat . ({a = 1 , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.b) )) ))
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (succ ({a = true , b = 0 }.b)) )) , b = (if (let u = (( \f: Rec X. X .((f (let u = 0 in true) ) false ) ) (\a: Bool .\b: Nat .a)) in u) then (if (if true then false else (((\x: Unit .\y: Unit .y) false ) false)) then (let u = 1 in 1) else (let u = ({a = 0 , b = true }.a) in u)) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (if false then (let u = 0 in u) else 1) ))) }.b)
(let u = ({a = (( \f: Nat .((f (unfold [ Bool ] (fold [ Bool ] (if true then 0 else 1) )) ) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Unit .a)) , b = (let u = (pred 1) in (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b))) , c = (case <l = ({a = true , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) }.c) in u)
(((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = ({a = false , b = 0 }.a) , b = (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) (let u = 1 in 1) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) , b = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ({a = ({a = true , b = 1 }.b) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a)) , c = 0 }.c) , b = (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) in ({a = 0 , b = false }.b)) , c =  ({a = (fix (\x: Unit . 0 )) , b = true }.a) }.b) }.b) , c =  (((\x: Unit .\y: Rec X. X .x) ({a = (let u = true in true) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) }.b) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true ))) }.b) ) (unfold [ Nat ] (fold [ Rec X. X ] ({a = (succ 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (if true then false else true) )) }.a) )))
(((\x: Unit .\y: Rec X. X .x) (pred ({a = (((\x: Rec X. X .\y: Nat .x) 1 ) true) , b = ({a = ({a = 1 , b = 0 }.b) , b = ({a = 0 , b = false }.b) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b) , c = (if (iszero 1) then ({a = false , b = 1 }.b) else (let u = false in 0)) }.c)) ) ({a = (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = (fix (\x: Unit . true )) , b = ({a = 1 , b = false , c =  1 }.b) }.b) }.b))
({a = (if ({a = ({a = false , b = 1 }.b) , b = ({a = (let u = 1 in false) , b = true }.b) }.b) then (unfold [ Unit ] (fold [ Rec X. X ] (let u = false in true) )) else ({a = (let u = 0 in false) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.a)) , b = (( \f: Bool .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) true ) 0) )) ) (( \f: Unit .((f 1 ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a)) }.a)
({a = (if (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) ) (\a: Unit .\b: Nat .a)) then (if (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .a)) then ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) else (pred 1)) else (fix (\x: Rec X. X . 0 ))) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (let u = false in 1) , b = 1 }.b) )) }.b)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . ({a = true , b = (pred 1) }.b) )) ))
(((\x: Unit .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = (succ 0) , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a)) , c =  (fix (\x: Nat . 0 )) }.b) )) )) ) (let u = ({a = (unfold [ Bool ] (fold [ Rec X. X ] true )) , b = (pred ({a = 0 , b = false }.a)) }.a) in u))
({a = (case <l = (case <l = ({a = 0 , b = ({a = false , b = 1 }.a) , c = ({a = 0 , b = 0 }.b) }.c) > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = (( \f: Bool .((f (let u = 1 in false) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) ) (\a: Bool .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.a)
({a = (let u = (((\x: Unit .\y: Nat .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) (iszero 0)) in (unfold [ Unit ] (fold [ Nat ] ({a = true , b = false }.b) ))) , b = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = true in 1) )) in u) }.a)
(case <l = (((\x: Rec X. X .\y: Nat .y) (fix (\x: Nat . (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .b)) )) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = (case <l = (((\x: Bool .\y: Rec X. X .x) (pred 0) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) , b = (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then ({a = 0 , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a)) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.b) else (iszero 0)) }.b) in ({a = (( \f: Nat .((f (let u = false in true) ) true ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Nat .((f 1 ) (succ 1) ) ) (\a: Bool .\b: Nat .b)) }.a))
({a = (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] ({a = (unfold [ Nat ] (fold [ Rec X. X ] true )) , b = ({a = 0 , b = true , c = 0 }.c) }.b) )) )) , b = (( \f: Nat .((f (if (if true then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) else (let u = 0 in true)) then (if true then ({a = 1 , b = false }.a) else 0) else ({a = 1 , b = false , c = 0 }.c)) ) (fix (\x: Nat . (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)
(((\x: Unit .\y: Unit .y) (( \f: Unit .((f ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f true ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Bool .\b: Nat .a)) , c =  (let u = ({a = true , b = 0 }.a) in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.b) ) ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Unit .\y: Unit .x) (let u = ({a = true , b = 1 }.a) in (if true then 0 else 1)) ) (fix (\x: Nat . (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) then (case <r = (let u = 1 in true) > as Unit of < l = x > => x | < r = y > => y) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 0 , b = true , c =  1 }.b) ))) ))))
(unfold [ Unit ] (fold [ Nat ] ({a = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in u) , c =  (fix (\x: Unit . 0 )) }.b) , b = (succ (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ))) }.a) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = ({a = false , b = false }.b) , c = 0 }.c) )) ))
(case <l = ({a = (((\x: Unit .\y: Rec X. X .y) (let u = ({a = true , b = 0 }.a) in ({a = false , b = 1 }.a)) ) ({a = ({a = 0 , b = true , c = 1 }.c) , b = (fix (\x: Nat . 1 )) }.b)) , b = ({a = ({a = 1 , b = 1 }.b) , b = (if true then true else false) }.b) , c = ({a = ({a = false , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) }.b) , b = (fix (\x: Rec X. X . ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )) )) }.a) }.c) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Unit .((f (fix (\x: Bool . (let u = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) in false) in ({a = 0 , b = 1 }.b)) )) ) (if (fix (\x: Unit . false )) then (pred ({a = 0 , b = true , c = 0 }.c)) else (((\x: Unit .\y: Bool .y) false ) (let u = true in 1))) ) ) (\a: Unit .\b: Rec X. X .b))
(let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (if true then 0 else 0) )) , b = ({a = (let u = (let u = true in 1) in 0) , b = (case <r = (((\x: Bool .\y: Rec X. X .y) true ) false) > as Bool of < l = x > => x | < r = y > => y) }.b) , c =  (((\x: Bool .\y: Unit .x) ({a = (let u = 0 in false) , b = (let u = true in 0) }.b) ) (iszero 1)) }.b) in (fix (\x: Unit . (if (let u = (let u = 1 in true) in ({a = (let u = 0 in u) , b = (unfold [ Bool ] (fold [ Bool ] true )) }.b)) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) else (succ ({a = 0 , b = 1 }.b))) )))
(iszero ({a = (let u = (let u = 0 in u) in u) , b = (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) in (((\x: Unit .\y: Nat .x) false ) false)) }.a))
(iszero (( \f: Nat .((f (let u = (let u = (fix (\x: Unit . true )) in 1) in (((\x: Unit .\y: Unit .x) 0 ) true)) ) (case <l = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)))
(case <r = (if (unfold [ Unit ] (fold [ Unit ] (let u = true in u) )) then (fix (\x: Rec X. X . (let u = 1 in false) )) else (((\x: Unit .\y: Rec X. X .y) (iszero 0) ) (((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) false))) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . (succ (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) in (let u = 0 in 0))) ))
(((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Rec X. X .x) (let u = ({a = (let u = false in false) , b = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) }.b) in ({a = false , b = 0 }.a)) ) (((\x: Unit .\y: Unit .x) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) ) (if ({a = 0 , b = ({a = true , b = true }.b) , c =  (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) then (fix (\x: Nat . true )) else ({a = true , b = 0 }.a)))) ) (let u = (let u = (succ 1) in u) in u))
(unfold [ Nat ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = 0 }.b) ) ({a = true , b = true }.b)) ) (fix (\x: Rec X. X . ({a = (unfold [ Unit ] (fold [ Nat ] true )) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) }.b) )) ) ) (\a: Unit .\b: Unit .b)) ))
(let u = ({a = ({a = ({a = 1 , b = (if false then 0 else 1) }.b) , b = (let u = ({a = 1 , b = true , c = 1 }.c) in (( \f: Rec X. X .((f (if true then false else false) ) false ) ) (\a: Nat .\b: Nat .a))) }.a) , b = (fix (\x: Rec X. X . (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true )) ) true ) ) (\a: Unit .\b: Rec X. X .a)) )) }.b) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (pred (let u = 0 in 0)) )))
(let u = (case <l = (let u = (pred 0) in u) > as Nat of < l = x > => x | < r = y > => y) in ({a = (( \f: Rec X. X .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (succ (let u = true in 1)) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (( \f: Nat .((f (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 )) in 1) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (iszero ({a = 0 , b = false }.a)) , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b) }.a))
(let u = (let u = (let u = (let u = 1 in u) in u) in u) in (let u = (( \f: Bool .((f false ) (let u = true in u) ) ) (\a: Bool .\b: Unit .b)) in ({a = 1 , b = false , c = 0 }.c)))
(((\x: Nat .\y: Rec X. X .x) (( \f: Unit .((f (succ (let u = 0 in 1)) ) (case <l = (if true then 1 else 1) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) ) (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (iszero (let u = 0 in 0)) }.b) )) ) ({a = ({a = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) }.a) , b = (fix (\x: Bool . (succ 1) )) }.a) ) ) (\a: Unit .\b: Rec X. X .a)))
(case <l = (let u = (( \f: Bool .((f (succ 1) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) ) ) (\a: Nat .\b: Rec X. X .a)) in u) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Unit . (case <r = (((\x: Unit .\y: Unit .x) (let u = (let u = false in true) in (if false then true else true)) ) (case <r = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y)) > as Bool of < l = x > => x | < r = y > => y) ))
({a = (( \f: Rec X. X .((f ({a = ({a = (let u = 0 in false) , b = ({a = false , b = 1 }.a) }.b) , b = (let u = 0 in (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 ))) }.a) ) (let u = (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y) in (let u = false in u)) ) ) (\a: Unit .\b: Bool .a)) , b = (let u = (unfold [ Unit ] (fold [ Bool ] true )) in (pred ({a = 0 , b = false }.a))) }.b)
({a = ({a = ({a = (if false then (((\x: Nat .\y: Nat .x) 0 ) true) else (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b))) , b = (( \f: Bool .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true , c = 0 }.c) ) ) (\a: Unit .\b: Nat .a)) }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] false )) )) , c = (( \f: Rec X. X .((f (fix (\x: Rec X. X . (( \f: Bool .((f (unfold [ Bool ] (fold [ Unit ] 0 )) ) 1 ) ) (\a: Unit .\b: Bool .a)) )) ) (((\x: Bool .\y: Bool .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) ) 0) ) ) (\a: Bool .\b: Unit .b)) }.c) , b = ({a = ({a = (((\x: Nat .\y: Unit .y) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ) true) , b = (succ 1) }.a) , b = ({a = ({a = ({a = false , b = 1 }.b) , b = (fix (\x: Unit . false )) , c = ({a = 1 , b = 1 }.b) }.c) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false )) , c = (let u = (((\x: Nat .\y: Bool .y) true ) 1) in 0) }.c) }.a) }.a)
(succ ({a = (( \f: Unit .((f ({a = 0 , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.b) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Nat .\b: Nat .a)) , b = (let u = ({a = (if true then true else false) , b = ({a = false , b = true }.b) }.b) in ({a = 0 , b = true , c =  0 }.b)) , c = (case <l = (((\x: Bool .\y: Unit .y) true ) 1) > as Nat of < l = x > => x | < r = y > => y) }.c))
(let u = (( \f: Bool .((f (let u = (((\x: Unit .\y: Unit .x) ({a = 0 , b = false }.a) ) true) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) ) ({a = 0 , b = true , c = (succ 0) }.c) ) ) (\a: Unit .\b: Rec X. X .a)) in u)
(pred (unfold [ Bool ] (fold [ Rec X. X ] ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = 1 }.b) )))
(let u = ({a = (let u = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) in 1) in ({a = 1 , b = true , c = 0 }.c)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . false )) )) }.a) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (((\x: Bool .\y: Rec X. X .x) (let u = true in false) ) ({a = true , b = false }.b)) in (succ 1)) )))
(succ (((\x: Unit .\y: Bool .x) (((\x: Unit .\y: Bool .x) (fix (\x: Rec X. X . 1 )) ) (if false then true else true)) ) (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .x) (let u = true in u) ) (let u = false in true)) ))))
(case <r = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f true ) ({a = false , b = 1 }.a) ) ) (\a: Bool .\b: Bool .b)) )) , b = (case <r = (((\x: Bool .\y: Nat .y) false ) ({a = 1 , b = false , c =  0 }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (case <l = (((\x: Rec X. X .\y: Unit .x) 1 ) false) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . (( \f: Rec X. X .((f 0 ) (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) ) (\a: Bool .\b: Nat .a)) )) }.b) , b = ({a = (((\x: Rec X. X .\y: Nat .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = 0 }.b)) , b = ({a = (((\x: Rec X. X .\y: Nat .y) false ) true) , b = (((\x: Nat .\y: Bool .x) true ) false) }.b) }.b) , c =  (pred (let u = ({a = ({a = 1 , b = ({a = true , b = 1 }.a) }.a) , b = ({a = false , b = 1 }.a) }.b) in (((\x: Nat .\y: Unit .x) 1 ) (let u = false in u)))) }.b)
(case <l = (((\x: Unit .\y: Bool .x) (let u = ({a = 1 , b = true , c = 0 }.c) in u) ) ({a = (unfold [ Nat ] (fold [ Bool ] 1 )) , b = (let u = 0 in false) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Bool .y) ({a = (( \f: Nat .((f (let u = ({a = 1 , b = true }.a) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) (fix (\x: Unit . ({a = 1 , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .a)) }.a) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if (let u = (case <r = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y) in u) then ({a = ({a = 0 , b = false , c =  0 }.b) , b = ({a = true , b = 0 }.a) }.b) else (let u = ({a = 1 , b = true , c =  0 }.b) in u)) }.b) ) ({a = (let u = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) in (let u = 0 in u)) , b = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .y) false ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 ))) )) }.b))
({a = (unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) (if (let u = false in u) then 0 else ({a = true , b = 0 }.b)) ) (let u = (((\x: Unit .\y: Nat .y) true ) true) in (if false then false else true))) )) , b = ({a = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) in ({a = 0 , b = false , c = 0 }.c)) , b = (unfold [ Unit ] (fold [ Bool ] (let u = false in u) )) }.b) }.b)
({a = (fix (\x: Bool . (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .x) 0 ) true) ) (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Bool .b)) )) , b = (unfold [ Nat ] (fold [ Bool ] (if (iszero 0) then ({a = true , b = 0 }.a) else true) )) , c =  (case <l = (let u = ({a = 1 , b = false , c = 1 }.c) in 1) > as Bool of < l = x > => x | < r = y > => y) }.b)
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .b)) , c = 0 }.c) )) , b = (let u = 0 in (iszero 0)) }.a) )) , b = (if ({a = (let u = true in u) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) then (( \f: Bool .((f (fix (\x: Bool . ({a = true , b = true }.b) )) ) (( \f: Unit .((f (let u = ({a = false , b = 1 }.b) in (let u = true in u)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = 0 }.a) )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Nat .b)) else (((\x: Nat .\y: Bool .x) (((\x: Bool .\y: Nat .y) false ) false) ) (let u = 1 in true))) , c =  (pred (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .y) true ) 1) ))) }.b)
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = (fix (\x: Nat . (pred 1) )) in (let u = (pred 1) in u)) )) , b = (let u = (( \f: Rec X. X .((f (if true then false else true) ) (((\x: Nat .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Unit ] true )) ) false) ) ) (\a: Rec X. X .\b: Nat .b)) in u) , c = (unfold [ Rec X. X ] (fold [ Unit ] ({a = (pred 1) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c = (succ 0) }.c) )) }.c)
(succ ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = (((\x: Unit .\y: Rec X. X .x) 1 ) true) , b = (case <r = (let u = false in u) > as Bool of < l = x > => x | < r = y > => y) , c = (((\x: Rec X. X .\y: Nat .y) false ) 1) }.c) in (((\x: Bool .\y: Unit .y) (unfold [ Bool ] (fold [ Rec X. X ] (let u = 1 in true) )) ) (case <l = (let u = 1 in 1) > as Unit of < l = x > => x | < r = y > => y))) )))
(( \f: Unit .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .x) ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Rec X. X .\y: Nat .y) (unfold [ Bool ] (fold [ Bool ] true )) ) false) }.a) ) (((\x: Bool .\y: Nat .x) ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false }.a) }.a) ) (iszero 1))) )) ) (let u = (fix (\x: Rec X. X . (((\x: Unit .\y: Bool .y) (iszero 1) ) (if false then false else false)) )) in ({a = (succ 1) , b = (iszero (let u = 0 in u)) , c = (let u = (let u = false in u) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) }.c)) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (( \f: Bool .((f (pred (unfold [ Unit ] (fold [ Nat ] 0 ))) ) (((\x: Bool .\y: Unit .x) (succ 1) ) true) ) ) (\a: Rec X. X .\b: Nat .a)) in u)
(let u = (let u = ({a = 1 , b = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a)) }.b) in (case <l = (unfold [ Bool ] (fold [ Nat ] 0 )) > as Nat of < l = x > => x | < r = y > => y)) in (( \f: Rec X. X .((f (let u = (if true then true else true) in (if true then true else false)) ) (fix (\x: Nat . (let u = 0 in false) )) ) ) (\a: Rec X. X .\b: Bool .a)))
(if (iszero (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Unit .\y: Unit .x) 0 ) true) ))) then ({a = (((\x: Unit .\y: Bool .y) (let u = false in false) ) (if (iszero 0) then (if true then true else true) else false)) , b = ({a = ({a = 1 , b = false , c = 1 }.c) , b = false }.a) }.b) else (let u = (let u = (((\x: Unit .\y: Nat .y) (fix (\x: Bool . true )) ) (if false then 1 else 0)) in u) in ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) }.b) )) , b = (let u = ({a = false , b = false }.b) in u) }.a)))
(fix (\x: Unit . (( \f: Bool .((f ({a = 1 , b = false }.a) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = (let u = 0 in 1) , b = ({a = 1 , b = true }.b) }.a) )) ) ) (\a: Unit .\b: Unit .a)) ))
(unfold [ Bool ] (fold [ Bool ] (let u = (case <r = (if false then true else true) > as Nat of < l = x > => x | < r = y > => y) in u) ))
(unfold [ Nat ] (fold [ Bool ] ({a = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (if false then true else true) else (unfold [ Unit ] (fold [ Unit ] false ))) , b = (succ 1) }.b) ))
({a = ({a = (((\x: Bool .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a))) , b = (let u = (((\x: Unit .\y: Nat .y) false ) 0) in (((\x: Rec X. X .\y: Unit .y) true ) 1)) }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f (( \f: Bool .((f (if false then false else true) ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b)) )) }.b)
(unfold [ Bool ] (fold [ Nat ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f ({a = (succ 0) , b = ({a = true , b = ({a = 1 , b = true }.a) }.a) , c = (((\x: Unit .\y: Unit .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) 1) }.c) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) )) ) ) (\a: Bool .\b: Nat .a)) )) ))
({a = (pred (let u = 1 in 1)) , b = (case <r = ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) , b = (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] true )) ) true ) ) (\a: Unit .\b: Nat .b)) }.b) > as Unit of < l = x > => x | < r = y > => y) }.a)
(case <r = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Rec X. X . 0 )) )) , b = (((\x: Bool .\y: Unit .y) ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) , b = false }.b) ) ({a = 0 , b = true }.b)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Unit .y) (( \f: Bool .((f ({a = (let u = (let u = true in false) in u) , b = (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] false )) )) }.b) ) (let u = ({a = (fix (\x: Rec X. X . false )) , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .a)) }.b) in u) ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Nat .((f (unfold [ Bool ] (fold [ Nat ] 1 )) ) ({a = 1 , b = ({a = 1 , b = false , c =  1 }.b) }.a) ) ) (\a: Unit .\b: Nat .a)))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (let u = false in u) )) )) in ({a = (((\x: Nat .\y: Bool .x) true ) (unfold [ Nat ] (fold [ Bool ] true ))) , b = (let u = (iszero 0) in (let u = (if true then 0 else 1) in u)) }.b))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = true }.b) )) )) ) (fix (\x: Rec X. X . (let u = false in u) ))) )) ))
({a = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (pred 0) in (((\x: Bool .\y: Nat .x) 1 ) true)) )) in (((\x: Unit .\y: Nat .x) (if true then true else true) ) ({a = false , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.a))) , b = ({a = (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) in (((\x: Rec X. X .\y: Rec X. X .y) (let u = 1 in false) ) (fix (\x: Bool . true )))) , b = (case <l = (let u = 1 in u) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b)
(let u = (let u = ({a = 1 , b = true , c =  ({a = 0 , b = true , c = 0 }.c) }.b) in u) in (case <r = ({a = ({a = 0 , b = false , c =  1 }.b) , b = ({a = ({a = false , b = true }.b) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) }.b) }.b) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Bool .y) (if (case <r = (unfold [ Rec X. X ] (fold [ Nat ] true )) > as Nat of < l = x > => x | < r = y > => y) then ({a = true , b = 1 }.a) else (fix (\x: Rec X. X . false ))) ) ({a = (let u = 0 in false) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) }.a)) ) (let u = (let u = false in false) in u) ) ) (\a: Rec X. X .\b: Unit .a))
({a = (let u = (((\x: Nat .\y: Nat .x) (( \f: Bool .((f ({a = ({a = 1 , b = true , c =  1 }.b) , b = 1 }.a) ) (let u = 1 in false) ) ) (\a: Nat .\b: Nat .a)) ) (( \f: Nat .((f (iszero ({a = 1 , b = false , c = 0 }.c)) ) (let u = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)) in u) ) ) (\a: Nat .\b: Rec X. X .b))) in u) , b = (( \f: Unit .((f ({a = ({a = 0 , b = false }.a) , b = ({a = (((\x: Unit .\y: Nat .x) 0 ) false) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .a)) }.b) , c =  (let u = (let u = false in u) in 0) }.b) ) ({a = false , b = (let u = false in 0) }.a) ) ) (\a: Nat .\b: Unit .b)) }.b)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f (fix (\x: Rec X. X . false )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) ))
(((\x: Unit .\y: Rec X. X .y) (fix (\x: Bool . ({a = true , b = 0 }.a) )) ) (succ ({a = ({a = 1 , b = 1 }.b) , b = false }.a)))
({a = ({a = (( \f: Bool .((f (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) ) (iszero 0) ) ) (\a: Unit .\b: Bool .a)) , b = (let u = (iszero 1) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b))) }.a) , b = (unfold [ Bool ] (fold [ Unit ] (let u = (let u = false in u) in (((\x: Rec X. X .\y: Rec X. X .y) (iszero 1) ) 0)) )) }.a)
(( \f: Unit .((f (((\x: Bool .\y: Unit .y) (fix (\x: Unit . (( \f: Unit .((f ({a = 1 , b = true }.b) ) (fix (\x: Rec X. X . true )) ) ) (\a: Rec X. X .\b: Unit .a)) )) ) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = ({a = false , b = 1 }.a) }.a)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in u) )) ) ) (\a: Unit .\b: Bool .b))
(let u = (((\x: Nat .\y: Unit .x) ({a = (if false then 1 else 0) , b = ({a = 0 , b = true }.b) , c = ({a = 1 , b = true , c = 0 }.c) }.c) ) (( \f: Unit .((f true ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Unit .b))) in (case <r = (((\x: Nat .\y: Rec X. X .x) (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = true , c =  0 }.b) ) (((\x: Bool .\y: Rec X. X .y) false ) true)) ) (( \f: Nat .((f (((\x: Bool .\y: Unit .x) true ) false) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Nat .a))) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Bool .((f ({a = (( \f: Nat .((f (((\x: Unit .\y: Bool .x) true ) true) ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Bool .b)) , b = (case <r = (case <r = true > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .x) ({a = 0 , b = false , c =  0 }.b) ) false) )) ) ) (\a: Bool .\b: Bool .b))
(( \f: Nat .((f (let u = (let u = true in ({a = 1 , b = false , c =  1 }.b)) in ({a = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Unit .a)) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) }.b)) ) (( \f: Bool .((f ({a = (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = true , b = ({a = 1 , b = false }.b) }.b) ) (let u = (let u = true in false) in (((\x: Rec X. X .\y: Bool .x) false ) true)) ) ) (\a: Nat .\b: Unit .a)) }.b) ) (unfold [ Nat ] (fold [ Bool ] (let u = (if true then 1 else 1) in (( \f: Unit .((f ({a = true , b = false }.b) ) (let u = true in false) ) ) (\a: Nat .\b: Rec X. X .b))) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .a))
(unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Unit . (let u = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .y) false ) true) ) ({a = true , b = (fix (\x: Unit . false )) }.b) ) ) (\a: Bool .\b: Nat .a)) in (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) true ) true) ) false ) ) (\a: Unit .\b: Bool .a))) )) ))
(let u = (let u = (pred 0) in ({a = false , b = (pred 1) }.a)) in u)
(let u = (fix (\x: Bool . ({a = (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = true , b = false }.b) }.b) )) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (pred (( \f: Rec X. X .((f 1 ) (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) ) (\a: Unit .\b: Unit .b))) )))
(let u = (succ ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 ))) in (iszero (let u = (if false then true else (unfold [ Nat ] (fold [ Nat ] false ))) in (fix (\x: Bool . ({a = 1 , b = 1 }.b) )))))
(succ (((\x: Unit .\y: Bool .y) (((\x: Rec X. X .\y: Unit .x) (let u = false in true) ) (((\x: Unit .\y: Unit .x) false ) true)) ) (pred (let u = ({a = false , b = 0 }.a) in ({a = 1 , b = 0 }.b)))))
(iszero (let u = (( \f: Bool .((f ({a = false , b = 1 }.b) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) in u))
(case <r = (( \f: Unit .((f (fix (\x: Nat . (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Unit .y) false ) false) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a))) )) ) ({a = ({a = 0 , b = true , c = 1 }.c) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (((\x: Nat .\y: Bool .x) (fix (\x: Unit . 0 )) ) true) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y)
(case <l = (let u = (case <r = ({a = 1 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] 0 )) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
(if ({a = (let u = ({a = ({a = false , b = 1 }.b) , b = 0 }.b) in u) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = (unfold [ Nat ] (fold [ Nat ] 1 )) , b = true , c =  1 }.b) )) }.b) then ({a = (let u = (fix (\x: Bool . ({a = false , b = true }.b) )) in ({a = ({a = ({a = 0 , b = 0 }.b) , b = true , c = 1 }.c) , b = (unfold [ Bool ] (fold [ Bool ] true )) , c = (let u = 0 in u) }.c)) , b = (let u = ({a = 0 , b = true }.b) in u) , c = (let u = (succ 1) in u) }.c) else (if ({a = ({a = 0 , b = true }.b) , b = true }.b) then (fix (\x: Unit . ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) else (let u = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) in 1) in ({a = false , b = 1 }.b))))
(pred ({a = (unfold [ Unit ] (fold [ Rec X. X ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) , b = (((\x: Unit .\y: Bool .y) ({a = 1 , b = false }.b) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b))
({a = (fix (\x: Bool . (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then ({a = (((\x: Nat .\y: Rec X. X .x) 0 ) false) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.b) else (if true then false else true)) )) , b = (case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) true ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Nat .b)) )) > as Bool of < l = x > => x | < r = y > => y) }.b)
(( \f: Unit .((f (let u = (( \f: Nat .((f ({a = (((\x: Nat .\y: Rec X. X .x) 0 ) ({a = true , b = true }.b)) , b = (let u = false in true) , c =  ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) )) }.b) ) (fix (\x: Nat . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Bool .b)) in (if (((\x: Rec X. X .\y: Nat .y) false ) ({a = 0 , b = true }.b)) then (unfold [ Nat ] (fold [ Unit ] (fix (\x: Unit . 1 )) )) else (case <l = (let u = 1 in 1) > as Nat of < l = x > => x | < r = y > => y))) ) (((\x: Nat .\y: Nat .x) (let u = (if false then 0 else 1) in u) ) (if (fix (\x: Rec X. X . (fix (\x: Bool . true )) )) then (iszero ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 ))) else (((\x: Unit .\y: Nat .y) true ) false))) ) ) (\a: Unit .\b: Bool .b))
(let u = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) in (((\x: Unit .\y: Unit .y) true ) 1)) in u)
(( \f: Unit .((f (unfold [ Nat ] (fold [ Rec X. X ] (let u = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) in (let u = true in 1)) )) ) (if (iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (if false then 1 else (unfold [ Nat ] (fold [ Unit ] 0 ))) ))) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (succ 0) )) else (if (fix (\x: Rec X. X . true )) then ({a = 1 , b = false , c = 1 }.c) else ({a = 1 , b = 0 }.b))) ) ) (\a: Bool .\b: Rec X. X .b))
(if ({a = (iszero ({a = 1 , b = 1 }.b)) , b = ({a = (let u = true in 1) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = (iszero 1) }.a) }.b) }.a) then (let u = (unfold [ Bool ] (fold [ Unit ] (let u = 0 in u) )) in (case <l = (let u = 0 in u) > as Unit of < l = x > => x | < r = y > => y)) else (let u = (fix (\x: Nat . 1 )) in u))
(iszero ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Bool ] 0 )) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) true ) false) )) , c = ({a = (fix (\x: Rec X. X . (((\x: Bool .\y: Nat .y) true ) 0) )) , b = ({a = (succ 1) , b = (if true then false else true) , c =  ({a = true , b = 1 }.b) }.b) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) }.c) }.c))
(fix (\x: Nat . (iszero ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) , b = (let u = true in true) , c = (let u = true in 0) }.c)) ))
(pred (let u = ({a = (let u = (if false then 0 else (((\x: Nat .\y: Nat .x) 1 ) false)) in u) , b = (let u = false in u) , c = ({a = (case <l = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = true , b = 1 }.a) , c = (( \f: Unit .((f 1 ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Bool .\b: Bool .b)) }.c) }.c) in u))
({a = (( \f: Bool .((f (let u = (((\x: Bool .\y: Unit .x) false ) true) in (let u = (let u = true in 0) in (let u = 0 in 0))) ) ({a = (fix (\x: Nat . ({a = (let u = false in u) , b = (let u = 0 in 1) }.a) )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) 0 ) false) )) }.b) ) ) (\a: Bool .\b: Nat .b)) , b = (( \f: Bool .((f (if (let u = true in u) then 1 else (((\x: Rec X. X .\y: Nat .y) false ) 1)) ) (if (case <r = ({a = 0 , b = true , c =  1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = 0 in 0) else ({a = ({a = 1 , b = 0 }.b) , b = (let u = 1 in true) , c = ({a = 1 , b = true }.a) }.c)) ) ) (\a: Bool .\b: Unit .a)) }.b)
(fix (\x: Unit . (case <r = (((\x: Rec X. X .\y: Nat .y) (let u = false in true) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true ))) > as Nat of < l = x > => x | < r = y > => y) ))
({a = ({a = (( \f: Rec X. X .((f (succ 1) ) (pred (pred 0)) ) ) (\a: Nat .\b: Unit .b)) , b = (fix (\x: Nat . (case <r = (((\x: Unit .\y: Rec X. X .x) false ) true) > as Nat of < l = x > => x | < r = y > => y) )) , c =  (case <l = (let u = 1 in u) > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (fix (\x: Nat . (let u = (let u = false in 1) in u) )) }.b)
({a = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .b))) in (let u = 0 in 1)) , b = ({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .x) 1 ) false) )) , b = (let u = 0 in 0) }.b) , b = (((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Nat ] false )) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) false)) }.b) }.b) , b = (( \f: Unit .((f (( \f: Rec X. X .((f (pred 1) ) (pred 0) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (unfold [ Unit ] (fold [ Nat ] (fix (\x: Rec X. X . ({a = 1 , b = false , c = 1 }.c) )) )) ) ) (\a: Bool .\b: Bool .b)) }.b)
({a = ({a = (let u = (let u = (let u = 1 in u) in true) in ({a = 1 , b = false }.a)) , b = (case <r = (unfold [ Rec X. X ] (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (iszero ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.b)) }.b)
({a = (let u = (((\x: Bool .\y: Rec X. X .y) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) ) true) in (fix (\x: Nat . (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) ))) , b = (case <r = ({a = 0 , b = ({a = false , b = true }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) }.a)
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = ({a = (case <r = (let u = false in false) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Nat .y) true ) (fix (\x: Rec X. X . 1 ))) }.b) in (let u = (fix (\x: Rec X. X . (let u = 1 in 0) )) in (succ ({a = 1 , b = false , c = 1 }.c)))) ))
(let u = (let u = (((\x: Bool .\y: Rec X. X .y) (let u = (((\x: Bool .\y: Bool .x) false ) true) in u) ) (unfold [ Unit ] (fold [ Rec X. X ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) ))) in (let u = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = ({a = 0 , b = false }.b) , c =  (((\x: Unit .\y: Bool .x) 1 ) true) }.b) in (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) > as Rec X. X of < l = x > => x | < r = y > => y))) in (unfold [ Bool ] (fold [ Nat ] (if (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .b)) then (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .b)) else (((\x: Nat .\y: Bool .y) (fix (\x: Bool . true )) ) ({a = 0 , b = false }.b))) )))
({a = (((\x: Unit .\y: Rec X. X .y) ({a = (let u = true in 0) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] true )) , b = ({a = 0 , b = 0 }.b) }.a) }.b) ) ({a = ({a = 0 , b = false , c =  0 }.b) , b = (((\x: Nat .\y: Unit .x) ({a = 0 , b = true }.b) ) false) }.b)) , b = (fix (\x: Nat . (fix (\x: Rec X. X . 0 )) )) }.b)
(pred ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = (iszero 0) }.a) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Bool .x) (fix (\x: Unit . false )) ) true) ) ({a = 0 , b = (let u = false in false) , c =  1 }.b)) )) ))
(unfold [ Bool ] (fold [ Nat ] ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (pred (( \f: Bool .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) ) (let u = true in 1) ) ) (\a: Unit .\b: Unit .b))) )) ))
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) )) , b = (let u = (let u = (( \f: Bool .((f 1 ) ({a = 1 , b = false }.a) ) ) (\a: Bool .\b: Bool .b)) in (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b))) in u) , c = (let u = ({a = ({a = (let u = 0 in u) , b = (unfold [ Nat ] (fold [ Nat ] 0 )) }.b) , b = ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = ({a = false , b = false }.b) }.b) }.a) in (if ({a = (((\x: Nat .\y: Unit .x) false ) false) , b = (let u = 1 in u) }.a) then (let u = false in 0) else (if true then 1 else 0))) }.c)
(if (case <r = (((\x: Nat .\y: Unit .x) false ) (unfold [ Rec X. X ] (fold [ Bool ] false ))) > as Nat of < l = x > => x | < r = y > => y) then (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 0 )) )) else ({a = (( \f: Bool .((f 1 ) (let u = 1 in u) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) }.a))
({a = (let u = (((\x: Nat .\y: Rec X. X .x) ({a = false , b = true }.b) ) ({a = 0 , b = true }.b)) in ({a = (let u = 0 in u) , b = (((\x: Unit .\y: Bool .y) true ) 0) }.b)) , b = (fix (\x: Unit . (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = true }.b) ) (iszero 0)) )) , c =  ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred (((\x: Rec X. X .\y: Bool .y) true ) 1)) )) }.b)
(let u = (( \f: Nat .((f (((\x: Rec X. X .\y: Nat .x) (let u = true in u) ) (((\x: Bool .\y: Nat .x) true ) true)) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b)) in (let u = ({a = (((\x: Rec X. X .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) false) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) in (if (let u = 1 in false) then true else false)))
(((\x: Bool .\y: Rec X. X .x) ({a = (if (let u = 0 in true) then (let u = false in u) else (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a))) , b = (fix (\x: Unit . (if (let u = false in u) then ({a = 0 , b = true , c = 0 }.c) else (unfold [ Rec X. X ] (fold [ Nat ] 1 ))) )) }.a) ) (((\x: Unit .\y: Nat .y) ({a = (succ 0) , b = (let u = (if true then false else true) in ({a = 1 , b = true , c =  1 }.b)) }.b) ) ({a = (let u = false in u) , b = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) in (unfold [ Nat ] (fold [ Unit ] true ))) }.b)))
(((\x: Rec X. X .\y: Unit .x) (succ (let u = 0 in (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)))) ) (let u = (let u = ({a = 1 , b = false }.b) in (iszero ({a = true , b = 1 }.b))) in u))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (succ (((\x: Nat .\y: Bool .x) (succ (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b))) ) ({a = ({a = (((\x: Bool .\y: Bool .y) true ) 0) , b = (unfold [ Bool ] (fold [ Unit ] true )) }.a) , b = (fix (\x: Unit . true )) }.b))) ))
({a = (((\x: Nat .\y: Nat .y) (unfold [ Nat ] (fold [ Nat ] ({a = true , b = ({a = 1 , b = false , c = 1 }.c) }.a) )) ) (pred (succ 1))) , b = (((\x: Unit .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Nat . true )) )) ) (if (let u = 1 in false) then true else true)) , c =  (case <l = (( \f: Unit .((f ({a = (let u = 1 in true) , b = 0 }.b) ) (if true then 1 else 0) ) ) (\a: Bool .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) }.b)
({a = ({a = (fix (\x: Rec X. X . (let u = 0 in false) )) , b = (((\x: Unit .\y: Unit .y) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .b)) ) false) }.b) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = true }.a) )) }.a)
(fix (\x: Nat . ({a = ({a = (((\x: Bool .\y: Rec X. X .y) false ) 0) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) true ) false) )) }.a) , b = ({a = ({a = true , b = true }.b) , b = (let u = false in false) }.b) , c =  ({a = (( \f: Nat .((f ({a = false , b = (fix (\x: Rec X. X . 1 )) }.b) ) (( \f: Unit .((f 0 ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .a)) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .x) 1 ) true) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = true }.a) ) ) (\a: Nat .\b: Unit .a)) }.b) }.b) ))
(iszero (((\x: Rec X. X .\y: Nat .x) ({a = (let u = 0 in u) , b = true , c = (let u = 0 in 1) }.c) ) ({a = ({a = 1 , b = false }.b) , b = (fix (\x: Bool . false )) }.b)))
({a = (let u = (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) , b = (let u = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Unit . true )) )) ) ({a = (let u = false in false) , b = 0 }.a) ) ) (\a: Rec X. X .\b: Nat .b)) in (let u = ({a = ({a = 0 , b = true , c =  0 }.b) , b = ({a = 0 , b = true , c =  1 }.b) }.b) in (( \f: Nat .((f ({a = 1 , b = 0 }.b) ) ({a = false , b = 1 }.b) ) ) (\a: Rec X. X .\b: Unit .b)))) }.b)
({a = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Nat ] ({a = ({a = false , b = 1 }.b) , b = true }.b) )) ) (let u = (if false then true else true) in u) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (case <l = ({a = 1 , b = (let u = true in 0) }.b) > as Unit of < l = x > => x | < r = y > => y) }.b)
(case <r = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = 1 }.a) )) ) (((\x: Rec X. X .\y: Nat .y) (let u = true in u) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = 0 in true) }.b)) ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Bool ] (case <l = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) , b = ({a = (pred 0) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) }.b) , c = (fix (\x: Unit . 1 )) }.c) > as Bool of < l = x > => x | < r = y > => y) ))
({a = (let u = (if (fix (\x: Rec X. X . (let u = false in true) )) then (let u = 1 in true) else (let u = true in false)) in (((\x: Bool .\y: Unit .x) (( \f: Bool .((f (fix (\x: Unit . 1 )) ) ({a = 1 , b = 1 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) (case <r = ({a = false , b = false }.b) > as Bool of < l = x > => x | < r = y > => y))) , b = (unfold [ Bool ] (fold [ Nat ] (iszero (fix (\x: Rec X. X . (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) ))) )) , c =  (((\x: Unit .\y: Unit .y) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Bool .x) (((\x: Nat .\y: Nat .x) (pred 1) ) (let u = false in u)) ) (((\x: Unit .\y: Unit .y) true ) true))) }.b)
({a = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) , b = true }.b) ) (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )))) )) , b = (let u = (fix (\x: Rec X. X . ({a = false , b = false }.b) )) in (let u = ({a = 1 , b = false }.b) in (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) in (((\x: Unit .\y: Bool .x) 0 ) true)))) }.b)
(((\x: Bool .\y: Nat .x) (( \f: Unit .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = true in 0) )) ) (pred (((\x: Rec X. X .\y: Bool .x) 0 ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (fix (\x: Nat . (let u = true in true) )) , b = (if false then ({a = 1 , b = true , c =  0 }.b) else false) }.b) )))
({a = (let u = (let u = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) in ({a = 0 , b = ({a = false , b = 1 }.a) }.a)) in (((\x: Unit .\y: Rec X. X .x) (pred 1) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y))) , b = ({a = ({a = (succ 0) , b = ({a = ({a = 0 , b = true }.b) , b = (let u = 0 in false) }.b) }.b) , b = (succ ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = 0 }.b)) }.a) , c = (( \f: Rec X. X .((f (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) ) ({a = ({a = 0 , b = true , c = 0 }.c) , b = (((\x: Bool .\y: Rec X. X .x) 0 ) true) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.c)
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (case <r = (unfold [ Bool ] (fold [ Unit ] (let u = 0 in false) )) > as Unit of < l = x > => x | < r = y > => y) ))
(pred (unfold [ Unit ] (fold [ Unit ] ({a = (let u = 0 in 0) , b = (let u = true in u) , c = (let u = (((\x: Nat .\y: Unit .x) false ) true) in 1) }.c) )))
({a = ({a = (( \f: Unit .((f ({a = false , b = 0 }.b) ) ({a = (let u = false in false) , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (unfold [ Nat ] (fold [ Nat ] true )) , c = (((\x: Nat .\y: Rec X. X .y) false ) (let u = 1 in 0)) }.c) }.b) , b = (((\x: Unit .\y: Nat .y) (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.b)) ) (( \f: Unit .((f ({a = 0 , b = true , c =  ({a = 1 , b = false }.a) }.b) ) (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b))) , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (pred (let u = 1 in u)) )) }.c)
(( \f: Nat .((f ({a = ({a = (let u = 1 in true) , b = (( \f: Bool .((f (succ 1) ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) , b = (((\x: Nat .\y: Bool .x) true ) false) , c =  ({a = 1 , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .a)) }.a) }.b) ) (iszero ({a = (succ (((\x: Bool .\y: Unit .x) 1 ) false)) , b = (( \f: Rec X. X .((f (succ 1) ) (((\x: Nat .\y: Unit .y) true ) 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(if (((\x: Bool .\y: Nat .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Unit .x) ({a = false , b = true }.b) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) )) ) (case <r = (( \f: Nat .((f (let u = 0 in false) ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y)) then (let u = (( \f: Rec X. X .((f ({a = (if true then 0 else 1) , b = (let u = 0 in true) }.b) ) (((\x: Bool .\y: Bool .y) ({a = true , b = false }.b) ) (let u = (if true then true else false) in true)) ) ) (\a: Bool .\b: Rec X. X .a)) in (let u = (let u = ({a = (let u = true in true) , b = true }.b) in u) in ({a = 1 , b = true }.a))) else (((\x: Unit .\y: Unit .y) (let u = ({a = 0 , b = 0 }.b) in ({a = false , b = true }.b)) ) (let u = ({a = 1 , b = true }.a) in u)))
(case <r = (((\x: Rec X. X .\y: Nat .y) (let u = (((\x: Nat .\y: Unit .y) (let u = true in false) ) ({a = 0 , b = true , c = 1 }.c)) in (unfold [ Bool ] (fold [ Nat ] (let u = true in true) ))) ) (unfold [ Nat ] (fold [ Unit ] (let u = (((\x: Unit .\y: Unit .y) false ) true) in (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .a))) ))) > as Bool of < l = x > => x | < r = y > => y)
(pred (( \f: Nat .((f ({a = ({a = false , b = 0 }.b) , b = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (let u = true in true) , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) }.b) }.a) ) (fix (\x: Nat . 1 )) ) ) (\a: Nat .\b: Bool .b)))
(let u = (let u = (case <r = (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) in u) in (let u = (case <r = (let u = (let u = false in u) in u) > as Nat of < l = x > => x | < r = y > => y) in u))
(let u = (let u = (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) in ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = (unfold [ Bool ] (fold [ Bool ] true )) }.b)) in (( \f: Unit .((f (((\x: Nat .\y: Unit .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) (iszero 1)) ) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (fix (\x: Rec X. X . 1 )) in 1) }.b) ) ) (\a: Nat .\b: Rec X. X .b)))
(let u = ({a = (((\x: Bool .\y: Nat .x) (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) true ) false) ) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (iszero 1)) , b = (let u = ({a = false , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.a) in u) }.b) in u)
({a = ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = true }.a) )) , b = (let u = 0 in u) }.b) , b = (iszero ({a = (let u = true in 1) , b = 0 }.b)) , c = (( \f: Bool .((f (( \f: Bool .((f 1 ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Unit .b)) ) ({a = 1 , b = 1 }.b) ) ) (\a: Nat .\b: Unit .b)) }.c)
({a = (fix (\x: Nat . (succ (let u = 0 in u)) )) , b = ({a = (case <r = (let u = ({a = true , b = 1 }.a) in u) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Bool .((f 0 ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (unfold [ Rec X. X ] (fold [ Unit ] false )) }.b) }.b) }.b)
(( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) 1 ) true) )) , b = (fix (\x: Rec X. X . (pred 1) )) }.b) ) (fix (\x: Nat . (( \f: Rec X. X .((f ({a = 0 , b = false }.a) ) (pred 0) ) ) (\a: Bool .\b: Bool .b)) )) ) ) (\a: Bool .\b: Bool .a))
(((\x: Nat .\y: Bool .y) (let u = (case <r = ({a = (if false then 0 else 1) , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (unfold [ Bool ] (fold [ Rec X. X ] (let u = (iszero 0) in u) ))) ) (let u = (let u = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .b)) in u) in (let u = ({a = 0 , b = 0 }.b) in u)))
({a = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = true in u) )) in (( \f: Nat .((f 1 ) (let u = 1 in 1) ) ) (\a: Nat .\b: Nat .a))) , b = (let u = ({a = (iszero 1) , b = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) }.b) in (unfold [ Nat ] (fold [ Bool ] ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] true )) , b = (((\x: Unit .\y: Nat .x) false ) true) }.b) ))) }.a)
(( \f: Bool .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Bool . 0 )) )) )) ) (( \f: Rec X. X .((f (( \f: Nat .((f (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Bool .y) true ) 0) )) ) (let u = true in 1) ) ) (\a: Unit .\b: Unit .b)) ) ({a = ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) true) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] false )) }.a) , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Nat .b)) , c = (pred 1) }.c) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Unit .\b: Bool .a))
(( \f: Bool .((f (( \f: Rec X. X .((f (fix (\x: Bool . ({a = true , b = 0 }.a) )) ) (( \f: Rec X. X .((f (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Bool .\b: Bool .b)) ) ({a = (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Nat .\y: Nat .x) (pred 1) ) ({a = true , b = 0 }.a))) , b = (let u = (iszero 0) in (let u = false in u)) , c =  (unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Unit .y) true ) 0) )) }.b) ) ) (\a: Unit .\b: Unit .a))
(let u = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .y) true ) 1) )) )) ) ({a = (if true then 0 else 1) , b = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Bool ] false )) ) (if false then false else true) ) ) (\a: Unit .\b: Bool .a)) , c = (unfold [ Unit ] (fold [ Nat ] 0 )) }.c) ) ) (\a: Rec X. X .\b: Nat .a)) in (case <r = (let u = (iszero 1) in ({a = (((\x: Unit .\y: Nat .x) true ) true) , b = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.a)) > as Unit of < l = x > => x | < r = y > => y))
(iszero (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .a)) ) (((\x: Nat .\y: Nat .x) false ) false) ) ) (\a: Rec X. X .\b: Bool .a)) ) (succ (let u = false in ({a = false , b = 1 }.b)))))
(fix (\x: Rec X. X . (((\x: Bool .\y: Unit .x) (( \f: Nat .((f ({a = (let u = true in u) , b = false }.b) ) (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) ) (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Unit .a)) ) (let u = false in u))) ))
(if (unfold [ Unit ] (fold [ Unit ] (fix (\x: Bool . (iszero (fix (\x: Nat . 0 ))) )) )) then (let u = (let u = ({a = 0 , b = true , c =  1 }.b) in (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a))) in (( \f: Bool .((f (fix (\x: Rec X. X . 1 )) ) (((\x: Unit .\y: Nat .y) true ) 1) ) ) (\a: Rec X. X .\b: Rec X. X .a))) else (case <l = ({a = ({a = 1 , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )) , c = 1 }.c) , b = ({a = 0 , b = (let u = false in true) , c =  0 }.b) }.a) > as Unit of < l = x > => x | < r = y > => y))
({a = ({a = ({a = (let u = (iszero ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 ))) in u) , b = ({a = (unfold [ Nat ] (fold [ Nat ] 1 )) , b = false , c = (let u = false in 0) }.c) }.b) , b = (fix (\x: Nat . (( \f: Bool .((f (let u = 1 in (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) ) (fix (\x: Rec X. X . (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .b)) )) ) ) (\a: Bool .\b: Bool .a)) )) }.b) , b = (((\x: Rec X. X .\y: Unit .y) (unfold [ Nat ] (fold [ Bool ] (let u = true in ({a = 0 , b = true , c =  0 }.b)) )) ) ({a = ({a = (pred (let u = false in 0)) , b = (let u = true in u) }.b) , b = (((\x: Rec X. X .\y: Unit .x) (let u = true in 1) ) true) }.a)) }.b)
({a = (( \f: Bool .((f ({a = 1 , b = true }.a) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (unfold [ Nat ] (fold [ Unit ] ({a = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Rec X. X .\y: Bool .y) true ) 0) }.b) )) }.b)
({a = (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Bool . (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) )) )) , c = ({a = (fix (\x: Rec X. X . 1 )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b) }.c)
({a = (case <l = (fix (\x: Rec X. X . (fix (\x: Unit . (pred (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) )) )) > as Nat of < l = x > => x | < r = y > => y) , b = (if (((\x: Bool .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) true) then (fix (\x: Bool . ({a = 0 , b = (let u = true in false) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) }.b) )) else ({a = 1 , b = ({a = 1 , b = true , c =  0 }.b) , c =  ({a = true , b = 1 }.b) }.b)) , c =  (unfold [ Nat ] (fold [ Bool ] (((\x: Nat .\y: Bool .x) (unfold [ Bool ] (fold [ Unit ] 1 )) ) false) )) }.b)
(fix (\x: Unit . (((\x: Unit .\y: Unit .x) (if ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (iszero 1) )) then (let u = true in u) else (let u = (iszero 0) in (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)))) ) (fix (\x: Nat . (let u = (if false then true else false) in u) ))) ))
(let u = ({a = (((\x: Rec X. X .\y: Bool .x) true ) true) , b = (let u = 0 in 1) }.b) in ({a = (pred (pred ({a = (let u = 0 in u) , b = (let u = 1 in true) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.c))) , b = (case <r = (fix (\x: Unit . false )) > as Bool of < l = x > => x | < r = y > => y) , c =  (unfold [ Bool ] (fold [ Nat ] (pred 0) )) }.b))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then (let u = 1 in 1) else 1) )) in ({a = (succ ({a = 1 , b = true , c = 1 }.c)) , b = (let u = (let u = false in true) in ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b)) }.b))
(let u = (succ (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = ({a = 0 , b = true }.a) }.b) ))) in u)
(fix (\x: Nat . ({a = (fix (\x: Nat . ({a = false , b = 0 }.b) )) , b = (iszero ({a = 1 , b = 1 }.b)) }.b) ))
(if (if (iszero (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) then (((\x: Bool .\y: Rec X. X .x) (case <r = ({a = true , b = ({a = 0 , b = true , c =  0 }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) ) (iszero 0)) else (((\x: Rec X. X .\y: Nat .x) (fix (\x: Bool . true )) ) ({a = false , b = (let u = 0 in u) }.a))) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (succ (( \f: Rec X. X .((f (if false then 0 else 1) ) (((\x: Bool .\y: Rec X. X .y) true ) 0) ) ) (\a: Nat .\b: Bool .b))) )) else ({a = (fix (\x: Unit . (let u = (fix (\x: Unit . (let u = false in u) )) in (unfold [ Nat ] (fold [ Unit ] false ))) )) , b = (fix (\x: Bool . (let u = ({a = ({a = 1 , b = false , c = 0 }.c) , b = false , c = ({a = 1 , b = false , c = 1 }.c) }.c) in (fix (\x: Rec X. X . 1 ))) )) }.b))
({a = ({a = (let u = (((\x: Unit .\y: Bool .y) (let u = false in true) ) (unfold [ Bool ] (fold [ Nat ] 0 ))) in u) , b = ({a = (let u = 0 in u) , b = ({a = (((\x: Bool .\y: Rec X. X .y) true ) false) , b = (let u = 0 in 1) }.a) }.b) }.a) , b = (((\x: Rec X. X .\y: Rec X. X .y) (if (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) then (let u = true in false) else (if true then ({a = 1 , b = false , c =  0 }.b) else (let u = false in true))) ) (pred ({a = 1 , b = (fix (\x: Nat . false )) }.a))) }.b)
(((\x: Unit .\y: Bool .x) (let u = (iszero ({a = 0 , b = true , c = 0 }.c)) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false ))) ) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (iszero ({a = false , b = (fix (\x: Unit . 1 )) }.b)) )) ) (((\x: Bool .\y: Unit .y) (let u = 1 in true) ) (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) false ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Unit .\b: Rec X. X .a)))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] ({a = (( \f: Nat .((f ({a = 0 , b = false , c = 1 }.c) ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = false , b = (((\x: Rec X. X .\y: Bool .x) 0 ) true) }.a) }.a) )) ))
(let u = (((\x: Unit .\y: Unit .x) (unfold [ Bool ] (fold [ Rec X. X ] (let u = (iszero 0) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) )) ) (let u = ({a = 1 , b = false }.a) in (let u = false in false))) in (((\x: Bool .\y: Nat .x) (case <r = (let u = 1 in true) > as Nat of < l = x > => x | < r = y > => y) ) (if (iszero (((\x: Bool .\y: Bool .y) true ) 0)) then (iszero 1) else (fix (\x: Rec X. X . false )))))
({a = ({a = (unfold [ Nat ] (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = true }.b) ) false) )) , b = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Bool . true )) ) (pred 1)) }.b) , b = ({a = (fix (\x: Nat . ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) )) , b = ({a = 0 , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , c =  0 }.b) , c =  (let u = (if true then 0 else 0) in (((\x: Nat .\y: Nat .y) false ) (((\x: Rec X. X .\y: Rec X. X .y) false ) 1))) }.b) , c = ({a = (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Bool ] 1 )) ) true) , b = (if ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) , b = false , c =  (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) then (let u = false in true) else (let u = false in false)) , c = ({a = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = (if (((\x: Rec X. X .\y: Unit .y) true ) true) then 0 else 0) }.b) }.c) }.c)
(let u = ({a = (if (((\x: Nat .\y: Nat .y) true ) false) then ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) , b = ({a = 0 , b = false }.b) }.b) else (let u = 0 in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )))) , b = ({a = (succ ({a = false , b = 0 }.b)) , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) , c = (let u = false in (pred 0)) }.c) }.b) in (((\x: Unit .\y: Nat .y) (fix (\x: Unit . (unfold [ Bool ] (fold [ Bool ] (if true then true else true) )) )) ) (( \f: Nat .((f (let u = true in u) ) (iszero 1) ) ) (\a: Unit .\b: Unit .a))))
(unfold [ Bool ] (fold [ Unit ] (( \f: Bool .((f (let u = ({a = false , b = 1 }.b) in (if true then (unfold [ Bool ] (fold [ Nat ] 0 )) else (let u = false in 0))) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = (let u = false in 0) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , c = 1 }.c) )) ) ) (\a: Bool .\b: Unit .b)) ))
(case <l = (( \f: Nat .((f ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = 1 , b = 1 }.b) )) }.b) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (succ 0) )) ) ) (\a: Nat .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y)
(iszero (let u = (((\x: Bool .\y: Nat .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) (let u = false in (iszero 1))) in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = true , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ))))
(( \f: Unit .((f (iszero (case <l = (((\x: Bool .\y: Bool .x) 1 ) true) > as Nat of < l = x > => x | < r = y > => y)) ) (case <r = ({a = 1 , b = false , c =  1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .a))
(let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = ({a = 1 , b = false , c = 0 }.c) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = false in 0) )) }.b) ) (let u = (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Rec X. X .y) false ) (let u = true in true)) ) ({a = false , b = false }.b)) in ({a = (fix (\x: Nat . true )) , b = ({a = (fix (\x: Rec X. X . 1 )) , b = (((\x: Nat .\y: Bool .y) false ) false) }.b) }.b))) in ({a = ({a = (((\x: Nat .\y: Bool .x) (let u = 0 in true) ) false) , b = ({a = 1 , b = 1 }.b) }.b) , b = (( \f: Unit .((f (let u = ({a = true , b = 0 }.a) in ({a = false , b = false }.b)) ) (if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] false )) then ({a = true , b = 0 }.a) else (if true then false else false)) ) ) (\a: Unit .\b: Nat .a)) }.a))
({a = (let u = (( \f: Bool .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ({a = false , b = true }.b) ) ) (\a: Rec X. X .\b: Unit .b)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = true , b = 1 }.a) ))) , b = (if (let u = ({a = 0 , b = false , c =  ({a = 0 , b = false , c = 1 }.c) }.b) in (unfold [ Rec X. X ] (fold [ Unit ] true ))) then ({a = (let u = (( \f: Rec X. X .((f (fix (\x: Unit . true )) ) ({a = true , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .b)) in (let u = true in 1)) , b = (if ({a = false , b = false }.b) then (let u = 0 in true) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true ))) , c =  (fix (\x: Nat . 1 )) }.b) else (let u = ({a = (let u = false in 1) , b = 1 }.b) in (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .a)))) }.b)
(let u = (fix (\x: Bool . ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (iszero 0) )) )) in u)
(let u = (if (let u = false in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false ))) then (((\x: Rec X. X .\y: Rec X. X .x) (case <r = ({a = false , b = 1 }.a) > as Bool of < l = x > => x | < r = y > => y) ) (let u = false in u)) else (if ({a = false , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) then (let u = 1 in false) else (let u = false in u))) in u)
({a = (( \f: Unit .((f (((\x: Nat .\y: Nat .x) (let u = 1 in 1) ) true) ) (case <l = (if true then 1 else 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) , b = (iszero ({a = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .a)) , b = 1 }.b)) }.b)
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f ({a = ({a = 0 , b = ({a = 1 , b = false }.b) , c = ({a = 0 , b = false , c = 1 }.c) }.c) , b = (if (unfold [ Bool ] (fold [ Bool ] true )) then false else false) }.b) ) (if true then (if true then true else true) else (let u = false in u)) ) ) (\a: Unit .\b: Unit .a)) ))
(((\x: Unit .\y: Rec X. X .x) (let u = (( \f: Rec X. X .((f (pred 0) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 1 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 ))) ) (case <r = (iszero (((\x: Nat .\y: Unit .x) 1 ) true)) > as Unit of < l = x > => x | < r = y > => y))
({a = ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = 0 , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) , c =  1 }.b) }.b) , b = (case <r = ({a = (((\x: Bool .\y: Rec X. X .y) true ) false) , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (((\x: Unit .\y: Bool .y) (let u = (((\x: Nat .\y: Bool .x) 1 ) false) in true) ) (((\x: Rec X. X .\y: Bool .x) (pred 0) ) true)) }.b)
(let u = (( \f: Unit .((f (let u = (let u = 0 in true) in u) ) (((\x: Nat .\y: Rec X. X .y) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = (iszero 0) , b = 0 }.a)) ) ) (\a: Nat .\b: Nat .b)) in u)
(((\x: Unit .\y: Unit .x) (let u = (fix (\x: Unit . 1 )) in (( \f: Unit .((f (iszero (let u = true in 0)) ) (((\x: Nat .\y: Unit .x) true ) true) ) ) (\a: Nat .\b: Nat .b))) ) (( \f: Rec X. X .((f (( \f: Bool .((f (fix (\x: Rec X. X . true )) ) (iszero 0) ) ) (\a: Unit .\b: Unit .a)) ) ({a = (let u = 1 in u) , b = (if true then false else true) , c =  ({a = (((\x: Rec X. X .\y: Bool .y) false ) true) , b = ({a = 0 , b = true }.a) }.b) }.b) ) ) (\a: Nat .\b: Nat .a)))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = (let u = true in ({a = 1 , b = true }.a)) in u) ))
({a = (case <r = (if (fix (\x: Rec X. X . (let u = true in u) )) then (((\x: Unit .\y: Bool .x) true ) true) else (((\x: Nat .\y: Rec X. X .x) false ) true)) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .x) (succ (( \f: Rec X. X .((f 0 ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Rec X. X .b))) ) ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) true) , b = (let u = 0 in false) }.b)) }.b)
(( \f: Nat .((f (let u = (let u = (case <r = (let u = 0 in false) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Nat .x) 0 ) false)) in (((\x: Bool .\y: Rec X. X .x) (if (let u = true in u) then false else true) ) (let u = true in true))) ) (unfold [ Nat ] (fold [ Nat ] (fix (\x: Unit . ({a = ({a = true , b = 1 }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) }.b) )) )) ) ) (\a: Bool .\b: Nat .a))
(( \f: Bool .((f (let u = (fix (\x: Nat . ({a = true , b = 0 }.b) )) in u) ) (let u = (((\x: Unit .\y: Unit .x) 0 ) false) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = 0 in 1) ))) ) ) (\a: Bool .\b: Bool .b))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (((\x: Bool .\y: Unit .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . true ))) , b = (((\x: Unit .\y: Unit .y) false ) 1) }.b) ))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (case <r = ({a = true , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (if (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Bool .y) true ) true) )) then ({a = false , b = 1 }.b) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a))) , b = (let u = true in (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .a))) }.a) }.a) ))
(( \f: Bool .((f (case <r = (unfold [ Nat ] (fold [ Rec X. X ] (case <r = (let u = true in u) > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = ({a = true , b = false }.b) }.b) )) ) ) (\a: Unit .\b: Unit .b))
(( \f: Unit .((f (let u = (let u = (iszero 1) in ({a = (fix (\x: Unit . 1 )) , b = true , c = 1 }.c)) in (let u = 1 in 0)) ) (let u = ({a = false , b = 0 }.b) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(succ ({a = ({a = (succ 0) , b = (succ 0) }.b) , b = ({a = (fix (\x: Unit . (unfold [ Bool ] (fold [ Bool ] true )) )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Unit . true )) )) }.b) , c = (if (( \f: Unit .((f true ) (fix (\x: Rec X. X . true )) ) ) (\a: Rec X. X .\b: Nat .b)) then (let u = false in (if false then 0 else 1)) else ({a = true , b = 1 }.b)) }.c))
(unfold [ Bool ] (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f ({a = ({a = false , b = 0 }.b) , b = true }.b) ) (let u = (let u = (unfold [ Bool ] (fold [ Nat ] 0 )) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 ))) in (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Nat .b))) ) ) (\a: Rec X. X .\b: Unit .b)) )) ))
(let u = ({a = (if (((\x: Unit .\y: Rec X. X .x) true ) false) then ({a = 0 , b = false }.b) else true) , b = (if ({a = false , b = 0 }.a) then (let u = 0 in false) else ({a = 0 , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = false in 1) }.b)) }.b) in u)
(((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = (succ ({a = 1 , b = true }.a)) , b = (((\x: Rec X. X .\y: Nat .y) true ) false) }.b) , b = (( \f: Rec X. X .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) false ) ) (\a: Bool .\b: Bool .b)) }.b) ) (let u = (let u = ({a = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) , b = false }.b) in (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b))) in ({a = ({a = 0 , b = false , c = (unfold [ Nat ] (fold [ Unit ] 0 )) }.c) , b = (( \f: Nat .((f (let u = true in 0) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)))
(if (((\x: Bool .\y: Nat .y) ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = 0 , b = false }.b) , c =  (unfold [ Nat ] (fold [ Bool ] ({a = 0 , b = true , c = 1 }.c) )) }.b) ) ({a = 0 , b = true , c =  0 }.b)) then (( \f: Unit .((f (let u = ({a = (((\x: Bool .\y: Unit .y) true ) true) , b = ({a = 1 , b = true , c = 1 }.c) }.a) in u) ) (( \f: Bool .((f (let u = (((\x: Unit .\y: Bool .y) (((\x: Unit .\y: Bool .x) true ) true) ) (let u = 1 in false)) in (fix (\x: Nat . false ))) ) (let u = (( \f: Bool .((f (iszero 1) ) false ) ) (\a: Unit .\b: Unit .b)) in u) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .a)) else ({a = ({a = ({a = (((\x: Rec X. X .\y: Unit .y) true ) 0) , b = true }.b) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) , b = (let u = (((\x: Bool .\y: Rec X. X .y) (let u = 0 in false) ) (let u = 1 in false)) in u) }.b))
(case <l = (((\x: Bool .\y: Rec X. X .x) (pred (if true then (unfold [ Unit ] (fold [ Nat ] 1 )) else (unfold [ Unit ] (fold [ Unit ] 1 )))) ) (fix (\x: Unit . (let u = false in false) ))) > as Unit of < l = x > => x | < r = y > => y)
(iszero (let u = (((\x: Unit .\y: Bool .y) (let u = ({a = 0 , b = (iszero 0) , c = 1 }.c) in ({a = (let u = 0 in 0) , b = false }.b)) ) (if ({a = 0 , b = false }.b) then (((\x: Unit .\y: Rec X. X .y) true ) 1) else (pred 0))) in u))
({a = (let u = (((\x: Nat .\y: Unit .y) (let u = (((\x: Bool .\y: Bool .x) true ) false) in (((\x: Nat .\y: Unit .x) false ) true)) ) (let u = (let u = true in u) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )))) in u) , b = (iszero (fix (\x: Rec X. X . (let u = 0 in (succ 1)) ))) , c =  (( \f: Rec X. X .((f (succ 0) ) (let u = (fix (\x: Rec X. X . 1 )) in 0) ) ) (\a: Rec X. X .\b: Unit .b)) }.b)
(let u = (succ ({a = (let u = 0 in 1) , b = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = true }.b) , c = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.c)) in ({a = (((\x: Rec X. X .\y: Bool .x) (let u = (fix (\x: Bool . 1 )) in u) ) (case <r = ({a = false , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = 1 , b = true }.a) }.b) }.b))
({a = (((\x: Bool .\y: Bool .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) )) ) (((\x: Rec X. X .\y: Unit .x) (let u = true in false) ) ({a = ({a = false , b = 1 }.a) , b = (if true then true else false) }.b))) , b = (((\x: Bool .\y: Nat .y) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) , b = (fix (\x: Unit . ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = 1 in false) )) )) }.b) ) (((\x: Unit .\y: Bool .x) (let u = false in 1) ) ({a = 0 , b = ({a = 0 , b = true , c =  0 }.b) , c =  (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) }.b))) }.a)
(((\x: Bool .\y: Unit .x) (unfold [ Bool ] (fold [ Bool ] (let u = false in false) )) ) (fix (\x: Bool . ({a = ({a = (let u = 1 in true) , b = ({a = 1 , b = true }.a) }.a) , b = (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) true) }.b) )))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (succ (if (if true then true else false) then 0 else (if false then 1 else 0))) in (let u = true in (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )))) ))
(let u = (( \f: Unit .((f (((\x: Bool .\y: Nat .y) (let u = true in true) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true)) ) (let u = 0 in true) ) ) (\a: Unit .\b: Rec X. X .a)) in u)
(((\x: Bool .\y: Bool .x) (let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = ({a = (unfold [ Unit ] (fold [ Nat ] 1 )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , c = (let u = 0 in u) }.c) }.a) in u) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = 1 in false) )))
(if (( \f: Unit .((f ({a = ({a = (fix (\x: Unit . true )) , b = 0 }.a) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.a) ) (if (unfold [ Bool ] (fold [ Nat ] true )) then (let u = true in u) else (((\x: Bool .\y: Rec X. X .y) false ) false)) ) ) (\a: Unit .\b: Nat .b)) then ({a = ({a = (succ 0) , b = (case <r = (fix (\x: Bool . false )) > as Bool of < l = x > => x | < r = y > => y) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (case <l = (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) (let u = true in 0) ) ) (\a: Nat .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) }.a) else (((\x: Bool .\y: Nat .x) (case <r = (unfold [ Rec X. X ] (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (let u = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) in true) ))))
(((\x: Nat .\y: Bool .x) ({a = (let u = (let u = true in 1) in u) , b = (( \f: Nat .((f (let u = 0 in false) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) , c =  (if (unfold [ Unit ] (fold [ Unit ] (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) )) then (pred 0) else (let u = true in (((\x: Rec X. X .\y: Nat .y) false ) 1))) }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) in (iszero 1)) )))
(fix (\x: Bool . (let u = (let u = (if (((\x: Nat .\y: Unit .y) false ) false) then true else true) in (((\x: Bool .\y: Nat .x) ({a = true , b = ({a = 0 , b = true }.a) }.b) ) (if true then true else true))) in (unfold [ Nat ] (fold [ Unit ] (succ 0) ))) ))
(( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (succ ({a = 0 , b = true , c = 1 }.c)) )) )) ) ({a = (( \f: Unit .((f (( \f: Rec X. X .((f (let u = 0 in u) ) 1 ) ) (\a: Nat .\b: Bool .a)) ) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = ({a = (((\x: Nat .\y: Rec X. X .y) false ) true) , b = (unfold [ Nat ] (fold [ Nat ] 1 )) }.a) , b = (((\x: Rec X. X .\y: Unit .y) ({a = 1 , b = true }.b) ) (let u = false in false)) }.b) , c = (let u = (( \f: Rec X. X .((f (let u = 1 in false) ) (if true then true else false) ) ) (\a: Rec X. X .\b: Bool .b)) in ({a = (let u = 0 in u) , b = ({a = (let u = false in u) , b = (if false then 0 else 1) }.a) }.a)) }.c) ) ) (\a: Bool .\b: Bool .b))
({a = (if (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y) then (iszero (fix (\x: Nat . (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ))) else (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) in (((\x: Rec X. X .\y: Nat .x) false ) true))) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] (if false then 0 else (((\x: Bool .\y: Nat .y) true ) 0)) )) )) }.b)
(( \f: Rec X. X .((f (if ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) )) then (( \f: Rec X. X .((f (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Nat ] 0 )) )) ) (unfold [ Rec X. X ] (fold [ Bool ] (pred ({a = 0 , b = false , c = 0 }.c)) )) ) ) (\a: Bool .\b: Rec X. X .b)) else (pred (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)))) ) (fix (\x: Bool . (unfold [ Unit ] (fold [ Rec X. X ] 0 )) )) ) ) (\a: Nat .\b: Unit .b))
(( \f: Unit .((f ({a = (case <r = (let u = true in true) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (((\x: Bool .\y: Nat .y) false ) 0) ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (if (((\x: Rec X. X .\y: Unit .x) false ) (iszero 0)) then (let u = ({a = 0 , b = true , c = 1 }.c) in u) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) )) ) ) (\a: Rec X. X .\b: Bool .a))
(pred (( \f: Unit .((f (case <l = (let u = (unfold [ Bool ] (fold [ Bool ] true )) in (let u = 1 in 1)) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 )) )) ) ) (\a: Nat .\b: Rec X. X .a)))
(let u = (let u = (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Unit . (if false then false else true) )) ) (( \f: Rec X. X .((f (let u = false in u) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Rec X. X .a))) in u) in (let u = ({a = ({a = (let u = true in true) , b = (fix (\x: Unit . 0 )) }.b) , b = (let u = 1 in false) , c =  (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.b) in u))
({a = (iszero (unfold [ Bool ] (fold [ Rec X. X ] 1 ))) , b = (unfold [ Unit ] (fold [ Unit ] (case <l = (let u = (let u = 1 in 0) in (((\x: Bool .\y: Nat .x) 0 ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a)
(let u = (let u = ({a = (let u = 0 in 1) , b = (((\x: Rec X. X .\y: Bool .x) false ) false) }.b) in (fix (\x: Rec X. X . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ))) in (if ({a = (((\x: Nat .\y: Rec X. X .y) true ) (((\x: Unit .\y: Rec X. X .x) 1 ) false)) , b = (unfold [ Nat ] (fold [ Unit ] (let u = 1 in false) )) }.b) then (if ({a = (iszero 0) , b = (pred (let u = 0 in u)) }.a) then (let u = 0 in 1) else (( \f: Unit .((f ({a = 0 , b = false }.a) ) (let u = 1 in u) ) ) (\a: Unit .\b: Nat .b))) else (case <l = (succ (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b))) > as Bool of < l = x > => x | < r = y > => y)))
(let u = (let u = (case <r = (( \f: Rec X. X .((f (fix (\x: Rec X. X . true )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Nat .x) ({a = true , b = 1 }.b) ) ({a = true , b = 0 }.a))) in u)
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = (((\x: Unit .\y: Rec X. X .y) true ) false) in (if false then false else false)) , b = (((\x: Nat .\y: Rec X. X .x) ({a = ({a = true , b = 1 }.b) , b = ({a = 1 , b = false }.a) }.b) ) (fix (\x: Nat . (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .b)) ))) }.b) ))
({a = (pred (pred 1)) , b = (( \f: Nat .((f (( \f: Rec X. X .((f (iszero (fix (\x: Nat . 1 ))) ) (if ({a = 0 , b = false , c =  0 }.b) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] false )) else true) ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Unit .((f ({a = true , b = true }.b) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  (fix (\x: Rec X. X . (succ (((\x: Bool .\y: Bool .y) true ) 1)) )) }.b)
({a = (let u = ({a = ({a = 0 , b = true }.b) , b = (let u = 0 in 0) }.b) in (if (if ({a = false , b = true }.b) then ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.a) else (let u = false in true)) then ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Rec X. X . true )) )) else (( \f: Unit .((f (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (if ({a = true , b = 1 }.a) then false else true) ) ) (\a: Bool .\b: Unit .b)))) , b = (if ({a = (let u = 0 in false) , b = (((\x: Rec X. X .\y: Unit .y) false ) true) }.b) then (unfold [ Unit ] (fold [ Nat ] (fix (\x: Rec X. X . true )) )) else (((\x: Rec X. X .\y: Bool .x) ({a = ({a = 1 , b = false }.b) , b = (((\x: Nat .\y: Rec X. X .x) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) false) }.a) ) ({a = (let u = false in u) , b = (let u = 1 in u) }.a))) }.b)
({a = ({a = ({a = (let u = 1 in u) , b = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) , c =  (let u = 1 in 0) }.b) , b = (case <r = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (let u = ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] false )) in ({a = 1 , b = (unfold [ Nat ] (fold [ Nat ] 0 )) }.b)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) }.a) in u) }.a)
({a = (let u = (let u = false in u) in (( \f: Nat .((f 1 ) (if false then 0 else 0) ) ) (\a: Unit .\b: Rec X. X .b))) , b = ({a = (((\x: Unit .\y: Rec X. X .x) (iszero 0) ) ({a = (let u = ({a = false , b = 0 }.a) in ({a = 1 , b = false }.b)) , b = (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) in u) }.a)) , b = (let u = (((\x: Unit .\y: Bool .y) ({a = true , b = 0 }.a) ) ({a = 1 , b = 0 }.b)) in u) }.a) , c = (fix (\x: Bool . (succ (let u = 1 in u)) )) }.c)
(( \f: Rec X. X .((f ({a = (unfold [ Bool ] (fold [ Rec X. X ] (succ 1) )) , b = (( \f: Nat .((f (let u = false in u) ) (((\x: Rec X. X .\y: Unit .y) false ) false) ) ) (\a: Rec X. X .\b: Bool .b)) , c = (case <l = (succ ({a = false , b = (((\x: Bool .\y: Rec X. X .y) false ) 1) }.b)) > as Unit of < l = x > => x | < r = y > => y) }.c) ) (( \f: Bool .((f (case <l = (( \f: Unit .((f (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Unit .\b: Unit .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Rec X. X .y) (iszero (if true then 1 else 1)) ) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 1 )) , b = (let u = 0 in true) , c = (succ 1) }.c)) ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(( \f: Bool .((f (let u = (let u = (pred 0) in u) in ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) ))) ) (((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Nat .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Bool .b)) )) ) ({a = 0 , b = true , c =  0 }.b)) ) (fix (\x: Bool . ({a = false , b = 0 }.a) ))) ) (let u = (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) )) in (if (iszero 0) then (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) else (((\x: Nat .\y: Bool .x) 0 ) false)))) ) ) (\a: Bool .\b: Unit .b))
(case <r = (let u = (let u = ({a = (((\x: Rec X. X .\y: Unit .x) false ) false) , b = (let u = true in 1) }.a) in u) in (( \f: Nat .((f (let u = (if true then false else false) in u) ) (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in false) ) ) (\a: Rec X. X .\b: Bool .a))) > as Nat of < l = x > => x | < r = y > => y)
(let u = (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in u) )) )) in (succ (( \f: Nat .((f (let u = true in ({a = 1 , b = false }.a)) ) ({a = (succ 0) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) , c = 0 }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b))))
(if (((\x: Bool .\y: Bool .y) (let u = (let u = false in (((\x: Bool .\y: Bool .y) false ) 1)) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) ) (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))) then (fix (\x: Unit . ({a = ({a = (unfold [ Rec X. X ] (fold [ Bool ] ({a = false , b = false }.b) )) , b = (( \f: Rec X. X .((f 1 ) ({a = true , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) , b = (let u = (succ 0) in u) }.b) )) else (let u = (((\x: Rec X. X .\y: Nat .y) ({a = false , b = 0 }.a) ) (((\x: Unit .\y: Bool .y) false ) 1)) in ({a = (( \f: Bool .((f true ) ({a = true , b = 0 }.a) ) ) (\a: Nat .\b: Bool .b)) , b = (let u = 1 in 0) }.b)))
({a = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = false in u) )) , b = (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in u) }.b) , b = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = true , c =  0 }.b) ) (fix (\x: Bool . 1 ))) in ({a = (let u = false in true) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.b)) , b = (let u = (let u = false in u) in (let u = (((\x: Rec X. X .\y: Nat .y) false ) true) in 1)) }.a) }.b)
({a = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = false , c =  0 }.b) )) , b = (succ (let u = (if true then false else true) in ({a = 1 , b = 1 }.b))) }.a) , b = (fix (\x: Rec X. X . ({a = (if true then 1 else 0) , b = (if true then 1 else (((\x: Unit .\y: Unit .x) 1 ) true)) }.b) )) }.b)
(unfold [ Bool ] (fold [ Unit ] (let u = ({a = (let u = (let u = true in 0) in (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) , b = ({a = true , b = 1 }.b) }.b) in ({a = (pred 1) , b = ({a = false , b = true }.b) }.a)) ))
(iszero (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Nat ] (fold [ Unit ] 0 )) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (fix (\x: Nat . 1 )) )) ) ) (\a: Bool .\b: Rec X. X .b)))
(( \f: Unit .((f ({a = (( \f: Unit .((f (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) in ({a = 0 , b = true , c = 1 }.c)) ) ({a = 0 , b = true , c = ({a = true , b = 0 }.b) }.c) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = ({a = (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] true )) ) (((\x: Unit .\y: Bool .y) false ) false) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Nat ] true )) }.b) , b = (((\x: Unit .\y: Bool .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) true) }.b) }.a) ) (if (fix (\x: Bool . (( \f: Rec X. X .((f false ) (let u = true in u) ) ) (\a: Nat .\b: Rec X. X .a)) )) then (( \f: Nat .((f (let u = 0 in u) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) else (( \f: Nat .((f (let u = 1 in u) ) 1 ) ) (\a: Nat .\b: Nat .b))) ) ) (\a: Bool .\b: Nat .b))
({a = ({a = ({a = ({a = 1 , b = 1 }.b) , b = ({a = 0 , b = (((\x: Bool .\y: Nat .x) true ) false) }.b) }.a) , b = (((\x: Unit .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) 1) }.b) , b = (fix (\x: Unit . (( \f: Nat .((f false ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) )) }.b)
(succ (let u = (let u = ({a = 1 , b = (((\x: Unit .\y: Unit .y) true ) 0) }.b) in ({a = 1 , b = (fix (\x: Bool . false )) , c = 0 }.c)) in u))
({a = (let u = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) in u) in (if ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true , c = 1 }.c) }.a) then ({a = 1 , b = 1 }.b) else (pred 0))) , b = (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in ({a = ({a = ({a = 0 , b = true , c = 0 }.c) , b = true }.a) , b = (let u = false in u) , c =  ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.c) }.b)) , c = (let u = (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (fix (\x: Nat . false )) else (unfold [ Rec X. X ] (fold [ Bool ] false ))) in (pred (if false then (succ 1) else 1))) }.c)
((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (let u = (unfold [ Unit ] (fold [ Unit ] false )) in 1) in (let u = ({a = false , b = 0 }.b) in (((\x: Bool .\y: Rec X. X .x) true ) false))) ))
({a = (if ({a = (( \f: Bool .((f ({a = 1 , b = true }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] false )) )) ) ) (\a: Unit .\b: Nat .a)) , b = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (if true then 1 else 0) )) in ({a = 1 , b = false , c =  ({a = 1 , b = 1 }.b) }.b)) }.b) then ({a = (let u = 1 in false) , b = (((\x: Rec X. X .\y: Bool .y) false ) 1) }.a) else ({a = (((\x: Bool .\y: Rec X. X .x) false ) true) , b = (fix (\x: Unit . (( \f: Rec X. X .((f 0 ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) ) ) (\a: Nat .\b: Bool .a)) )) }.a)) , b = (((\x: Bool .\y: Nat .x) (( \f: Nat .((f (( \f: Unit .((f true ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) ) ({a = true , b = ({a = 0 , b = true }.a) }.a)) ) ) (\a: Nat .\b: Bool .b)) ) ({a = (pred (fix (\x: Nat . 0 ))) , b = (let u = (let u = 1 in 1) in ({a = 1 , b = (unfold [ Unit ] (fold [ Nat ] true )) }.b)) }.b)) }.b)
(unfold [ Unit ] (fold [ Nat ] ({a = (fix (\x: Unit . (fix (\x: Nat . true )) )) , b = (pred ({a = (((\x: Bool .\y: Nat .x) ({a = false , b = true }.b) ) true) , b = (((\x: Bool .\y: Bool .y) false ) 0) }.b)) }.b) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f (iszero (let u = true in 0)) ) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) , b = (let u = 1 in (((\x: Unit .\y: Unit .y) true ) false)) , c =  (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) )) }.b) ) ) (\a: Unit .\b: Bool .b)) ))
(pred (( \f: Bool .((f ({a = (iszero 1) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (if false then 1 else 1) )) }.b) ) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = 1 }.b) ) ) (\a: Unit .\b: Rec X. X .a)))
(let u = (if (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) false ) true) ) false ) ) (\a: Nat .\b: Rec X. X .b)) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) else (let u = ({a = true , b = false }.b) in 1)) in (if ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (iszero (let u = (((\x: Unit .\y: Unit .y) true ) 1) in 1)) )) then (((\x: Rec X. X .\y: Unit .x) (case <r = ({a = 1 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f false ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Nat .b))) else (let u = (let u = (pred 0) in (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a))) in ({a = 0 , b = false , c =  1 }.b))))
(let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = (let u = false in 0) }.b) )) in ({a = (iszero (succ 1)) , b = (let u = (let u = ({a = 0 , b = false }.a) in (let u = false in 1)) in u) }.a))
(let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Bool .\y: Nat .x) (let u = ({a = 0 , b = 1 }.b) in true) ) ({a = true , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b)) )) in ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) )) )))
(let u = (( \f: Bool .((f (succ (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = false , b = 0 }.b))) ) (succ (fix (\x: Nat . (let u = false in 1) ))) ) ) (\a: Rec X. X .\b: Unit .a)) in u)
(if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) (let u = true in u) ) ({a = true , b = (fix (\x: Rec X. X . true )) }.b)) )) then ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (if false then true else true) )) , b = (( \f: Rec X. X .((f (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = true , b = false }.b) ) ) (\a: Unit .\b: Nat .b)) }.b) else (((\x: Unit .\y: Unit .x) (( \f: Nat .((f (fix (\x: Nat . true )) ) (((\x: Rec X. X .\y: Unit .x) false ) true) ) ) (\a: Unit .\b: Nat .b)) ) ({a = (let u = 0 in false) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.b)))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = ({a = (((\x: Nat .\y: Rec X. X .x) (iszero 0) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = (succ 0) }.b) in u) ))
(let u = (let u = (iszero 1) in ({a = (let u = 1 in 1) , b = (iszero 0) , c = ({a = 0 , b = true , c = 1 }.c) }.c)) in u)
({a = (let u = (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Nat ] (let u = false in false) )) ) (if (( \f: Rec X. X .((f (fix (\x: Rec X. X . true )) ) (((\x: Unit .\y: Rec X. X .y) true ) true) ) ) (\a: Nat .\b: Nat .b)) then (case <r = (((\x: Rec X. X .\y: Rec X. X .y) true ) true) > as Bool of < l = x > => x | < r = y > => y) else (if true then true else true))) in u) , b = (if (iszero (unfold [ Bool ] (fold [ Bool ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ))) then (( \f: Unit .((f ({a = 1 , b = true , c = 0 }.c) ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) else (let u = (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) in 1) in (fix (\x: Unit . (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) )))) }.a)
({a = (case <l = ({a = ({a = 1 , b = false , c =  1 }.b) , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Nat .x) ({a = (( \f: Bool .((f false ) (((\x: Nat .\y: Nat .y) false ) true) ) ) (\a: Unit .\b: Nat .b)) , b = (((\x: Unit .\y: Bool .x) (fix (\x: Nat . false )) ) true) }.b) ) (((\x: Bool .\y: Bool .y) ({a = (fix (\x: Unit . 1 )) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .b)) , c =  ({a = 0 , b = 0 }.b) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )))) }.a)
(unfold [ Unit ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .a)) then 0 else ({a = 0 , b = true }.a)) )) ))
(if (iszero (let u = (let u = (let u = true in true) in false) in (( \f: Unit .((f (let u = false in (let u = false in 0)) ) (let u = 0 in u) ) ) (\a: Unit .\b: Unit .a)))) then (succ (( \f: Unit .((f (let u = 1 in u) ) (( \f: Bool .((f (pred 0) ) 0 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Unit .\b: Unit .b))) else ({a = ({a = (((\x: Bool .\y: Rec X. X .y) true ) true) , b = (pred 0) }.a) , b = (fix (\x: Nat . (let u = false in (fix (\x: Nat . 1 ))) )) }.b))
(succ ({a = ({a = ({a = false , b = (((\x: Bool .\y: Unit .x) 0 ) false) }.b) , b = (let u = 1 in (let u = 1 in 0)) }.b) , b = (((\x: Rec X. X .\y: Unit .y) (iszero 1) ) (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) }.b))
(case <l = ({a = (case <l = (let u = 1 in u) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Rec X. X .x) (( \f: Unit .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) (((\x: Rec X. X .\y: Nat .y) false ) false) ) ) (\a: Unit .\b: Nat .b)) ) (let u = (unfold [ Nat ] (fold [ Unit ] (let u = true in false) )) in u)) , c = (((\x: Bool .\y: Rec X. X .x) ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) , b = true , c = (let u = false in 1) }.c) ) (unfold [ Unit ] (fold [ Nat ] false ))) }.c) > as Nat of < l = x > => x | < r = y > => y)
(if (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in (( \f: Unit .((f (if true then false else true) ) (fix (\x: Rec X. X . true )) ) ) (\a: Nat .\b: Bool .a))) then (let u = (let u = ({a = 1 , b = false }.a) in ({a = 1 , b = true }.b)) in u) else (let u = (( \f: Unit .((f (fix (\x: Unit . 0 )) ) (pred 1) ) ) (\a: Rec X. X .\b: Unit .b)) in (fix (\x: Nat . false ))))
({a = (unfold [ Bool ] (fold [ Unit ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 0 , b = false , c = 1 }.c) )) )) , b = ({a = (succ (let u = ({a = 1 , b = 0 }.b) in u)) , b = (((\x: Nat .\y: Rec X. X .y) ({a = (( \f: Rec X. X .((f (if true then true else false) ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = 0 , b = false , c = (let u = false in 1) }.c) }.a) ) (unfold [ Unit ] (fold [ Nat ] (let u = (if true then false else false) in (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) ))) }.b) }.b)
({a = (((\x: Unit .\y: Bool .y) ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .b)) , b = 1 }.a) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a))) , b = (let u = (((\x: Rec X. X .\y: Nat .x) (unfold [ Bool ] (fold [ Nat ] (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b)) )) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a))) in (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Bool .y) true ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) else (let u = false in true))) }.b)
(unfold [ Nat ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (case <l = ({a = 0 , b = (((\x: Nat .\y: Nat .y) false ) false) , c = (let u = 0 in 1) }.c) > as Unit of < l = x > => x | < r = y > => y) )) ))
({a = (( \f: Bool .((f ({a = (((\x: Nat .\y: Nat .x) 0 ) true) , b = ({a = 0 , b = false , c = 0 }.c) }.b) ) (((\x: Unit .\y: Nat .x) ({a = 0 , b = true , c = 1 }.c) ) (( \f: Bool .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (let u = false in true) ) ) (\a: Bool .\b: Unit .b))) ) ) (\a: Bool .\b: Nat .b)) , b = ({a = (let u = (iszero (unfold [ Rec X. X ] (fold [ Unit ] 0 ))) in (iszero 1)) , b = (fix (\x: Rec X. X . 0 )) }.b) }.b)
((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (( \f: Rec X. X .((f (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a))) ) ({a = ({a = 0 , b = 0 }.b) , b = (((\x: Bool .\y: Unit .y) true ) 1) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) ))
(( \f: Unit .((f (if (( \f: Nat .((f (((\x: Unit .\y: Unit .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .y) false ) false) )) ) (iszero 0)) ) (((\x: Nat .\y: Unit .y) ({a = 1 , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) }.b) ) (unfold [ Unit ] (fold [ Unit ] true ))) ) ) (\a: Bool .\b: Nat .b)) then (pred (let u = false in 0)) else (succ (if false then 0 else (unfold [ Nat ] (fold [ Rec X. X ] 0 ))))) ) ({a = (pred (if (let u = false in u) then ({a = true , b = 1 }.b) else (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)))) , b = (iszero ({a = true , b = 0 }.b)) }.a) ) ) (\a: Unit .\b: Bool .b))
(let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a)) ) (if true then false else true)) , b = (( \f: Nat .((f 1 ) (pred 0) ) ) (\a: Nat .\b: Unit .a)) }.b) )) in u)
(((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Bool .y) ({a = ({a = (iszero 0) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .y) true ) 1) )) ) ({a = ({a = 1 , b = true }.b) , b = 1 }.b) ) ) (\a: Nat .\b: Unit .a)) }.a) ) (((\x: Unit .\y: Unit .y) (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then false else ({a = 0 , b = true }.b)) ) (iszero 1))) ) (unfold [ Unit ] (fold [ Nat ] (let u = (iszero 0) in (let u = false in false)) )))
(let u = (fix (\x: Unit . (let u = (if true then (((\x: Bool .\y: Bool .y) true ) 1) else 0) in (unfold [ Unit ] (fold [ Bool ] (fix (\x: Unit . false )) ))) )) in u)
(let u = (if ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (if (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) then true else false) )) then (( \f: Unit .((f 1 ) (let u = true in 1) ) ) (\a: Bool .\b: Nat .b)) else (( \f: Rec X. X .((f 0 ) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) ) ) (\a: Rec X. X .\b: Bool .a))) in u)
({a = (pred (fix (\x: Nat . (succ 1) ))) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (((\x: Unit .\y: Bool .y) true ) ({a = 1 , b = false }.b)) , b = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , b = (let u = false in 0) }.a) }.b) )) }.b)
(let u = (case <l = ({a = ({a = true , b = 0 }.b) , b = (let u = 0 in true) }.a) > as Bool of < l = x > => x | < r = y > => y) in u)
(( \f: Bool .((f (fix (\x: Bool . (let u = (succ 0) in (( \f: Unit .((f (((\x: Bool .\y: Nat .y) true ) 1) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Nat .a))) )) ) (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) )) in u) ) ) (\a: Unit .\b: Unit .b))
(fix (\x: Rec X. X . ({a = (case <l = ({a = 1 , b = true }.a) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (if false then 0 else 1) , b = (fix (\x: Unit . true )) , c =  (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) }.b) ))
(fix (\x: Bool . (let u = (((\x: Unit .\y: Rec X. X .x) ({a = 1 , b = (unfold [ Bool ] (fold [ Nat ] false )) }.b) ) (( \f: Bool .((f (fix (\x: Unit . false )) ) (if true then false else false) ) ) (\a: Unit .\b: Rec X. X .a))) in u) ))
(let u = ({a = ({a = (if ({a = (let u = 1 in u) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) , c =  0 }.b) then ({a = (let u = true in u) , b = ({a = 0 , b = false , c =  0 }.b) }.b) else ({a = false , b = 1 }.a)) , b = (let u = 0 in (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) }.b) , b = (let u = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in (fix (\x: Bool . 1 ))) in (((\x: Unit .\y: Nat .x) (((\x: Rec X. X .\y: Unit .x) false ) true) ) (unfold [ Rec X. X ] (fold [ Bool ] false )))) }.b) in u)
(((\x: Unit .\y: Nat .x) ({a = (if ({a = false , b = true }.b) then (pred 0) else ({a = 0 , b = false }.a)) , b = (case <l = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 1 )) > as Nat of < l = x > => x | < r = y > => y) }.b) ) ({a = (let u = (((\x: Unit .\y: Unit .y) true ) 0) in u) , b = (if (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) then (let u = true in true) else false) , c =  (let u = (((\x: Rec X. X .\y: Nat .y) false ) false) in (((\x: Rec X. X .\y: Bool .x) 0 ) true)) }.b))
(iszero (( \f: Bool .((f (((\x: Rec X. X .\y: Bool .y) false ) 1) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Unit .a)))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ({a = ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = ({a = 1 , b = true , c =  0 }.b) , c =  (((\x: Nat .\y: Nat .x) 1 ) true) }.b) , b = (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 0 in u) ))) }.b) , b = (((\x: Bool .\y: Bool .x) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Nat ] true ))) }.b) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (( \f: Unit .((f (let u = 0 in true) ) (let u = 0 in false) ) ) (\a: Bool .\b: Bool .b)) in (iszero 0)) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = false }.b) }.a) ) (let u = 1 in u) ) ) (\a: Unit .\b: Bool .a)) ))
(pred (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) ({a = false , b = 0 }.b) ) (if false then true else true)) )))
(((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (let u = 0 in (if true then 1 else 0)) ) (unfold [ Nat ] (fold [ Unit ] (let u = 0 in 1) )) ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = (iszero (((\x: Unit .\y: Bool .x) 1 ) true)) in u))
(( \f: Unit .((f (( \f: Nat .((f (fix (\x: Bool . (let u = ({a = true , b = 1 }.a) in u) )) ) (case <r = (( \f: Nat .((f true ) (unfold [ Bool ] (fold [ Rec X. X ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) ) ({a = (((\x: Nat .\y: Bool .x) (unfold [ Unit ] (fold [ Bool ] 0 )) ) (let u = 1 in (iszero 0))) , b = ({a = ({a = true , b = 1 }.a) , b = true }.b) , c =  (succ (let u = 1 in 1)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(if (unfold [ Bool ] (fold [ Nat ] ({a = (pred ({a = 0 , b = true , c = 1 }.c)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) }.b) )) then ({a = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = false , c =  (let u = 0 in u) }.b) , b = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = 1 , b = true , c =  0 }.b)) }.b) else (if (iszero (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b))) then (let u = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 0 )) , b = (if false then false else false) , c =  (let u = 1 in 1) }.b) in (if true then true else true)) else (let u = (unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) )) in (case <r = false > as Nat of < l = x > => x | < r = y > => y))))
({a = (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) (let u = false in 0) ) (((\x: Bool .\y: Rec X. X .x) false ) false)) ) ({a = ({a = 0 , b = 1 }.b) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .a)) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = (fix (\x: Nat . (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) in (unfold [ Bool ] (fold [ Rec X. X ] (let u = ({a = true , b = (succ 1) }.b) in ({a = 1 , b = true , c =  1 }.b)) ))) , c = (fix (\x: Bool . (let u = 0 in u) )) }.c)
(if (let u = (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = false , c =  0 }.b) )) in u) then (if ({a = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (if true then 1 else 1) , b = (unfold [ Nat ] (fold [ Nat ] true )) }.b) }.b) , b = (((\x: Bool .\y: Nat .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = (let u = false in false) }.a)) }.a) then (( \f: Rec X. X .((f (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) false ) true) ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = (let u = ({a = 0 , b = 1 }.b) in (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a))) in (if true then false else (((\x: Nat .\y: Nat .y) true ) true))) ) ) (\a: Rec X. X .\b: Bool .b)) else (if (iszero 1) then (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Nat .b)) else (let u = 0 in (unfold [ Unit ] (fold [ Rec X. X ] false ))))) else (let u = (iszero ({a = 0 , b = true , c = 1 }.c)) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)))
({a = (let u = (( \f: Bool .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) ) (if false then false else true) ) ) (\a: Unit .\b: Unit .b)) in u) , b = (case <r = ({a = (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false , c = 0 }.c) }.a) > as Nat of < l = x > => x | < r = y > => y) }.b)
(((\x: Unit .\y: Bool .x) (case <l = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then 1 else (fix (\x: Unit . 0 ))) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (fix (\x: Rec X. X . (let u = (if ({a = false , b = 0 }.a) then true else true) in ({a = ({a = 0 , b = 1 }.b) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) }.b)) )) in (((\x: Unit .\y: Bool .x) (((\x: Bool .\y: Rec X. X .y) false ) true) ) ({a = true , b = false }.b))))
(unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Unit .y) ({a = true , b = true }.b) ) (fix (\x: Nat . ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ))) ))
(fix (\x: Unit . (((\x: Bool .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Unit ] (fix (\x: Unit . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) )) )) ) (iszero ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b))) ))
({a = (unfold [ Unit ] (fold [ Bool ] ({a = (let u = true in false) , b = (((\x: Nat .\y: Bool .y) false ) true) }.b) )) , b = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (succ (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b))) )) , b = (( \f: Rec X. X .((f ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) , b = true }.a) ) (let u = ({a = 1 , b = true , c =  0 }.b) in ({a = 0 , b = false , c = 0 }.c)) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) }.a)
({a = (fix (\x: Nat . (if (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (succ 0) else (pred 1)) )) , b = ({a = (pred 0) , b = ({a = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = 1 , b = false }.b) }.b) , c =  ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) )) }.b) }.a)
({a = ({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in false) )) in ({a = (let u = 1 in 1) , b = (let u = 0 in false) }.b)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) }.b) , b = (case <l = ({a = (if (let u = true in false) then (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in u) else (fix (\x: Unit . 1 ))) , b = ({a = (succ 0) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , c =  (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) }.a) > as Unit of < l = x > => x | < r = y > => y) }.b)
(((\x: Nat .\y: Bool .x) (let u = (( \f: Rec X. X .((f (let u = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) in (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b))) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = false in false) )) ) ) (\a: Bool .\b: Rec X. X .b)) in (unfold [ Nat ] (fold [ Bool ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) ))) ) ({a = (let u = (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) in u) , b = (((\x: Rec X. X .\y: Rec X. X .y) (let u = (((\x: Bool .\y: Rec X. X .y) false ) false) in ({a = 0 , b = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a)) , c =  1 }.b)) ) (let u = (((\x: Bool .\y: Nat .x) false ) (((\x: Unit .\y: Nat .x) true ) true)) in u)) }.b))
(let u = (case <r = (let u = (if false then 1 else 0) in false) > as Nat of < l = x > => x | < r = y > => y) in u)
(let u = (if (let u = true in true) then (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .b)) ) (let u = true in true)) else ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = ({a = 1 , b = 0 }.b) }.a)) in ({a = (succ 1) , b = ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) true) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Nat .b)) }.a) }.b))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) )) ) ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in (fix (\x: Nat . false ))) , c =  (( \f: Bool .((f 1 ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Unit .b)) }.b)) ) (case <l = ({a = (((\x: Rec X. X .\y: Nat .x) (let u = true in 1) ) false) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) }.a) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a))
(((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) (let u = 1 in true) ) ({a = 1 , b = false }.b)) ) (let u = ({a = 0 , b = false }.b) in (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b))) ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Bool .\y: Rec X. X .x) ({a = (unfold [ Bool ] (fold [ Bool ] 1 )) , b = (let u = (fix (\x: Unit . true )) in 1) }.b) ) (fix (\x: Bool . (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = true in false)) ))))
({a = (if ({a = (let u = (unfold [ Unit ] (fold [ Unit ] false )) in u) , b = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = 0 , b = true }.b)) }.b) then (let u = (if false then 0 else 0) in ({a = 1 , b = false , c = 0 }.c)) else (( \f: Rec X. X .((f ({a = 0 , b = true , c = 1 }.c) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Rec X. X .a))) , b = (iszero ({a = 1 , b = 1 }.b)) , c =  (pred ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (pred 1) ))) }.b)
({a = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Unit .((f (if false then 1 else 0) ) (succ 0) ) ) (\a: Unit .\b: Unit .a)) else ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 ))) , b = (let u = (fix (\x: Unit . 0 )) in ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) , b = (succ 1) }.a)) , c = (let u = ({a = ({a = 0 , b = false , c =  1 }.b) , b = (unfold [ Bool ] (fold [ Nat ] 0 )) }.b) in u) }.c)
(((\x: Unit .\y: Bool .y) ({a = (( \f: Rec X. X .((f ({a = 0 , b = true }.b) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = ({a = 1 , b = false }.b) in u) }.b) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = ({a = (( \f: Bool .((f (succ 1) ) (succ 1) ) ) (\a: Nat .\b: Unit .b)) , b = (unfold [ Nat ] (fold [ Unit ] 1 )) }.b) }.b))
(( \f: Nat .((f ({a = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (let u = 1 in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Bool .\b: Unit .b)) , b = (( \f: Nat .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (if false then true else true) ) ) (\a: Bool .\b: Nat .a)) }.a) ) (if ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (let u = true in (fix (\x: Unit . true ))) , c =  (fix (\x: Bool . 1 )) }.b) then (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) (let u = false in 0) ) ) (\a: Nat .\b: Bool .b)) else (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) ) (fix (\x: Nat . 0 )) ) ) (\a: Nat .\b: Bool .b))) ) ) (\a: Bool .\b: Nat .a))
(iszero ({a = (fix (\x: Unit . (fix (\x: Bool . 0 )) )) , b = (fix (\x: Bool . (let u = 1 in true) )) }.a))
({a = (pred (case <l = (if false then 0 else 0) > as Bool of < l = x > => x | < r = y > => y)) , b = (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (let u = false in 1)) )) }.b)
(iszero (case <l = ({a = (fix (\x: Nat . true )) , b = (((\x: Nat .\y: Nat .y) (let u = false in u) ) (((\x: Bool .\y: Bool .x) 1 ) true)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
(unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Rec X. X .x) (if ({a = (let u = 1 in 1) , b = ({a = 1 , b = false }.b) }.b) then ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (pred 1) )) else ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then 0 else (if false then 1 else 1)) ))) ) (((\x: Bool .\y: Rec X. X .x) ({a = ({a = 1 , b = false }.a) , b = ({a = false , b = 0 }.a) }.b) ) (let u = 0 in false))) ))
({a = (let u = ({a = (((\x: Nat .\y: Unit .x) 1 ) ({a = 1 , b = false }.b)) , b = (( \f: Unit .((f false ) (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) in (succ (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)))) , b = (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) false) )) , c =  (let u = (fix (\x: Unit . ({a = ({a = false , b = 1 }.b) , b = 0 }.b) )) in (pred ({a = 0 , b = true }.a))) }.b)
(let u = ({a = (let u = (((\x: Unit .\y: Rec X. X .x) 1 ) (fix (\x: Bool . false ))) in (fix (\x: Rec X. X . true ))) , b = (succ (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))) }.b) in (let u = (((\x: Unit .\y: Unit .x) false ) (let u = true in u)) in (let u = ({a = 0 , b = false }.a) in false)))
(fix (\x: Bool . (( \f: Rec X. X .((f ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) , b = ({a = 0 , b = true }.b) , c = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.c) ) (case <l = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = false in u) , c = 1 }.c) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) ))
(iszero ({a = (fix (\x: Unit . (pred 0) )) , b = (((\x: Rec X. X .\y: Nat .y) ({a = (let u = false in u) , b = ({a = 1 , b = true }.b) }.b) ) (iszero 0)) , c = ({a = (( \f: Bool .((f ({a = 0 , b = true }.a) ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a) }.c))
(((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Nat .y) (((\x: Bool .\y: Bool .x) true ) ({a = 1 , b = false }.b)) ) (unfold [ Rec X. X ] (fold [ Bool ] (let u = false in false) ))) ) (fix (\x: Bool . ({a = ({a = ({a = true , b = 0 }.a) , b = 1 }.b) , b = (iszero (case <l = (let u = 0 in u) > as Unit of < l = x > => x | < r = y > => y)) , c =  (succ 1) }.b) )))
(if ({a = (if (unfold [ Nat ] (fold [ Rec X. X ] false )) then (((\x: Rec X. X .\y: Unit .x) false ) false) else ({a = true , b = (fix (\x: Nat . true )) }.b)) , b = (( \f: Nat .((f (unfold [ Nat ] (fold [ Unit ] true )) ) (let u = 0 in (((\x: Nat .\y: Bool .x) false ) true)) ) ) (\a: Bool .\b: Nat .b)) }.b) then ({a = (pred ({a = 0 , b = (let u = 0 in 1) }.b)) , b = (iszero (let u = 0 in u)) }.b) else (if (let u = (( \f: Nat .((f (iszero 0) ) (let u = false in u) ) ) (\a: Nat .\b: Unit .b)) in (unfold [ Nat ] (fold [ Rec X. X ] (if true then true else false) ))) then (unfold [ Unit ] (fold [ Nat ] (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in u) )) else (iszero (if (unfold [ Bool ] (fold [ Nat ] false )) then (pred 1) else 1))))
({a = (let u = (((\x: Rec X. X .\y: Nat .x) 0 ) ({a = 1 , b = true , c =  1 }.b)) in u) , b = (let u = (((\x: Nat .\y: Unit .y) ({a = 0 , b = false , c =  0 }.b) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) in u) }.b)
(succ (((\x: Unit .\y: Rec X. X .y) (iszero (unfold [ Nat ] (fold [ Unit ] (succ 0) ))) ) (let u = (pred 0) in (unfold [ Rec X. X ] (fold [ Bool ] 1 )))))
(if ({a = ({a = (let u = 1 in false) , b = (let u = true in u) }.b) , b = ({a = (let u = true in 0) , b = (fix (\x: Bool . false )) }.b) }.b) then (let u = (((\x: Bool .\y: Bool .y) false ) true) in (fix (\x: Nat . (let u = true in u) ))) else (case <r = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) , c =  ({a = 0 , b = 1 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y))
(( \f: Unit .((f (iszero (( \f: Bool .((f (fix (\x: Nat . 1 )) ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) ) ({a = (case <l = (if (let u = (fix (\x: Rec X. X . 0 )) in true) then ({a = 0 , b = 1 }.b) else (if true then 0 else (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = ({a = (let u = 1 in 1) , b = ({a = false , b = 1 }.a) }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Bool .a))
(let u = (if ({a = (((\x: Nat .\y: Unit .x) 0 ) false) , b = ({a = 1 , b = false , c =  1 }.b) , c =  1 }.b) then (let u = true in (pred 0)) else (let u = true in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )))) in u)
({a = (let u = (( \f: Rec X. X .((f ({a = 1 , b = ({a = true , b = 0 }.b) }.b) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) in ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = ({a = 1 , b = true }.b) }.b)) , b = (unfold [ Bool ] (fold [ Unit ] (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (let u = ({a = true , b = 0 }.b) in true)) )) }.b)
(( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] (( \f: Rec X. X .((f (fix (\x: Unit . false )) ) ({a = false , b = (((\x: Unit .\y: Unit .y) true ) false) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) )) ) (let u = (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = false , c =  0 }.b) )) in ({a = (fix (\x: Unit . 0 )) , b = (((\x: Rec X. X .\y: Bool .x) false ) false) , c =  ({a = 0 , b = 1 }.b) }.b)) ) ) (\a: Unit .\b: Bool .b))
(let u = (((\x: Bool .\y: Unit .x) (case <r = ({a = (fix (\x: Rec X. X . 0 )) , b = (iszero 1) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (case <r = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) > as Bool of < l = x > => x | < r = y > => y) in u)) in ({a = (if false then (((\x: Rec X. X .\y: Unit .y) false ) 0) else 1) , b = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) }.a) }.b))
(fix (\x: Bool . (((\x: Unit .\y: Rec X. X .x) (let u = ({a = (let u = 0 in 0) , b = false , c = ({a = 1 , b = false , c = 1 }.c) }.c) in (case <l = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (fix (\x: Nat . (let u = (if true then true else false) in false) ))) ))
({a = (pred ({a = (( \f: Rec X. X .((f (succ 1) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Unit .b)) , b = (unfold [ Rec X. X ] (fold [ Bool ] (if false then false else true) )) , c = (fix (\x: Unit . 0 )) }.c)) , b = (iszero (( \f: Nat .((f (pred (unfold [ Bool ] (fold [ Nat ] 0 ))) ) ({a = 1 , b = false , c = (succ 1) }.c) ) ) (\a: Nat .\b: Bool .a))) }.b)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = (let u = (unfold [ Nat ] (fold [ Rec X. X ] true )) in u) in ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = true , c = 0 }.c)) ))
(fix (\x: Unit . ({a = (iszero (let u = 1 in u)) , b = ({a = 1 , b = 0 }.b) }.b) ))
({a = (let u = ({a = true , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) }.a) in u) , b = (let u = (( \f: Unit .((f 0 ) ({a = true , b = 0 }.b) ) ) (\a: Bool .\b: Unit .b)) in ({a = (if true then true else true) , b = false }.b)) }.b)
(if ({a = (let u = true in 1) , b = (fix (\x: Unit . false )) , c =  (fix (\x: Nat . 1 )) }.b) then ({a = (succ (((\x: Nat .\y: Rec X. X .y) true ) 1)) , b = (((\x: Rec X. X .\y: Nat .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) ) (let u = 1 in false)) , c = (succ ({a = 1 , b = 0 }.b)) }.c) else (( \f: Nat .((f (let u = (let u = false in u) in (let u = false in 0)) ) (((\x: Rec X. X .\y: Nat .y) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , b = (let u = false in u) }.b) ) (pred ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , c = 0 }.c))) ) ) (\a: Rec X. X .\b: Unit .a)))
(( \f: Bool .((f ({a = ({a = (iszero 0) , b = (let u = true in false) }.b) , b = ({a = (case <r = ({a = 1 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.a) }.b) ) (((\x: Bool .\y: Nat .y) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = true , c = 0 }.c) )) in ({a = false , b = 1 }.a)) ) ({a = (((\x: Unit .\y: Bool .y) true ) true) , b = (succ 1) }.a)) ) ) (\a: Unit .\b: Bool .b))
(((\x: Unit .\y: Unit .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = (let u = true in 0) , b = true , c = (let u = true in 1) }.c) in (if true then 1 else 1)) )) ) (((\x: Nat .\y: Unit .x) (((\x: Unit .\y: Bool .y) false ) true) ) (( \f: Unit .((f true ) ({a = 0 , b = true }.b) ) ) (\a: Nat .\b: Rec X. X .a))))
({a = (( \f: Rec X. X .((f (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) )) ) (iszero ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) false ) 0) ) (pred 0) ) ) (\a: Rec X. X .\b: Bool .a)) ))) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = ({a = 1 , b = (pred 1) }.b) in u) }.b)
({a = ({a = (fix (\x: Unit . (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = (((\x: Bool .\y: Rec X. X .y) ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) false) , b = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) }.b) ) (fix (\x: Rec X. X . ({a = 0 , b = true , c = 1 }.c) ))) }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = false in false) )) )) }.a)
({a = (unfold [ Unit ] (fold [ Unit ] (( \f: Bool .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = false , b = true }.b) ) ) (\a: Nat .\b: Bool .b)) )) , b = (let u = ({a = (((\x: Nat .\y: Rec X. X .y) false ) false) , b = (((\x: Bool .\y: Nat .x) (let u = 0 in 0) ) true) }.b) in (unfold [ Bool ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) ))) }.b)
(fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f (let u = (((\x: Bool .\y: Nat .x) 1 ) true) in u) ) (if false then 1 else 0) ) ) (\a: Nat .\b: Rec X. X .a)) )) ))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (case <r = (let u = (if false then ({a = 1 , b = true , c = 0 }.c) else (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) in (let u = true in u)) > as Nat of < l = x > => x | < r = y > => y) ))
(( \f: Nat .((f (fix (\x: Bool . ({a = 1 , b = ({a = 0 , b = false , c =  0 }.b) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.c) )) ) (( \f: Unit .((f (case <l = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) > as Bool of < l = x > => x | < r = y > => y) ) (pred ({a = false , b = 1 }.b)) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .a))
({a = (succ (succ (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)))) , b = ({a = (case <l = (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Unit ] 1 )) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (if true then 1 else 1) , b = (((\x: Bool .\y: Rec X. X .x) false ) false) , c = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.c) }.b) }.b)
(let u = (if (((\x: Rec X. X .\y: Rec X. X .x) (if ({a = 0 , b = false , c =  1 }.b) then ({a = false , b = false }.b) else (fix (\x: Rec X. X . false ))) ) (((\x: Nat .\y: Rec X. X .x) true ) ({a = true , b = true }.b))) then (fix (\x: Rec X. X . (iszero ({a = 0 , b = 1 }.b)) )) else (( \f: Rec X. X .((f (if (let u = false in u) then (let u = (let u = false in false) in ({a = 0 , b = false }.b)) else (((\x: Unit .\y: Bool .x) true ) true)) ) (if ({a = (((\x: Bool .\y: Nat .y) false ) 0) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , c =  1 }.b) then (unfold [ Nat ] (fold [ Rec X. X ] false )) else (((\x: Bool .\y: Nat .x) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) false)) ) ) (\a: Bool .\b: Nat .b))) in (((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Bool .y) (let u = 1 in false) ) false) ) (succ ({a = 0 , b = false , c = 0 }.c))))
(let u = (((\x: Bool .\y: Rec X. X .y) (let u = ({a = true , b = 1 }.a) in u) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = (((\x: Bool .\y: Unit .y) true ) false) , c = 1 }.c) ))) in ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) )) , b = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .x) 0 ) true) )) }.b) }.a))
(fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Bool ] (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) )) ))
(((\x: Unit .\y: Bool .x) (if (let u = ({a = 0 , b = true , c =  0 }.b) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) then (succ 0) else (succ 0)) ) ({a = (fix (\x: Nat . ({a = 0 , b = true , c = 0 }.c) )) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) , c =  ({a = (( \f: Unit .((f ({a = 1 , b = false }.a) ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = false , b = true }.b) }.a) }.b))
(iszero (case <l = (( \f: Unit .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) ) (case <l = (((\x: Rec X. X .\y: Nat .y) false ) 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) > as Nat of < l = x > => x | < r = y > => y))
(succ ({a = (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Unit . 1 )) ))) , b = (( \f: Rec X. X .((f (if true then 1 else 1) ) ({a = (succ 1) , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) }.b))
(let u = (let u = ({a = (case <r = (( \f: Unit .((f (let u = true in u) ) true ) ) (\a: Bool .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (pred (((\x: Unit .\y: Bool .x) 1 ) false)) }.b) in u) in u)
(succ ({a = (succ (unfold [ Rec X. X ] (fold [ Unit ] (succ 0) ))) , b = (let u = (let u = 0 in u) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) }.a))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Nat ] (let u = 0 in 1) )) )) , b = (if (case <r = ({a = 0 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) then (iszero (( \f: Unit .((f 0 ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b))) else (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (unfold [ Rec X. X ] (fold [ Nat ] false )) else ({a = true , b = false }.b))) }.a)
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Unit . ({a = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) (( \f: Nat .((f ({a = true , b = 0 }.b) ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .b)) , b = ({a = false , b = true }.b) , c =  (unfold [ Bool ] (fold [ Unit ] (let u = 1 in 0) )) }.b) )) ))
({a = ({a = (( \f: Unit .((f (succ 0) ) ({a = 1 , b = 0 }.b) ) ) (\a: Unit .\b: Bool .a)) , b = (let u = (( \f: Rec X. X .((f 0 ) (if false then 1 else 1) ) ) (\a: Nat .\b: Nat .a)) in (let u = true in 0)) }.b) , b = (if ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) then ({a = (let u = (((\x: Nat .\y: Rec X. X .x) true ) (unfold [ Nat ] (fold [ Nat ] false ))) in u) , b = (pred (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a))) }.a) else (case <r = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y)) }.a)
(((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f (let u = ({a = (let u = false in true) , b = true }.b) in (fix (\x: Unit . false ))) ) (let u = (((\x: Bool .\y: Unit .x) false ) (let u = 1 in true)) in u) ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = (((\x: Nat .\y: Nat .y) (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Unit .a))) in u))
(let u = (unfold [ Bool ] (fold [ Nat ] (if ({a = (((\x: Unit .\y: Bool .x) false ) true) , b = true }.b) then ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) else (((\x: Rec X. X .\y: Unit .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) ) (((\x: Rec X. X .\y: Bool .x) 1 ) false))) )) in u)
(((\x: Nat .\y: Nat .x) (pred (if (unfold [ Nat ] (fold [ Unit ] false )) then (pred 0) else (succ 0))) ) ({a = (pred (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) , b = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .a)) }.b) }.b))
({a = ({a = (((\x: Bool .\y: Unit .x) ({a = (succ 0) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b))) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) false ) 0) ) ({a = 0 , b = 1 }.b) ) ) (\a: Bool .\b: Unit .a)) }.a) , b = ({a = (let u = ({a = ({a = 0 , b = true , c =  1 }.b) , b = 1 }.a) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (case <r = ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .a)) , c =  (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) > as Unit of < l = x > => x | < r = y > => y) }.b) }.b)
(( \f: Bool .((f ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = (((\x: Nat .\y: Nat .y) true ) ({a = 0 , b = 0 }.b)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] true )) )) }.a) )) , b = (let u = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Unit .\y: Nat .y) ({a = false , b = true }.b) ) false) , c = (pred 0) }.c) in (iszero 0)) , c = ({a = (succ (let u = false in 0)) , b = ({a = true , b = true }.b) }.a) }.c) ) (((\x: Bool .\y: Unit .y) ({a = (let u = (let u = 1 in 1) in false) , b = (( \f: Bool .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (case <r = ({a = 1 , b = false , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b)) }.b) ) (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) (pred 1) ) true) ) (((\x: Unit .\y: Nat .x) (let u = 0 in 1) ) (let u = (let u = true in false) in false)) ) ) (\a: Nat .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Unit .b))
(((\x: Nat .\y: Rec X. X .y) (iszero (let u = (((\x: Nat .\y: Bool .y) ({a = 0 , b = true , c =  0 }.b) ) 0) in ({a = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.a))) ) (fix (\x: Bool . (fix (\x: Unit . (( \f: Bool .((f (let u = false in false) ) (let u = false in u) ) ) (\a: Nat .\b: Bool .b)) )) )))
({a = ({a = (let u = (((\x: Unit .\y: Bool .y) false ) false) in (fix (\x: Nat . 1 ))) , b = (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .x) false ) true) ) ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = (((\x: Bool .\y: Unit .y) true ) true) }.b) ) ) (\a: Nat .\b: Unit .b)) }.a) , b = ({a = (let u = (unfold [ Bool ] (fold [ Rec X. X ] ({a = false , b = 0 }.a) )) in (iszero 0)) , b = (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (pred 1) ))) }.a) }.b)
(let u = (((\x: Rec X. X .\y: Nat .y) ({a = (iszero 0) , b = (((\x: Nat .\y: Rec X. X .x) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) false) }.b) ) (if (( \f: Unit .((f ({a = true , b = true }.b) ) ({a = false , b = 1 }.a) ) ) (\a: Nat .\b: Nat .b)) then (case <r = (let u = true in true) > as Unit of < l = x > => x | < r = y > => y) else ({a = false , b = 0 }.a))) in u)
(pred (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.a) ))))
(let u = ({a = (( \f: Unit .((f ({a = (fix (\x: Unit . 1 )) , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)) , c = (pred 0) }.c) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (case <r = ({a = false , b = ({a = false , b = false }.b) }.b) > as Bool of < l = x > => x | < r = y > => y) , c = (let u = (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Unit .((f ({a = 1 , b = false , c = 0 }.c) ) 1 ) ) (\a: Nat .\b: Bool .b))) }.c) in ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] (iszero (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) )) )))
(let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (((\x: Unit .\y: Unit .x) false ) true) in (iszero 0)) )) in ({a = (( \f: Unit .((f ({a = true , b = 1 }.b) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (fix (\x: Unit . true )) , c =  ({a = (iszero 0) , b = ({a = 0 , b = 1 }.b) }.b) }.b))
(( \f: Unit .((f (( \f: Nat .((f (succ (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (fix (\x: Bool . 0 )))) ) (if (let u = (if false then 0 else 0) in ({a = (fix (\x: Rec X. X . 1 )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.b)) then ({a = (fix (\x: Nat . 0 )) , b = (pred 0) }.b) else ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (unfold [ Nat ] (fold [ Bool ] false )) }.a)) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Rec X. X .y) (if (fix (\x: Unit . ({a = true , b = 1 }.a) )) then (case <r = ({a = 1 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) else ({a = (if true then (let u = true in false) else (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b))) , b = (succ 0) }.a)) ) (if (let u = true in u) then (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] 0 )) )) else (if (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Unit .a)) then (((\x: Nat .\y: Rec X. X .x) 1 ) true) else (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)))) ) ) (\a: Bool .\b: Unit .a))
(let u = (succ (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) in (fix (\x: Rec X. X . ({a = ({a = (let u = 1 in 1) , b = (if false then false else false) }.b) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) )))
({a = ({a = (pred (fix (\x: Nat . 1 ))) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = ({a = (let u = (if false then 1 else 1) in (((\x: Nat .\y: Unit .y) false ) false)) , b = ({a = (( \f: Unit .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a)) }.b) }.b) , c =  (unfold [ Nat ] (fold [ Bool ] ({a = (let u = 1 in 1) , b = ({a = (let u = true in 0) , b = ({a = 0 , b = true }.a) }.b) }.b) )) }.b)
({a = (if ({a = (if true then (let u = false in 0) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 ))) , b = (( \f: Bool .((f ({a = ({a = 1 , b = true , c =  1 }.b) , b = false }.b) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Nat .b)) }.b) then (((\x: Rec X. X .\y: Bool .x) (let u = (if true then 1 else 1) in u) ) (((\x: Nat .\y: Nat .y) true ) false)) else (succ (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)))) , b = (let u = (((\x: Unit .\y: Rec X. X .x) false ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))) in ({a = (succ 0) , b = ({a = 1 , b = false }.b) , c =  1 }.b)) , c =  (succ ({a = ({a = true , b = false }.b) , b = ({a = (let u = false in false) , b = 1 }.b) }.b)) }.b)
(case <l = (( \f: Nat .((f (pred ({a = (if false then 0 else 1) , b = ({a = 1 , b = false }.b) }.a)) ) ({a = ({a = 1 , b = (let u = true in false) , c = 0 }.c) , b = (((\x: Unit .\y: Bool .x) false ) ({a = true , b = false }.b)) }.a) ) ) (\a: Nat .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y)
((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f ({a = (let u = (if false then (let u = false in false) else false) in (( \f: Bool .((f 0 ) (succ 1) ) ) (\a: Bool .\b: Nat .b))) , b = (((\x: Nat .\y: Bool .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = (fix (\x: Unit . true )) , c =  0 }.b)) }.a) ) (fix (\x: Nat . (let u = (succ 0) in u) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
(let u = (let u = (iszero (let u = (let u = false in 1) in u)) in (((\x: Unit .\y: Bool .y) false ) (iszero 0))) in (let u = (((\x: Unit .\y: Unit .y) ({a = false , b = false }.b) ) ({a = (fix (\x: Rec X. X . false )) , b = false }.b)) in u))
({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = (fix (\x: Unit . 0 )) , b = 1 }.b) )) , b = (((\x: Rec X. X .\y: Bool .x) (let u = (((\x: Rec X. X .\y: Unit .x) (((\x: Unit .\y: Unit .x) true ) false) ) ({a = 0 , b = false , c =  0 }.b)) in (((\x: Bool .\y: Nat .x) ({a = true , b = true }.b) ) (if false then false else true))) ) (iszero (succ 1))) }.a)
(pred ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (pred (pred 0)) )))
(fix (\x: Unit . (let u = (pred 1) in u) ))
({a = ({a = (iszero (unfold [ Unit ] (fold [ Unit ] (let u = 1 in u) ))) , b = (( \f: Rec X. X .((f ({a = (let u = true in u) , b = 0 }.b) ) (case <l = ({a = true , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) }.b) , b = (let u = (( \f: Nat .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) in (let u = (( \f: Bool .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 0 in true) ) ) (\a: Bool .\b: Nat .a)) in (fix (\x: Unit . false )))) }.b)
({a = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Rec X. X ] 1 )) )) ) ({a = (pred 1) , b = false }.a) ) ) (\a: Bool .\b: Nat .a)) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = true }.b) )) }.a)
(unfold [ Unit ] (fold [ Nat ] (succ (let u = (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) in u)) ))
(if (( \f: Nat .((f ({a = 1 , b = true }.b) ) (((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Bool ] ({a = true , b = 0 }.a) )) ) (( \f: Bool .((f true ) (let u = true in true) ) ) (\a: Rec X. X .\b: Unit .a))) ) ) (\a: Unit .\b: Nat .a)) then (let u = (case <r = (((\x: Unit .\y: Rec X. X .x) (((\x: Nat .\y: Unit .x) true ) false) ) (((\x: Bool .\y: Rec X. X .x) (iszero 1) ) (if true then true else false))) > as Nat of < l = x > => x | < r = y > => y) in (pred (case <l = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y))) else (let u = (if (iszero 1) then (( \f: Nat .((f (let u = 0 in 0) ) 0 ) ) (\a: Nat .\b: Nat .a)) else (((\x: Unit .\y: Rec X. X .x) 1 ) false)) in ({a = 0 , b = (if false then false else true) }.a)))
(let u = (((\x: Bool .\y: Bool .x) (((\x: Bool .\y: Unit .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) )) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (((\x: Nat .\y: Unit .x) ({a = false , b = 1 }.b) ) ({a = false , b = true }.b)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = true , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) )) , c =  (( \f: Nat .((f ({a = 1 , b = true }.a) ) (let u = (succ 1) in u) ) ) (\a: Bool .\b: Bool .b)) }.b)) in ({a = (((\x: Nat .\y: Nat .y) (let u = (iszero 0) in (((\x: Unit .\y: Rec X. X .x) false ) true)) ) (unfold [ Nat ] (fold [ Rec X. X ] ({a = false , b = 1 }.a) ))) , b = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .y) false ) (let u = 0 in 0)) ) (( \f: Bool .((f (let u = false in 0) ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .b)) }.a))
((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = 0 in (let u = false in 0)) ))) ))
({a = ({a = (( \f: Bool .((f (( \f: Rec X. X .((f (succ 1) ) (let u = true in 1) ) ) (\a: Nat .\b: Unit .b)) ) ({a = (((\x: Bool .\y: Unit .x) ({a = 0 , b = true , c =  0 }.b) ) (((\x: Unit .\y: Bool .x) false ) true)) , b = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Unit .\y: Nat .y) ({a = 1 , b = (let u = false in u) , c =  1 }.b) ) (if false then 0 else 0)) }.b) , b = (let u = (fix (\x: Unit . (let u = 1 in false) )) in ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (if false then false else false) , c =  0 }.b) }.b)) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (pred (let u = 1 in u)) )) }.b)
(((\x: Rec X. X .\y: Rec X. X .y) ({a = (( \f: Unit .((f ({a = 1 , b = true , c = 0 }.c) ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Unit .\b: Unit .a)) , b = (let u = false in u) }.b) ) (((\x: Nat .\y: Nat .y) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) (succ (unfold [ Bool ] (fold [ Bool ] 1 )))))
(( \f: Nat .((f ({a = (succ ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (let u = false in false) }.a)) , b = (fix (\x: Rec X. X . (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) )) }.b) ) (((\x: Unit .\y: Rec X. X .y) ({a = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = (if false then false else true) }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) true ) 1) )) }.a) ) (if (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Nat .b)) then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else (let u = 1 in u))) ) ) (\a: Rec X. X .\b: Bool .a))
(( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = 1 , b = false , c =  0 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) }.b) )) ) (((\x: Bool .\y: Bool .y) (( \f: Bool .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) ) ) (\a: Nat .\b: Unit .a)) ) ({a = ({a = 0 , b = false , c =  0 }.b) , b = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) in u) }.a)) ) ) (\a: Rec X. X .\b: Nat .a))
(succ (let u = ({a = (succ 0) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.b) in (((\x: Rec X. X .\y: Nat .y) (if false then ({a = 1 , b = false , c =  0 }.b) else false) ) (fix (\x: Bool . 0 )))))
(let u = (succ ({a = ({a = 0 , b = false }.a) , b = (unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Nat . 1 )) )) }.b)) in (let u = ({a = ({a = 0 , b = false }.a) , b = (let u = (((\x: Unit .\y: Unit .y) true ) 0) in (unfold [ Bool ] (fold [ Unit ] true ))) }.b) in (fix (\x: Unit . (( \f: Unit .((f (let u = 0 in true) ) (((\x: Nat .\y: Unit .y) true ) true) ) ) (\a: Bool .\b: Bool .b)) ))))
({a = (((\x: Unit .\y: Bool .y) ({a = (( \f: Rec X. X .((f ({a = (fix (\x: Nat . 0 )) , b = ({a = true , b = true }.b) , c = 1 }.c) ) ({a = 0 , b = true }.a) ) ) (\a: Nat .\b: Unit .b)) , b = (unfold [ Unit ] (fold [ Unit ] ({a = ({a = true , b = 0 }.b) , b = false }.b) )) }.b) ) ({a = (let u = 1 in u) , b = (let u = 0 in false) }.a)) , b = (let u = ({a = (let u = 0 in u) , b = (if ({a = 1 , b = false , c =  0 }.b) then true else (((\x: Bool .\y: Unit .x) true ) false)) }.b) in (if ({a = 1 , b = (unfold [ Unit ] (fold [ Bool ] true )) , c =  (((\x: Unit .\y: Unit .y) true ) 0) }.b) then (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) )) else (case <r = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) > as Rec X. X of < l = x > => x | < r = y > => y))) }.a)
({a = (let u = (let u = (fix (\x: Bool . false )) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b))) in (unfold [ Unit ] (fold [ Nat ] (if (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .b)) then false else ({a = false , b = true }.b)) ))) , b = (((\x: Bool .\y: Nat .y) (( \f: Bool .((f (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) in (((\x: Bool .\y: Bool .y) true ) true)) ) (((\x: Unit .\y: Bool .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) (if false then false else false) ) ({a = 0 , b = false , c =  1 }.b))) ) ) (\a: Unit .\b: Bool .b)) ) (unfold [ Rec X. X ] (fold [ Nat ] (case <l = (let u = 0 in u) > as Unit of < l = x > => x | < r = y > => y) ))) }.a)
(case <l = (((\x: Unit .\y: Rec X. X .y) (((\x: Nat .\y: Unit .x) ({a = false , b = true }.b) ) false) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a))) > as Bool of < l = x > => x | < r = y > => y)
(unfold [ Rec X. X ] (fold [ Nat ] ({a = ({a = ({a = true , b = false }.b) , b = 1 }.a) , b = (let u = 1 in 1) }.b) ))
(let u = (fix (\x: Nat . (case <l = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) )) in u)
(fix (\x: Bool . (let u = (case <r = ({a = true , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) in (let u = (((\x: Bool .\y: Rec X. X .x) 0 ) false) in (fix (\x: Nat . 0 )))) ))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Rec X. X .x) (case <l = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Unit ] (let u = false in u) ))) , b = (let u = (fix (\x: Unit . false )) in u) }.a) ))
(unfold [ Nat ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) (pred (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Unit .b))) ) (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (let u = 0 in ({a = false , b = true }.b)))) ))
(let u = (((\x: Bool .\y: Nat .x) (let u = (((\x: Bool .\y: Nat .y) (let u = 0 in false) ) false) in (case <l = (if false then 1 else 1) > as Bool of < l = x > => x | < r = y > => y)) ) (( \f: Nat .((f (fix (\x: Bool . true )) ) ({a = 1 , b = false }.b) ) ) (\a: Unit .\b: Nat .b))) in (( \f: Unit .((f (fix (\x: Rec X. X . ({a = 0 , b = true }.b) )) ) (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .y) false ) false) ) ({a = true , b = 0 }.a) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .b)))
(((\x: Unit .\y: Nat .x) ({a = ({a = ({a = 0 , b = true , c = 0 }.c) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) }.a) , b = (iszero ({a = (let u = false in u) , b = (unfold [ Bool ] (fold [ Bool ] 0 )) }.b)) , c = (fix (\x: Nat . (pred 0) )) }.c) ) (iszero (( \f: Nat .((f (succ ({a = 1 , b = false }.a)) ) (if false then ({a = false , b = 0 }.b) else 1) ) ) (\a: Unit .\b: Rec X. X .b))))
({a = (( \f: Unit .((f (let u = (unfold [ Unit ] (fold [ Nat ] 0 )) in ({a = false , b = (let u = false in 0) }.a)) ) (((\x: Bool .\y: Unit .y) false ) (let u = 1 in false)) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) , b = ({a = (let u = false in (let u = 1 in u)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) }.b) }.b) }.b)
(succ (fix (\x: Nat . (fix (\x: Rec X. X . (fix (\x: Nat . 0 )) )) )))
({a = (( \f: Unit .((f (pred (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Unit .\y: Unit .x) 1 ) true) }.b) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Rec X. X .((f (pred ({a = 0 , b = false }.a)) ) ({a = ({a = ({a = 1 , b = false }.a) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Unit .x) 1 ) true) )) }.b) ) ) (\a: Nat .\b: Bool .b)) }.b)
(if (let u = (let u = (let u = 1 in false) in (pred 1)) in (unfold [ Unit ] (fold [ Bool ] ({a = ({a = false , b = 0 }.a) , b = (let u = false in u) }.b) ))) then ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = true , b = 0 }.b) )) )) else (((\x: Rec X. X .\y: Bool .x) (succ ({a = (let u = (fix (\x: Unit . false )) in (let u = 0 in 1)) , b = (if (((\x: Nat .\y: Bool .x) false ) false) then ({a = 1 , b = true , c =  0 }.b) else true) }.a)) ) ({a = (((\x: Nat .\y: Rec X. X .y) false ) (let u = 1 in false)) , b = (( \f: Rec X. X .((f ({a = false , b = true }.b) ) (if true then true else true) ) ) (\a: Unit .\b: Nat .a)) }.b)))
(case <l = ({a = (let u = ({a = (let u = 1 in 0) , b = true , c =  0 }.b) in ({a = 1 , b = false }.b)) , b = (if (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) false) then (let u = false in (fix (\x: Rec X. X . 1 ))) else (succ 0)) }.b) > as Bool of < l = x > => x | < r = y > => y)
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f (succ 0) ) (unfold [ Nat ] (fold [ Rec X. X ] (pred (pred 1)) )) ) ) (\a: Bool .\b: Rec X. X .b)) ))
(let u = (((\x: Nat .\y: Rec X. X .x) ({a = ({a = 0 , b = false }.b) , b = ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .b)) , b = (unfold [ Nat ] (fold [ Bool ] true )) }.b) }.b) ) ({a = (fix (\x: Nat . true )) , b = ({a = (let u = 0 in u) , b = false , c =  1 }.b) }.b)) in (( \f: Bool .((f (( \f: Bool .((f (let u = 0 in false) ) (iszero 0) ) ) (\a: Rec X. X .\b: Unit .b)) ) (if (if true then true else true) then (iszero 1) else (fix (\x: Rec X. X . true ))) ) ) (\a: Unit .\b: Rec X. X .a)))
({a = (if (( \f: Unit .((f (fix (\x: Nat . ({a = 1 , b = false , c =  0 }.b) )) ) ({a = true , b = ({a = 1 , b = 0 }.b) }.a) ) ) (\a: Nat .\b: Bool .b)) then (let u = (if (unfold [ Bool ] (fold [ Unit ] false )) then (let u = ({a = 1 , b = true , c =  1 }.b) in ({a = 1 , b = false , c =  0 }.b)) else ({a = 0 , b = false , c =  0 }.b)) in u) else (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = true , c =  1 }.b) ))) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = true , b = (let u = true in 1) }.a) )) }.b)
(( \f: Rec X. X .((f ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in 1) )) , b = (( \f: Bool .((f ({a = false , b = 0 }.a) ) (if false then true else true) ) ) (\a: Bool .\b: Nat .a)) , c = (((\x: Unit .\y: Rec X. X .x) (let u = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) in 1) ) (let u = 1 in true)) }.c) ) ({a = (let u = (if ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) then (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) else (iszero 0)) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (unfold [ Nat ] (fold [ Nat ] 1 )) , b = true , c = 1 }.c) ))) , b = (( \f: Nat .((f ({a = ({a = 1 , b = false , c =  1 }.b) , b = (let u = false in 1) }.a) ) (fix (\x: Unit . (if false then false else false) )) ) ) (\a: Rec X. X .\b: Bool .b)) , c = (((\x: Rec X. X .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = false in u)) ) ({a = (case <l = (succ 1) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in true) , c = (let u = 0 in u) }.c)) }.c) ) ) (\a: Unit .\b: Bool .a))
(((\x: Nat .\y: Rec X. X .x) (succ ({a = (((\x: Unit .\y: Unit .y) false ) 1) , b = 1 }.b)) ) (( \f: Bool .((f ({a = ({a = 1 , b = true , c = 0 }.c) , b = (( \f: Unit .((f (fix (\x: Rec X. X . true )) ) (let u = true in false) ) ) (\a: Bool .\b: Unit .b)) }.b) ) ({a = false , b = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) }.b) ) ) (\a: Unit .\b: Nat .a)))
({a = (fix (\x: Rec X. X . ({a = (let u = true in false) , b = (((\x: Bool .\y: Unit .x) false ) (if false then true else true)) }.b) )) , b = ({a = (if (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Unit .a)) then ({a = 1 , b = false , c =  0 }.b) else ({a = 0 , b = true , c =  0 }.b)) , b = (( \f: Bool .((f (( \f: Nat .((f 1 ) (let u = 1 in 1) ) ) (\a: Unit .\b: Nat .b)) ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) }.b)
({a = (let u = (( \f: Unit .((f false ) (iszero 1) ) ) (\a: Unit .\b: Unit .b)) in (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .x) false ) false) ) (if false then ({a = 0 , b = false }.b) else true) ) ) (\a: Rec X. X .\b: Bool .a))) , b = ({a = ({a = 1 , b = false }.a) , b = (let u = ({a = true , b = true }.b) in u) }.a) }.b)
(pred (case <l = ({a = ({a = 1 , b = 1 }.b) , b = ({a = true , b = (let u = 0 in u) }.a) , c = (let u = false in 0) }.c) > as Nat of < l = x > => x | < r = y > => y))
(pred (fix (\x: Rec X. X . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = true }.a) )) )))
(((\x: Rec X. X .\y: Nat .y) (fix (\x: Nat . ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Unit . (if false then (fix (\x: Unit . false )) else false) )) )) )) ) (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] (let u = true in true) )) )) in u))
(( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = false , b = 1 }.a) , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a)) }.a) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = false in false) )) ))) ) (let u = (( \f: Rec X. X .((f ({a = ({a = 0 , b = true }.a) , b = true }.b) ) ({a = (( \f: Nat .((f true ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) }.b) ) ) (\a: Unit .\b: Unit .a)) in u) ) ) (\a: Nat .\b: Bool .b))
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Unit .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) ({a = false , b = 0 }.a) ) ) (\a: Nat .\b: Nat .a)) )) in u)
(fix (\x: Bool . (let u = (((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Unit .y) true ) false) ) (fix (\x: Bool . true ))) in (let u = (let u = 1 in u) in false)) ))
(unfold [ Nat ] (fold [ Unit ] (iszero (unfold [ Nat ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) 0 ) false) ))) ))
(((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Nat .y) ({a = true , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) }.b) ) ({a = (unfold [ Nat ] (fold [ Unit ] false )) , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.b)) ) ({a = ({a = (let u = 0 in 1) , b = (if false then false else true) }.a) , b = ({a = true , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a)) }.b) , c = (((\x: Nat .\y: Rec X. X .x) 1 ) ({a = false , b = true }.b)) }.c))
({a = (unfold [ Nat ] (fold [ Unit ] (let u = (case <r = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) in (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b))) )) , b = (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) ({a = (let u = true in false) , b = true }.b) ) ({a = 1 , b = false }.a)) )) }.a)
({a = (case <l = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (if true then 0 else 1) else (if true then 0 else 1)) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Unit ] (fold [ Unit ] ({a = true , b = true }.b) )) in (( \f: Rec X. X .((f (let u = 0 in true) ) ({a = (let u = false in 1) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Nat .b)) , c =  0 }.b) ) ) (\a: Unit .\b: Bool .b))) , c = (((\x: Unit .\y: Bool .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f ({a = 0 , b = true }.b) ) false ) ) (\a: Bool .\b: Bool .a)) )) )) ) (unfold [ Unit ] (fold [ Bool ] (((\x: Rec X. X .\y: Nat .y) true ) 1) ))) }.c)
(let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (pred (unfold [ Unit ] (fold [ Rec X. X ] 0 ))) )) in (let u = ({a = (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) )) , b = ({a = (pred ({a = 0 , b = false , c = 1 }.c)) , b = ({a = 0 , b = true }.b) }.b) }.b) in u))
(if (( \f: Rec X. X .((f ({a = 0 , b = true , c =  0 }.b) ) (if (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) then false else true) ) ) (\a: Rec X. X .\b: Nat .b)) then (( \f: Bool .((f (( \f: Rec X. X .((f (let u = 1 in u) ) (pred 1) ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = ({a = 0 , b = true }.a) in u) ) ) (\a: Nat .\b: Rec X. X .a)) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (fix (\x: Rec X. X . 0 )) in (let u = true in 1)) )))
({a = (((\x: Unit .\y: Bool .x) (( \f: Unit .((f (let u = 1 in 0) ) (if false then 0 else 1) ) ) (\a: Rec X. X .\b: Nat .b)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Bool .x) false ) false) ))) , b = ({a = (let u = (iszero 1) in (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in 0)) , b = ({a = (let u = 1 in u) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) }.b) }.b) }.a)
({a = ({a = (iszero (let u = false in 0)) , b = (case <l = (unfold [ Unit ] (fold [ Unit ] 1 )) > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (( \f: Unit .((f (case <l = (((\x: Rec X. X .\y: Nat .y) ({a = false , b = false }.b) ) 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) (case <l = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) }.b)
(let u = (let u = (( \f: Rec X. X .((f ({a = 1 , b = (((\x: Bool .\y: Bool .x) false ) true) , c =  0 }.b) ) (if true then true else false) ) ) (\a: Bool .\b: Bool .a)) in u) in ({a = (succ 1) , b = ({a = ({a = false , b = false }.b) , b = ({a = (((\x: Bool .\y: Rec X. X .y) false ) 1) , b = ({a = 0 , b = false , c =  1 }.b) , c =  (((\x: Nat .\y: Rec X. X .x) 1 ) false) }.b) }.b) , c = (((\x: Unit .\y: Bool .x) (let u = false in 1) ) (iszero 1)) }.c))
(((\x: Rec X. X .\y: Bool .x) (( \f: Bool .((f (case <l = ({a = (let u = false in 1) , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .x) 1 ) false) )) )) ) ) (\a: Bool .\b: Nat .b)) ) ({a = (succ (if ({a = 0 , b = false }.b) then 0 else 1)) , b = (let u = (let u = 1 in u) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , c =  (if (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) then (pred 0) else (succ 0)) }.b))
(succ ({a = (let u = (((\x: Rec X. X .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Unit ] 0 )) ) false) in (let u = (( \f: Nat .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Unit .\y: Bool .x) true ) true) ) ) (\a: Nat .\b: Bool .b)) in (pred (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b))))) , b = (((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Bool .x) true ) false) ) ({a = 0 , b = true }.b)) }.a))
(let u = (((\x: Unit .\y: Unit .x) (let u = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = false in u)) in (( \f: Rec X. X .((f (if true then 0 else 1) ) 1 ) ) (\a: Rec X. X .\b: Bool .a))) ) (((\x: Rec X. X .\y: Bool .y) (((\x: Bool .\y: Nat .x) false ) true) ) (let u = (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Unit .x) 0 ) true) )) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true ))))) in ({a = (if (let u = 0 in true) then ({a = 0 , b = false , c =  0 }.b) else (((\x: Unit .\y: Nat .y) false ) (let u = true in true))) , b = (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f (((\x: Nat .\y: Nat .y) true ) 0) ) (((\x: Nat .\y: Bool .x) 1 ) true) ) ) (\a: Rec X. X .\b: Nat .b)) )) }.a))
(fix (\x: Unit . (let u = (let u = (fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) )) in u) in u) ))
(( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = (let u = true in u) , b = 0 }.b) )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) in 1) )) ) ) (\a: Nat .\b: Bool .b))
(if ({a = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a))) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 1 , b = ({a = false , b = true }.b) , c =  0 }.b) )) }.b) then (( \f: Nat .((f (fix (\x: Unit . ({a = true , b = 0 }.a) )) ) ({a = ({a = true , b = 1 }.b) , b = (iszero (pred 1)) , c =  (pred (let u = true in 1)) }.b) ) ) (\a: Bool .\b: Bool .b)) else (let u = (unfold [ Unit ] (fold [ Nat ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) in ({a = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) , b = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = false , c =  1 }.b) )) }.b)))
(( \f: Bool .((f (let u = (pred (succ 0)) in (((\x: Unit .\y: Rec X. X .x) 0 ) true)) ) (let u = (pred (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Bool .y) true ) true) ) ({a = 0 , b = 0 }.b))) in u) ) ) (\a: Rec X. X .\b: Bool .a))
(let u = (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (fix (\x: Unit . false )) , b = (let u = 1 in true) }.b) )) ) (if (let u = false in u) then ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) else (if (let u = false in false) then false else false)) ) ) (\a: Bool .\b: Unit .a)) in u)
(fix (\x: Unit . (((\x: Nat .\y: Rec X. X .y) ({a = ({a = 0 , b = false , c =  1 }.b) , b = (if false then true else true) }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) ))) ))
(succ (case <l = (((\x: Bool .\y: Unit .y) (unfold [ Unit ] (fold [ Nat ] (((\x: Nat .\y: Nat .x) false ) false) )) ) (unfold [ Bool ] (fold [ Nat ] (fix (\x: Unit . 1 )) ))) > as Bool of < l = x > => x | < r = y > => y))
({a = (let u = (iszero ({a = 0 , b = (let u = true in 1) }.b)) in u) , b = (let u = (((\x: Unit .\y: Unit .x) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ({a = false , b = 1 }.a)) in u) }.b)
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (let u = (((\x: Unit .\y: Bool .y) false ) false) in 0) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ({a = ({a = ({a = 0 , b = true , c =  0 }.b) , b = (let u = (((\x: Unit .\y: Nat .y) false ) 0) in (pred 1)) }.a) , b = (((\x: Nat .\y: Nat .x) (pred (((\x: Nat .\y: Unit .y) false ) 1)) ) ({a = ({a = 1 , b = false }.b) , b = false }.b)) }.a))
(( \f: Unit .((f (( \f: Nat .((f (( \f: Rec X. X .((f (let u = 1 in u) ) ({a = false , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .b)) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = (pred 1) }.b) )) ) ) (\a: Bool .\b: Nat .a)) ) ({a = (succ (( \f: Bool .((f ({a = (unfold [ Unit ] (fold [ Unit ] 1 )) , b = true , c = 1 }.c) ) ({a = 1 , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .a))) , b = ({a = (((\x: Nat .\y: Unit .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.a) }.a) ) ) (\a: Nat .\b: Unit .b))
({a = (let u = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) in (( \f: Rec X. X .((f (let u = (let u = true in u) in 1) ) (fix (\x: Nat . 1 )) ) ) (\a: Rec X. X .\b: Bool .a))) , b = (if (( \f: Bool .((f ({a = (pred 0) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) , c =  (((\x: Unit .\y: Bool .x) 0 ) true) }.b) ) (let u = false in ({a = true , b = true }.b)) ) ) (\a: Bool .\b: Nat .b)) then (( \f: Nat .((f (if false then true else true) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Nat .\b: Unit .a)) else ({a = false , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.b)) , c =  (if (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (unfold [ Nat ] (fold [ Nat ] true )) else ({a = 0 , b = false , c =  0 }.b)) then (succ (let u = false in 1)) else (((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f ({a = false , b = false }.b) ) true ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Nat .\y: Unit .x) 0 ) false))) }.b)
(iszero (( \f: Bool .((f ({a = (((\x: Unit .\y: Nat .x) (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) ) (let u = 0 in false)) , b = ({a = true , b = 0 }.a) }.a) ) (pred (let u = (((\x: Nat .\y: Nat .y) false ) true) in (( \f: Unit .((f ({a = 1 , b = 1 }.b) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)))) ) ) (\a: Nat .\b: Rec X. X .b)))
({a = ({a = ({a = 0 , b = false }.a) , b = (fix (\x: Nat . ({a = (fix (\x: Bool . 1 )) , b = 0 }.b) )) }.b) , b = ({a = (fix (\x: Bool . (succ 1) )) , b = (let u = (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y) in (if true then true else (((\x: Nat .\y: Unit .y) false ) false))) }.b) , c = (((\x: Rec X. X .\y: Rec X. X .x) (succ (((\x: Rec X. X .\y: Rec X. X .y) true ) 1)) ) (let u = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) in (iszero 1))) }.c)
(let u = ({a = ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in (fix (\x: Bool . 0 ))) , b = ({a = (let u = 1 in u) , b = ({a = 0 , b = false , c =  1 }.b) }.b) }.a) , b = (let u = (if false then false else false) in (iszero ({a = 1 , b = true , c = 1 }.c))) }.a) in u)
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) (fix (\x: Rec X. X . ({a = true , b = 0 }.a) )) ) (succ 0)) )) , b = (( \f: Bool .((f (((\x: Unit .\y: Nat .y) ({a = false , b = 1 }.a) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) ) (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .b)) }.b)
(pred (let u = (case <l = (fix (\x: Rec X. X . 0 )) > as Unit of < l = x > => x | < r = y > => y) in (let u = (( \f: Unit .((f (let u = false in u) ) false ) ) (\a: Nat .\b: Rec X. X .b)) in (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)))))
(( \f: Bool .((f (( \f: Nat .((f (if true then (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) else (((\x: Unit .\y: Nat .y) false ) false)) ) (( \f: Nat .((f (if true then false else false) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Rec X. X .b)) ) ({a = (let u = 1 in (if true then false else false)) , b = (fix (\x: Nat . ({a = 0 , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) }.b) )) }.b) ) ) (\a: Unit .\b: Unit .a))
(( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Bool ] ({a = (case <l = ({a = false , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ({a = 1 , b = true }.b) ) (iszero 1) ) ) (\a: Nat .\b: Unit .b)) , c = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = true , c = 1 }.c) )) ) (if false then 1 else 1) ) ) (\a: Unit .\b: Unit .b)) }.c) )) ) (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] 0 )) )) ) ) (\a: Bool .\b: Unit .b))
(( \f: Nat .((f (((\x: Bool .\y: Nat .x) (let u = (case <r = ({a = 1 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) , b = (((\x: Nat .\y: Unit .x) false ) false) , c =  ({a = 1 , b = true , c = 0 }.c) }.b)) ) (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f true ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true) ) ) (\a: Unit .\b: Nat .a)) ) (iszero ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )))) ) ) (\a: Bool .\b: Rec X. X .b))
(((\x: Rec X. X .\y: Nat .x) (let u = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = true , c = 0 }.c) else (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )))) in (succ (if ({a = 1 , b = false , c =  0 }.b) then (fix (\x: Bool . 1 )) else 1))) ) (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (succ 1) )) in ({a = ({a = ({a = 0 , b = false }.b) , b = ({a = true , b = ({a = 1 , b = 1 }.b) }.b) }.b) , b = (unfold [ Nat ] (fold [ Bool ] ({a = false , b = 1 }.a) )) , c =  (let u = ({a = false , b = 1 }.b) in (let u = false in 0)) }.b)))
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero (pred 1)) )) , b = (fix (\x: Nat . (( \f: Nat .((f (let u = true in 0) ) (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] 1 )) ) (pred (unfold [ Unit ] (fold [ Rec X. X ] 0 ))) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Bool .b)) )) }.a)
(((\x: Nat .\y: Unit .y) ({a = ({a = (if (((\x: Bool .\y: Bool .y) false ) false) then (succ 0) else (if false then 1 else 1)) , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) , c = ({a = 1 , b = (if true then 0 else 0) }.b) }.c) , b = (let u = (((\x: Rec X. X .\y: Unit .y) false ) true) in u) , c =  ({a = (let u = 0 in u) , b = (((\x: Bool .\y: Nat .x) 0 ) true) }.b) }.b) ) (let u = (let u = (pred 1) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in (unfold [ Unit ] (fold [ Nat ] true ))))
(let u = (let u = (pred (let u = 1 in 0)) in (fix (\x: Rec X. X . 0 ))) in ({a = (case <r = (if false then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = true in false)) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Rec X. X .x) (unfold [ Bool ] (fold [ Nat ] 1 )) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) }.a))
(if (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] true )) )) in u) then (let u = (if (unfold [ Bool ] (fold [ Rec X. X ] false )) then 0 else ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 ))) in ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true ))) else (if (( \f: Rec X. X .((f (let u = false in true) ) ({a = 1 , b = false }.b) ) ) (\a: Rec X. X .\b: Bool .b)) then (let u = ({a = ({a = 0 , b = true }.b) , b = (fix (\x: Nat . true )) }.b) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = 0 , b = true }.b) ))) else ({a = (let u = false in false) , b = (let u = 0 in (((\x: Nat .\y: Nat .y) true ) true)) }.b)))
(unfold [ Unit ] (fold [ Unit ] (fix (\x: Unit . (( \f: Bool .((f ({a = 1 , b = false , c =  0 }.b) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .b)) )) ))
({a = ({a = (( \f: Rec X. X .((f (( \f: Rec X. X .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) (case <l = (if true then 0 else 0) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) ) (unfold [ Bool ] (fold [ Bool ] ({a = (pred 0) , b = 1 }.b) )) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (case <l = (((\x: Nat .\y: Nat .x) (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) true) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (iszero (((\x: Unit .\y: Unit .y) (let u = false in u) ) ({a = true , b = 1 }.b))) , c = ({a = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u) , b = (succ (unfold [ Nat ] (fold [ Nat ] 1 ))) }.b) }.c)
({a = (((\x: Unit .\y: Bool .x) (succ (let u = 0 in 0)) ) (let u = ({a = 1 , b = true , c =  0 }.b) in u)) , b = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (iszero (succ 1)) )) in (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Unit .\y: Nat .y) false ) true) else (if true then true else true))) }.a)
(((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f (case <r = ({a = 0 , b = true , c =  0 }.b) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Rec X. X .b)) ) (fix (\x: Rec X. X . ({a = ({a = false , b = (succ 0) }.a) , b = (((\x: Unit .\y: Bool .x) false ) true) }.b) )))
(fix (\x: Nat . (((\x: Nat .\y: Nat .x) ({a = 0 , b = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) , c = 0 }.c) ) (let u = true in false)) ))
(case <l = (let u = (if (if true then true else false) then (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) else (succ 0)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Unit . 0 )) ))) > as Bool of < l = x > => x | < r = y > => y)
({a = (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Unit . (let u = ({a = true , b = 0 }.a) in ({a = 0 , b = false , c =  1 }.b)) )) )) , b = ({a = ({a = (let u = (((\x: Rec X. X .\y: Bool .x) 0 ) true) in (if false then false else false)) , b = (if false then false else false) }.b) , b = (if (let u = (fix (\x: Bool . 1 )) in false) then ({a = true , b = (let u = 1 in 1) }.b) else (((\x: Unit .\y: Rec X. X .x) 0 ) true)) }.a) }.b)
(let u = (iszero (fix (\x: Rec X. X . (succ (( \f: Bool .((f (pred 0) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) ) (\a: Bool .\b: Bool .b))) ))) in (((\x: Rec X. X .\y: Bool .x) (if (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) in false) then (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Nat ] 0 )) )) else ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = false }.a) ))) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Unit .x) false ) true) )) in (let u = true in ({a = 1 , b = false }.b)))))
(( \f: Rec X. X .((f (case <r = (unfold [ Unit ] (fold [ Bool ] ({a = true , b = true }.b) )) > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Rec X. X .y) (fix (\x: Rec X. X . ({a = (fix (\x: Rec X. X . true )) , b = 0 }.a) )) ) ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = ({a = false , b = false }.b) }.b)) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (case <l = (((\x: Unit .\y: Rec X. X .x) (succ 0) ) (fix (\x: Nat . false ))) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (let u = 1 in u) , b = (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Rec X. X .y) true ) true) ) (let u = true in u)) }.b) }.a)
(let u = ({a = (if (let u = false in false) then ({a = false , b = 0 }.a) else ({a = true , b = false }.b)) , b = (iszero (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) }.b) in u)
({a = (( \f: Rec X. X .((f (let u = (((\x: Nat .\y: Bool .y) false ) false) in (((\x: Bool .\y: Rec X. X .y) true ) true)) ) ({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = (let u = 0 in false) }.b) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) }.a) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (((\x: Bool .\y: Rec X. X .y) ({a = (((\x: Rec X. X .\y: Unit .y) true ) true) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) }.b) ) ({a = false , b = 1 }.a)) }.b)
(( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (unfold [ Unit ] (fold [ Unit ] false )) , b = (let u = 1 in u) }.a) )) ) ({a = (if (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) else (fix (\x: Unit . false ))) , b = ({a = ({a = 0 , b = false , c = 0 }.c) , b = true }.a) }.a) ) ) (\a: Rec X. X .\b: Nat .a))
(( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = (let u = true in 0) , b = (( \f: Bool .((f ({a = 0 , b = true , c =  0 }.b) ) true ) ) (\a: Unit .\b: Rec X. X .b)) }.a) )) ) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) , b = ({a = false , b = (let u = 0 in u) }.a) }.a) ) ) (\a: Rec X. X .\b: Bool .b))
(let u = (fix (\x: Unit . (iszero (succ 0)) )) in u)
({a = (let u = (iszero (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) in ({a = ({a = ({a = 1 , b = 1 }.b) , b = false }.a) , b = ({a = 0 , b = true , c =  0 }.b) }.a)) , b = ({a = (pred (( \f: Bool .((f ({a = false , b = 1 }.b) ) ({a = true , b = 1 }.b) ) ) (\a: Nat .\b: Unit .a))) , b = (((\x: Unit .\y: Unit .x) ({a = (succ 0) , b = true , c =  (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = false in u) ))) }.b) , c =  ({a = (( \f: Rec X. X .((f (let u = false in u) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (let u = (let u = false in u) in (((\x: Rec X. X .\y: Unit .x) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) true)) }.b) }.b)
({a = (unfold [ Bool ] (fold [ Nat ] (iszero ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) true ) false) }.a)) )) , b = (let u = (( \f: Bool .((f (((\x: Unit .\y: Unit .y) true ) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a))) ) ({a = ({a = false , b = true }.b) , b = (if (let u = 1 in false) then true else (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.b) ) ) (\a: Rec X. X .\b: Unit .a)) in (iszero ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.a) , c = (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) }.c))) }.b)
(case <l = (let u = (succ 1) in u) > as Unit of < l = x > => x | < r = y > => y)
({a = ({a = (pred (case <l = (fix (\x: Nat . 0 )) > as Unit of < l = x > => x | < r = y > => y)) , b = (( \f: Rec X. X .((f (iszero 1) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) , c = ({a = (fix (\x: Rec X. X . 0 )) , b = (pred 0) }.b) }.c) , b = (let u = (((\x: Unit .\y: Rec X. X .x) ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Unit ] false )) }.a) ) (let u = (fix (\x: Rec X. X . (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) )) in (if false then false else false))) in (( \f: Rec X. X .((f ({a = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Unit .y) true ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) }.a) ) ({a = (let u = false in u) , b = (fix (\x: Rec X. X . true )) }.b) ) ) (\a: Nat .\b: Rec X. X .b))) , c =  ({a = ({a = (let u = 1 in 1) , b = false , c = 1 }.c) , b = (case <r = (unfold [ Unit ] (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y) , c = (case <l = (let u = 0 in 0) > as Rec X. X of < l = x > => x | < r = y > => y) }.c) }.b)
(unfold [ Bool ] (fold [ Unit ] (let u = (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then (( \f: Bool .((f 0 ) (((\x: Unit .\y: Nat .x) 1 ) true) ) ) (\a: Nat .\b: Unit .a)) else (pred (if true then 0 else 1))) in (( \f: Unit .((f (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then false else (let u = false in u)) ) (( \f: Nat .((f (unfold [ Bool ] (fold [ Nat ] true )) ) true ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .b))) ))
(((\x: Rec X. X .\y: Nat .x) ({a = (let u = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) in (((\x: Rec X. X .\y: Unit .y) false ) true)) in ({a = (let u = ({a = true , b = 0 }.b) in false) , b = (if true then 0 else 0) }.a)) , b = (let u = ({a = ({a = false , b = 1 }.b) , b = (((\x: Unit .\y: Nat .x) true ) true) }.a) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) ) ({a = (((\x: Nat .\y: Unit .x) (iszero 1) ) false) , b = ({a = (((\x: Rec X. X .\y: Unit .y) true ) (let u = false in 0)) , b = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = false }.b) , c = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) }.c) }.a))
(unfold [ Unit ] (fold [ Rec X. X ] ({a = (let u = (let u = false in u) in (fix (\x: Nat . true ))) , b = (let u = 1 in u) }.a) ))
(let u = ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (iszero ({a = false , b = 0 }.b)) , c =  (let u = (let u = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (pred 0)) in u) }.b) in u)
(iszero ({a = (let u = (if ({a = 1 , b = true , c =  1 }.b) then true else ({a = true , b = 1 }.a)) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a))) , b = (if (let u = ({a = 0 , b = false }.b) in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) then (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false ))) else ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = true in u) ))) }.a))
(((\x: Rec X. X .\y: Rec X. X .y) ({a = (( \f: Bool .((f ({a = (let u = 0 in u) , b = true , c =  ({a = true , b = 0 }.b) }.b) ) (unfold [ Nat ] (fold [ Unit ] true )) ) ) (\a: Bool .\b: Rec X. X .a)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .y) true ) ({a = true , b = 0 }.b)) )) }.a) ) (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Bool .y) (unfold [ Bool ] (fold [ Bool ] true )) ) (let u = 0 in 1)) ) (unfold [ Nat ] (fold [ Unit ] true ))))
(iszero (if (let u = (let u = 1 in (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a))) in u) then (let u = ({a = (fix (\x: Rec X. X . 0 )) , b = true }.a) in u) else (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Nat .x) 1 ) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Bool .b))) ) (unfold [ Bool ] (fold [ Unit ] true )))))
(((\x: Unit .\y: Rec X. X .x) (let u = (unfold [ Nat ] (fold [ Bool ] ({a = (if (case <r = false > as Bool of < l = x > => x | < r = y > => y) then (let u = true in 1) else 0) , b = (unfold [ Unit ] (fold [ Unit ] false )) }.b) )) in (let u = (let u = ({a = 0 , b = 0 }.b) in (let u = 0 in false)) in ({a = (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] 0 )) ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .b)) }.a))) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = (fix (\x: Unit . (succ 1) )) , b = ({a = ({a = (((\x: Nat .\y: Unit .x) false ) true) , b = false }.b) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b) )))
(( \f: Nat .((f (if (if (unfold [ Rec X. X ] (fold [ Nat ] ({a = 0 , b = false }.b) )) then ({a = (let u = 0 in 1) , b = false }.b) else (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = false }.b) ) (((\x: Bool .\y: Unit .x) true ) false))) then ({a = (if (let u = 0 in true) then false else ({a = true , b = false }.b)) , b = (let u = 1 in u) }.a) else (((\x: Nat .\y: Bool .x) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (((\x: Unit .\y: Nat .x) (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) true))) ) ({a = (( \f: Nat .((f ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = true }.b) ) (let u = true in true) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b) }.a) ) ) (\a: Bool .\b: Rec X. X .b))
(case <r = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = ({a = true , b = 0 }.a) }.b) )) in u) > as Nat of < l = x > => x | < r = y > => y)
({a = (let u = ({a = ({a = true , b = 1 }.b) , b = ({a = 1 , b = false , c =  0 }.b) , c =  0 }.b) in (pred ({a = 1 , b = 0 }.b))) , b = (fix (\x: Bool . (if (let u = false in false) then (if false then false else false) else (if false then true else (case <r = false > as Unit of < l = x > => x | < r = y > => y))) )) }.b)
({a = ({a = ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) true) , b = (unfold [ Unit ] (fold [ Nat ] false )) , c =  (if true then ({a = true , b = 1 }.b) else (succ 0)) }.b) , b = ({a = (fix (\x: Nat . (let u = false in true) )) , b = ({a = false , b = 0 }.b) }.b) }.b) , b = (fix (\x: Bool . (( \f: Rec X. X .((f ({a = true , b = true }.b) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Bool .b)) )) }.b)
({a = ({a = ({a = false , b = true }.b) , b = (let u = (succ 0) in ({a = 1 , b = 0 }.b)) }.b) , b = (let u = (fix (\x: Unit . (fix (\x: Unit . ({a = 1 , b = false }.a) )) )) in (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a))) , c =  (let u = ({a = (( \f: Bool .((f true ) ({a = 0 , b = true }.b) ) ) (\a: Bool .\b: Unit .b)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) }.b) in ({a = (let u = ({a = true , b = 0 }.a) in u) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) }.b)) }.b)
(pred (if (let u = true in u) then ({a = (( \f: Bool .((f (((\x: Nat .\y: Unit .y) false ) 0) ) 1 ) ) (\a: Unit .\b: Bool .a)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) else ({a = (let u = 0 in u) , b = false , c = ({a = 1 , b = 1 }.b) }.c)))
(if (case <r = ({a = (fix (\x: Unit . true )) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.a) > as Nat of < l = x > => x | < r = y > => y) then (( \f: Nat .((f (let u = (if true then (fix (\x: Rec X. X . true )) else (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a))) in (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) > as Unit of < l = x > => x | < r = y > => y)) ) (fix (\x: Nat . (let u = (if false then false else (let u = 0 in true)) in ({a = (let u = 0 in true) , b = ({a = 0 , b = true }.a) }.a)) )) ) ) (\a: Nat .\b: Unit .b)) else (let u = ({a = ({a = 0 , b = true }.a) , b = (unfold [ Nat ] (fold [ Bool ] (iszero 1) )) , c =  (pred 1) }.b) in u))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = ({a = (if false then true else true) , b = ({a = false , b = 1 }.b) }.a) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (if (if true then true else true) then (iszero 1) else (let u = true in u)) )) }.b) ))
(( \f: Rec X. X .((f ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] false )) )) , b = (if false then 1 else 0) }.a) ) (((\x: Unit .\y: Bool .y) (let u = (((\x: Bool .\y: Nat .x) true ) ({a = 1 , b = true , c =  0 }.b)) in (let u = true in u)) ) (let u = true in u)) ) ) (\a: Unit .\b: Unit .b))
({a = (((\x: Rec X. X .\y: Nat .y) ({a = (unfold [ Bool ] (fold [ Rec X. X ] (let u = true in false) )) , b = (unfold [ Bool ] (fold [ Unit ] ({a = true , b = 0 }.a) )) }.b) ) (if ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) then (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .x) false ) false) )) else (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) true ) ) (\a: Rec X. X .\b: Nat .b)))) , b = (case <l = (((\x: Nat .\y: Unit .y) ({a = (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = ({a = 1 , b = false , c =  1 }.b) , c =  ({a = (pred 0) , b = false }.a) }.b) ) (let u = 0 in u)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(((\x: Nat .\y: Bool .y) ({a = (let u = ({a = 1 , b = ({a = 0 , b = false , c =  0 }.b) }.b) in (let u = false in false)) , b = (fix (\x: Bool . (iszero 1) )) }.b) ) ({a = ({a = (((\x: Bool .\y: Rec X. X .x) (let u = true in 0) ) (let u = false in true)) , b = (if ({a = false , b = true }.b) then (unfold [ Unit ] (fold [ Nat ] false )) else (((\x: Rec X. X .\y: Bool .y) true ) true)) , c =  (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) }.b) , b = ({a = false , b = 1 }.b) }.b))
(pred (pred ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .x) true ) true) , c = 1 }.c)))
(((\x: Unit .\y: Nat .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .y) false ) false) ) true) ) (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] true )) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Nat .b)) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) true) )))
({a = (case <l = (pred (if false then (((\x: Nat .\y: Rec X. X .x) 0 ) true) else ({a = false , b = 1 }.b))) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (let u = false in u) )) , c = (((\x: Rec X. X .\y: Unit .x) ({a = (if false then ({a = true , b = 0 }.a) else (let u = 1 in false)) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = (((\x: Unit .\y: Unit .x) true ) false) in 0) )) }.b) ) ({a = (case <r = (let u = 1 in false) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Unit .x) 1 ) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b))) }.a)) }.c)
({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = (((\x: Nat .\y: Rec X. X .y) true ) (let u = 1 in false)) in u) )) , b = (( \f: Bool .((f ({a = ({a = (let u = 0 in u) , b = (( \f: Bool .((f 1 ) (((\x: Bool .\y: Nat .y) true ) 0) ) ) (\a: Bool .\b: Nat .a)) }.b) , b = (fix (\x: Rec X. X . 0 )) }.b) ) (( \f: Unit .((f (( \f: Nat .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Unit .\b: Rec X. X .a)) ) (( \f: Bool .((f (pred 0) ) (let u = (((\x: Bool .\y: Rec X. X .y) true ) 1) in ({a = 1 , b = false , c = 0 }.c)) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b)) }.a)
(( \f: Nat .((f (pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (succ (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) ))) ) ({a = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) , b = (pred ({a = 1 , b = true , c = 1 }.c)) }.b) ) ) (\a: Nat .\b: Unit .b))
(fix (\x: Nat . ({a = (let u = (((\x: Bool .\y: Bool .x) 0 ) false) in ({a = 0 , b = 1 }.b)) , b = (case <r = ({a = true , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) }.b) ))
(let u = ({a = ({a = true , b = ({a = 1 , b = false , c =  1 }.b) }.b) , b = (fix (\x: Bool . (pred (let u = false in 0)) )) }.a) in (pred (pred (let u = 1 in u))))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (if (let u = false in u) then (if true then false else true) else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (let u = 1 in 0) }.b) ))
(fix (\x: Unit . (iszero (let u = false in 1)) ))
(( \f: Bool .((f (let u = (succ (succ 0)) in u) ) (case <l = (let u = (succ (pred 0)) in (fix (\x: Unit . 0 ))) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .a))
({a = ({a = (let u = (((\x: Nat .\y: Rec X. X .x) (( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) ) (fix (\x: Nat . false )) ) ) (\a: Rec X. X .\b: Bool .b)) ) (let u = 0 in true)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (let u = false in u) ))) , b = (((\x: Nat .\y: Unit .y) ({a = (let u = true in false) , b = ({a = true , b = true }.b) }.b) ) (let u = ({a = 1 , b = true }.a) in u)) }.b) , b = (((\x: Nat .\y: Rec X. X .y) (let u = ({a = true , b = 1 }.a) in u) ) (let u = (let u = false in true) in (let u = ({a = 1 , b = true , c =  0 }.b) in ({a = 1 , b = true , c =  1 }.b)))) , c = (let u = (case <l = ({a = 0 , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (pred 1) ))) }.c)
(pred (let u = ({a = 0 , b = (unfold [ Nat ] (fold [ Bool ] true )) }.a) in (( \f: Bool .((f ({a = 0 , b = false , c = 0 }.c) ) (pred 1) ) ) (\a: Nat .\b: Bool .a))))
({a = (let u = (let u = (let u = 0 in u) in (if true then false else true)) in ({a = (( \f: Unit .((f (((\x: Nat .\y: Nat .x) 0 ) true) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = ({a = 0 , b = false }.b) }.a)) , b = (unfold [ Bool ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] (let u = 1 in false) )) )) , c =  (let u = (((\x: Nat .\y: Nat .y) ({a = ({a = false , b = 1 }.a) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.b) ) (let u = (iszero 0) in ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )))) in (pred (let u = (succ 0) in ({a = 0 , b = false , c = 0 }.c)))) }.b)
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (case <r = (if false then false else true) > as Rec X. X of < l = x > => x | < r = y > => y) )) in (succ ({a = false , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) }.b)))
(if (if (iszero (case <l = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y)) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = 1 in (let u = true in u)) )) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero 1) ))) then (let u = (let u = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b)) in u) in u) else (if (iszero (pred ({a = 0 , b = false }.a))) then (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) in true) else ({a = (((\x: Nat .\y: Bool .x) true ) false) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.a)))
(let u = (if (( \f: Bool .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = true , b = 0 }.a) )) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b)) then (fix (\x: Nat . (fix (\x: Bool . (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) )) else (( \f: Rec X. X .((f (pred (succ 0)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (if false then 0 else 1) )) ) ) (\a: Bool .\b: Unit .b))) in (let u = (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) in (if (fix (\x: Rec X. X . (unfold [ Unit ] (fold [ Rec X. X ] (let u = 0 in false) )) )) then (let u = ({a = true , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) in (((\x: Rec X. X .\y: Rec X. X .y) false ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y))) else (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y))))
(((\x: Bool .\y: Nat .y) ({a = ({a = false , b = false }.b) , b = (((\x: Nat .\y: Unit .x) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true ))) }.a) ) (((\x: Unit .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) ) (( \f: Unit .((f (unfold [ Bool ] (fold [ Bool ] true )) ) (if false then true else false) ) ) (\a: Bool .\b: Nat .a))))
(pred (pred (let u = (unfold [ Unit ] (fold [ Bool ] 0 )) in (let u = 1 in 1))))
(fix (\x: Unit . (let u = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Unit ] false )) ) true) in u) ))
(unfold [ Rec X. X ] (fold [ Bool ] (( \f: Nat .((f (case <r = (unfold [ Bool ] (fold [ Unit ] ({a = false , b = 1 }.a) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) in (let u = false in false)) ) ) (\a: Rec X. X .\b: Bool .b)) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = (if (case <r = (((\x: Nat .\y: Unit .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = 1 , b = false }.b) else ({a = false , b = 1 }.a)) , b = (case <l = (if ({a = 0 , b = true }.b) then (let u = 1 in u) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a))) > as Bool of < l = x > => x | < r = y > => y) }.a) ))
({a = (case <r = (case <r = (unfold [ Bool ] (fold [ Rec X. X ] false )) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then (iszero (let u = 1 in 1)) else (((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .a)) ) ({a = true , b = false }.b))) , b = (let u = ({a = (let u = true in false) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in u) }.b) }.b)
(( \f: Rec X. X .((f ({a = (unfold [ Bool ] (fold [ Nat ] (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) )) , b = (((\x: Rec X. X .\y: Bool .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) false) , c = (( \f: Rec X. X .((f (if false then 0 else (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b))) ) (fix (\x: Unit . 0 )) ) ) (\a: Nat .\b: Rec X. X .b)) }.c) ) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = false }.a) )) , b = (iszero (if true then 0 else 1)) , c = (((\x: Bool .\y: Bool .y) false ) 0) }.c) ) ) (\a: Nat .\b: Bool .a))
(let u = ({a = (fix (\x: Nat . (let u = true in true) )) , b = (let u = (unfold [ Bool ] (fold [ Bool ] false )) in u) }.b) in u)
({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) , b = (((\x: Bool .\y: Unit .x) (unfold [ Nat ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) )) ) (( \f: Nat .((f (let u = 1 in false) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a))) }.b)
(((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f (let u = (case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) > as Nat of < l = x > => x | < r = y > => y) in ({a = 1 , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) , c =  0 }.b)) ) (let u = (succ 0) in (unfold [ Nat ] (fold [ Rec X. X ] true ))) ) ) (\a: Nat .\b: Unit .a)) ) (let u = (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . false )) )) in (((\x: Nat .\y: Nat .x) ({a = 0 , b = false , c = 0 }.c) ) (iszero 0))))
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = (pred ({a = 0 , b = false }.a)) in u) ))
(( \f: Rec X. X .((f (let u = (if (let u = 0 in false) then 0 else 0) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false ))) ) (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .x) (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b)) ) ({a = true , b = 0 }.a)) ) ) (\a: Unit .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Nat .b))
({a = (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Bool .x) (iszero (let u = 1 in u)) ) (( \f: Rec X. X .((f (if false then true else false) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Unit .\b: Unit .b))) ) (let u = (case <l = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 1 , b = 0 }.b) )))) , b = ({a = (pred ({a = true , b = (if false then 1 else 0) }.b)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) )) , c =  (case <l = ({a = true , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y) }.b) }.a)
(( \f: Unit .((f ({a = (iszero (let u = (succ 0) in ({a = true , b = 0 }.b))) , b = (fix (\x: Unit . (((\x: Nat .\y: Nat .y) ({a = 0 , b = true }.b) ) (let u = 0 in 0)) )) }.a) ) (( \f: Nat .((f ({a = ({a = (let u = 1 in 0) , b = (let u = 0 in false) }.a) , b = ({a = (unfold [ Bool ] (fold [ Rec X. X ] true )) , b = false }.b) , c =  (fix (\x: Rec X. X . 1 )) }.b) ) (((\x: Bool .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Bool .b))
(case <r = (( \f: Nat .((f (( \f: Rec X. X .((f ({a = false , b = true }.b) ) (iszero 1) ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Bool .\y: Unit .x) ({a = false , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) (let u = 1 in true)) ) ) (\a: Rec X. X .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y)
(unfold [ Nat ] (fold [ Bool ] (let u = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (iszero 0) , c =  (let u = true in 0) }.b) in (if ({a = (if false then ({a = 0 , b = 0 }.b) else 0) , b = (let u = true in u) , c =  (let u = 0 in u) }.b) then (fix (\x: Nat . (let u = 0 in true) )) else (iszero (unfold [ Unit ] (fold [ Rec X. X ] 1 ))))) ))
(let u = ({a = (((\x: Rec X. X .\y: Nat .x) true ) false) , b = (((\x: Nat .\y: Nat .x) (unfold [ Unit ] (fold [ Bool ] true )) ) (if true then true else false)) }.b) in u)
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (iszero (succ (succ 1))) ))
(fix (\x: Bool . ({a = (( \f: Nat .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Nat .a)) , b = ({a = (((\x: Nat .\y: Rec X. X .y) true ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a))) , b = (fix (\x: Nat . ({a = 1 , b = true }.a) )) }.a) }.a) ))
(((\x: Unit .\y: Rec X. X .x) ({a = (iszero (case <l = (((\x: Unit .\y: Unit .y) true ) 1) > as Unit of < l = x > => x | < r = y > => y)) , b = (let u = ({a = (fix (\x: Unit . 1 )) , b = 0 }.b) in (let u = ({a = true , b = false }.b) in (let u = false in 0))) }.b) ) (let u = (case <r = ({a = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in u))
(pred (case <l = (unfold [ Bool ] (fold [ Unit ] (pred 1) )) > as Bool of < l = x > => x | < r = y > => y))
({a = (case <l = (pred (( \f: Rec X. X .((f 0 ) (if false then 0 else 0) ) ) (\a: Rec X. X .\b: Unit .a))) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (if (let u = (((\x: Nat .\y: Rec X. X .x) 0 ) true) in true) then ({a = (fix (\x: Unit . 1 )) , b = (unfold [ Bool ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .y) true ) true) )) , c =  (let u = (let u = true in 0) in u) }.b) else (if (case <r = (let u = true in false) > as Rec X. X of < l = x > => x | < r = y > => y) then (let u = 0 in true) else (let u = 0 in false))) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (if false then false else false) )) }.b) }.b)
(case <r = (((\x: Bool .\y: Bool .x) (unfold [ Bool ] (fold [ Nat ] false )) ) (((\x: Nat .\y: Rec X. X .y) false ) true)) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Unit .x) (case <l = (((\x: Nat .\y: Unit .y) (fix (\x: Rec X. X . (if false then false else true) )) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (let u = (((\x: Nat .\y: Rec X. X .x) true ) true) in ({a = (let u = 0 in u) , b = 1 }.b)) , b = (( \f: Nat .((f ({a = 1 , b = false , c =  (succ 1) }.b) ) ({a = 0 , b = true }.b) ) ) (\a: Unit .\b: Nat .a)) , c =  ({a = (let u = true in 1) , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.a) }.b))
(unfold [ Unit ] (fold [ Bool ] (if ({a = (( \f: Nat .((f (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) (((\x: Rec X. X .\y: Unit .y) false ) 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (let u = (iszero 0) in 1) ) ) (\a: Nat .\b: Unit .b)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Unit .a)) )) }.b) then (unfold [ Bool ] (fold [ Bool ] ({a = (let u = false in true) , b = (if false then true else true) }.b) )) else (let u = (( \f: Unit .((f (let u = 1 in false) ) (let u = false in u) ) ) (\a: Unit .\b: Rec X. X .a)) in ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (let u = 1 in true) , c =  (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) }.b))) ))
({a = ({a = (((\x: Bool .\y: Nat .y) true ) 1) , b = (fix (\x: Nat . (fix (\x: Rec X. X . true )) )) , c = (unfold [ Unit ] (fold [ Unit ] ({a = 1 , b = true }.a) )) }.c) , b = (( \f: Rec X. X .((f (succ ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 ))) ) (case <l = (let u = 1 in ({a = false , b = 1 }.b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) }.b)
({a = (unfold [ Bool ] (fold [ Unit ] (let u = (if false then 1 else 1) in u) )) , b = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Nat .\b: Nat .b)) )) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (iszero 1) ))) , c =  ({a = (let u = ({a = false , b = false }.b) in u) , b = (( \f: Bool .((f (let u = true in 1) ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Bool .\b: Nat .a)) }.b) }.b)
(if (if (case <r = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Unit ] true )) ) (iszero 1) ) ) (\a: Unit .\b: Unit .a)) > as Nat of < l = x > => x | < r = y > => y) then (if (((\x: Bool .\y: Unit .y) (if true then false else true) ) ({a = 0 , b = true , c =  0 }.b)) then (fix (\x: Bool . false )) else (let u = 1 in false)) else ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = true in true) }.a) , b = (let u = (let u = true in u) in u) }.b)) then ({a = (let u = (((\x: Nat .\y: Bool .x) 1 ) true) in u) , b = ({a = (let u = (((\x: Nat .\y: Nat .y) false ) true) in (if false then false else true)) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.b) }.a) else (succ ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = 1 }.b) }.b)))
(( \f: Nat .((f (if (iszero (let u = 0 in 1)) then (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = true }.a) )) else ({a = (let u = 0 in 0) , b = true }.a)) ) (let u = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) , b = (if false then 0 else 1) }.b) in (case <l = (succ 1) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Bool .a))
({a = (pred (( \f: Rec X. X .((f (let u = 0 in u) ) ({a = true , b = 1 }.b) ) ) (\a: Nat .\b: Rec X. X .b))) , b = (unfold [ Bool ] (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Bool .y) true ) false) , b = ({a = ({a = false , b = 1 }.b) , b = 0 }.b) }.a) )) }.b)
(let u = ({a = (( \f: Unit .((f ({a = 0 , b = false }.b) ) ({a = (((\x: Nat .\y: Nat .y) true ) true) , b = (fix (\x: Nat . 1 )) }.a) ) ) (\a: Bool .\b: Unit .b)) , b = (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in false) }.b) in u)
(case <l = (case <l = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (pred 1) )) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Nat ] (( \f: Bool .((f (((\x: Nat .\y: Unit .y) (( \f: Unit .((f (let u = false in true) ) false ) ) (\a: Bool .\b: Nat .a)) ) (if ({a = true , b = false }.b) then true else (let u = 0 in false))) ) ({a = (( \f: Nat .((f ({a = 1 , b = false , c =  1 }.b) ) (let u = false in true) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = 0 in u) )) }.a) ) ) (\a: Rec X. X .\b: Nat .a)) ))
(unfold [ Nat ] (fold [ Nat ] (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .y) false ) false) ) ({a = true , b = false }.b) ) ) (\a: Unit .\b: Nat .a)) ))
(let u = ({a = ({a = (unfold [ Nat ] (fold [ Nat ] true )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (let u = false in 1) )) }.b) in u)
({a = (let u = (let u = (case <l = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) > as Nat of < l = x > => x | < r = y > => y) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) in u) , b = ({a = (((\x: Unit .\y: Rec X. X .x) (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .b)) in u) ) (fix (\x: Nat . false ))) , b = ({a = false , b = false }.b) }.b) }.b)
({a = (iszero ({a = (((\x: Nat .\y: Bool .x) 0 ) true) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] false )) }.a)) , b = (succ (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) in u)) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = (let u = false in false) , b = (((\x: Rec X. X .\y: Unit .x) false ) true) }.b) , b = (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 ))) }.a) ))
(((\x: Rec X. X .\y: Bool .x) (let u = (unfold [ Bool ] (fold [ Nat ] (case <r = (( \f: Rec X. X .((f false ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Rec X. X .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) )) in ({a = (unfold [ Rec X. X ] (fold [ Bool ] (let u = 1 in (fix (\x: Bool . 0 ))) )) , b = (if false then true else true) , c = (succ ({a = 0 , b = false , c = 1 }.c)) }.c)) ) (if (( \f: Nat .((f (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (fix (\x: Nat . false )) ) ) (\a: Bool .\b: Nat .a)) then (let u = (fix (\x: Rec X. X . (pred 1) )) in (fix (\x: Unit . (case <r = true > as Nat of < l = x > => x | < r = y > => y) ))) else (iszero (pred (if true then 0 else 1)))))
({a = (let u = (( \f: Nat .((f (let u = 0 in true) ) true ) ) (\a: Rec X. X .\b: Bool .a)) in (( \f: Nat .((f 0 ) (unfold [ Unit ] (fold [ Nat ] 0 )) ) ) (\a: Bool .\b: Rec X. X .b))) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Unit .x) true ) true) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.a) )) , c = (((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Bool .x) ({a = false , b = 0 }.a) ) (( \f: Bool .((f (unfold [ Bool ] (fold [ Nat ] true )) ) true ) ) (\a: Nat .\b: Nat .a))) ) (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Bool ] 0 )) ) ({a = true , b = 1 }.b) ) ) (\a: Rec X. X .\b: Bool .a))) }.c)
(((\x: Unit .\y: Rec X. X .x) (fix (\x: Bool . (if (let u = 0 in false) then ({a = (unfold [ Nat ] (fold [ Bool ] false )) , b = (let u = 1 in u) }.a) else (let u = true in u)) )) ) (if ({a = (if (fix (\x: Unit . false )) then (((\x: Nat .\y: Nat .x) true ) true) else true) , b = (succ 0) }.a) then ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = (if false then true else false) }.b) else (if true then (fix (\x: Unit . false )) else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )))))
(( \f: Nat .((f (if (((\x: Rec X. X .\y: Bool .y) ({a = 0 , b = true }.b) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false ))) then (( \f: Unit .((f ({a = true , b = 0 }.a) ) ({a = (if false then 1 else 1) , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .a)) else (if (( \f: Nat .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Bool .a)) then (if true then false else (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b))) else (((\x: Nat .\y: Bool .x) false ) true))) ) ({a = (if (let u = true in u) then (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) else (iszero 1)) , b = (let u = ({a = 0 , b = true , c =  0 }.b) in u) }.b) ) ) (\a: Bool .\b: Bool .b))
(let u = (if ({a = (( \f: Nat .((f ({a = 1 , b = true , c = 0 }.c) ) (let u = 1 in u) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (if false then true else true) }.b) then (unfold [ Unit ] (fold [ Bool ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) else ({a = ({a = false , b = 0 }.b) , b = (let u = false in true) }.a)) in (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f (pred 1) ) (case <l = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a)) ) (let u = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = true }.a) in ({a = (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) in u) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b))))
(let u = ({a = ({a = (((\x: Nat .\y: Unit .y) false ) false) , b = (case <l = (fix (\x: Nat . 0 )) > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (( \f: Unit .((f (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false , c =  1 }.b) ) ) (\a: Nat .\b: Bool .b)) , c = (((\x: Nat .\y: Nat .y) true ) 1) }.c) in u)
(let u = ({a = (let u = 1 in true) , b = (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Bool .y) false ) false) ) 0) }.a) in (unfold [ Nat ] (fold [ Rec X. X ] ({a = false , b = true }.b) )))
({a = (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) )) , b = ({a = ({a = (let u = 0 in false) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b) , b = (let u = (let u = 1 in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) in u) }.b) }.b)
(if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (iszero (pred 0)) )) then (let u = (let u = ({a = (let u = false in 1) , b = 1 }.b) in (let u = ({a = 1 , b = false }.b) in u)) in (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Nat .\y: Unit .x) false ) false) ))) else ({a = (fix (\x: Rec X. X . (((\x: Unit .\y: Nat .y) (( \f: Rec X. X .((f false ) ({a = true , b = 0 }.a) ) ) (\a: Unit .\b: Bool .b)) ) (let u = false in 1)) )) , b = (((\x: Rec X. X .\y: Nat .x) (let u = true in true) ) (let u = false in u)) }.b))
(((\x: Rec X. X .\y: Unit .x) (fix (\x: Rec X. X . ({a = (succ 0) , b = (((\x: Unit .\y: Bool .y) false ) true) }.b) )) ) ({a = (( \f: Unit .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (if ({a = 1 , b = true , c =  0 }.b) then (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = 0 in false)) }.b))
({a = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) 1 ) false) )) , b = (( \f: Bool .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .b)) ) (let u = 0 in false) ) ) (\a: Bool .\b: Nat .b)) , c = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) )) }.c) , b = ({a = (( \f: Nat .((f ({a = true , b = 0 }.b) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = (((\x: Nat .\y: Bool .x) false ) true) }.a) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (case <r = ({a = (let u = (((\x: Nat .\y: Unit .x) false ) false) in ({a = true , b = true }.b)) , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) }.b) > as Bool of < l = x > => x | < r = y > => y) , c =  (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in 0) )) }.b) , c =  (( \f: Bool .((f ({a = (if true then 0 else 0) , b = false , c = 1 }.c) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) in ({a = 1 , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Nat .b)) }.b)
((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = (unfold [ Bool ] (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) )) in u) ))
(fix (\x: Rec X. X . (((\x: Nat .\y: Nat .y) (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = true , c =  0 }.b) )) ) (( \f: Unit .((f ({a = 1 , b = true }.b) ) (let u = true in u) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Bool .\b: Unit .a)) ) ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = true in u) , c =  (succ ({a = false , b = 1 }.b)) }.b)) ))
({a = ({a = ({a = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = true , c = 1 }.c) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] false )) )) , c =  ({a = (fix (\x: Rec X. X . false )) , b = (((\x: Rec X. X .\y: Unit .y) true ) ({a = 1 , b = 1 }.b)) }.b) }.b) , b = (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = (succ 1) }.b) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) )) }.a)
(let u = (( \f: Unit .((f (((\x: Bool .\y: Rec X. X .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (let u = true in false)) ) (pred (unfold [ Bool ] (fold [ Unit ] 0 ))) ) ) (\a: Nat .\b: Rec X. X .a)) in (if (fix (\x: Bool . (let u = false in (((\x: Unit .\y: Nat .y) true ) true)) )) then (let u = 0 in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) else (fix (\x: Bool . (pred 0) ))))
(((\x: Nat .\y: Unit .y) (iszero ({a = (let u = 0 in u) , b = ({a = 0 , b = false }.b) , c = (let u = false in 1) }.c)) ) (succ (( \f: Nat .((f (succ (let u = 0 in u)) ) (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) in u) ) ) (\a: Unit .\b: Nat .a))))
(unfold [ Nat ] (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] (let u = ({a = true , b = true }.b) in false) )) ))
({a = ({a = (((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Nat .a)) ) (let u = 0 in u)) , b = (case <r = (unfold [ Nat ] (fold [ Nat ] false )) > as Unit of < l = x > => x | < r = y > => y) }.a) , b = (fix (\x: Rec X. X . (( \f: Nat .((f true ) (((\x: Unit .\y: Bool .y) false ) false) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , c = ({a = (((\x: Bool .\y: Rec X. X .y) ({a = false , b = 0 }.a) ) (((\x: Unit .\y: Bool .y) true ) 0)) , b = (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .x) 1 ) (((\x: Rec X. X .\y: Rec X. X .y) false ) false)) )) }.b) }.c)
(fix (\x: Bool . (iszero (let u = (iszero 0) in (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)))) ))
(if ({a = ({a = ({a = 0 , b = true }.a) , b = false , c =  0 }.b) , b = ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = true }.b) }.b) then ({a = (let u = (if false then 1 else 1) in u) , b = ({a = (( \f: Rec X. X .((f (((\x: Nat .\y: Rec X. X .y) false ) true) ) (((\x: Unit .\y: Unit .y) true ) true) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (( \f: Bool .((f ({a = 0 , b = 0 }.b) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Nat .a)) }.a) , c = (pred (( \f: Nat .((f (if false then 0 else 0) ) (if true then 0 else 0) ) ) (\a: Rec X. X .\b: Bool .a))) }.c) else ({a = (let u = ({a = (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Nat .y) false ) true) ) true) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) }.b) in (if false then (let u = 1 in 1) else 0)) , b = (fix (\x: Bool . (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a))
(( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) (pred (if false then 0 else 0)) ) (iszero 0)) ) ({a = (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) false ) true) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) ) (\a: Unit .\b: Unit .a)) , b = (succ (succ 1)) }.b) ) ) (\a: Bool .\b: Unit .b))
({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ({a = true , b = (((\x: Unit .\y: Bool .y) true ) 1) }.b) , b = ({a = (let u = false in (if false then true else true)) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.a) }.b) )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) (( \f: Unit .((f ({a = true , b = 1 }.a) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ) (( \f: Unit .((f 1 ) ({a = 0 , b = 0 }.b) ) ) (\a: Bool .\b: Rec X. X .b))) )) }.a)
({a = ({a = (case <l = ({a = (fix (\x: Rec X. X . true )) , b = (case <l = (let u = false in 1) > as Bool of < l = x > => x | < r = y > => y) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Rec X. X . (let u = true in 0) )) }.b) , b = ({a = (fix (\x: Unit . (( \f: Bool .((f (let u = false in 1) ) 1 ) ) (\a: Unit .\b: Unit .b)) )) , b = ({a = (let u = (unfold [ Rec X. X ] (fold [ Nat ] true )) in (( \f: Unit .((f (succ 0) ) (((\x: Rec X. X .\y: Nat .y) false ) 0) ) ) (\a: Bool .\b: Rec X. X .a))) , b = (let u = true in u) , c =  (if false then (((\x: Nat .\y: Rec X. X .y) true ) 0) else 1) }.b) }.b) }.a)
({a = (((\x: Nat .\y: Nat .y) ({a = (fix (\x: Bool . 1 )) , b = (( \f: Unit .((f true ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Unit .a)) }.b) ) ({a = (((\x: Rec X. X .\y: Unit .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) 1) , b = ({a = 0 , b = true , c =  (fix (\x: Bool . 1 )) }.b) }.b)) , b = (((\x: Unit .\y: Nat .y) (case <r = ({a = 0 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ({a = true , b = 0 }.b) , b = (case <l = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) }.a)
(( \f: Unit .((f ({a = (((\x: Unit .\y: Unit .x) (unfold [ Bool ] (fold [ Bool ] 1 )) ) ({a = true , b = false }.b)) , b = (pred (let u = 0 in 0)) }.b) ) (((\x: Unit .\y: Unit .y) (((\x: Nat .\y: Nat .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ({a = (unfold [ Rec X. X ] (fold [ Unit ] true )) , b = (unfold [ Nat ] (fold [ Nat ] 1 )) }.a)) ) (( \f: Bool .((f (unfold [ Bool ] (fold [ Bool ] ({a = false , b = 0 }.b) )) ) (unfold [ Bool ] (fold [ Nat ] 0 )) ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Nat .\b: Bool .b))
(unfold [ Unit ] (fold [ Bool ] (fix (\x: Nat . (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) )) ))
(succ (((\x: Bool .\y: Unit .y) (let u = (((\x: Unit .\y: Rec X. X .x) true ) true) in u) ) ({a = (fix (\x: Nat . ({a = 1 , b = false }.a) )) , b = (((\x: Rec X. X .\y: Unit .y) (if true then false else true) ) (fix (\x: Rec X. X . true ))) }.a)))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (case <r = (iszero (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = true , c = 1 }.c) ))) > as Unit of < l = x > => x | < r = y > => y) ))
(( \f: Unit .((f ({a = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) false ) true) )) , b = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = (fix (\x: Nat . false )) }.b) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) }.b) ) (( \f: Rec X. X .((f ({a = (pred 0) , b = ({a = 1 , b = 0 }.b) }.b) ) ({a = ({a = (if false then 1 else 0) , b = false }.a) , b = (unfold [ Nat ] (fold [ Bool ] (((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Unit .x) true ) true) ) 1) )) }.b) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Nat .\b: Rec X. X .b))
(fix (\x: Nat . (fix (\x: Nat . (fix (\x: Nat . (if false then (((\x: Bool .\y: Unit .x) 0 ) true) else (pred 1)) )) )) ))
(((\x: Nat .\y: Nat .y) (( \f: Nat .((f ({a = 0 , b = ({a = 0 , b = true }.b) }.b) ) (case <r = (case <r = (let u = false in u) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) ) (( \f: Unit .((f ({a = (((\x: Unit .\y: Bool .y) true ) 1) , b = (if true then 0 else (let u = false in 1)) }.b) ) ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Unit .b)))
(( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] (case <l = (( \f: Nat .((f (((\x: Rec X. X .\y: Unit .x) 0 ) true) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Rec X. X .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) )) ) (let u = (case <r = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = (fix (\x: Unit . false )) , b = 0 }.b)) ) ) (\a: Unit .\b: Bool .b))
(let u = (( \f: Bool .((f (iszero (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) ) (fix (\x: Nat . false )) ) ) (\a: Unit .\b: Nat .a)) in u)
(let u = (fix (\x: Nat . ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Unit ] 1 )) )) )) in (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) (let u = 1 in (fix (\x: Rec X. X . 0 ))) ) ({a = (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Rec X. X .a)) , b = ({a = false , b = true }.b) , c =  (( \f: Rec X. X .((f (((\x: Nat .\y: Nat .x) 1 ) true) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Nat .\b: Nat .b)) }.b)) )))
(( \f: Nat .((f (let u = ({a = (((\x: Nat .\y: Rec X. X .x) true ) false) , b = ({a = true , b = false }.b) }.b) in (((\x: Nat .\y: Bool .y) (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in u) )) ) (((\x: Unit .\y: Unit .y) false ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Bool .a))))) ) ({a = (iszero ({a = ({a = false , b = false }.b) , b = ({a = 1 , b = true , c = 1 }.c) }.b)) , b = (( \f: Bool .((f (fix (\x: Rec X. X . 1 )) ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) }.a) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (if (let u = (((\x: Bool .\y: Bool .x) 0 ) true) in (if false then false else true)) then (pred (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)))) else (((\x: Nat .\y: Bool .y) (let u = false in u) ) 1)) in u)
(((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) true ) true) ) (let u = true in false) ) ) (\a: Bool .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = (let u = true in false) }.b) ) (((\x: Nat .\y: Nat .x) true ) true)) ) ) (\a: Bool .\b: Bool .a)) ) (let u = (let u = (let u = 1 in (((\x: Nat .\y: Unit .x) true ) false)) in u) in (fix (\x: Unit . (((\x: Nat .\y: Nat .x) 1 ) true) ))))
(fix (\x: Bool . (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Unit .y) (((\x: Nat .\y: Unit .x) ({a = true , b = 1 }.a) ) ({a = 0 , b = false }.b)) ) (((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Bool .x) false ) false) ) (fix (\x: Unit . 0 )))) ) (fix (\x: Unit . ({a = 0 , b = true }.b) ))) ))
(let u = (if (let u = ({a = 1 , b = ({a = false , b = true }.b) , c = 0 }.c) in (((\x: Bool .\y: Unit .x) false ) false)) then (let u = (unfold [ Nat ] (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) )) in ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = 1 }.b)) else ({a = (((\x: Rec X. X .\y: Unit .x) ({a = 0 , b = true }.b) ) ({a = 0 , b = false }.b)) , b = (let u = (let u = 1 in true) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 ))) }.b)) in ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = 1 }.b) )) , b = (iszero (succ 0)) }.b))
(( \f: Rec X. X .((f (case <l = (fix (\x: Nat . (if (if false then false else true) then (fix (\x: Unit . 1 )) else (((\x: Nat .\y: Unit .y) (let u = false in false) ) ({a = 0 , b = 1 }.b))) )) > as Bool of < l = x > => x | < r = y > => y) ) ({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .x) 1 ) true) ) (((\x: Unit .\y: Nat .y) true ) 0) ) ) (\a: Bool .\b: Unit .b)) , b = ({a = (let u = true in false) , b = ({a = true , b = 1 }.a) }.b) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (let u = 0 in u) , b = true , c = (((\x: Bool .\y: Nat .y) true ) 0) }.c) )) }.c) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(( \f: Rec X. X .((f (fix (\x: Bool . (((\x: Bool .\y: Bool .y) true ) false) )) ) (let u = (let u = (((\x: Nat .\y: Bool .y) true ) false) in u) in ({a = ({a = (unfold [ Unit ] (fold [ Rec X. X ] true )) , b = (((\x: Rec X. X .\y: Nat .y) false ) (((\x: Nat .\y: Bool .y) true ) 0)) }.b) , b = (let u = ({a = (let u = true in true) , b = (pred 0) }.a) in ({a = 1 , b = false , c =  ({a = 0 , b = false }.a) }.b)) , c =  (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = 0 , b = true , c = 1 }.c) ))) }.b)) ) ) (\a: Unit .\b: Rec X. X .a))
(pred ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = 0 }.b) )) , b = (unfold [ Bool ] (fold [ Nat ] (iszero (fix (\x: Bool . 0 ))) )) , c = ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = ({a = 0 , b = false }.a) }.b) }.c))
(case <l = (( \f: Rec X. X .((f (succ (pred 0)) ) (case <l = ({a = 1 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y)
({a = (((\x: Nat .\y: Bool .x) ({a = (let u = true in 1) , b = (if false then false else (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .a))) , c = (((\x: Nat .\y: Nat .y) true ) 1) }.c) ) (( \f: Nat .((f ({a = 1 , b = false }.b) ) ({a = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = true in false) }.b) ) ) (\a: Unit .\b: Nat .b))) , b = (case <r = ({a = (((\x: Rec X. X .\y: Unit .x) 0 ) (let u = true in true)) , b = (let u = true in u) }.b) > as Nat of < l = x > => x | < r = y > => y) , c =  (( \f: Nat .((f (unfold [ Nat ] (fold [ Bool ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (unfold [ Unit ] (fold [ Unit ] (let u = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .a)) in (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a))) )) ) ) (\a: Rec X. X .\b: Nat .b)) }.b)
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) (let u = ({a = true , b = true }.b) in (fix (\x: Rec X. X . (fix (\x: Nat . 0 )) ))) ) (( \f: Rec X. X .((f (if false then false else false) ) true ) ) (\a: Nat .\b: Nat .b))) )) , b = ({a = (case <r = (unfold [ Rec X. X ] (fold [ Bool ] true )) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ({a = (fix (\x: Rec X. X . 0 )) , b = (((\x: Rec X. X .\y: Bool .y) false ) true) , c =  ({a = 0 , b = false }.a) }.b) , b = (let u = (((\x: Bool .\y: Rec X. X .y) false ) true) in (iszero 1)) }.b) }.b) , c =  (if ({a = ({a = 0 , b = 0 }.b) , b = (let u = 0 in false) , c =  (pred 1) }.b) then ({a = (let u = 1 in 1) , b = ({a = 1 , b = true }.b) , c = (if false then (succ 0) else (pred 0)) }.c) else (succ ({a = ({a = 1 , b = true , c =  1 }.b) , b = 1 }.b))) }.b)
(((\x: Unit .\y: Unit .x) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) false ) true) )) , b = (pred (succ ({a = 0 , b = true }.a))) }.a) ) (let u = (((\x: Rec X. X .\y: Unit .x) ({a = (if false then true else true) , b = false }.b) ) ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , b = ({a = false , b = 1 }.b) }.a)) in (let u = (succ 1) in ({a = ({a = true , b = false }.b) , b = (let u = false in u) }.b))))
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) (if ({a = 0 , b = true , c =  0 }.b) then (( \f: Rec X. X .((f false ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Bool .a)) else (( \f: Bool .((f (if true then true else false) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Bool .\b: Nat .b))) ) (if (((\x: Unit .\y: Bool .x) true ) true) then ({a = (((\x: Unit .\y: Nat .x) 0 ) true) , b = (let u = true in false) }.b) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )))) ) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (((\x: Bool .\y: Bool .x) ({a = 0 , b = false }.a) ) ({a = true , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b)) )) , b = (((\x: Rec X. X .\y: Nat .x) (((\x: Rec X. X .\y: Rec X. X .y) (let u = false in u) ) (let u = 0 in true)) ) (((\x: Bool .\y: Rec X. X .x) true ) false)) , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.b) )) }.b) ) ) (\a: Bool .\b: Bool .a))
(let u = (fix (\x: Unit . (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) in ({a = (fix (\x: Nat . (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) )) , b = (let u = (unfold [ Nat ] (fold [ Nat ] true )) in 1) }.b))
(fix (\x: Rec X. X . ({a = ({a = (case <l = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (let u = 0 in 1) ) (if true then 1 else 0) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) , b = (iszero ({a = ({a = false , b = 1 }.b) , b = (pred 0) }.b)) }.b) ))
(pred (case <l = (if ({a = 0 , b = true , c =  0 }.b) then ({a = 0 , b = true }.a) else (if false then 0 else 1)) > as Rec X. X of < l = x > => x | < r = y > => y))
(pred ({a = (if ({a = true , b = ({a = false , b = false }.b) }.b) then (if (let u = (if true then true else true) in u) then (unfold [ Rec X. X ] (fold [ Nat ] true )) else ({a = false , b = 1 }.a)) else (( \f: Unit .((f (fix (\x: Rec X. X . true )) ) false ) ) (\a: Bool .\b: Unit .b))) , b = (pred ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (succ 1) ))) }.b))
(let u = (if ({a = ({a = (let u = 1 in 1) , b = false , c =  1 }.b) , b = (if true then false else true) }.b) then (((\x: Bool .\y: Rec X. X .y) (iszero 0) ) (let u = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) in (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)))) else (let u = ({a = ({a = 0 , b = false , c =  1 }.b) , b = 1 }.a) in u)) in ({a = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = false }.b) , b = (let u = ({a = 0 , b = ({a = 1 , b = 0 }.b) }.b) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b))) }.a))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .y) (( \f: Unit .((f ({a = false , b = 1 }.a) ) (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = (( \f: Bool .((f 1 ) ({a = 0 , b = 0 }.b) ) ) (\a: Unit .\b: Unit .a)) , b = (iszero 0) }.b)) ))
(fix (\x: Nat . (let u = (((\x: Nat .\y: Nat .x) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = true , b = false }.b)) in (( \f: Unit .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ({a = false , b = 1 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ))
(( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] (let u = (unfold [ Rec X. X ] (fold [ Bool ] (iszero 1) )) in (let u = true in u)) )) ) (fix (\x: Nat . (if ({a = 1 , b = true }.b) then (( \f: Bool .((f (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .b)) ) true ) ) (\a: Nat .\b: Rec X. X .b)) else ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) )) ) ) (\a: Rec X. X .\b: Bool .a))
(( \f: Unit .((f (( \f: Rec X. X .((f (let u = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) in (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b))) ) (fix (\x: Nat . ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .a)) , b = true }.b) )) ) ) (\a: Unit .\b: Rec X. X .a)) ) ({a = (if (unfold [ Bool ] (fold [ Rec X. X ] ({a = true , b = (let u = false in 1) }.a) )) then (if (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Unit .b)) then ({a = false , b = true }.b) else ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) else (let u = ({a = 0 , b = 0 }.b) in (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)))) , b = (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ) ({a = 0 , b = 0 }.b) ) ) (\a: Nat .\b: Bool .a)) }.a) ) ) (\a: Bool .\b: Bool .a))
(unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) ({a = (succ (pred ({a = 1 , b = 0 }.b))) , b = (iszero (( \f: Bool .((f 0 ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .a))) }.b) ) ({a = ({a = (let u = 0 in u) , b = (if true then true else false) , c = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) }.c) , b = ({a = ({a = ({a = false , b = 1 }.b) , b = false }.a) , b = ({a = (let u = true in u) , b = (fix (\x: Unit . false )) }.b) , c =  (pred 1) }.b) , c =  ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = true }.a) }.b)) ))
(((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Rec X. X .x) (let u = true in u) ) (( \f: Unit .((f (let u = true in false) ) ({a = true , b = true }.b) ) ) (\a: Bool .\b: Rec X. X .b))) ) (let u = (( \f: Nat .((f ({a = false , b = (unfold [ Nat ] (fold [ Nat ] true )) }.b) ) ({a = false , b = true }.b) ) ) (\a: Rec X. X .\b: Nat .a)) in u))
(( \f: Bool .((f (unfold [ Nat ] (fold [ Nat ] (case <l = (unfold [ Nat ] (fold [ Nat ] 0 )) > as Bool of < l = x > => x | < r = y > => y) )) ) (( \f: Nat .((f (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] 0 )) ) (let u = 1 in 1) ) ) (\a: Rec X. X .\b: Bool .b)) ) (((\x: Unit .\y: Nat .x) ({a = 0 , b = false , c = ({a = 1 , b = true , c = 0 }.c) }.c) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false ))) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(unfold [ Rec X. X ] (fold [ Unit ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .a)) )) , b = (fix (\x: Unit . false )) }.b) ))
({a = ({a = (( \f: Unit .((f ({a = 0 , b = true }.a) ) (if false then 0 else 1) ) ) (\a: Bool .\b: Unit .b)) , b = (unfold [ Bool ] (fold [ Nat ] (((\x: Nat .\y: Rec X. X .y) true ) true) )) }.a) , b = (((\x: Nat .\y: Unit .y) (let u = ({a = 0 , b = false }.b) in u) ) ({a = (case <l = ({a = 1 , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = 1 , b = false }.b)) , c =  (((\x: Nat .\y: Nat .x) (pred (((\x: Unit .\y: Bool .x) 1 ) true)) ) (fix (\x: Rec X. X . (if true then true else false) ))) }.b)) }.a)
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Bool .((f (((\x: Nat .\y: Unit .y) ({a = true , b = 1 }.a) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a))) ) (((\x: Bool .\y: Unit .x) (let u = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) in u) ) (let u = true in u)) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(fix (\x: Unit . (((\x: Nat .\y: Bool .x) (if (unfold [ Nat ] (fold [ Unit ] false )) then ({a = true , b = 0 }.b) else (succ 0)) ) (let u = (unfold [ Bool ] (fold [ Rec X. X ] false )) in (let u = false in false))) ))
(case <l = (fix (\x: Unit . (succ (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) )) ) ) (\a: Bool .\b: Rec X. X .a))) )) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (let u = (if (iszero ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 ))) then (((\x: Nat .\y: Bool .y) ({a = (unfold [ Rec X. X ] (fold [ Bool ] true )) , b = (fix (\x: Bool . 1 )) }.a) ) (let u = false in u)) else ({a = ({a = 0 , b = true }.b) , b = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = false }.b) }.b)) in ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , b = (let u = ({a = 1 , b = 1 }.b) in (((\x: Unit .\y: Bool .x) 1 ) false)) }.a)) ) (unfold [ Nat ] (fold [ Rec X. X ] (case <r = (let u = (fix (\x: Rec X. X . 0 )) in true) > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Nat .b))
(((\x: Unit .\y: Nat .x) ({a = (fix (\x: Unit . (((\x: Unit .\y: Nat .y) (if false then true else false) ) ({a = 1 , b = true }.b)) )) , b = (((\x: Nat .\y: Bool .x) (( \f: Unit .((f (pred 0) ) 1 ) ) (\a: Nat .\b: Nat .a)) ) (case <r = (fix (\x: Bool . true )) > as Unit of < l = x > => x | < r = y > => y)) }.a) ) ({a = (let u = ({a = true , b = 0 }.a) in u) , b = ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) false) , b = (((\x: Nat .\y: Nat .y) true ) 0) }.b) }.a))
(((\x: Unit .\y: Bool .x) ({a = (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in ({a = 0 , b = false }.b)) , b = (let u = false in false) }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = true , b = false }.b) , b = true }.b) )))
(let u = (if (( \f: Unit .((f (let u = true in u) ) true ) ) (\a: Unit .\b: Bool .b)) then (case <r = (if (fix (\x: Nat . true )) then true else (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .b))) > as Bool of < l = x > => x | < r = y > => y) else (unfold [ Rec X. X ] (fold [ Unit ] (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) in false) ))) in ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Unit .y) false ) 0) )) , b = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (fix (\x: Nat . 0 )) in (let u = 1 in false)) )) in u) , c = (fix (\x: Nat . (succ 0) )) }.c))
(succ (unfold [ Nat ] (fold [ Nat ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) )))
(let u = ({a = (fix (\x: Bool . (( \f: Unit .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) ) (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .y) true ) 1) ) (let u = 1 in 1) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Bool .\b: Nat .a)) )) , b = (((\x: Nat .\y: Nat .x) (let u = (unfold [ Bool ] (fold [ Nat ] false )) in u) ) (unfold [ Bool ] (fold [ Bool ] true ))) , c = (case <l = (if (let u = false in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false ))) then (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) else (let u = (let u = true in u) in 1)) > as Rec X. X of < l = x > => x | < r = y > => y) }.c) in u)
(((\x: Unit .\y: Nat .x) (succ (fix (\x: Rec X. X . 1 ))) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Nat . (let u = (if false then true else false) in (iszero 1)) )) )))
(case <r = (unfold [ Nat ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Nat ] true )) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(pred ({a = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (pred 1) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.a) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = (let u = 0 in u) }.a) )) }.a))
(((\x: Nat .\y: Unit .x) (let u = (unfold [ Nat ] (fold [ Nat ] (((\x: Rec X. X .\y: Nat .x) (let u = 1 in u) ) true) )) in u) ) (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .x) true ) true) )))
(((\x: Rec X. X .\y: Unit .x) (fix (\x: Nat . (iszero (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) )) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = ({a = 0 , b = true , c = 0 }.c) , b = (succ (fix (\x: Unit . 1 ))) }.b) , b = (let u = false in (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b))) }.b) )))
(let u = (let u = (( \f: Rec X. X .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) in u) in u)
(( \f: Nat .((f (unfold [ Nat ] (fold [ Bool ] ({a = (fix (\x: Nat . (((\x: Bool .\y: Bool .y) false ) false) )) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = true , b = true }.b) )) }.b) )) ) (( \f: Unit .((f ({a = ({a = false , b = (pred 0) }.b) , b = (if (let u = true in false) then (iszero 0) else (let u = false in true)) , c =  ({a = 1 , b = true }.a) }.b) ) (iszero (let u = 0 in 0)) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Bool .\b: Unit .a))
(( \f: Nat .((f (fix (\x: Rec X. X . (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (let u = true in 1) )) in (case <r = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] false )) > as Rec X. X of < l = x > => x | < r = y > => y)) )) ) (unfold [ Bool ] (fold [ Unit ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true )) , b = true }.b) )) ) ) (\a: Rec X. X .\b: Bool .a))
(case <l = (if ({a = 1 , b = false , c =  0 }.b) then ({a = (let u = false in 0) , b = ({a = (if true then true else false) , b = (let u = 0 in false) }.b) , c = (let u = 1 in 0) }.c) else (fix (\x: Rec X. X . 0 ))) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (( \f: Bool .((f (fix (\x: Nat . (let u = 0 in u) )) ) (((\x: Rec X. X .\y: Bool .x) (let u = 1 in 1) ) true) ) ) (\a: Rec X. X .\b: Unit .a)) in ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) }.b)) in u)
(( \f: Unit .((f (if ({a = (let u = (let u = true in u) in u) , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.a) then (if (((\x: Nat .\y: Nat .x) false ) false) then (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) else (((\x: Bool .\y: Rec X. X .y) false ) true)) else ({a = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , b = (((\x: Nat .\y: Rec X. X .y) false ) true) }.b)) ) (((\x: Bool .\y: Unit .x) ({a = (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) true ) true) )) , b = (fix (\x: Nat . (iszero 1) )) }.b) ) (( \f: Nat .((f (( \f: Unit .((f (iszero 0) ) (let u = true in true) ) ) (\a: Unit .\b: Unit .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = false }.b) )) ) ) (\a: Unit .\b: Bool .a))) ) ) (\a: Bool .\b: Bool .b))
(unfold [ Nat ] (fold [ Nat ] (( \f: Unit .((f (unfold [ Unit ] (fold [ Rec X. X ] ({a = 1 , b = (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.b) )) ) ({a = (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Rec X. X .y) true ) false) , c = (let u = 0 in u) }.c) ) ) (\a: Nat .\b: Nat .b)) ))
(((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Rec X. X .y) (let u = 0 in (((\x: Unit .\y: Nat .x) false ) false)) ) (unfold [ Nat ] (fold [ Bool ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) ))) ) ({a = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = ({a = 1 , b = true , c =  1 }.b) }.a) , b = (iszero 0) }.b)) ) (iszero ({a = (let u = 1 in 0) , b = (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) in u) }.b)))
(iszero (let u = ({a = ({a = ({a = 0 , b = true }.a) , b = (iszero 1) , c = (fix (\x: Bool . 0 )) }.c) , b = (case <l = ({a = true , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) }.b) in (let u = (((\x: Unit .\y: Unit .y) true ) ({a = 0 , b = false }.a)) in u)))
(unfold [ Nat ] (fold [ Nat ] (let u = (unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) )) in (case <l = ({a = (let u = true in true) , b = (((\x: Bool .\y: Bool .y) true ) 1) }.b) > as Nat of < l = x > => x | < r = y > => y)) ))
(fix (\x: Nat . (((\x: Bool .\y: Unit .y) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) in (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a))) ) (if ({a = 1 , b = true }.b) then (fix (\x: Nat . (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .b)) )) else (fix (\x: Rec X. X . true )))) ))
(( \f: Unit .((f (let u = (unfold [ Bool ] (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] true )) )) in (((\x: Unit .\y: Rec X. X .y) (let u = 1 in false) ) (((\x: Bool .\y: Nat .x) 1 ) true))) ) (succ (let u = (succ ({a = 1 , b = false }.a)) in u)) ) ) (\a: Rec X. X .\b: Nat .b))
({a = ({a = (((\x: Nat .\y: Nat .x) (iszero (let u = 1 in u)) ) (if ({a = 1 , b = true , c =  0 }.b) then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)))) , b = (if (case <r = (((\x: Unit .\y: Unit .x) true ) true) > as Nat of < l = x > => x | < r = y > => y) then (let u = 0 in 1) else (if false then ({a = 0 , b = 0 }.b) else (fix (\x: Rec X. X . 0 )))) }.b) , b = ({a = (( \f: Unit .((f ({a = 1 , b = false }.a) ) (( \f: Unit .((f (let u = 1 in u) ) (succ 0) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Bool .\b: Unit .b)) , b = (case <r = (let u = true in u) > as Nat of < l = x > => x | < r = y > => y) }.b) }.a)
(succ ({a = (let u = ({a = (succ 0) , b = ({a = false , b = true }.b) , c =  (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) }.b) in (let u = 0 in 1)) , b = (unfold [ Unit ] (fold [ Bool ] (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in false) )) }.a))
(unfold [ Bool ] (fold [ Nat ] (let u = ({a = ({a = 0 , b = 1 }.b) , b = (let u = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) in u) }.b) in ({a = (fix (\x: Nat . 1 )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , c =  1 }.b)) ))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = (((\x: Bool .\y: Unit .y) true ) true) , b = 1 }.b) , b = (case <r = (((\x: Nat .\y: Nat .y) false ) ({a = 1 , b = false }.b)) > as Unit of < l = x > => x | < r = y > => y) }.b) ))
(let u = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Nat . 1 )) ) (fix (\x: Unit . ({a = false , b = true }.b) ))) in ({a = (((\x: Rec X. X .\y: Nat .y) true ) (let u = 0 in true)) , b = (( \f: Rec X. X .((f (case <l = (let u = true in 1) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (fix (\x: Nat . 0 )) , b = true }.a) ) ) (\a: Unit .\b: Rec X. X .b)) }.a))
(( \f: Unit .((f ({a = (((\x: Nat .\y: Nat .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a)) ) (if true then 0 else 0)) , b = ({a = (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = false , c = 1 }.c) )) , b = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = 1 , b = true }.b) , c =  (let u = 1 in 1) }.b) , c =  (( \f: Rec X. X .((f ({a = (pred 0) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) , c = 1 }.c) ) (((\x: Nat .\y: Nat .x) 0 ) true) ) ) (\a: Unit .\b: Unit .b)) }.b) , c =  (( \f: Rec X. X .((f (( \f: Bool .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Bool .a)) }.b) ) (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Unit .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Bool .b)) ) true ) ) (\a: Unit .\b: Rec X. X .b)) )) ) ) (\a: Bool .\b: Unit .a))
(let u = (let u = ({a = (let u = (iszero 0) in u) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.a) in u) in u)
(fix (\x: Unit . (unfold [ Bool ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f (let u = false in u) ) false ) ) (\a: Bool .\b: Nat .b)) , b = (case <l = ({a = 1 , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) }.b) )) ))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = (let u = ({a = 1 , b = true , c = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) }.c) in (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Bool .y) ({a = false , b = true }.b) ) false) ) (((\x: Bool .\y: Nat .x) true ) (((\x: Unit .\y: Rec X. X .y) true ) false)))) , b = ({a = (iszero 0) , b = (if (unfold [ Rec X. X ] (fold [ Bool ] false )) then 0 else 0) }.b) }.a) ))
(( \f: Unit .((f (case <l = (fix (\x: Bool . (pred (let u = 0 in u)) )) > as Nat of < l = x > => x | < r = y > => y) ) (succ (let u = (fix (\x: Nat . true )) in (fix (\x: Rec X. X . 0 )))) ) ) (\a: Unit .\b: Unit .a))
(((\x: Bool .\y: Unit .y) (if ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (fix (\x: Nat . true )) )) then ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) , b = (((\x: Unit .\y: Bool .x) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) ) (((\x: Rec X. X .\y: Bool .x) false ) false)) }.b) else (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) false ) true) ))) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = true , b = 1 }.a) )))
(pred ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .x) (let u = (((\x: Unit .\y: Nat .x) false ) false) in ({a = true , b = 0 }.b)) ) (((\x: Nat .\y: Unit .y) true ) ({a = 1 , b = false , c =  0 }.b))) )))
({a = (let u = (((\x: Rec X. X .\y: Nat .y) (case <r = (iszero 0) > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) in (((\x: Bool .\y: Unit .x) ({a = 0 , b = true , c = 0 }.c) ) (((\x: Rec X. X .\y: Unit .x) (fix (\x: Nat . true )) ) (((\x: Bool .\y: Nat .x) false ) true)))) , b = (unfold [ Nat ] (fold [ Bool ] (let u = (fix (\x: Rec X. X . 1 )) in true) )) , c = (( \f: Nat .((f (pred (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ) (succ (let u = (fix (\x: Rec X. X . 0 )) in u)) ) ) (\a: Rec X. X .\b: Bool .a)) }.c)
(unfold [ Rec X. X ] (fold [ Unit ] ({a = (unfold [ Nat ] (fold [ Bool ] (fix (\x: Unit . 0 )) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.a) ))
(let u = (( \f: Nat .((f (((\x: Unit .\y: Bool .x) ({a = 0 , b = false , c =  1 }.b) ) (iszero 1)) ) (fix (\x: Rec X. X . (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ({a = (let u = (pred 1) in u) , b = ({a = (iszero 0) , b = ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = 1 }.a) }.b) }.b))
(pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (if (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .b)) then (((\x: Nat .\y: Unit .y) true ) 1) else (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b))) )))
(let u = ({a = (let u = (((\x: Nat .\y: Bool .x) false ) false) in ({a = false , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) , b = (( \f: Bool .((f 1 ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Nat .b)) }.a) in (((\x: Bool .\y: Rec X. X .x) (( \f: Rec X. X .((f ({a = (((\x: Nat .\y: Unit .y) true ) false) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) )) }.b) ) (fix (\x: Rec X. X . ({a = 0 , b = false , c = 1 }.c) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (fix (\x: Nat . false )) ) ) (\a: Nat .\b: Bool .a)) ) (unfold [ Nat ] (fold [ Rec X. X ] true )))))
(((\x: Unit .\y: Bool .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (if false then (let u = true in u) else (case <r = false > as Nat of < l = x > => x | < r = y > => y)) )) ) (case <r = (let u = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (fix (\x: Unit . ({a = true , b = 0 }.a) ))) > as Nat of < l = x > => x | < r = y > => y))
(case <l = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = ({a = (((\x: Rec X. X .\y: Unit .y) false ) 0) , b = true }.a) , b = (fix (\x: Bool . true )) }.a) )) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = ({a = (((\x: Rec X. X .\y: Nat .y) false ) 1) , b = (iszero 1) , c =  (if true then 0 else 1) }.b) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (iszero (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b))) }.b)
(((\x: Rec X. X .\y: Nat .y) (unfold [ Bool ] (fold [ Unit ] ({a = false , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) )) ) (let u = (if (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) then (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .b)) else (((\x: Bool .\y: Unit .y) true ) true)) in u))
(((\x: Bool .\y: Unit .y) (((\x: Bool .\y: Bool .y) ({a = 1 , b = ({a = true , b = false }.b) , c =  1 }.b) ) (fix (\x: Unit . (let u = true in false) ))) ) (((\x: Bool .\y: Bool .y) (let u = (let u = false in 1) in (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .b))) ) (let u = (((\x: Unit .\y: Rec X. X .y) true ) 0) in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)))))
(((\x: Rec X. X .\y: Bool .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Unit .\y: Unit .y) (let u = true in u) ) (( \f: Rec X. X .((f (fix (\x: Bool . true )) ) false ) ) (\a: Rec X. X .\b: Nat .b))) )) ) (( \f: Unit .((f ({a = ({a = 1 , b = true , c =  1 }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] false )) }.b) ) (((\x: Unit .\y: Rec X. X .x) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.b)) ) ) (\a: Bool .\b: Rec X. X .b)))
(fix (\x: Bool . (((\x: Unit .\y: Unit .y) (iszero ({a = 1 , b = 0 }.b)) ) (fix (\x: Unit . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) )) ))) ))
({a = (let u = (let u = (succ 0) in (((\x: Nat .\y: Rec X. X .y) (iszero 0) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)))) in u) , b = (iszero (if (((\x: Unit .\y: Bool .y) false ) (fix (\x: Rec X. X . true ))) then (let u = (succ 0) in u) else (fix (\x: Nat . (pred 0) )))) }.a)
({a = (fix (\x: Rec X. X . ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) , b = ({a = ({a = true , b = 1 }.b) , b = (((\x: Nat .\y: Bool .y) true ) true) }.b) }.a) )) , b = (unfold [ Rec X. X ] (fold [ Bool ] (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) in u) )) }.b)
({a = (let u = (if (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) then 0 else ({a = 1 , b = 0 }.b)) in ({a = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Rec X. X ] (if false then 0 else 0) )) }.a)) , b = (succ (fix (\x: Bool . 0 ))) }.b)
({a = (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) , b = (let u = false in u) }.a) )) in u) , b = ({a = (fix (\x: Nat . 1 )) , b = (pred (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a))) }.b) }.b)
(let u = (fix (\x: Nat . (case <l = (fix (\x: Unit . 0 )) > as Bool of < l = x > => x | < r = y > => y) )) in u)
(let u = (let u = (( \f: Rec X. X .((f ({a = 1 , b = false , c =  0 }.b) ) (((\x: Unit .\y: Bool .x) false ) true) ) ) (\a: Unit .\b: Bool .b)) in ({a = (case <l = (if false then 0 else 0) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.a)) in ({a = (let u = ({a = 0 , b = false , c = (let u = true in 0) }.c) in u) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (((\x: Nat .\y: Nat .x) (((\x: Nat .\y: Rec X. X .y) false ) (((\x: Bool .\y: Unit .y) false ) false)) ) (case <r = (((\x: Rec X. X .\y: Unit .y) true ) true) > as Nat of < l = x > => x | < r = y > => y)) )) }.b))
(( \f: Nat .((f (if (fix (\x: Unit . (((\x: Bool .\y: Unit .y) false ) false) )) then ({a = (let u = false in false) , b = (((\x: Unit .\y: Unit .y) true ) false) }.b) else (( \f: Rec X. X .((f (let u = ({a = 0 , b = false }.b) in u) ) (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] true )) ) false ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b))) ) (let u = ({a = (((\x: Rec X. X .\y: Nat .y) true ) 0) , b = (unfold [ Bool ] (fold [ Rec X. X ] true )) }.a) in (unfold [ Rec X. X ] (fold [ Unit ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) ))) ) ) (\a: Unit .\b: Unit .a))
(case <r = (( \f: Bool .((f (if (unfold [ Bool ] (fold [ Unit ] (let u = false in u) )) then ({a = 0 , b = true , c =  1 }.b) else (let u = false in u)) ) (( \f: Nat .((f ({a = 0 , b = false }.b) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Bool .x) (succ (( \f: Unit .((f (pred (if false then 0 else 1)) ) ({a = (((\x: Nat .\y: Bool .x) 0 ) true) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) , c = ({a = 0 , b = true , c = 0 }.c) }.c) ) ) (\a: Rec X. X .\b: Bool .b))) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .x) ({a = 0 , b = true , c =  0 }.b) ) true) )))
({a = (((\x: Nat .\y: Nat .y) (if ({a = ({a = false , b = true }.b) , b = (let u = true in false) }.b) then ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) else ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (iszero 1) ))) ) ({a = (succ 0) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.a)) , b = (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) }.b)
(case <r = (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Nat .b))) ) (fix (\x: Rec X. X . ({a = 1 , b = false }.b) ))) > as Unit of < l = x > => x | < r = y > => y)
(let u = (case <r = (let u = ({a = (unfold [ Bool ] (fold [ Unit ] false )) , b = (fix (\x: Rec X. X . true )) }.b) in (let u = 1 in true)) > as Unit of < l = x > => x | < r = y > => y) in u)
(unfold [ Rec X. X ] (fold [ Bool ] (let u = ({a = (((\x: Rec X. X .\y: Unit .y) false ) false) , b = (( \f: Rec X. X .((f (if false then 1 else 1) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) in (((\x: Unit .\y: Bool .y) (iszero 0) ) (let u = 1 in true))) ))
(case <r = ({a = (((\x: Bool .\y: Rec X. X .x) (if true then 0 else 1) ) ({a = false , b = false }.b)) , b = (let u = (((\x: Unit .\y: Rec X. X .y) true ) 0) in (let u = 0 in false)) , c =  (let u = false in 0) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = ({a = (pred ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) }.b)) , b = (iszero ({a = (let u = false in ({a = 1 , b = false , c =  0 }.b)) , b = (unfold [ Unit ] (fold [ Rec X. X ] ({a = false , b = 0 }.b) )) }.b)) , c =  (((\x: Bool .\y: Unit .y) ({a = false , b = false }.b) ) (((\x: Bool .\y: Nat .y) false ) 0)) }.b) , b = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = 0 in (let u = true in 0)) )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] true )) , c =  (case <l = ({a = ({a = 0 , b = true , c = 1 }.c) , b = false , c = 1 }.c) > as Unit of < l = x > => x | < r = y > => y) }.b) }.b)
(unfold [ Bool ] (fold [ Nat ] (case <l = (( \f: Nat .((f (( \f: Bool .((f (((\x: Bool .\y: Bool .x) 0 ) false) ) ({a = 0 , b = false }.a) ) ) (\a: Unit .\b: Bool .a)) ) ({a = (let u = true in u) , b = (let u = 0 in u) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) > as Bool of < l = x > => x | < r = y > => y) ))
(case <r = ({a = (( \f: Unit .((f ({a = (let u = 1 in false) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.b) ) (fix (\x: Bool . 0 )) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) ({a = true , b = 1 }.a) ) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a))) ) (let u = (fix (\x: Unit . true )) in false) ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (if (((\x: Unit .\y: Nat .x) (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) in true) ) ({a = 1 , b = false , c =  1 }.b)) then (case <l = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) else (let u = 0 in 0)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (if (case <r = (case <r = false > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Rec X. X .((f (let u = 1 in false) ) (((\x: Unit .\y: Bool .x) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) false) ) ) (\a: Rec X. X .\b: Bool .a)) else (let u = false in u)) ) (let u = (let u = (if true then 0 else 1) in ({a = false , b = 1 }.b)) in ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] true )) ))) ) ) (\a: Rec X. X .\b: Bool .a))
({a = (let u = ({a = (fix (\x: Unit . ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) )) , b = (( \f: Bool .((f (((\x: Nat .\y: Unit .x) 1 ) true) ) ({a = true , b = 0 }.b) ) ) (\a: Nat .\b: Unit .a)) }.a) in u) , b = (let u = (iszero 1) in (iszero 0)) }.b)
({a = (( \f: Bool .((f (let u = ({a = (succ 0) , b = ({a = (let u = 0 in u) , b = true , c =  0 }.b) }.b) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = 0 in true) ))) ) ({a = ({a = ({a = 1 , b = true }.b) , b = (fix (\x: Nat . 0 )) }.a) , b = (case <l = ({a = true , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if ({a = false , b = 0 }.a) then (iszero (((\x: Unit .\y: Nat .x) ({a = 1 , b = false , c = 0 }.c) ) true)) else (let u = ({a = 0 , b = false }.b) in true)) }.b)
(case <r = ({a = (iszero (((\x: Rec X. X .\y: Rec X. X .y) false ) 0)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) )) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (unfold [ Unit ] (fold [ Unit ] (let u = false in false) )) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Unit .\y: Unit .x) (pred 0) ) (let u = false in u)) )) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = ({a = 1 , b = false , c =  0 }.b) , b = (((\x: Unit .\y: Rec X. X .x) 0 ) false) }.b) )) ) ) (\a: Nat .\b: Nat .a)) }.a)
(if (( \f: Unit .((f (let u = (unfold [ Bool ] (fold [ Unit ] (let u = true in true) )) in u) ) ({a = (( \f: Unit .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Unit .\y: Nat .x) 1 ) false) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (fix (\x: Bool . true )) , c =  (pred (let u = 1 in 1)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) then (fix (\x: Nat . (let u = ({a = (iszero 1) , b = (((\x: Unit .\y: Bool .x) 0 ) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b))) }.b) in (( \f: Unit .((f (if true then 1 else 1) ) (pred 0) ) ) (\a: Rec X. X .\b: Rec X. X .a))) )) else ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (case <l = (pred (let u = 1 in (let u = true in 0))) > as Bool of < l = x > => x | < r = y > => y) )))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Nat .((f (( \f: Unit .((f (let u = 0 in false) ) ({a = true , b = ({a = 1 , b = true }.a) }.a) ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Nat .\y: Unit .y) true ) false) ) ) (\a: Bool .\b: Bool .a)) ))
(fix (\x: Nat . (unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = 0 , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) in u) )) ))
(let u = ({a = (iszero (if false then 0 else 1)) , b = (case <r = ({a = false , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in u)
({a = (( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = false , c =  1 }.b) )) ) (((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Nat .y) true ) true) ) ({a = 1 , b = true }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (((\x: Bool .\y: Nat .x) (let u = ({a = 1 , b = true , c = 1 }.c) in ({a = true , b = 1 }.b)) ) (if (let u = true in u) then false else false)) }.b)
({a = (unfold [ Bool ] (fold [ Unit ] (fix (\x: Bool . (succ 0) )) )) , b = (let u = (fix (\x: Rec X. X . (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .a)) )) in ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . false )) ))) , c = (((\x: Rec X. X .\y: Nat .x) (let u = (case <l = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y) in u) ) ({a = (case <l = ({a = 1 , b = false }.a) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = false , c =  0 }.b) }.b)) }.c)
(( \f: Bool .((f (((\x: Bool .\y: Nat .y) (iszero ({a = (fix (\x: Bool . 0 )) , b = ({a = 0 , b = false , c = 0 }.c) }.b)) ) (((\x: Rec X. X .\y: Nat .y) (if false then false else false) ) ({a = 1 , b = false , c =  1 }.b))) ) (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Bool ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = false , c =  0 }.b) )) )) )) ) ) (\a: Nat .\b: Unit .b))
(fix (\x: Unit . (((\x: Bool .\y: Unit .y) ({a = (if true then 0 else 0) , b = true }.b) ) ({a = false , b = (fix (\x: Rec X. X . 1 )) }.b)) ))
({a = (case <r = ({a = (if true then 1 else (fix (\x: Unit . 0 ))) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f (fix (\x: Bool . false )) ) true ) ) (\a: Rec X. X .\b: Bool .b)) )) , c =  ({a = (let u = true in 1) , b = (((\x: Unit .\y: Nat .x) ({a = false , b = 0 }.a) ) false) , c = ({a = 1 , b = false , c = 1 }.c) }.c) }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (unfold [ Bool ] (fold [ Unit ] ({a = ({a = (succ 0) , b = ({a = true , b = 0 }.a) , c = 1 }.c) , b = ({a = 0 , b = ({a = false , b = 0 }.a) }.b) }.a) )) }.a)
({a = (succ (unfold [ Rec X. X ] (fold [ Rec X. X ] (pred 1) ))) , b = (let u = (((\x: Nat .\y: Unit .y) (iszero 1) ) (((\x: Bool .\y: Bool .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) in (let u = (( \f: Nat .((f (( \f: Bool .((f 1 ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .a)) ) (succ 1) ) ) (\a: Bool .\b: Bool .a)) in (unfold [ Unit ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) )))) }.b)
({a = (let u = ({a = (((\x: Nat .\y: Bool .y) false ) 0) , b = (( \f: Rec X. X .((f ({a = 1 , b = true , c = 1 }.c) ) ({a = true , b = 1 }.b) ) ) (\a: Bool .\b: Bool .b)) }.b) in ({a = (unfold [ Bool ] (fold [ Unit ] 1 )) , b = ({a = false , b = 0 }.a) }.b)) , b = (unfold [ Nat ] (fold [ Bool ] ({a = ({a = 1 , b = true }.a) , b = ({a = false , b = false }.b) , c =  1 }.b) )) }.b)
({a = (case <l = ({a = (let u = ({a = (unfold [ Bool ] (fold [ Unit ] 1 )) , b = false , c = (((\x: Unit .\y: Unit .x) 1 ) false) }.c) in (((\x: Unit .\y: Rec X. X .y) true ) 0)) , b = (((\x: Bool .\y: Bool .y) true ) 1) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) ({a = ({a = ({a = true , b = 0 }.b) , b = (fix (\x: Rec X. X . false )) }.b) , b = (let u = (let u = false in u) in u) }.b) ) (let u = (unfold [ Nat ] (fold [ Nat ] 0 )) in u)) , b = (unfold [ Unit ] (fold [ Unit ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) , c = (let u = (fix (\x: Rec X. X . 0 )) in u) }.c) }.b)
(succ ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f ({a = false , b = 1 }.b) ) ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = (fix (\x: Bool . false )) }.a) ) ) (\a: Unit .\b: Bool .b)) )))
(((\x: Nat .\y: Unit .y) (let u = (let u = ({a = 1 , b = false , c =  0 }.b) in u) in u) ) (( \f: Unit .((f ({a = (let u = 1 in u) , b = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Nat .a)) , c =  ({a = 0 , b = 0 }.b) }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Nat .b)))
({a = ({a = (((\x: Bool .\y: Rec X. X .x) (let u = (let u = 1 in u) in u) ) ({a = 0 , b = (iszero 0) }.b)) , b = ({a = ({a = 0 , b = true , c = 1 }.c) , b = (let u = 1 in false) , c = ({a = 1 , b = false , c = 0 }.c) }.c) }.b) , b = ({a = (( \f: Rec X. X .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) 0 ) ) (\a: Nat .\b: Bool .a)) , b = (((\x: Nat .\y: Nat .x) ({a = false , b = true }.b) ) (((\x: Nat .\y: Rec X. X .y) false ) false)) }.b) }.a)
(( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (let u = false in false) )) ) (pred ({a = false , b = (let u = 0 in 0) }.b))) ) (let u = (((\x: Rec X. X .\y: Rec X. X .y) ({a = (let u = 1 in (unfold [ Bool ] (fold [ Nat ] 1 ))) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b) ) (fix (\x: Nat . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ))) in (succ (let u = true in 0))) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (let u = ({a = (iszero ({a = 1 , b = false , c = 0 }.c)) , b = ({a = 0 , b = true }.a) }.b) in ({a = 1 , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.a)) , b = ({a = (((\x: Bool .\y: Rec X. X .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) )) ) (( \f: Nat .((f ({a = (succ 1) , b = false , c =  ({a = 0 , b = false , c = 0 }.c) }.b) ) ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) , b = (iszero 1) }.b) ) ) (\a: Bool .\b: Nat .b))) , b = (fix (\x: Bool . (( \f: Unit .((f (((\x: Bool .\y: Nat .y) true ) true) ) false ) ) (\a: Unit .\b: Bool .a)) )) , c =  (let u = ({a = false , b = 0 }.b) in ({a = true , b = 1 }.b)) }.b) , c =  (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = false }.a) )) }.b)
({a = (((\x: Bool .\y: Unit .y) (let u = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) in true) ) ({a = (let u = 0 in false) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) }.b)) , b = (succ (( \f: Bool .((f (let u = 1 in 1) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) ) (\a: Bool .\b: Nat .a))) }.b)
({a = (pred (unfold [ Bool ] (fold [ Bool ] (((\x: Unit .\y: Bool .y) false ) 0) ))) , b = (((\x: Unit .\y: Nat .x) ({a = true , b = true }.b) ) (iszero 0)) }.b)
(((\x: Rec X. X .\y: Unit .y) ({a = (let u = (pred 0) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) , b = (((\x: Rec X. X .\y: Nat .x) (((\x: Rec X. X .\y: Unit .y) (fix (\x: Nat . true )) ) ({a = (succ 0) , b = ({a = false , b = 0 }.a) , c = (fix (\x: Rec X. X . 0 )) }.c)) ) (unfold [ Nat ] (fold [ Bool ] true ))) }.a) ) (let u = (( \f: Unit .((f ({a = 0 , b = true , c = 0 }.c) ) 1 ) ) (\a: Unit .\b: Unit .b)) in (pred ({a = true , b = 0 }.b))))
(pred (if (( \f: Unit .((f (let u = false in true) ) ({a = (fix (\x: Nat . 1 )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) }.b) ) ) (\a: Rec X. X .\b: Nat .a)) then (let u = (if false then 1 else 1) in (succ 1)) else (case <l = (((\x: Unit .\y: Nat .y) (if true then false else true) ) 0) > as Bool of < l = x > => x | < r = y > => y)))
(fix (\x: Nat . ({a = (let u = (let u = 1 in 0) in u) , b = (let u = (( \f: Nat .((f ({a = 0 , b = false , c = 1 }.c) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Nat .\b: Nat .b)) in u) }.b) ))
(((\x: Rec X. X .\y: Rec X. X .x) ({a = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) , b = 0 }.b) , b = ({a = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .y) false ) false) )) , b = (let u = (let u = 1 in u) in u) }.a) }.a) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f (( \f: Unit .((f (if false then false else false) ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = false , b = true }.b) ) ) (\a: Rec X. X .\b: Nat .a)) )))
(let u = (((\x: Rec X. X .\y: Rec X. X .y) (let u = (let u = 1 in true) in (iszero 0)) ) (fix (\x: Nat . false ))) in (let u = (iszero (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) in u))
({a = (if (if (let u = (if true then true else false) in u) then (((\x: Nat .\y: Bool .x) (((\x: Bool .\y: Bool .y) true ) false) ) false) else (let u = false in false)) then (if (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .a)) then ({a = true , b = 0 }.a) else (if false then false else false)) else (((\x: Bool .\y: Bool .x) true ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .a)))) , b = (((\x: Bool .\y: Bool .y) (let u = (let u = 1 in u) in true) ) (( \f: Bool .((f false ) (fix (\x: Unit . false )) ) ) (\a: Bool .\b: Rec X. X .a))) }.b)
(case <l = ({a = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (let u = 0 in (let u = 0 in u)) }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) }.b) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (fix (\x: Unit . (((\x: Unit .\y: Unit .x) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ({a = true , b = 1 }.a)) )) in (case <l = ({a = false , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) in u)
(( \f: Rec X. X .((f ({a = (case <l = (let u = 1 in u) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = true }.b) , c = (((\x: Rec X. X .\y: Bool .x) (let u = 1 in u) ) (iszero 1)) }.c) ) ({a = (let u = (let u = true in u) in 0) , b = (if (iszero 0) then ({a = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) , b = (unfold [ Unit ] (fold [ Bool ] true )) , c =  1 }.b) else (((\x: Rec X. X .\y: Unit .x) true ) true)) , c = ({a = true , b = 0 }.b) }.c) ) ) (\a: Nat .\b: Bool .b))
({a = ({a = (succ 0) , b = (fix (\x: Unit . (( \f: Nat .((f (iszero 0) ) true ) ) (\a: Bool .\b: Bool .a)) )) }.b) , b = (case <l = (fix (\x: Rec X. X . ({a = (((\x: Unit .\y: Bool .x) 0 ) true) , b = (let u = false in true) }.a) )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b)
(fix (\x: Nat . (( \f: Nat .((f (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f false ) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ({a = 1 , b = ({a = false , b = true }.b) , c =  1 }.b)) ) (fix (\x: Unit . (if (let u = false in true) then ({a = true , b = 1 }.a) else (let u = true in true)) )) ) ) (\a: Unit .\b: Unit .a)) ))
({a = (((\x: Rec X. X .\y: Nat .x) ({a = (((\x: Bool .\y: Nat .x) 1 ) false) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) }.a) ) ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)) , b = ({a = (( \f: Unit .((f ({a = true , b = true }.b) ) (((\x: Nat .\y: Bool .y) true ) true) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (unfold [ Rec X. X ] (fold [ Bool ] (let u = true in 0) )) }.a) , c =  (( \f: Unit .((f (( \f: Unit .((f ({a = 0 , b = false , c = 1 }.c) ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Unit .((f ({a = 1 , b = true }.a) ) (pred (fix (\x: Rec X. X . 0 ))) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Nat .\b: Bool .b)) }.b)
(if (iszero (case <l = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 )) > as Unit of < l = x > => x | < r = y > => y)) then ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = ({a = false , b = (((\x: Nat .\y: Unit .x) true ) false) }.b) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.a) )) else (let u = (((\x: Bool .\y: Unit .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false ))) in ({a = (let u = false in true) , b = ({a = true , b = false }.b) }.b)))
(((\x: Nat .\y: Unit .y) (if (( \f: Rec X. X .((f false ) (fix (\x: Nat . true )) ) ) (\a: Bool .\b: Rec X. X .b)) then (unfold [ Rec X. X ] (fold [ Bool ] true )) else ({a = ({a = true , b = true }.b) , b = true }.b)) ) (let u = (((\x: Rec X. X .\y: Nat .x) (let u = ({a = 0 , b = true , c = 1 }.c) in (let u = true in false)) ) (fix (\x: Bool . true ))) in u))
(if ({a = (( \f: Nat .((f true ) (fix (\x: Nat . true )) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = ({a = true , b = 0 }.b) in u) }.a) then (let u = ({a = (if false then true else false) , b = (((\x: Bool .\y: Nat .y) false ) ({a = 0 , b = 0 }.b)) }.b) in (if false then true else (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .b)))) else ({a = (succ (((\x: Unit .\y: Rec X. X .x) 0 ) (iszero 0))) , b = (let u = (iszero ({a = 1 , b = 1 }.b)) in ({a = (let u = 1 in 0) , b = (( \f: Nat .((f (let u = true in u) ) (((\x: Bool .\y: Unit .x) false ) false) ) ) (\a: Nat .\b: Rec X. X .a)) , c =  (pred (pred 1)) }.b)) }.b))
(let u = (let u = ({a = ({a = 0 , b = 0 }.b) , b = ({a = 0 , b = true , c =  1 }.b) }.a) in (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .y) (if true then true else false) ) (let u = 0 in true)) ) (let u = (succ 1) in (if false then true else false)) ) ) (\a: Unit .\b: Unit .b))) in u)
(((\x: Rec X. X .\y: Bool .x) ({a = (let u = ({a = 1 , b = true }.b) in u) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) )) }.a) ) (case <r = (((\x: Nat .\y: Bool .y) true ) true) > as Unit of < l = x > => x | < r = y > => y))
(succ (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .y) false ) true) ) (((\x: Unit .\y: Bool .x) (let u = false in 1) ) true)) )))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f (let u = (( \f: Rec X. X .((f false ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Bool .a)) in (((\x: Unit .\y: Rec X. X .x) (let u = 0 in u) ) false)) ) (if (if true then (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .b)) else false) then ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.a) else ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = 1 }.b)) ) ) (\a: Rec X. X .\b: Nat .a)) ))
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .a)) )) in u)
(let u = ({a = (case <l = (fix (\x: Bool . 1 )) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) false ) true) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .a)) , c =  ({a = 0 , b = ({a = 1 , b = false }.b) , c = (if true then 0 else 0) }.c) }.b) in u)
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = (let u = ({a = 0 , b = 1 }.b) in (unfold [ Bool ] (fold [ Bool ] (pred 1) ))) }.a) ) (let u = ({a = 0 , b = 0 }.b) in (((\x: Rec X. X .\y: Bool .y) true ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )))))
({a = ({a = ({a = ({a = (fix (\x: Nat . false )) , b = 0 }.b) , b = (let u = (iszero 0) in u) }.a) , b = (((\x: Bool .\y: Bool .x) (( \f: Rec X. X .((f (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) true ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Nat .\y: Unit .y) ({a = false , b = 1 }.a) ) (fix (\x: Unit . true )))) , c =  (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Nat .\y: Bool .y) (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Bool .a)) ) (let u = false in 0)) ) (let u = true in false)) }.b) , b = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = 0 , b = false , c = 1 }.c) )) , b = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (iszero 0) in u) )) , b = (((\x: Unit .\y: Bool .x) ({a = false , b = 1 }.a) ) ({a = 1 , b = true , c =  1 }.b)) }.b) }.b) }.b)
({a = (if ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) then (let u = (let u = (fix (\x: Rec X. X . true )) in 1) in (if true then 0 else 0)) else ({a = (let u = 0 in u) , b = ({a = 1 , b = ({a = 1 , b = true , c = 1 }.c) }.b) }.b)) , b = (case <r = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Unit .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) true ) ) (\a: Rec X. X .\b: Bool .b)) )) > as Unit of < l = x > => x | < r = y > => y) }.a)
(let u = (case <r = (( \f: Unit .((f (unfold [ Bool ] (fold [ Bool ] true )) ) ({a = (let u = 0 in 0) , b = false , c =  (succ 1) }.b) ) ) (\a: Nat .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) in u)
(let u = (let u = (( \f: Nat .((f (case <l = (let u = false in 1) > as Nat of < l = x > => x | < r = y > => y) ) (succ ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) ) ) (\a: Bool .\b: Bool .b)) in (if (let u = true in false) then (let u = 0 in u) else (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) in ({a = (((\x: Unit .\y: Bool .x) (pred (((\x: Nat .\y: Nat .y) true ) 0)) ) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = false }.b)) , b = (let u = ({a = true , b = 0 }.b) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = 0 in 0) ))) }.b))
((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (case <r = (let u = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b)) in false) in u) > as Unit of < l = x > => x | < r = y > => y) ))
(((\x: Unit .\y: Unit .y) (let u = (let u = (( \f: Bool .((f ({a = 0 , b = false , c =  1 }.b) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Bool .b)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) ))) in (let u = (((\x: Rec X. X .\y: Bool .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) true) in (((\x: Bool .\y: Bool .x) false ) false))) ) ({a = (succ 0) , b = (iszero ({a = false , b = 1 }.b)) }.a))
({a = (let u = (let u = ({a = false , b = 0 }.b) in u) in u) , b = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Rec X. X ] 0 )) )) , b = (( \f: Rec X. X .((f false ) (if true then true else false) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) , c =  (let u = (( \f: Bool .((f ({a = (fix (\x: Unit . true )) , b = true }.b) ) (((\x: Unit .\y: Rec X. X .y) true ) (unfold [ Rec X. X ] (fold [ Nat ] false ))) ) ) (\a: Bool .\b: Rec X. X .b)) in (( \f: Nat .((f (pred (((\x: Bool .\y: Unit .y) true ) 0)) ) (((\x: Unit .\y: Rec X. X .y) true ) 1) ) ) (\a: Bool .\b: Nat .b))) }.b)
({a = (( \f: Rec X. X .((f (let u = ({a = 0 , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .b)) }.a) in (succ 1)) ) ({a = (((\x: Nat .\y: Nat .x) false ) (((\x: Rec X. X .\y: Rec X. X .y) false ) true)) , b = (( \f: Nat .((f (let u = false in 0) ) ({a = false , b = 1 }.b) ) ) (\a: Nat .\b: Unit .b)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Unit ] (((\x: Nat .\y: Bool .x) (if false then 1 else (fix (\x: Bool . 0 ))) ) (((\x: Bool .\y: Bool .x) (let u = 0 in false) ) (unfold [ Rec X. X ] (fold [ Nat ] true )))) )) }.b)
({a = (fix (\x: Rec X. X . ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.a) )) , b = (if ({a = false , b = false }.b) then (unfold [ Bool ] (fold [ Bool ] 1 )) else ({a = ({a = false , b = 1 }.b) , b = (iszero 0) , c = ({a = ({a = 0 , b = true }.b) , b = 1 }.b) }.c)) }.b)
({a = (pred (case <l = (((\x: Rec X. X .\y: Bool .x) 0 ) false) > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (case <l = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (succ 0) , b = ({a = 1 , b = false }.b) }.b) , c = (if ({a = false , b = 0 }.a) then 1 else 1) }.c) }.b)
({a = (let u = ({a = (((\x: Bool .\y: Nat .y) false ) true) , b = ({a = ({a = 0 , b = 1 }.b) , b = true }.a) }.b) in (fix (\x: Bool . ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (pred 0) )) ))) , b = (succ (pred ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )))) }.b)
({a = (let u = (( \f: Bool .((f (( \f: Rec X. X .((f false ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = ({a = 0 , b = false , c = 1 }.c) , b = true , c =  (fix (\x: Rec X. X . 1 )) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) in (( \f: Bool .((f ({a = (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) then ({a = false , b = 0 }.b) else 1) , b = (let u = 1 in false) }.a) ) (((\x: Rec X. X .\y: Nat .x) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (iszero 1)) ) ) (\a: Rec X. X .\b: Unit .b))) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) )) ) (fix (\x: Bool . ({a = false , b = true }.b) )) ) ) (\a: Nat .\b: Rec X. X .a)) , c = ({a = (((\x: Unit .\y: Nat .y) (let u = true in false) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 ))) , b = (iszero (pred (let u = 0 in u))) , c = (unfold [ Rec X. X ] (fold [ Unit ] (if false then 1 else 1) )) }.c) }.c)
(let u = (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) ({a = (fix (\x: Rec X. X . true )) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) }.a) ) (pred ({a = 1 , b = 1 }.b))) )) in (( \f: Bool .((f ({a = (case <l = (((\x: Nat .\y: Unit .y) false ) 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ({a = (let u = false in u) , b = (((\x: Bool .\y: Nat .x) false ) true) }.b) , b = ({a = false , b = 1 }.a) }.b) }.b) ) (case <r = ({a = 0 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)))
({a = (( \f: Unit .((f ({a = (((\x: Unit .\y: Rec X. X .y) (iszero 1) ) (fix (\x: Rec X. X . 0 ))) , b = (if (fix (\x: Bool . true )) then ({a = 0 , b = 0 }.b) else (((\x: Rec X. X .\y: Bool .y) true ) 0)) }.b) ) (case <l = (let u = 0 in 0) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (case <l = (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in (let u = 0 in u)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(succ ({a = (pred (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Unit ] 1 )) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Unit .\b: Rec X. X .a))) , b = (let u = (let u = (unfold [ Unit ] (fold [ Bool ] true )) in 1) in (iszero ({a = 1 , b = 0 }.b))) }.a))
(let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Bool . true )) )) then (((\x: Bool .\y: Bool .y) true ) true) else ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) )) in u)
(let u = (if ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero 0) )) then (fix (\x: Unit . (fix (\x: Rec X. X . true )) )) else (case <r = false > as Bool of < l = x > => x | < r = y > => y)) in (unfold [ Unit ] (fold [ Rec X. X ] ({a = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = (fix (\x: Bool . 0 )) , b = (let u = 0 in 0) }.b) }.a) )))
({a = (case <l = (let u = ({a = (((\x: Bool .\y: Nat .x) 0 ) true) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , c = ({a = 0 , b = 1 }.b) }.c) in u) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (succ (((\x: Rec X. X .\y: Nat .x) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b))))) , b = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in u) ) ) (\a: Nat .\b: Rec X. X .b)) , c =  (succ ({a = 1 , b = (let u = false in 0) }.b)) }.b) }.a)
({a = ({a = (((\x: Bool .\y: Bool .y) (iszero 0) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a))) , b = (let u = 1 in u) }.b) , b = ({a = ({a = (let u = (if true then 0 else 0) in u) , b = (let u = true in u) , c = ({a = 0 , b = false }.a) }.c) , b = (((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Bool .x) (let u = true in u) ) (iszero ({a = 1 , b = false , c = 1 }.c))) ) ({a = ({a = false , b = 0 }.b) , b = false , c =  0 }.b)) , c =  (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) (fix (\x: Nat . (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) )) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) }.a)
(case <r = (((\x: Rec X. X .\y: Nat .y) (( \f: Rec X. X .((f (fix (\x: Nat . true )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) ) (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) in (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))))) > as Unit of < l = x > => x | < r = y > => y)
({a = (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .y) (let u = false in u) ) ({a = 0 , b = false }.a)) )) , b = ({a = ({a = (if false then (unfold [ Bool ] (fold [ Nat ] false )) else ({a = 0 , b = false }.b)) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) }.b) , b = (( \f: Unit .((f (((\x: Unit .\y: Unit .y) false ) 1) ) (let u = (((\x: Unit .\y: Bool .y) false ) true) in 0) ) ) (\a: Unit .\b: Unit .a)) }.a) }.b)
(fix (\x: Rec X. X . (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) }.b) ) (iszero (fix (\x: Unit . 0 )))) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] (succ (( \f: Unit .((f (let u = 1 in u) ) (unfold [ Unit ] (fold [ Bool ] 1 )) ) ) (\a: Bool .\b: Unit .a))) ))
({a = ({a = (if (let u = false in u) then (((\x: Unit .\y: Rec X. X .y) true ) false) else (if (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .a)) then (((\x: Bool .\y: Bool .x) true ) false) else (let u = true in u))) , b = (fix (\x: Unit . (let u = 1 in u) )) }.b) , b = (case <r = (case <r = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , c = ({a = (( \f: Rec X. X .((f (let u = 1 in u) ) 0 ) ) (\a: Unit .\b: Nat .a)) , b = (fix (\x: Unit . ({a = false , b = false }.b) )) }.a) }.c)
(fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in (pred 1)) )) ))
(((\x: Bool .\y: Bool .x) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = ({a = ({a = 1 , b = 1 }.b) , b = (succ 1) }.b) in (((\x: Rec X. X .\y: Nat .y) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) true)) )) ) (( \f: Rec X. X .((f ({a = 1 , b = ({a = 0 , b = false , c =  0 }.b) , c =  ({a = 1 , b = false }.a) }.b) ) (let u = (let u = 0 in true) in (if true then false else true)) ) ) (\a: Unit .\b: Nat .b)))
(unfold [ Unit ] (fold [ Nat ] (let u = (let u = (fix (\x: Rec X. X . (if true then true else true) )) in (((\x: Nat .\y: Rec X. X .x) (( \f: Bool .((f 0 ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true))) in (( \f: Bool .((f (if ({a = 0 , b = false , c =  1 }.b) then (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) ) (pred 0) ) ) (\a: Nat .\b: Rec X. X .b))) ))
(fix (\x: Bool . (unfold [ Bool ] (fold [ Nat ] ({a = (let u = true in true) , b = (let u = 0 in 0) }.a) )) ))
(((\x: Bool .\y: Unit .x) (if (unfold [ Nat ] (fold [ Nat ] (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) )) then (((\x: Bool .\y: Nat .x) (succ 0) ) (iszero 1)) else ({a = ({a = 1 , b = (let u = false in u) }.a) , b = (fix (\x: Nat . ({a = 1 , b = true }.b) )) }.a)) ) (fix (\x: Nat . ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) )) )))
(case <l = (((\x: Rec X. X .\y: Bool .x) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) (fix (\x: Unit . (fix (\x: Nat . false )) ))) > as Bool of < l = x > => x | < r = y > => y)
(case <r = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero 1) )) > as Unit of < l = x > => x | < r = y > => y)
({a = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) , b = ({a = (case <l = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) > as Unit of < l = x > => x | < r = y > => y) , b = (pred (let u = true in 1)) }.b) }.a)
(let u = (case <r = (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .y) false ) false) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) )) > as Bool of < l = x > => x | < r = y > => y) in u)
(((\x: Rec X. X .\y: Nat .y) (fix (\x: Nat . (((\x: Unit .\y: Bool .y) ({a = ({a = true , b = 1 }.a) , b = (( \f: Bool .((f true ) (iszero 0) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) ({a = false , b = 1 }.a)) )) ) (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Rec X. X . ({a = true , b = true }.b) )) ) (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in (let u = true in false))))
(let u = ({a = ({a = (if true then false else false) , b = (fix (\x: Nat . false )) }.b) , b = (let u = (if true then 0 else 1) in (let u = 1 in u)) }.b) in (fix (\x: Unit . (((\x: Rec X. X .\y: Bool .x) (let u = 0 in u) ) ({a = true , b = true }.b)) )))
(if ({a = (let u = (let u = 1 in false) in u) , b = (let u = ({a = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = ({a = true , b = true }.b) }.b) , b = (let u = 0 in u) }.a) in ({a = ({a = 1 , b = false }.b) , b = true }.b)) }.b) then (((\x: Bool .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Nat ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) ) (((\x: Rec X. X .\y: Nat .y) ({a = true , b = true }.b) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)))) else (unfold [ Unit ] (fold [ Unit ] (succ 1) )))
(( \f: Nat .((f (let u = (case <l = ({a = 0 , b = true , c = 0 }.c) > as Nat of < l = x > => x | < r = y > => y) in u) ) ({a = (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (let u = true in false)) , b = (( \f: Nat .((f (let u = (unfold [ Nat ] (fold [ Unit ] 1 )) in 0) ) ({a = 0 , b = true , c = 0 }.c) ) ) (\a: Unit .\b: Unit .b)) }.b) ) ) (\a: Nat .\b: Bool .b))
({a = ({a = ({a = (if (fix (\x: Nat . false )) then (pred 1) else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = ({a = (succ 1) , b = ({a = (let u = false in false) , b = 0 }.a) , c = (pred 0) }.c) }.b) , b = (( \f: Rec X. X .((f ({a = 0 , b = true , c =  0 }.b) ) (((\x: Bool .\y: Unit .y) true ) false) ) ) (\a: Bool .\b: Rec X. X .a)) , c = (((\x: Rec X. X .\y: Bool .y) (if false then true else false) ) (((\x: Rec X. X .\y: Nat .x) (pred 1) ) false)) }.c) , b = (( \f: Unit .((f ({a = ({a = (((\x: Rec X. X .\y: Unit .x) true ) false) , b = 0 }.b) , b = ({a = ({a = 0 , b = true }.b) , b = (((\x: Nat .\y: Rec X. X .x) true ) false) }.b) }.b) ) (case <r = (( \f: Unit .((f true ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) , c = (unfold [ Bool ] (fold [ Nat ] (( \f: Rec X. X .((f ({a = (if true then true else true) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) ) ({a = ({a = (let u = true in true) , b = (fix (\x: Nat . 0 )) }.a) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) )) }.c)
(if (let u = (case <r = (let u = 1 in true) > as Nat of < l = x > => x | < r = y > => y) in u) then ({a = (let u = ({a = false , b = 1 }.a) in false) , b = (( \f: Rec X. X .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) ) (\a: Bool .\b: Bool .a)) }.b) else ({a = ({a = (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = 0 , b = 1 }.b) }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Nat ] true )) )) , c =  ({a = 1 , b = true }.a) }.b))
({a = (pred (((\x: Rec X. X .\y: Nat .x) (succ 1) ) ({a = false , b = 0 }.a))) , b = (if (let u = (case <r = ({a = true , b = 1 }.a) > as Nat of < l = x > => x | < r = y > => y) in ({a = (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) in u) , b = (let u = 1 in u) }.a)) then (fix (\x: Bool . ({a = (fix (\x: Rec X. X . 0 )) , b = true , c =  ({a = true , b = 0 }.b) }.b) )) else ({a = (let u = (pred 1) in true) , b = ({a = 1 , b = false , c = 0 }.c) }.a)) }.a)
({a = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) ) (( \f: Nat .((f (((\x: Bool .\y: Bool .y) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) ) (let u = 0 in false)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Bool .b)) , b = (if (iszero ({a = (let u = false in 1) , b = true , c = (let u = 1 in u) }.c)) then (iszero (if false then 1 else 0)) else ({a = ({a = (((\x: Bool .\y: Unit .x) 1 ) false) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (if false then 1 else 1) }.c) , b = (let u = true in u) }.b)) }.b)
(fix (\x: Unit . (let u = (((\x: Unit .\y: Bool .y) (if true then false else true) ) (let u = 1 in u)) in u) ))
(if ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then true else true) )) )) then ({a = ({a = (fix (\x: Rec X. X . 0 )) , b = ({a = 0 , b = true , c =  (((\x: Nat .\y: Rec X. X .y) false ) 0) }.b) }.a) , b = (iszero (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a))) }.a) else ({a = ({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 1 )) in (pred (fix (\x: Unit . 1 )))) , b = ({a = ({a = true , b = 0 }.a) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) }.b) }.a) , b = (((\x: Unit .\y: Unit .x) (( \f: Bool .((f 0 ) (let u = 0 in 0) ) ) (\a: Unit .\b: Unit .b)) ) ({a = 1 , b = true , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b)) }.b))
(let u = (if (( \f: Bool .((f (fix (\x: Nat . false )) ) true ) ) (\a: Bool .\b: Nat .a)) then (let u = 0 in u) else (let u = (fix (\x: Nat . 1 )) in u)) in u)
(( \f: Unit .((f (if (let u = ({a = 0 , b = false , c = 0 }.c) in (((\x: Unit .\y: Bool .y) true ) false)) then (let u = (let u = 0 in u) in (let u = (((\x: Nat .\y: Rec X. X .y) true ) 1) in u)) else ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) , b = (fix (\x: Rec X. X . 0 )) }.b)) ) (((\x: Bool .\y: Nat .y) (if (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) then (( \f: Bool .((f ({a = 1 , b = true }.b) ) (iszero 1) ) ) (\a: Bool .\b: Unit .a)) else (case <r = (fix (\x: Unit . true )) > as Nat of < l = x > => x | < r = y > => y)) ) (succ (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)))) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (( \f: Nat .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .b)) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .a)) in (unfold [ Nat ] (fold [ Rec X. X ] (iszero (if false then 1 else 1)) )))
({a = (unfold [ Bool ] (fold [ Bool ] (((\x: Unit .\y: Unit .y) ({a = false , b = false }.b) ) (let u = 0 in 0)) )) , b = (((\x: Bool .\y: Bool .x) ({a = (((\x: Rec X. X .\y: Nat .y) true ) 0) , b = false , c =  0 }.b) ) (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) (((\x: Rec X. X .\y: Nat .x) true ) false))) }.b)
((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) )) ))
({a = (succ (case <l = ({a = true , b = 1 }.b) > as Bool of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Rec X. X .x) ({a = (( \f: Unit .((f true ) (fix (\x: Nat . false )) ) ) (\a: Nat .\b: Unit .a)) , b = (if false then 0 else 1) }.a) ) (case <r = (let u = (let u = 1 in u) in false) > as Unit of < l = x > => x | < r = y > => y)) }.b)
(iszero (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) )) ) (let u = (( \f: Bool .((f (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .a)) ) false ) ) (\a: Bool .\b: Unit .a)) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Rec X. X .\b: Unit .a)))
((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = (if true then false else (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = false , b = false }.b) }.b) in u) ))
(let u = (((\x: Rec X. X .\y: Bool .y) (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) in (let u = 0 in false)) ) ({a = (fix (\x: Bool . 0 )) , b = ({a = true , b = 0 }.a) , c = (( \f: Unit .((f 0 ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) }.c)) in (( \f: Rec X. X .((f (case <l = ({a = ({a = 1 , b = false }.a) , b = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = (( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) (let u = 1 in u) ) ) (\a: Nat .\b: Bool .a)) in u) ) ) (\a: Nat .\b: Rec X. X .a)))
(((\x: Rec X. X .\y: Nat .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = (((\x: Unit .\y: Nat .y) false ) 0) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) }.a) , b = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) , b = true }.b) }.a) )) ) (( \f: Nat .((f (if (fix (\x: Rec X. X . true )) then (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Rec X. X .x) false ) true) ) ({a = false , b = true }.b)) else ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false ))) ) (fix (\x: Unit . (((\x: Unit .\y: Rec X. X .x) (if false then false else false) ) ({a = 0 , b = true }.b)) )) ) ) (\a: Bool .\b: Nat .b)))
(let u = ({a = ({a = (iszero 0) , b = (let u = ({a = 0 , b = false , c =  0 }.b) in 1) }.a) , b = ({a = (let u = 1 in 0) , b = (let u = true in true) , c = (succ 0) }.c) }.a) in u)
({a = ({a = ({a = true , b = (if true then 0 else 0) }.a) , b = (let u = (iszero 1) in u) }.b) , b = (if ({a = (let u = true in 1) , b = ({a = false , b = false }.b) , c =  (if false then 0 else 0) }.b) then (( \f: Unit .((f (let u = ({a = 1 , b = false }.b) in false) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Bool .\b: Nat .a)) else (let u = (((\x: Unit .\y: Nat .y) false ) false) in u)) }.b)
({a = ({a = (case <l = (succ 1) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = ({a = (( \f: Unit .((f true ) ({a = false , b = 0 }.a) ) ) (\a: Unit .\b: Unit .a)) , b = (succ (let u = 1 in 1)) }.b) , b = (case <r = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , c =  (((\x: Nat .\y: Unit .x) (pred 1) ) (let u = 0 in false)) }.b) , c =  ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = true , b = 0 }.a) }.a) }.b) , b = ({a = (((\x: Unit .\y: Rec X. X .x) (( \f: Nat .((f ({a = (fix (\x: Bool . true )) , b = (let u = 1 in 0) }.a) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) ) (case <r = (((\x: Nat .\y: Nat .y) true ) false) > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (succ (fix (\x: Bool . (let u = 1 in ({a = 1 , b = true }.a)) ))) }.b) }.b)
(if ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (let u = (((\x: Nat .\y: Bool .x) 0 ) false) in (let u = 1 in (iszero 1))) )) then (case <r = ({a = true , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) else (let u = ({a = (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .x) 0 ) false) ) (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .b)) , b = (let u = (succ 0) in true) }.b) in u))
(((\x: Unit .\y: Unit .x) ({a = (succ ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) , b = (let u = 1 in true) , c = 1 }.c)) , b = (iszero (fix (\x: Rec X. X . 0 ))) , c = (unfold [ Bool ] (fold [ Bool ] 1 )) }.c) ) (((\x: Bool .\y: Unit .x) (case <r = (unfold [ Rec X. X ] (fold [ Bool ] (if false then true else true) )) > as Nat of < l = x > => x | < r = y > => y) ) (let u = (pred (let u = 0 in 0)) in ({a = 0 , b = (if true then true else false) , c =  ({a = 1 , b = false }.a) }.b))))
(case <r = (( \f: Bool .((f (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) ) (let u = (iszero 0) in ({a = false , b = (if true then 0 else 0) }.a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Nat of < l = x > => x | < r = y > => y)
(if (let u = (( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )) ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Bool .a)) in ({a = (if false then false else false) , b = (fix (\x: Rec X. X . false )) }.b)) then (let u = (((\x: Rec X. X .\y: Bool .y) (( \f: Nat .((f (((\x: Bool .\y: Nat .x) true ) false) ) (let u = 1 in true) ) ) (\a: Nat .\b: Unit .a)) ) ({a = (((\x: Nat .\y: Bool .y) false ) (let u = 1 in 0)) , b = ({a = (((\x: Unit .\y: Unit .x) true ) false) , b = (fix (\x: Rec X. X . true )) }.b) , c = (( \f: Bool .((f (let u = true in 1) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Bool .\b: Nat .a)) }.c)) in (case <l = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , b = (let u = 0 in 1) }.b) > as Unit of < l = x > => x | < r = y > => y)) else ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = true }.a) )))
(unfold [ Bool ] (fold [ Nat ] ({a = (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Bool .y) true ) 0) )) )) , b = (( \f: Bool .((f (fix (\x: Nat . true )) ) ({a = true , b = 0 }.a) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ))
(((\x: Nat .\y: Rec X. X .y) ({a = (let u = (((\x: Bool .\y: Rec X. X .y) false ) ({a = 1 , b = true }.b)) in u) , b = ({a = ({a = (case <l = ({a = 0 , b = true , c = 1 }.c) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (succ 1) in u) }.b) , b = ({a = true , b = (pred 0) }.a) }.a) }.a) ) (((\x: Rec X. X .\y: Rec X. X .y) ({a = true , b = (((\x: Unit .\y: Bool .x) true ) false) }.b) ) ({a = (let u = 1 in u) , b = (((\x: Nat .\y: Unit .x) (let u = true in false) ) true) }.a)))
(let u = (case <l = (fix (\x: Rec X. X . (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) in (let u = false in 0)) )) > as Unit of < l = x > => x | < r = y > => y) in u)
(if (( \f: Rec X. X .((f (let u = ({a = false , b = 1 }.b) in ({a = 1 , b = false }.b)) ) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) in u) ) ) (\a: Rec X. X .\b: Nat .b)) then ({a = (let u = (let u = true in u) in (if ({a = 1 , b = true }.b) then 0 else (let u = 0 in 1))) , b = (unfold [ Nat ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .b)) )) )) }.b) else ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Nat .x) (if false then true else true) ) (unfold [ Bool ] (fold [ Rec X. X ] true ))) )))
(( \f: Bool .((f ({a = ({a = ({a = 0 , b = 1 }.b) , b = (let u = true in false) , c =  (((\x: Unit .\y: Unit .x) 1 ) true) }.b) , b = (((\x: Nat .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) }.a) ) ({a = ({a = 1 , b = ({a = 0 , b = false , c = 0 }.c) }.b) , b = (( \f: Unit .((f (iszero ({a = 0 , b = false }.a)) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) ) ) (\a: Unit .\b: Rec X. X .b))
(unfold [ Nat ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) (case <r = ({a = (let u = 1 in 1) , b = ({a = false , b = ({a = 1 , b = false , c = 0 }.c) }.a) , c =  ({a = 0 , b = (let u = 1 in 1) }.b) }.b) > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Unit ] ({a = (fix (\x: Nat . false )) , b = (let u = 1 in 1) }.a) ))) ))
(pred ({a = (succ (fix (\x: Rec X. X . 1 ))) , b = (let u = (succ (let u = false in 1)) in (case <r = (case <r = (let u = false in false) > as Bool of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)) }.a))
(((\x: Rec X. X .\y: Nat .x) (iszero (succ (succ (let u = 0 in 0)))) ) (let u = (((\x: Rec X. X .\y: Bool .y) ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) , b = 1 }.a) ) (if (if true then true else false) then (let u = true in u) else (iszero 0))) in (if ({a = true , b = false }.b) then (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) in (unfold [ Bool ] (fold [ Unit ] true ))) else (fix (\x: Unit . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )))))
({a = (((\x: Bool .\y: Rec X. X .y) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) in (((\x: Rec X. X .\y: Rec X. X .y) true ) false)) ) ({a = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Nat .b)) , b = (pred 0) }.a)) , b = (if (((\x: Unit .\y: Bool .x) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (case <r = (((\x: Nat .\y: Rec X. X .x) false ) false) > as Rec X. X of < l = x > => x | < r = y > => y)) then (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 0 )) > as Nat of < l = x > => x | < r = y > => y) else (if ({a = 0 , b = true , c =  1 }.b) then (((\x: Nat .\y: Bool .y) true ) 0) else 0)) }.b)
({a = ({a = (pred (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) ({a = 1 , b = true , c =  1 }.b)) , b = (iszero (succ 1)) , c =  (if (fix (\x: Rec X. X . false )) then (( \f: Bool .((f (let u = 0 in 0) ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) else (succ 1)) }.b) , c =  (let u = (((\x: Rec X. X .\y: Bool .y) (let u = true in true) ) (fix (\x: Unit . false ))) in ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (succ 1) ))) }.b) , b = (let u = ({a = ({a = false , b = 0 }.a) , b = ({a = 1 , b = false , c =  0 }.b) }.b) in (succ (let u = 0 in 1))) }.b)
({a = ({a = ({a = ({a = (pred 0) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , c = (succ 1) }.c) , b = (iszero (if true then 0 else 1)) }.a) , b = (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.b) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Bool .\y: Bool .y) false ) 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) }.b)
(if (fix (\x: Bool . ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  ({a = 0 , b = false }.a) }.b) )) then (let u = (case <r = (((\x: Rec X. X .\y: Rec X. X .x) ({a = (fix (\x: Unit . 0 )) , b = ({a = true , b = false }.b) , c =  (let u = 0 in u) }.b) ) (( \f: Rec X. X .((f false ) (fix (\x: Rec X. X . false )) ) ) (\a: Unit .\b: Rec X. X .a))) > as Rec X. X of < l = x > => x | < r = y > => y) in u) else (((\x: Bool .\y: Nat .x) (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) else (let u = false in u)))))
(case <r = (((\x: Unit .\y: Nat .y) (let u = (let u = true in u) in (let u = true in false)) ) (((\x: Rec X. X .\y: Nat .y) false ) (((\x: Rec X. X .\y: Bool .y) true ) false))) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (( \f: Bool .((f (fix (\x: Unit . ({a = 1 , b = 1 }.b) )) ) (fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) )) ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = (unfold [ Bool ] (fold [ Nat ] (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Unit .((f ({a = 1 , b = false , c =  0 }.b) ) false ) ) (\a: Bool .\b: Unit .b)) ) (unfold [ Nat ] (fold [ Nat ] 1 ))) )) , b = (let u = (fix (\x: Rec X. X . 1 )) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true ))) }.a) ) ) (\a: Bool .\b: Nat .a))
(let u = (let u = (case <r = ({a = false , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y) in u) in u)
(unfold [ Rec X. X ] (fold [ Unit ] (( \f: Rec X. X .((f (let u = ({a = (unfold [ Unit ] (fold [ Nat ] 0 )) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c =  ({a = 0 , b = false , c = 0 }.c) }.b) in (((\x: Bool .\y: Bool .x) (iszero 0) ) false)) ) (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) in ({a = false , b = 1 }.a)) ) ) (\a: Rec X. X .\b: Unit .a)) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] (succ (((\x: Unit .\y: Bool .x) 0 ) (unfold [ Nat ] (fold [ Nat ] false )))) )) ))
({a = (((\x: Rec X. X .\y: Bool .y) (((\x: Nat .\y: Rec X. X .y) (let u = 1 in false) ) (let u = false in false)) ) (let u = (if true then (fix (\x: Nat . 1 )) else (fix (\x: Unit . 0 ))) in u)) , b = ({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) in (fix (\x: Nat . false ))) , b = (case <r = ({a = false , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b)
(succ ({a = ({a = ({a = (let u = false in u) , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) }.b) , b = (let u = (((\x: Nat .\y: Unit .x) 0 ) true) in (fix (\x: Nat . 1 ))) }.b) , b = ({a = (if false then 1 else 0) , b = (let u = false in false) , c =  (( \f: Unit .((f 0 ) (let u = 1 in 0) ) ) (\a: Unit .\b: Bool .a)) }.b) }.a))
(fix (\x: Rec X. X . (let u = (if (( \f: Rec X. X .((f false ) (((\x: Rec X. X .\y: Nat .y) true ) false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) then (succ 0) else (fix (\x: Rec X. X . 0 ))) in (let u = (let u = false in true) in u)) ))
(if (iszero (unfold [ Bool ] (fold [ Nat ] ({a = true , b = 1 }.b) ))) then ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Unit ] false )) )) )) else (case <r = ({a = ({a = 1 , b = false }.b) , b = (if (((\x: Nat .\y: Unit .y) true ) true) then false else true) }.b) > as Unit of < l = x > => x | < r = y > => y))
(fix (\x: Unit . ({a = (if (( \f: Unit .((f (let u = true in true) ) (((\x: Bool .\y: Rec X. X .y) false ) false) ) ) (\a: Nat .\b: Bool .b)) then (let u = ({a = 0 , b = (((\x: Bool .\y: Unit .x) false ) true) , c =  ({a = 0 , b = 1 }.b) }.b) in (let u = 1 in u)) else (fix (\x: Bool . 0 ))) , b = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) , b = ({a = (unfold [ Nat ] (fold [ Bool ] 1 )) , b = (( \f: Rec X. X .((f 0 ) (fix (\x: Unit . 1 )) ) ) (\a: Rec X. X .\b: Unit .a)) }.b) }.a) , c =  (case <l = ({a = 0 , b = true }.a) > as Nat of < l = x > => x | < r = y > => y) }.b) ))
(((\x: Unit .\y: Rec X. X .y) (case <r = ({a = ({a = 1 , b = (if true then 0 else 0) }.b) , b = (((\x: Bool .\y: Unit .y) false ) false) }.b) > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . (((\x: Bool .\y: Unit .x) (let u = (let u = 1 in u) in false) ) ({a = false , b = 0 }.a)) )))
(((\x: Bool .\y: Bool .y) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (iszero (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .a))) }.b) ) (( \f: Rec X. X .((f (let u = false in 1) ) (((\x: Nat .\y: Bool .y) ({a = (let u = true in u) , b = true }.b) ) (( \f: Unit .((f 0 ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Bool .\b: Nat .a)))
({a = (( \f: Nat .((f (let u = (((\x: Bool .\y: Nat .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (if true then 1 else 0)) in (((\x: Unit .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) false)) ) ({a = ({a = false , b = 1 }.a) , b = ({a = false , b = false }.b) }.b) ) ) (\a: Bool .\b: Unit .b)) , b = (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in u) }.b)
(((\x: Nat .\y: Nat .y) (( \f: Unit .((f (let u = false in u) ) (( \f: Rec X. X .((f ({a = false , b = 0 }.a) ) (let u = 1 in true) ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = (let u = ({a = 1 , b = true }.a) in (unfold [ Bool ] (fold [ Bool ] 0 ))) in u))
(((\x: Nat .\y: Bool .x) ({a = (((\x: Rec X. X .\y: Bool .y) ({a = true , b = 0 }.a) ) ({a = 0 , b = true }.b)) , b = (fix (\x: Nat . (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Nat .b)) )) }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (( \f: Nat .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 0 in 1) ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = (let u = (let u = true in u) in ({a = (succ 0) , b = (((\x: Bool .\y: Rec X. X .x) true ) false) , c =  1 }.b)) }.b) )))
({a = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Unit .((f (fix (\x: Nat . 1 )) ) ({a = 0 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (fix (\x: Rec X. X . (if true then true else false) ))) , b = (if ({a = (if true then 1 else 1) , b = (if false then ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) else (let u = false in u)) , c =  (succ (((\x: Nat .\y: Rec X. X .y) false ) 0)) }.b) then (unfold [ Bool ] (fold [ Unit ] (((\x: Nat .\y: Nat .y) (let u = false in u) ) (if false then false else false)) )) else (( \f: Unit .((f (((\x: Nat .\y: Unit .y) ({a = 1 , b = (unfold [ Unit ] (fold [ Nat ] true )) }.b) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .b))) ) (let u = 1 in ({a = 0 , b = true }.b)) ) ) (\a: Rec X. X .\b: Nat .a))) , c = (unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f (succ 1) ) (if false then 1 else 1) ) ) (\a: Bool .\b: Unit .b)) )) }.c)
(((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f (((\x: Nat .\y: Unit .x) (( \f: Unit .((f false ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true ))) ) ({a = (pred (((\x: Unit .\y: Bool .y) true ) 0)) , b = (( \f: Unit .((f true ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) ) (\a: Nat .\b: Bool .b)) ) ({a = (unfold [ Rec X. X ] (fold [ Nat ] ({a = ({a = 0 , b = true }.a) , b = (let u = true in u) , c =  (let u = (((\x: Unit .\y: Nat .x) 0 ) true) in u) }.b) )) , b = (( \f: Rec X. X .((f (fix (\x: Unit . 1 )) ) (pred (succ 0)) ) ) (\a: Nat .\b: Rec X. X .a)) }.b))
(fix (\x: Rec X. X . (fix (\x: Nat . (unfold [ Nat ] (fold [ Unit ] (let u = ({a = 0 , b = true }.b) in u) )) )) ))
(((\x: Bool .\y: Bool .y) (iszero (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) in u)) ) (((\x: Nat .\y: Bool .x) (((\x: Nat .\y: Nat .y) (((\x: Unit .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Rec X. X .y) false ) true)) ) (unfold [ Bool ] (fold [ Nat ] (iszero 0) ))) ) (fix (\x: Unit . ({a = 1 , b = true , c =  1 }.b) ))))
(unfold [ Unit ] (fold [ Bool ] (case <l = (let u = (((\x: Unit .\y: Nat .y) true ) (((\x: Rec X. X .\y: Rec X. X .y) true ) true)) in (fix (\x: Rec X. X . 0 ))) > as Unit of < l = x > => x | < r = y > => y) ))
(fix (\x: Nat . (case <r = (((\x: Rec X. X .\y: Unit .y) (fix (\x: Bool . false )) ) (let u = true in false)) > as Unit of < l = x > => x | < r = y > => y) ))
(let u = (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] true )) ) (let u = 0 in false) ) ) (\a: Unit .\b: Rec X. X .a)) in (iszero (let u = ({a = (((\x: Rec X. X .\y: Bool .y) true ) 0) , b = false }.b) in (let u = (pred 1) in u))))
(if (iszero ({a = (fix (\x: Unit . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) )) , b = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true ))) ) ({a = (fix (\x: Unit . true )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.a)) }.b)) then (fix (\x: Unit . (let u = ({a = 1 , b = (iszero 1) , c = (let u = false in 0) }.c) in (unfold [ Rec X. X ] (fold [ Bool ] true ))) )) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (iszero ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (let u = false in 1) ))) )))
(case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (iszero (case <l = (if true then 0 else 1) > as Unit of < l = x > => x | < r = y > => y)) )) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = 1 in false) )) in (let u = ({a = (fix (\x: Unit . (fix (\x: Nat . 0 )) )) , b = ({a = true , b = false }.b) , c = ({a = 1 , b = false }.a) }.c) in (((\x: Unit .\y: Bool .x) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .b)) ) (let u = false in u)))) ))
(pred ({a = ({a = (((\x: Unit .\y: Bool .y) (iszero 1) ) 1) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) , c =  (let u = (let u = 0 in 0) in ({a = ({a = 1 , b = true , c = 0 }.c) , b = ({a = 1 , b = 0 }.b) }.b)) }.b) , b = (case <l = ({a = ({a = 1 , b = false }.a) , b = (fix (\x: Unit . false )) }.a) > as Unit of < l = x > => x | < r = y > => y) }.b))
(((\x: Bool .\y: Bool .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f 0 ) (succ 1) ) ) (\a: Bool .\b: Nat .b)) , b = (let u = (((\x: Rec X. X .\y: Bool .x) false ) false) in u) }.a) )) ) (( \f: Bool .((f ({a = (pred 1) , b = (let u = 0 in false) }.b) ) (( \f: Bool .((f true ) (let u = 1 in false) ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Nat .\b: Bool .a)))
(( \f: Bool .((f (((\x: Rec X. X .\y: Unit .y) (case <r = (unfold [ Unit ] (fold [ Bool ] true )) > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = false in false) ))) ) ({a = (let u = (let u = false in false) in (((\x: Bool .\y: Nat .y) false ) true)) , b = (succ (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) }.a) ) ) (\a: Unit .\b: Nat .b))
({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (case <l = (let u = (if true then 0 else 0) in u) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Nat .y) ({a = true , b = 0 }.a) ) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b))) }.b) )) , b = (fix (\x: Unit . ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 1 in 0) )) )) }.a)
({a = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (succ 0) )) , b = ({a = (let u = (unfold [ Rec X. X ] (fold [ Unit ] false )) in u) , b = (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Unit ] (fold [ Nat ] false )) )) }.b) , c = (case <l = (succ 0) > as Nat of < l = x > => x | < r = y > => y) }.c) , b = (let u = (let u = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) in true) in ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] false ))) }.a)
(let u = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Bool ] (fold [ Unit ] true )) ) ({a = 1 , b = true }.b)) , b = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) in (((\x: Nat .\y: Unit .x) 1 ) false)) }.b) }.a) in (((\x: Bool .\y: Unit .y) ({a = (let u = true in (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .b))) , b = (let u = true in 1) }.a) ) ({a = (( \f: Rec X. X .((f (if false then 0 else 0) ) 1 ) ) (\a: Nat .\b: Nat .a)) , b = ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = 1 }.b) }.a) , c =  ({a = 0 , b = true , c = 0 }.c) }.b)))
({a = ({a = ({a = (((\x: Rec X. X .\y: Bool .y) false ) 1) , b = (pred (let u = 1 in (unfold [ Unit ] (fold [ Unit ] 0 )))) }.b) , b = (if (((\x: Bool .\y: Nat .y) false ) true) then (case <l = ({a = false , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) else (let u = (fix (\x: Bool . false )) in (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)))) }.b) , b = (let u = ({a = true , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) in (((\x: Unit .\y: Unit .y) ({a = 0 , b = false , c =  0 }.b) ) (let u = false in false))) }.b)
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (if false then 1 else 0) , b = ({a = 0 , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) , c =  (succ 0) }.b) , c =  (fix (\x: Rec X. X . 0 )) }.b) )) ))
(((\x: Unit .\y: Nat .x) (iszero (unfold [ Rec X. X ] (fold [ Bool ] (if true then 0 else 1) ))) ) (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Bool ] (let u = true in u) )) ) ({a = (pred (let u = 1 in u)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] false )) }.b) ) ) (\a: Rec X. X .\b: Nat .b)))
(((\x: Nat .\y: Nat .y) (((\x: Bool .\y: Unit .x) (iszero 0) ) (iszero (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)))) ) (let u = (( \f: Unit .((f (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) ) (((\x: Nat .\y: Unit .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) 1) ) ) (\a: Rec X. X .\b: Nat .b)) in ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b)))
({a = (fix (\x: Unit . ({a = false , b = 1 }.b) )) , b = (((\x: Nat .\y: Nat .y) ({a = ({a = (if (iszero 1) then true else (iszero 1)) , b = (((\x: Bool .\y: Nat .y) true ) 1) }.b) , b = (((\x: Bool .\y: Nat .y) (let u = true in u) ) (let u = true in u)) }.b) ) (if (((\x: Rec X. X .\y: Bool .x) false ) true) then ({a = 0 , b = false , c =  0 }.b) else (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)))) }.a)
(unfold [ Rec X. X ] (fold [ Unit ] (fix (\x: Unit . (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in ({a = 1 , b = 0 }.b)) )) ))
({a = (((\x: Nat .\y: Unit .x) (( \f: Bool .((f 0 ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = true in true) ))) , b = (fix (\x: Nat . (iszero (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .x) 1 ) true) ) (let u = true in (if true then 1 else 1)) ) ) (\a: Rec X. X .\b: Unit .a))) )) }.b)
(let u = ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = 1 }.b) )) , b = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) in (iszero 1)) }.b) in (((\x: Rec X. X .\y: Unit .y) (let u = 1 in false) ) ({a = 0 , b = false }.a)))
(( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) ({a = (( \f: Rec X. X .((f ({a = true , b = 0 }.a) ) (if false then false else false) ) ) (\a: Unit .\b: Unit .b)) , b = (let u = true in 0) }.b) ) ({a = ({a = 1 , b = (iszero 0) , c =  1 }.b) , b = (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (unfold [ Bool ] (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Bool .b)) }.b)) ) (case <l = (succ (let u = false in (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)))) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .b))
(fix (\x: Bool . ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = ({a = (pred 1) , b = (let u = false in false) }.b) , b = (((\x: Unit .\y: Rec X. X .x) (pred 1) ) true) }.a) )) ))
(unfold [ Bool ] (fold [ Nat ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in u) )) ))
(case <r = (( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a))) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f ({a = false , b = true }.b) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Bool .\b: Nat .b)) ))) ) (let u = (succ ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 1 ))) in ({a = ({a = false , b = 0 }.b) , b = (if false then false else false) }.b)) ) ) (\a: Bool .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Nat .y) ({a = (((\x: Nat .\y: Rec X. X .x) ({a = (let u = 1 in 1) , b = ({a = true , b = false }.b) }.b) ) ({a = ({a = true , b = 0 }.a) , b = (let u = (fix (\x: Unit . true )) in (let u = true in u)) }.b)) , b = (if ({a = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .a)) , b = (let u = 1 in 0) }.a) then (((\x: Rec X. X .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) (((\x: Unit .\y: Bool .y) true ) false)) else (((\x: Bool .\y: Bool .y) true ) false)) }.b) ) (pred (( \f: Bool .((f ({a = 1 , b = 1 }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .a))))
(case <r = (let u = ({a = (((\x: Nat .\y: Nat .x) 1 ) true) , b = (if false then (fix (\x: Nat . false )) else true) }.a) in ({a = ({a = 0 , b = 0 }.b) , b = (let u = false in true) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b)) }.b)) > as Bool of < l = x > => x | < r = y > => y)
({a = (let u = (case <r = (fix (\x: Unit . (iszero 1) )) > as Bool of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = 0 }.b) ))) , b = ({a = (let u = (fix (\x: Bool . 0 )) in 0) , b = (let u = true in true) }.b) , c = (succ (fix (\x: Bool . (((\x: Rec X. X .\y: Bool .x) 1 ) false) ))) }.c)
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] ({a = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .a)) , b = (unfold [ Nat ] (fold [ Nat ] false )) }.b) )) , b = (let u = (fix (\x: Unit . ({a = ({a = 1 , b = 1 }.b) , b = 1 }.b) )) in u) }.b)
(unfold [ Bool ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (let u = ({a = 1 , b = true , c = 0 }.c) in (if true then false else ({a = 1 , b = false }.b))) ) (let u = (let u = false in u) in (case <r = ({a = 1 , b = false , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .a)) ))
(((\x: Unit .\y: Rec X. X .x) (fix (\x: Bool . (( \f: Bool .((f 1 ) ({a = 0 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) ) (fix (\x: Nat . (( \f: Bool .((f ({a = false , b = 0 }.a) ) true ) ) (\a: Unit .\b: Unit .b)) )))
({a = ({a = ({a = ({a = 1 , b = false }.a) , b = 1 }.b) , b = (((\x: Bool .\y: Rec X. X .y) (let u = true in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) (((\x: Bool .\y: Nat .y) false ) true)) }.a) , b = (pred (( \f: Rec X. X .((f (pred 0) ) (let u = 0 in u) ) ) (\a: Unit .\b: Bool .a))) }.b)
({a = (((\x: Nat .\y: Rec X. X .x) (let u = ({a = 1 , b = true , c =  1 }.b) in true) ) (((\x: Rec X. X .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y))) , b = (let u = (unfold [ Nat ] (fold [ Rec X. X ] (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) )) in u) }.b)
({a = (if (let u = (let u = true in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) in ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = ({a = true , b = (let u = 1 in false) }.b) , c =  ({a = 0 , b = (((\x: Nat .\y: Rec X. X .x) false ) false) , c = 1 }.c) }.b)) then ({a = (let u = 0 in 1) , b = (iszero ({a = 1 , b = 1 }.b)) , c = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) }.c) else ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)) , b = (fix (\x: Rec X. X . ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) )) , c = (pred (pred 0)) }.c)) , b = (let u = (case <r = (( \f: Nat .((f ({a = 0 , b = true , c =  1 }.b) ) ({a = false , b = true }.b) ) ) (\a: Bool .\b: Bool .a)) > as Rec X. X of < l = x > => x | < r = y > => y) in u) , c = (( \f: Bool .((f (((\x: Nat .\y: Nat .x) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (let u = true in u)) ) ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b) ) ) (\a: Unit .\b: Bool .b)) }.c)
(unfold [ Nat ] (fold [ Nat ] ({a = (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Unit .y) (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) (let u = true in true)) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 1 ))) , b = ({a = (((\x: Nat .\y: Bool .x) false ) true) , b = (((\x: Bool .\y: Bool .y) false ) true) }.b) , c =  ({a = (let u = true in (let u = 0 in 1)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , c = (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u) }.c) }.b) ))
(pred ({a = (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f ({a = false , b = 1 }.b) ) 0 ) ) (\a: Nat .\b: Nat .a)) ) (let u = false in true)) , b = ({a = (if true then ({a = false , b = 1 }.a) else (let u = 0 in true)) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) }.a))
(if (let u = (case <r = ({a = true , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) in (unfold [ Nat ] (fold [ Unit ] (let u = false in false) ))) then (( \f: Rec X. X .((f ({a = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) , b = (((\x: Unit .\y: Unit .x) 1 ) false) }.b) ) ({a = (if true then 1 else (if true then 1 else 0)) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.b) ) ) (\a: Nat .\b: Nat .b)) else (((\x: Bool .\y: Unit .y) (if false then (unfold [ Unit ] (fold [ Nat ] false )) else false) ) (let u = (if (((\x: Nat .\y: Nat .y) true ) false) then (fix (\x: Rec X. X . 1 )) else (succ 1)) in u)))
({a = (((\x: Unit .\y: Rec X. X .y) (case <r = (fix (\x: Nat . true )) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .b)) ) ({a = 1 , b = true , c =  1 }.b) ) ) (\a: Unit .\b: Bool .a))) , b = ({a = (fix (\x: Unit . (let u = ({a = 1 , b = 0 }.b) in u) )) , b = (if (let u = false in (let u = 0 in true)) then (((\x: Bool .\y: Rec X. X .x) true ) (((\x: Unit .\y: Bool .x) false ) false)) else (let u = false in u)) , c =  (((\x: Nat .\y: Unit .x) (let u = (pred 0) in u) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = true }.b) )) }.b)) }.b) }.b)
(( \f: Nat .((f ({a = (( \f: Bool .((f (fix (\x: Nat . 1 )) ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (unfold [ Unit ] (fold [ Nat ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) , c =  ({a = ({a = ({a = 0 , b = true , c = 1 }.c) , b = 0 }.b) , b = (iszero (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) , c = (unfold [ Nat ] (fold [ Unit ] 0 )) }.c) }.b) ) (let u = ({a = (( \f: Unit .((f 1 ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (((\x: Unit .\y: Bool .y) (if true then true else false) ) ({a = true , b = 1 }.a)) , c = ({a = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in 0) , b = (if true then false else false) }.a) }.c) in ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (unfold [ Bool ] (fold [ Unit ] false )) , c =  ({a = true , b = 1 }.b) }.b)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(((\x: Bool .\y: Bool .x) (case <l = (( \f: Nat .((f 0 ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . (((\x: Unit .\y: Unit .y) (unfold [ Bool ] (fold [ Nat ] false )) ) (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) false ) true) ))) )))
(let u = (unfold [ Bool ] (fold [ Unit ] (case <l = ({a = 0 , b = true , c = 0 }.c) > as Bool of < l = x > => x | < r = y > => y) )) in (( \f: Bool .((f (( \f: Unit .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)) ) (if true then (let u = 0 in u) else (((\x: Unit .\y: Bool .y) false ) 1)) ) ) (\a: Bool .\b: Nat .b)) ) (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in (pred 1)) ) ) (\a: Bool .\b: Unit .a)))
({a = (((\x: Bool .\y: Unit .y) (unfold [ Nat ] (fold [ Unit ] (fix (\x: Rec X. X . false )) )) ) (( \f: Nat .((f (let u = (let u = 0 in 1) in false) ) ({a = (((\x: Unit .\y: Bool .x) false ) false) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.b) ) ) (\a: Bool .\b: Rec X. X .a))) , b = ({a = (if (iszero 1) then (let u = 1 in u) else (fix (\x: Bool . 1 ))) , b = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) in ({a = 1 , b = false }.a)) }.b) }.a)
(pred (let u = ({a = 1 , b = true }.a) in u))
(( \f: Bool .((f (( \f: Nat .((f ({a = (fix (\x: Unit . (fix (\x: Rec X. X . false )) )) , b = ({a = (case <l = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . false )) }.a) }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (if false then ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) else 0) )) ) ) (\a: Bool .\b: Rec X. X .b)) ) (fix (\x: Nat . (( \f: Rec X. X .((f (( \f: Nat .((f (((\x: Unit .\y: Nat .x) 0 ) false) ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) ) ({a = (fix (\x: Nat . true )) , b = ({a = 1 , b = 1 }.b) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) )) ) ) (\a: Nat .\b: Nat .a))
({a = (pred (( \f: Unit .((f ({a = (pred 1) , b = ({a = false , b = 0 }.a) , c = 0 }.c) ) (( \f: Nat .((f ({a = 0 , b = true }.a) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Unit .x) (((\x: Bool .\y: Bool .y) false ) true) ) (iszero 1)) )) , c = ({a = ({a = ({a = 0 , b = ({a = 1 , b = true , c =  0 }.b) , c = (fix (\x: Rec X. X . 1 )) }.c) , b = ({a = false , b = 1 }.a) }.a) , b = ({a = (fix (\x: Unit . (iszero 1) )) , b = (( \f: Unit .((f true ) (if true then true else true) ) ) (\a: Nat .\b: Bool .b)) }.b) }.a) }.c)
(if (let u = ({a = (((\x: Rec X. X .\y: Nat .y) false ) false) , b = ({a = 0 , b = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Unit .a)) , c =  1 }.b) }.b) in u) then ({a = (((\x: Rec X. X .\y: Rec X. X .x) (if true then 0 else 0) ) ({a = 1 , b = true }.b)) , b = (case <r = (unfold [ Rec X. X ] (fold [ Bool ] ({a = 1 , b = false }.b) )) > as Bool of < l = x > => x | < r = y > => y) }.b) else (let u = (unfold [ Rec X. X ] (fold [ Bool ] (let u = (((\x: Rec X. X .\y: Nat .x) false ) true) in u) )) in (iszero (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u))))
(iszero ({a = ({a = (pred 1) , b = (let u = true in 1) }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) (case <r = (((\x: Rec X. X .\y: Unit .x) false ) false) > as Nat of < l = x > => x | < r = y > => y) ) (case <r = ({a = (if true then true else true) , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y)) , c = (case <l = (case <l = (succ 0) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) }.c))
({a = (fix (\x: Unit . (let u = ({a = 1 , b = ({a = 1 , b = false , c =  1 }.b) }.a) in (unfold [ Bool ] (fold [ Bool ] 1 ))) )) , b = (let u = ({a = (let u = 1 in (iszero 1)) , b = ({a = true , b = 0 }.b) }.b) in (let u = ({a = 0 , b = true , c =  1 }.b) in u)) }.b)
(unfold [ Nat ] (fold [ Bool ] (let u = (case <l = (((\x: Unit .\y: Rec X. X .x) 0 ) (((\x: Rec X. X .\y: Bool .y) true ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) in ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = (let u = 0 in u) , b = ({a = true , b = true }.b) , c =  1 }.b) ))) ))
(( \f: Nat .((f (((\x: Bool .\y: Unit .y) (fix (\x: Nat . true )) ) (((\x: Nat .\y: Unit .x) ({a = 0 , b = false }.b) ) (((\x: Rec X. X .\y: Nat .y) true ) (((\x: Bool .\y: Nat .x) false ) false)))) ) (let u = (iszero 0) in u) ) ) (\a: Rec X. X .\b: Bool .a))
(fix (\x: Rec X. X . (( \f: Unit .((f (fix (\x: Bool . ({a = (((\x: Nat .\y: Unit .x) true ) false) , b = false }.b) )) ) (fix (\x: Nat . ({a = (if false then 1 else 0) , b = (((\x: Rec X. X .\y: Bool .x) true ) false) , c =  (let u = ({a = 1 , b = false }.a) in u) }.b) )) ) ) (\a: Unit .\b: Unit .b)) ))
({a = ({a = ({a = (pred 0) , b = ({a = (succ 0) , b = ({a = 1 , b = true }.b) , c = (((\x: Bool .\y: Nat .x) 0 ) true) }.c) }.b) , b = ({a = (if true then (let u = 1 in 0) else 1) , b = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) in 0) }.b) }.b) , b = ({a = (succ (succ ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )))) , b = (if (( \f: Unit .((f (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) false ) ) (\a: Unit .\b: Rec X. X .b)) then ({a = 1 , b = false , c =  0 }.b) else (unfold [ Nat ] (fold [ Rec X. X ] true ))) , c =  (let u = false in 0) }.b) , c =  (((\x: Rec X. X .\y: Unit .x) (let u = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) in u) ) (let u = ({a = ({a = false , b = 1 }.a) , b = (if false then 1 else 0) }.a) in ({a = (let u = false in u) , b = true }.b))) }.b)
(case <r = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (case <r = (let u = 0 in false) > as Rec X. X of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (let u = (((\x: Bool .\y: Unit .y) (iszero (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a))) ) (if (iszero 1) then (if true then true else true) else ({a = false , b = false }.b))) in u) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in u) )) }.b)
(let u = (let u = (( \f: Nat .((f ({a = false , b = 1 }.a) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Bool .\b: Rec X. X .a)) in u) in (unfold [ Nat ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in u) )) )))
(fix (\x: Unit . ({a = (let u = (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in u) )) in u) , b = (( \f: Rec X. X .((f ({a = 1 , b = true , c = 1 }.c) ) (((\x: Nat .\y: Nat .y) true ) 1) ) ) (\a: Bool .\b: Rec X. X .a)) }.b) ))
(let u = (let u = (fix (\x: Unit . (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Bool .b)) )) in (let u = ({a = 0 , b = ({a = true , b = true }.b) , c =  0 }.b) in (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .b)))) in u)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .b)) )) in (iszero (unfold [ Unit ] (fold [ Unit ] 0 )))) ))
(unfold [ Nat ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Rec X. X .y) false ) true) ) ({a = ({a = ({a = 0 , b = true }.a) , b = (let u = 0 in true) , c =  1 }.b) , b = (let u = (let u = 0 in 0) in u) }.a)) ))
(( \f: Bool .((f ({a = ({a = 1 , b = false , c = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a)) }.c) , b = (( \f: Nat .((f false ) ({a = 1 , b = true }.b) ) ) (\a: Nat .\b: Nat .b)) }.a) ) (((\x: Unit .\y: Rec X. X .x) (if false then 1 else (((\x: Bool .\y: Unit .y) true ) 0)) ) (case <r = (unfold [ Nat ] (fold [ Nat ] true )) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Bool .a))
(((\x: Unit .\y: Bool .y) (let u = (fix (\x: Bool . (let u = true in u) )) in u) ) (((\x: Unit .\y: Unit .x) ({a = ({a = 0 , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.b) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.b) ) (let u = 0 in true)))
(pred (let u = (( \f: Bool .((f (let u = (fix (\x: Rec X. X . false )) in 1) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .a)) in u))
(((\x: Bool .\y: Bool .y) (fix (\x: Bool . (iszero (let u = ({a = false , b = 0 }.b) in 0)) )) ) (let u = (let u = (fix (\x: Unit . false )) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) in (let u = (unfold [ Nat ] (fold [ Bool ] true )) in (let u = 0 in false))))
(( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] (if (let u = true in true) then ({a = false , b = false }.b) else ({a = true , b = true }.b)) )) ) (let u = (((\x: Bool .\y: Rec X. X .x) (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) ) (let u = ({a = 1 , b = true }.b) in ({a = 0 , b = false }.b))) in (let u = (if true then true else (((\x: Nat .\y: Bool .x) false ) true)) in ({a = 0 , b = true , c =  0 }.b))) ) ) (\a: Bool .\b: Bool .a))
(if (let u = (case <r = (if ({a = false , b = 0 }.a) then (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Bool .b)) else (((\x: Nat .\y: Rec X. X .x) true ) true)) > as Rec X. X of < l = x > => x | < r = y > => y) in u) then ({a = (unfold [ Nat ] (fold [ Rec X. X ] (case <r = (let u = (pred 0) in ({a = true , b = false }.b)) > as Unit of < l = x > => x | < r = y > => y) )) , b = (iszero (((\x: Rec X. X .\y: Bool .x) ({a = ({a = false , b = true }.b) , b = (pred 1) }.b) ) (fix (\x: Rec X. X . ({a = 1 , b = false , c =  1 }.b) )))) }.b) else (let u = (fix (\x: Nat . ({a = (iszero 1) , b = 1 }.a) )) in u))
(iszero ({a = (succ ({a = (((\x: Nat .\y: Unit .y) (if true then true else false) ) ({a = 0 , b = 1 }.b)) , b = (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) false) in (succ 0)) }.b)) , b = (iszero (let u = false in 1)) }.a))
({a = (succ ({a = (if ({a = true , b = false }.b) then 0 else 0) , b = (((\x: Unit .\y: Rec X. X .x) true ) false) }.a)) , b = ({a = (iszero 1) , b = (((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Bool .y) true ) true) ) 0) }.a) , c =  (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Bool ] (succ 1) )) ) (let u = (let u = true in u) in (unfold [ Unit ] (fold [ Rec X. X ] 0 ))) ) ) (\a: Nat .\b: Bool .b)) }.b)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) (( \f: Bool .((f ({a = ({a = true , b = 0 }.a) , b = (let u = 1 in false) }.b) ) (let u = (succ 0) in (let u = true in true)) ) ) (\a: Bool .\b: Nat .b)) ) (fix (\x: Rec X. X . (let u = ({a = true , b = 0 }.b) in (if false then false else true)) ))) ))
(( \f: Nat .((f (((\x: Nat .\y: Nat .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (let u = (fix (\x: Rec X. X . true )) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )))) ) ({a = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = (if true then 0 else 1) , b = (iszero 0) , c = (let u = 1 in u) }.c) )) in (succ 1)) , b = (fix (\x: Rec X. X . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )) }.a) ) ) (\a: Unit .\b: Nat .b))
(pred (pred ({a = (iszero 1) , b = (( \f: Bool .((f 1 ) (((\x: Bool .\y: Nat .x) 1 ) false) ) ) (\a: Nat .\b: Rec X. X .b)) }.b)))
(case <r = ({a = (succ 1) , b = (( \f: Unit .((f (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) in false) ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Unit .b)) }.b) > as Unit of < l = x > => x | < r = y > => y)
({a = (((\x: Bool .\y: Unit .y) (((\x: Nat .\y: Rec X. X .y) ({a = false , b = true }.b) ) (unfold [ Unit ] (fold [ Nat ] true ))) ) (fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ))) , b = (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (succ 1) )) in (( \f: Rec X. X .((f true ) (fix (\x: Unit . false )) ) ) (\a: Unit .\b: Rec X. X .a))) , c =  (( \f: Unit .((f ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = true }.a) ) (unfold [ Unit ] (fold [ Unit ] ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) , b = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .a)) }.a) )) ) ) (\a: Unit .\b: Nat .b)) }.b)
(let u = ({a = (let u = ({a = (let u = 1 in false) , b = false }.b) in u) , b = (( \f: Unit .((f (iszero 1) ) (((\x: Rec X. X .\y: Unit .x) (iszero 0) ) (fix (\x: Nat . false ))) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) in u)
(let u = ({a = (((\x: Rec X. X .\y: Nat .x) (if (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) then (fix (\x: Rec X. X . true )) else (iszero 0)) ) ({a = (fix (\x: Rec X. X . true )) , b = true }.b)) , b = ({a = (((\x: Nat .\y: Unit .y) (let u = true in u) ) ({a = 0 , b = 0 }.b)) , b = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , b = false }.b) , c =  ({a = (if false then 0 else 1) , b = false }.a) }.b) }.b) in (let u = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) (case <l = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) in ({a = (pred ({a = false , b = 0 }.b)) , b = ({a = 0 , b = true , c =  0 }.b) , c = (let u = 0 in u) }.c)))
(( \f: Nat .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] ({a = false , b = true }.b) )) )) ) (case <r = (let u = (unfold [ Nat ] (fold [ Unit ] (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .a)) )) in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b))
(let u = (let u = ({a = (pred 0) , b = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.b) in (fix (\x: Nat . true ))) in u)
(succ (( \f: Bool .((f (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in 1) ) (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Bool .a)))
(let u = ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) (let u = 1 in true)) in ({a = ({a = true , b = 1 }.b) , b = 0 }.b)) , b = ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = ({a = false , b = 1 }.b) }.a) , c =  (pred ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = 0 }.b)) }.b) in (let u = (((\x: Nat .\y: Rec X. X .y) (let u = false in u) ) (if true then 0 else 1)) in (case <l = (let u = false in ({a = 1 , b = true }.a)) > as Unit of < l = x > => x | < r = y > => y)))
({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (succ (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) )) , b = (( \f: Bool .((f ({a = (unfold [ Unit ] (fold [ Unit ] (let u = 0 in u) )) , b = (((\x: Nat .\y: Nat .y) true ) true) }.a) ) (( \f: Nat .((f (let u = true in 0) ) (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = 1 }.b) )) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Nat .a)) }.b)
(if (let u = (case <l = ({a = (( \f: Nat .((f (fix (\x: Bool . 1 )) ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (fix (\x: Unit . 1 )) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = ({a = ({a = true , b = 0 }.a) , b = 1 }.b) in (( \f: Unit .((f false ) (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .a)))) then ({a = (succ (((\x: Rec X. X .\y: Nat .y) false ) 0)) , b = (( \f: Bool .((f (let u = 0 in (iszero 1)) ) (((\x: Unit .\y: Unit .x) (fix (\x: Bool . true )) ) (fix (\x: Rec X. X . true ))) ) ) (\a: Nat .\b: Bool .a)) , c =  ({a = (((\x: Rec X. X .\y: Unit .y) false ) (pred 1)) , b = (unfold [ Bool ] (fold [ Bool ] (let u = 0 in 0) )) }.b) }.b) else (( \f: Rec X. X .((f ({a = (((\x: Unit .\y: Unit .x) 1 ) false) , b = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (if false then false else false) )) ) ) (\a: Nat .\b: Unit .a)))
((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = ({a = 0 , b = true }.a) , b = true , c =  (((\x: Nat .\y: Bool .x) 0 ) true) }.b) )) , b = (let u = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) , b = (if false then 0 else 1) }.a) in (fix (\x: Rec X. X . ({a = 0 , b = false , c =  1 }.b) ))) }.b) ))
(case <l = (((\x: Nat .\y: Unit .x) (let u = (succ 1) in u) ) (fix (\x: Nat . (iszero (fix (\x: Nat . 0 ))) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Nat ] (fold [ Rec X. X ] (pred ({a = (((\x: Unit .\y: Bool .y) false ) 0) , b = (let u = 0 in false) , c = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.c)) ))
(let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) in false) , b = (succ 0) }.a) )) in u)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] ({a = ({a = (case <r = (((\x: Nat .\y: Bool .y) false ) true) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (iszero 0) in (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) }.a) , b = (((\x: Bool .\y: Bool .y) ({a = false , b = 0 }.a) ) ({a = 0 , b = false }.b)) }.b) )) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = ({a = ({a = true , b = false }.b) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] 0 )) }.a) in u) )) ) ) (\a: Rec X. X .\b: Bool .a))
(iszero (let u = ({a = ({a = 1 , b = 0 }.b) , b = ({a = 1 , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .b)) }.b) }.b) in ({a = (((\x: Nat .\y: Unit .y) true ) 0) , b = (iszero 0) }.a)))
({a = ({a = (fix (\x: Unit . ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (if true then false else false) , c = ({a = (let u = false in true) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) }.c) )) , b = (( \f: Unit .((f (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Bool .a)) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) }.b) , b = (if (( \f: Unit .((f (unfold [ Unit ] (fold [ Bool ] false )) ) (iszero 0) ) ) (\a: Unit .\b: Nat .b)) then (fix (\x: Unit . (case <r = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) )) else (((\x: Unit .\y: Bool .y) (( \f: Rec X. X .((f ({a = 0 , b = true , c =  1 }.b) ) (let u = true in u) ) ) (\a: Nat .\b: Nat .a)) ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)))) }.b)
(unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Rec X. X . (succ (let u = 0 in u)) )) ))
(((\x: Rec X. X .\y: Nat .y) (( \f: Bool .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (( \f: Nat .((f ({a = false , b = true }.b) ) true ) ) (\a: Bool .\b: Nat .b)) )) ) (( \f: Nat .((f (if true then false else false) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Bool .b)) ) (let u = ({a = (succ (((\x: Rec X. X .\y: Nat .x) 0 ) false)) , b = (let u = false in u) }.b) in ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (succ (let u = false in 0)) ))))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (( \f: Nat .((f (if true then true else false) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .b)) , b = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) ))
({a = (let u = (let u = (((\x: Nat .\y: Bool .y) true ) true) in u) in (((\x: Nat .\y: Unit .x) 0 ) false)) , b = (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Unit . ({a = 1 , b = true , c =  (pred 0) }.b) )) )) ) (let u = (case <l = (let u = false in 1) > as Nat of < l = x > => x | < r = y > => y) in (let u = (iszero 1) in u)) ) ) (\a: Rec X. X .\b: Bool .b)) }.a)
(if (case <r = (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ) ({a = false , b = (if false then true else false) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) then (((\x: Bool .\y: Unit .y) (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .a))) ) ({a = (let u = true in (unfold [ Nat ] (fold [ Rec X. X ] false ))) , b = ({a = true , b = false }.b) }.b)) else (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) in u))
(let u = (unfold [ Rec X. X ] (fold [ Unit ] (if (fix (\x: Bool . (((\x: Bool .\y: Bool .y) true ) false) )) then (if (iszero 0) then false else true) else (let u = (fix (\x: Bool . true )) in u)) )) in ({a = (((\x: Rec X. X .\y: Nat .x) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) (if false then false else false)) , b = (if (((\x: Bool .\y: Bool .x) true ) true) then (let u = 1 in false) else (((\x: Nat .\y: Bool .y) true ) true)) , c =  ({a = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 )) in u) , b = (((\x: Nat .\y: Unit .y) true ) (unfold [ Nat ] (fold [ Nat ] 0 ))) }.b) }.b))
(pred ({a = ({a = (case <l = (if true then 0 else 1) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (if true then 1 else 1) , b = (((\x: Nat .\y: Rec X. X .x) false ) false) , c =  (((\x: Unit .\y: Rec X. X .y) false ) 1) }.b) }.a) , b = (iszero (succ 0)) , c = ({a = ({a = (if false then 0 else 0) , b = (((\x: Unit .\y: Bool .y) ({a = 1 , b = false , c =  1 }.b) ) false) }.a) , b = ({a = ({a = 1 , b = true , c = 0 }.c) , b = ({a = 1 , b = false , c =  1 }.b) }.b) , c = (((\x: Nat .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) ({a = 1 , b = 1 }.b)) }.c) }.c))
(case <r = (((\x: Bool .\y: Nat .y) (if ({a = (if (let u = true in true) then false else ({a = true , b = 0 }.a)) , b = (let u = 0 in 0) }.a) then ({a = 1 , b = ({a = true , b = 1 }.a) }.b) else (unfold [ Unit ] (fold [ Nat ] ({a = 1 , b = false }.b) ))) ) (unfold [ Unit ] (fold [ Nat ] (let u = (iszero 0) in u) ))) > as Rec X. X of < l = x > => x | < r = y > => y)
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (fix (\x: Rec X. X . (pred (pred 0)) )) , b = (let u = (let u = 0 in false) in u) , c =  (unfold [ Rec X. X ] (fold [ Nat ] (if true then 1 else (let u = 1 in u)) )) }.b) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (if ({a = 0 , b = true }.b) then ({a = true , b = 0 }.a) else ({a = ({a = 0 , b = false }.b) , b = ({a = false , b = 1 }.a) }.b)) ))
(fix (\x: Rec X. X . (( \f: Bool .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Unit . false )) ) ) (\a: Bool .\b: Bool .a)) ))
(case <r = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) (((\x: Nat .\y: Bool .x) true ) true) ) ) (\a: Rec X. X .\b: Unit .a)) in u) )) > as Bool of < l = x > => x | < r = y > => y)
(succ ({a = ({a = 1 , b = 0 }.b) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.a))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] (fix (\x: Nat . (succ ({a = 1 , b = (iszero 1) }.a)) )) ))
(let u = (case <l = (succ (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) > as Bool of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Rec X. X .y) ({a = (((\x: Rec X. X .\y: Unit .y) (((\x: Bool .\y: Rec X. X .y) true ) false) ) (let u = true in 0)) , b = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) then ({a = ({a = true , b = 0 }.b) , b = ({a = true , b = false }.b) , c =  (succ 0) }.b) else (unfold [ Bool ] (fold [ Unit ] false ))) , c =  (((\x: Unit .\y: Bool .y) ({a = 1 , b = true }.b) ) 1) }.b) ) ({a = (((\x: Bool .\y: Bool .x) (if false then false else false) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) , b = (( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] 1 )) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Bool .b)) }.a)))
(fix (\x: Nat . (((\x: Nat .\y: Nat .y) ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = (((\x: Nat .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] ({a = true , b = 0 }.b) )) ) (iszero 1)) }.a) ) (let u = (fix (\x: Nat . (let u = (((\x: Rec X. X .\y: Rec X. X .x) true ) false) in ({a = false , b = 0 }.a)) )) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y))) ))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (if ({a = (fix (\x: Unit . 0 )) , b = (fix (\x: Unit . false )) , c =  ({a = false , b = 1 }.b) }.b) then (( \f: Unit .((f ({a = false , b = true }.b) ) (let u = (let u = true in true) in u) ) ) (\a: Bool .\b: Rec X. X .a)) else (let u = (((\x: Rec X. X .\y: Bool .x) true ) true) in (let u = false in true))) ))
(let u = (( \f: Unit .((f (let u = ({a = ({a = 1 , b = 1 }.b) , b = (let u = false in true) }.b) in (unfold [ Nat ] (fold [ Bool ] 0 ))) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) in u)
(iszero (fix (\x: Bool . (let u = (let u = 0 in u) in u) )))
(let u = (fix (\x: Bool . ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) , b = (let u = true in u) , c =  ({a = false , b = ({a = 1 , b = false , c = 1 }.c) }.b) }.b) )) in u)
({a = ({a = (succ ({a = true , b = (let u = true in 1) }.b)) , b = ({a = (((\x: Nat .\y: Unit .x) false ) true) , b = (let u = (let u = 1 in false) in u) }.b) , c = ({a = (( \f: Nat .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) ) (((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Nat .x) true ) false) ) (fix (\x: Nat . true ))) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (((\x: Nat .\y: Bool .x) (let u = ({a = false , b = 0 }.b) in 1) ) (let u = (if true then 0 else 0) in true)) }.b) }.c) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (iszero ({a = 1 , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) }.b)) )) , c =  (let u = ({a = (fix (\x: Unit . true )) , b = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Rec X. X ] false )) ) (unfold [ Unit ] (fold [ Nat ] 1 ))) }.b) in u) }.b)
(fix (\x: Bool . ({a = (case <r = (((\x: Rec X. X .\y: Bool .y) ({a = 0 , b = false , c =  0 }.b) ) true) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .x) ({a = false , b = false }.b) ) (let u = false in u)) ) ) (\a: Nat .\b: Bool .b)) }.b) ))
(fix (\x: Bool . (pred (( \f: Nat .((f (succ 1) ) 0 ) ) (\a: Bool .\b: Bool .a))) ))
(fix (\x: Nat . (( \f: Nat .((f (let u = ({a = 0 , b = 0 }.b) in 0) ) (pred ({a = false , b = 0 }.b)) ) ) (\a: Unit .\b: Bool .a)) ))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = ({a = ({a = 0 , b = (let u = false in 1) }.b) , b = (iszero 0) , c = (case <l = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) }.c) in u) ))
(( \f: Nat .((f (unfold [ Nat ] (fold [ Bool ] ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = (iszero 0) , c =  (((\x: Rec X. X .\y: Bool .y) ({a = false , b = true }.b) ) (let u = 0 in u)) }.b) )) ) (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (let u = 1 in ({a = false , b = 0 }.a)) )) in (let u = (iszero 0) in ({a = 0 , b = true }.b))) ) ) (\a: Unit .\b: Nat .b))
(( \f: Nat .((f ({a = (( \f: Unit .((f (iszero 0) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f ({a = 0 , b = (iszero 0) }.a) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) )) }.a) ) ({a = (pred (let u = ({a = 0 , b = (let u = 0 in false) }.a) in u)) , b = ({a = (unfold [ Nat ] (fold [ Bool ] (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = (((\x: Rec X. X .\y: Bool .x) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) ({a = true , b = false }.b)) }.a) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(iszero ({a = (succ ({a = 1 , b = 0 }.b)) , b = (((\x: Nat .\y: Bool .x) ({a = (fix (\x: Unit . 1 )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) }.b) ) (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) (let u = false in false) ) ) (\a: Bool .\b: Bool .b))) }.a))
(unfold [ Nat ] (fold [ Rec X. X ] (case <r = (let u = ({a = (let u = true in true) , b = (if false then true else true) }.b) in ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in 1) }.a)) > as Nat of < l = x > => x | < r = y > => y) ))
(( \f: Bool .((f (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] false )) )) in (case <r = (case <r = (if false then true else false) > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)) ) (if (let u = ({a = ({a = false , b = 0 }.b) , b = (let u = true in u) , c =  (let u = true in 0) }.b) in u) then (( \f: Nat .((f (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) in u) ) (let u = ({a = true , b = false }.b) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) else (unfold [ Unit ] (fold [ Unit ] (let u = ({a = true , b = 0 }.a) in u) ))) ) ) (\a: Unit .\b: Nat .b))
(case <l = (let u = ({a = (iszero (unfold [ Unit ] (fold [ Bool ] 0 ))) , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) }.b) in (if (( \f: Rec X. X .((f false ) (fix (\x: Unit . true )) ) ) (\a: Unit .\b: Unit .b)) then (case <l = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) > as Unit of < l = x > => x | < r = y > => y) else (if (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) false) in true) then ({a = 0 , b = true , c = 0 }.c) else (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a))))) > as Unit of < l = x > => x | < r = y > => y)
(if ({a = ({a = (let u = 1 in false) , b = (((\x: Nat .\y: Bool .y) false ) 1) }.a) , b = (fix (\x: Nat . (unfold [ Bool ] (fold [ Bool ] 0 )) )) }.a) then (if (((\x: Bool .\y: Nat .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Nat .\y: Nat .y) false ) false) )) ) (( \f: Rec X. X .((f (let u = ({a = 0 , b = false , c =  0 }.b) in ({a = true , b = 1 }.a)) ) (let u = 1 in false) ) ) (\a: Nat .\b: Unit .b))) then ({a = ({a = true , b = (unfold [ Unit ] (fold [ Bool ] 1 )) }.a) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.b) else (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) in u)) else (((\x: Unit .\y: Unit .y) (let u = false in u) ) (succ (let u = 0 in 0))))
(( \f: Nat .((f (((\x: Unit .\y: Bool .x) (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f ({a = false , b = true }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) ) (\a: Unit .\b: Unit .a)) ))) ) (let u = ({a = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .b)) , b = 1 }.b) in ({a = (fix (\x: Nat . 1 )) , b = (let u = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) in ({a = 0 , b = 0 }.b)) }.b)) ) ) (\a: Bool .\b: Bool .b))
(((\x: Nat .\y: Bool .y) (( \f: Unit .((f (iszero (let u = true in 1)) ) (((\x: Unit .\y: Rec X. X .x) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Rec X. X .\y: Nat .x) (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) in (((\x: Nat .\y: Rec X. X .x) true ) true)) ) (( \f: Bool .((f (let u = 0 in false) ) true ) ) (\a: Nat .\b: Nat .b))))
(fix (\x: Unit . (((\x: Nat .\y: Bool .x) ({a = (fix (\x: Bool . 0 )) , b = ({a = 1 , b = (unfold [ Nat ] (fold [ Bool ] false )) , c =  0 }.b) }.b) ) (let u = ({a = true , b = 1 }.a) in (unfold [ Nat ] (fold [ Nat ] (if true then true else false) )))) ))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = ({a = (((\x: Nat .\y: Unit .y) true ) 1) , b = (( \f: Unit .((f ({a = false , b = 0 }.a) ) (unfold [ Unit ] (fold [ Unit ] false )) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) in (let u = (let u = 1 in 1) in (iszero 1))) ))
(case <l = (((\x: Rec X. X .\y: Unit .x) (let u = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = true , c =  1 }.b) in ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Unit .x) 1 ) true) ))) ) (let u = ({a = (pred 0) , b = ({a = 0 , b = ({a = true , b = 0 }.a) , c =  1 }.b) , c = (let u = 1 in 0) }.c) in (( \f: Rec X. X .((f (let u = false in true) ) (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b))) ) ) (\a: Nat .\b: Rec X. X .a)))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Unit .y) (let u = (((\x: Nat .\y: Bool .x) (succ ({a = 0 , b = true , c = 1 }.c)) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) in (if (fix (\x: Nat . true )) then (iszero 1) else (if (let u = true in u) then ({a = true , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) }.b) else (fix (\x: Nat . (unfold [ Bool ] (fold [ Rec X. X ] true )) ))))) ) (let u = (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Unit .\y: Nat .y) true ) 1)) ) (let u = true in 1) ) ) (\a: Unit .\b: Unit .b)) in (((\x: Bool .\y: Unit .x) (let u = false in true) ) (iszero 0))))
(( \f: Nat .((f (let u = (( \f: Nat .((f true ) (unfold [ Unit ] (fold [ Unit ] true )) ) ) (\a: Nat .\b: Rec X. X .a)) in ({a = false , b = ({a = 0 , b = true }.b) }.b)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = ({a = true , b = false }.b) }.a) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = false , b = true }.b) ) (unfold [ Nat ] (fold [ Nat ] false ))) }.b) )) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (( \f: Bool .((f (let u = (fix (\x: Unit . false )) in u) ) (( \f: Unit .((f (let u = (let u = true in 0) in true) ) (case <r = (let u = true in false) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .a)) , b = (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = false , c =  (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) }.b) )) }.b)
(pred (((\x: Nat .\y: Bool .x) (( \f: Nat .((f (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) ) (((\x: Nat .\y: Rec X. X .x) 0 ) true) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (unfold [ Nat ] (fold [ Bool ] true ))))
({a = (let u = (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Nat .x) 0 ) false) )) in (let u = ({a = 0 , b = false , c = 1 }.c) in 0)) , b = (let u = (unfold [ Bool ] (fold [ Nat ] (let u = true in false) )) in u) , c = (if ({a = (unfold [ Unit ] (fold [ Unit ] 1 )) , b = (((\x: Unit .\y: Bool .y) true ) true) , c =  (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) }.b) then ({a = (pred 1) , b = 1 }.b) else ({a = 1 , b = false , c = ({a = true , b = 1 }.b) }.c)) }.c)
(if (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (((\x: Unit .\y: Bool .y) true ) 0) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) ))) )) ) (fix (\x: Nat . ({a = 0 , b = false }.b) ))) then (let u = ({a = (if false then true else false) , b = ({a = 0 , b = (iszero 0) , c =  1 }.b) }.b) in u) else (case <r = (if (if true then false else false) then true else false) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Bool .((f (let u = ({a = ({a = 0 , b = 0 }.b) , b = 1 }.b) in u) ) (if (let u = false in false) then (( \f: Bool .((f (let u = true in 0) ) ({a = 1 , b = false }.a) ) ) (\a: Unit .\b: Rec X. X .a)) else (if true then 0 else 1)) ) ) (\a: Unit .\b: Rec X. X .b))
(let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = (let u = true in (fix (\x: Bool . false ))) > as Nat of < l = x > => x | < r = y > => y) )) in (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Unit ] true )) )) > as Bool of < l = x > => x | < r = y > => y))
(fix (\x: Unit . (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f (( \f: Bool .((f ({a = 0 , b = (((\x: Bool .\y: Nat .y) true ) false) }.b) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Rec X. X .y) false ) false) ) (iszero 0)) ) ) (\a: Unit .\b: Unit .a)) ) (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .a)) , b = 0 }.a) ) ({a = (pred 1) , b = (let u = false in true) , c =  0 }.b) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Bool .\y: Rec X. X .x) (succ (if true then (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) else 0)) ) ({a = 1 , b = false , c =  ({a = 1 , b = 1 }.b) }.b))) ))
(succ (( \f: Bool .((f (let u = (unfold [ Nat ] (fold [ Nat ] 1 )) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 )) ))) ) ({a = (pred 1) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) ) (\a: Nat .\b: Bool .a)))
(let u = (( \f: Nat .((f ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a)) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) }.a) ) (( \f: Rec X. X .((f ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , c = (unfold [ Nat ] (fold [ Nat ] 1 )) }.c) ) (unfold [ Bool ] (fold [ Unit ] 1 )) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Unit .\b: Rec X. X .b)) in u)
(unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Bool .y) ({a = ({a = 0 , b = true , c =  0 }.b) , b = false }.b) ) (unfold [ Nat ] (fold [ Bool ] ({a = true , b = 1 }.a) ))) ))
(fix (\x: Nat . (( \f: Nat .((f (let u = (((\x: Unit .\y: Bool .x) 0 ) true) in u) ) (if (iszero ({a = false , b = 1 }.b)) then ({a = 1 , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) else (let u = ({a = true , b = 0 }.b) in u)) ) ) (\a: Rec X. X .\b: Nat .b)) ))
(pred (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .y) false ) 0) ) (( \f: Bool .((f (succ 1) ) (( \f: Unit .((f (((\x: Unit .\y: Unit .x) 0 ) true) ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Nat .\b: Unit .b)))
(let u = (( \f: Rec X. X .((f ({a = ({a = false , b = 1 }.b) , b = true , c =  0 }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) in u)
(if ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] true )) , c = ({a = 0 , b = false }.a) }.c) ) (((\x: Nat .\y: Bool .y) true ) false)) , b = ({a = ({a = true , b = 0 }.a) , b = (if true then 0 else 0) }.a) , c =  (succ ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) }.b) then (succ (case <l = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)) else (let u = (if ({a = (if false then 0 else 0) , b = ({a = false , b = true }.b) , c =  (((\x: Bool .\y: Unit .x) 1 ) false) }.b) then (((\x: Unit .\y: Rec X. X .x) true ) false) else (fix (\x: Bool . (iszero 0) ))) in (case <l = ({a = (fix (\x: Nat . 0 )) , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .a)) }.a) > as Bool of < l = x > => x | < r = y > => y)))
(case <l = (case <l = ({a = (iszero (let u = 0 in u)) , b = ({a = 1 , b = false , c = 0 }.c) }.b) > as Bool of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(let u = ({a = ({a = (((\x: Rec X. X .\y: Unit .x) false ) true) , b = (((\x: Unit .\y: Unit .x) 1 ) false) }.b) , b = (( \f: Nat .((f ({a = 1 , b = (((\x: Bool .\y: Unit .y) false ) false) }.b) ) (iszero 1) ) ) (\a: Nat .\b: Nat .a)) }.a) in (succ (if ({a = ({a = true , b = 1 }.b) , b = (iszero (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) }.b) then (let u = 1 in ({a = 0 , b = 0 }.b)) else (pred (pred (pred 0))))))
(( \f: Unit .((f ({a = (if (iszero ({a = (((\x: Unit .\y: Nat .x) 0 ) true) , b = (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) }.a)) then (( \f: Rec X. X .((f (if true then 1 else 0) ) (fix (\x: Unit . 1 )) ) ) (\a: Unit .\b: Rec X. X .b)) else (succ 1)) , b = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 1 , b = false }.a) )) , b = ({a = (let u = false in false) , b = (((\x: Rec X. X .\y: Bool .x) 0 ) false) }.a) , c = (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) )) }.c) }.b) ) (fix (\x: Unit . (fix (\x: Bool . ({a = (unfold [ Unit ] (fold [ Unit ] 0 )) , b = (unfold [ Unit ] (fold [ Nat ] 0 )) }.b) )) )) ) ) (\a: Bool .\b: Nat .a))
(unfold [ Nat ] (fold [ Nat ] (let u = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (pred (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) )) , b = (let u = (iszero 0) in u) }.a) in ({a = (( \f: Nat .((f (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .b)) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Bool .a)) , b = (if (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) then (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) else 0) }.a)) ))
({a = (unfold [ Bool ] (fold [ Bool ] (unfold [ Nat ] (fold [ Bool ] ({a = 1 , b = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) , c = ({a = 0 , b = false }.a) }.c) )) )) , b = (fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Unit ] ({a = ({a = (((\x: Bool .\y: Nat .x) 0 ) false) , b = (fix (\x: Nat . false )) , c =  0 }.b) , b = (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in false) }.b) )) )) }.a)
(((\x: Nat .\y: Nat .x) (((\x: Bool .\y: Unit .y) (case <r = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) in ({a = false , b = false }.b)) > as Bool of < l = x > => x | < r = y > => y) ) (let u = ({a = ({a = false , b = 1 }.b) , b = 1 }.b) in u)) ) (let u = (((\x: Bool .\y: Unit .x) ({a = (let u = 1 in 0) , b = (let u = false in u) , c = (let u = false in 0) }.c) ) (unfold [ Unit ] (fold [ Nat ] (iszero 1) ))) in ({a = ({a = true , b = 0 }.a) , b = ({a = true , b = 0 }.a) }.b)))
(case <r = (let u = (((\x: Nat .\y: Unit .y) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .b)) ) ({a = true , b = 1 }.a)) in ({a = (if true then true else false) , b = (let u = true in false) }.b)) > as Unit of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Nat ] (iszero (let u = (((\x: Nat .\y: Rec X. X .x) 1 ) false) in u)) ))
(succ ({a = (((\x: Unit .\y: Unit .x) (succ 0) ) (let u = false in u)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 1 )) , b = true }.b) )) }.a))
(let u = (let u = (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Nat .y) false ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = true in true)) in (((\x: Rec X. X .\y: Bool .x) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) (( \f: Nat .((f false ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)))) in ({a = (unfold [ Unit ] (fold [ Unit ] ({a = true , b = true }.b) )) , b = (((\x: Rec X. X .\y: Nat .y) (let u = ({a = 1 , b = false }.b) in u) ) (((\x: Nat .\y: Unit .x) (let u = true in 0) ) ({a = 0 , b = false }.b))) }.a))
(fix (\x: Nat . (case <l = (if (let u = (((\x: Bool .\y: Nat .x) 0 ) false) in false) then (( \f: Unit .((f 1 ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) else (let u = false in (let u = 1 in u))) > as Nat of < l = x > => x | < r = y > => y) ))
(( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) (iszero 1) ) (( \f: Bool .((f (succ 1) ) (let u = 1 in 1) ) ) (\a: Unit .\b: Nat .b))) ) (case <l = (((\x: Rec X. X .\y: Rec X. X .x) ({a = ({a = 1 , b = 1 }.b) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) ) (let u = false in false)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a))
(unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = ({a = 1 , b = true }.b) , b = (if true then (let u = 0 in 0) else 0) }.b) , b = (unfold [ Unit ] (fold [ Unit ] (fix (\x: Nat . false )) )) }.b) ))
(((\x: Bool .\y: Nat .x) (( \f: Bool .((f ({a = (if false then false else true) , b = ({a = 0 , b = false , c = 1 }.c) }.a) ) (((\x: Bool .\y: Nat .x) ({a = false , b = 0 }.a) ) (let u = false in true)) ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = (pred (let u = true in 1)) , b = ({a = (succ 1) , b = (let u = 0 in (case <r = true > as Nat of < l = x > => x | < r = y > => y)) }.b) , c =  (unfold [ Bool ] (fold [ Nat ] (((\x: Nat .\y: Bool .x) 0 ) false) )) }.b))
(let u = (let u = (unfold [ Bool ] (fold [ Bool ] (unfold [ Nat ] (fold [ Rec X. X ] 0 )) )) in u) in u)
(((\x: Nat .\y: Nat .y) (( \f: Bool .((f ({a = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a)) , b = (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = 1 }.b) ) (unfold [ Bool ] (fold [ Unit ] false ))) }.a) ) ({a = (((\x: Nat .\y: Bool .y) true ) 1) , b = ({a = 0 , b = false , c =  0 }.b) , c =  1 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) ) (((\x: Nat .\y: Nat .y) (((\x: Bool .\y: Bool .x) false ) true) ) ({a = ({a = (fix (\x: Unit . 1 )) , b = false , c = ({a = true , b = 1 }.b) }.c) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a)) }.a)))
(( \f: Unit .((f (( \f: Unit .((f (( \f: Unit .((f (let u = false in (((\x: Nat .\y: Unit .y) false ) 1)) ) (pred 1) ) ) (\a: Bool .\b: Bool .a)) ) (case <l = (unfold [ Nat ] (fold [ Bool ] (succ ({a = 1 , b = true , c = 0 }.c)) )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) ) (let u = (((\x: Bool .\y: Unit .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Bool ] 0 ))) in ({a = ({a = 0 , b = false }.a) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) }.b)) ) ) (\a: Nat .\b: Nat .a))
(let u = (case <r = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if true then true else false) )) ) ({a = (if true then false else true) , b = 0 }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) in (iszero (succ (unfold [ Nat ] (fold [ Bool ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) )))))
(let u = ({a = (( \f: Rec X. X .((f (let u = 0 in 0) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Unit .b)) , b = ({a = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = true }.a) , b = ({a = true , b = (((\x: Unit .\y: Nat .y) false ) false) }.b) , c =  ({a = ({a = 0 , b = true }.a) , b = (fix (\x: Rec X. X . 1 )) }.b) }.b) , c =  ({a = ({a = ({a = false , b = true }.b) , b = ({a = 1 , b = 0 }.b) }.b) , b = (( \f: Nat .((f (let u = false in 0) ) 0 ) ) (\a: Nat .\b: Bool .b)) }.b) }.b) in u)
({a = (pred (unfold [ Rec X. X ] (fold [ Nat ] (pred 1) ))) , b = (fix (\x: Nat . ({a = (let u = true in 1) , b = (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = 1 }.b) ) (let u = false in u)) }.b) )) }.b)
(let u = ({a = (let u = ({a = 1 , b = true }.b) in u) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) }.a) , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c) }.b) in u)
(fix (\x: Rec X. X . ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) )) )) ))
(iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = false in 0) , b = (( \f: Unit .((f 1 ) (((\x: Rec X. X .\y: Nat .y) false ) 0) ) ) (\a: Nat .\b: Rec X. X .b)) }.b) )))
(unfold [ Bool ] (fold [ Rec X. X ] (if (unfold [ Nat ] (fold [ Rec X. X ] (iszero 1) )) then (let u = ({a = 1 , b = true }.b) in (((\x: Rec X. X .\y: Rec X. X .y) false ) false)) else (iszero ({a = 1 , b = false , c = 1 }.c))) ))
(( \f: Unit .((f (case <l = (case <l = (unfold [ Rec X. X ] (fold [ Nat ] (succ 0) )) > as Nat of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f (case <l = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (((\x: Nat .\y: Unit .y) ({a = true , b = 1 }.a) ) (let u = 1 in 0)) }.b) > as Bool of < l = x > => x | < r = y > => y) ) (if ({a = ({a = 0 , b = true }.a) , b = false }.b) then (let u = 0 in u) else (let u = 1 in u)) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Bool .b))
(unfold [ Unit ] (fold [ Bool ] (let u = (if (fix (\x: Unit . true )) then (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) else 1) in ({a = (((\x: Unit .\y: Bool .y) true ) true) , b = (if false then 0 else 1) }.a)) ))
(pred ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) (fix (\x: Unit . 1 )) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a))) )) )))
(( \f: Unit .((f (if (iszero (unfold [ Unit ] (fold [ Nat ] 1 ))) then ({a = (let u = true in true) , b = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.a) else (let u = true in true)) ) (((\x: Rec X. X .\y: Unit .y) (let u = (let u = 0 in 0) in ({a = true , b = 0 }.a)) ) ({a = ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] 0 )) , b = false , c =  (let u = 1 in u) }.b) , b = (((\x: Rec X. X .\y: Nat .x) true ) false) }.b)) ) ) (\a: Bool .\b: Unit .a))
(fix (\x: Bool . (( \f: Rec X. X .((f ({a = (((\x: Unit .\y: Nat .y) (fix (\x: Nat . true )) ) (((\x: Nat .\y: Unit .y) ({a = 1 , b = false , c =  1 }.b) ) ({a = true , b = 1 }.a))) , b = (let u = (((\x: Unit .\y: Bool .y) false ) 1) in 0) }.a) ) (let u = (if ({a = false , b = 1 }.a) then false else ({a = false , b = false }.b)) in u) ) ) (\a: Unit .\b: Rec X. X .a)) ))
({a = (((\x: Bool .\y: Nat .y) (let u = (let u = false in u) in u) ) (let u = 0 in u)) , b = (( \f: Rec X. X .((f ({a = ({a = ({a = 1 , b = 1 }.b) , b = 0 }.b) , b = (let u = 0 in 1) }.b) ) ({a = (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] 0 )) ) (pred 1) ) ) (\a: Nat .\b: Nat .a)) , b = (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = 0 in u) ) ) (\a: Unit .\b: Nat .b)) }.b) ) ) (\a: Bool .\b: Unit .b)) }.b)
(unfold [ Bool ] (fold [ Unit ] (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Bool .((f (((\x: Unit .\y: Unit .x) false ) false) ) true ) ) (\a: Bool .\b: Nat .a)) )) > as Bool of < l = x > => x | < r = y > => y) ))
({a = (let u = (let u = (( \f: Rec X. X .((f (let u = 1 in false) ) ({a = 0 , b = true }.b) ) ) (\a: Bool .\b: Bool .a)) in u) in (if (((\x: Unit .\y: Nat .y) false ) true) then ({a = 0 , b = true }.b) else ({a = false , b = false }.b))) , b = ({a = (( \f: Unit .((f ({a = (fix (\x: Rec X. X . (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) )) , b = (iszero ({a = 0 , b = false , c = 0 }.c)) }.b) ) ({a = 0 , b = ({a = true , b = 0 }.a) , c =  1 }.b) ) ) (\a: Unit .\b: Nat .b)) , b = ({a = ({a = ({a = (fix (\x: Rec X. X . 1 )) , b = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) , c =  0 }.b) , b = ({a = 0 , b = 0 }.b) }.a) , b = (pred ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) }.a) }.b) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Nat .\y: Nat .y) (let u = ({a = 0 , b = 1 }.b) in (let u = true in u)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) ))) ))
({a = (let u = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = (( \f: Nat .((f (unfold [ Unit ] (fold [ Nat ] false )) ) (let u = false in false) ) ) (\a: Unit .\b: Nat .b)) , c = (if (let u = false in true) then (let u = (fix (\x: Rec X. X . 1 )) in (fix (\x: Bool . 0 ))) else (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b))) }.c) in ({a = (unfold [ Bool ] (fold [ Unit ] 0 )) , b = (((\x: Nat .\y: Unit .x) false ) false) }.a)) , b = (case <r = ({a = ({a = (fix (\x: Bool . 1 )) , b = ({a = true , b = 1 }.a) }.a) , b = (let u = (let u = (unfold [ Unit ] (fold [ Unit ] 0 )) in u) in (let u = (fix (\x: Rec X. X . true )) in (let u = 0 in true))) , c =  ({a = (if true then 1 else 1) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) , c = ({a = 0 , b = false }.a) }.c) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.a)
(((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Bool ] false )) )) ) (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = false , b = 0 }.a) )) in (let u = (let u = true in u) in u)) ) ) (\a: Nat .\b: Bool .b)) ) (let u = ({a = (let u = 0 in true) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 )) }.b) in u))
({a = (let u = (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .x) true ) true) )) in (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a))) , b = (( \f: Bool .((f (let u = ({a = true , b = true }.b) in ({a = true , b = 1 }.b)) ) (((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Unit .y) true ) 1) ) (let u = true in (((\x: Unit .\y: Nat .y) true ) true))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)
(let u = ({a = (fix (\x: Unit . (fix (\x: Rec X. X . 1 )) )) , b = (((\x: Rec X. X .\y: Unit .y) (let u = false in u) ) (if false then true else false)) , c = ({a = 1 , b = ({a = false , b = 1 }.b) }.b) }.c) in (if (let u = false in u) then (fix (\x: Unit . ({a = true , b = 1 }.b) )) else (((\x: Rec X. X .\y: Bool .x) ({a = true , b = (let u = 1 in u) }.b) ) ({a = true , b = false }.b))))
(( \f: Rec X. X .((f ({a = (case <l = (fix (\x: Unit . ({a = true , b = 1 }.b) )) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) in false) )) }.a) ) ({a = (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) in 0) , b = (case <r = (if false then false else true) > as Unit of < l = x > => x | < r = y > => y) , c = (let u = (((\x: Nat .\y: Nat .y) true ) (((\x: Unit .\y: Unit .x) 0 ) true)) in u) }.c) ) ) (\a: Bool .\b: Bool .a))
({a = (let u = ({a = ({a = 1 , b = true , c =  1 }.b) , b = 1 }.a) in u) , b = ({a = ({a = ({a = (if true then false else true) , b = ({a = 0 , b = false }.b) }.b) , b = ({a = (let u = false in u) , b = false }.b) }.b) , b = (case <r = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 )) in (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Bool ] true )) ))) > as Bool of < l = x > => x | < r = y > => y) }.b) }.b)
(( \f: Unit .((f ({a = ({a = ({a = true , b = 1 }.a) , b = (pred 1) }.a) , b = ({a = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (iszero 1) else false) , b = (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .y) true ) true) )) }.b) }.b) ) (fix (\x: Bool . ({a = true , b = 1 }.a) )) ) ) (\a: Unit .\b: Nat .b))
(let u = (unfold [ Unit ] (fold [ Bool ] ({a = (((\x: Bool .\y: Unit .x) true ) false) , b = ({a = false , b = true }.b) }.b) )) in (case <r = ({a = ({a = false , b = true }.b) , b = ({a = (if false then 1 else 1) , b = false , c =  (unfold [ Rec X. X ] (fold [ Bool ] 0 )) }.b) }.b) > as Unit of < l = x > => x | < r = y > => y))
(((\x: Bool .\y: Nat .y) (( \f: Unit .((f (iszero (let u = (succ 0) in (((\x: Unit .\y: Bool .x) 1 ) true))) ) (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Unit ] false )) )) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = (fix (\x: Nat . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = false }.b) )) )) , b = (((\x: Bool .\y: Unit .x) (let u = (((\x: Bool .\y: Unit .y) true ) 0) in u) ) (if (iszero 0) then (fix (\x: Nat . false )) else false)) }.b))
({a = (pred (let u = (((\x: Bool .\y: Rec X. X .y) false ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) in ({a = true , b = 1 }.b))) , b = (let u = (unfold [ Bool ] (fold [ Unit ] ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false )) , b = (let u = 0 in u) }.a) )) in u) , c =  (let u = ({a = true , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) }.a) in (case <l = ({a = 0 , b = false , c = (let u = true in 0) }.c) > as Bool of < l = x > => x | < r = y > => y)) }.b)
(( \f: Bool .((f (((\x: Bool .\y: Unit .x) ({a = false , b = (let u = 1 in 1) }.a) ) (fix (\x: Bool . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) )) ))) ) (((\x: Unit .\y: Unit .x) ({a = (let u = (pred 1) in 1) , b = (if true then true else true) , c =  ({a = 1 , b = 1 }.b) }.b) ) (((\x: Nat .\y: Unit .x) ({a = false , b = false }.b) ) (unfold [ Rec X. X ] (fold [ Unit ] false )))) ) ) (\a: Unit .\b: Unit .a))
(if (case <r = (( \f: Bool .((f ({a = 1 , b = true , c =  1 }.b) ) true ) ) (\a: Bool .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) then ({a = (let u = (( \f: Nat .((f false ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Rec X. X .\y: Bool .y) true ) 1)) , b = (case <l = (succ 0) > as Nat of < l = x > => x | < r = y > => y) }.b) else ({a = ({a = (fix (\x: Rec X. X . 0 )) , b = ({a = (if true then 0 else 0) , b = false , c = (let u = 0 in u) }.c) }.b) , b = ({a = ({a = (succ 0) , b = (let u = false in false) }.b) , b = (case <l = (((\x: Bool .\y: Nat .y) false ) 1) > as Unit of < l = x > => x | < r = y > => y) }.b) }.b))
(let u = ({a = (succ (if false then 0 else 0)) , b = (let u = (let u = 1 in false) in u) , c =  ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then 0 else 1) )) }.b) in u)
(((\x: Unit .\y: Unit .x) (iszero (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Unit .\y: Nat .x) 1 ) false) )) ))) ) (((\x: Unit .\y: Rec X. X .x) (let u = (iszero 1) in (((\x: Unit .\y: Rec X. X .x) true ) true)) ) (((\x: Bool .\y: Bool .x) (let u = true in u) ) (fix (\x: Rec X. X . (((\x: Unit .\y: Bool .y) false ) true) )))))
(if (((\x: Rec X. X .\y: Unit .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Nat . true )) )) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Rec X. X .\y: Unit .y) false ) false) ) (iszero 0))) then (( \f: Unit .((f (((\x: Unit .\y: Unit .y) ({a = (let u = 1 in true) , b = ({a = 1 , b = 0 }.b) }.a) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (iszero 0) ))) ) (unfold [ Unit ] (fold [ Bool ] ({a = 0 , b = (if true then false else false) }.b) )) ) ) (\a: Bool .\b: Bool .b)) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = (( \f: Unit .((f false ) (fix (\x: Unit . true )) ) ) (\a: Bool .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) )))
({a = (succ (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) in u)) , b = (iszero (let u = false in 1)) , c = ({a = (iszero ({a = 1 , b = true , c = 1 }.c)) , b = (unfold [ Unit ] (fold [ Bool ] (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (succ 1) )) ) ({a = true , b = ({a = 0 , b = true , c =  0 }.b) }.b)) )) }.b) }.c)
({a = (succ (succ (let u = (let u = 0 in (((\x: Rec X. X .\y: Unit .x) true ) false)) in (((\x: Bool .\y: Rec X. X .y) true ) 1)))) , b = (( \f: Bool .((f (if (let u = false in u) then (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a)) else ({a = true , b = 1 }.a)) ) (let u = ({a = (((\x: Nat .\y: Nat .y) false ) true) , b = true }.b) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c =  (pred ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) ))) }.b)
(( \f: Unit .((f ({a = (((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b))) , b = (( \f: Unit .((f 1 ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ) ({a = (if (let u = (if false then 1 else 0) in (let u = 0 in true)) then (let u = (let u = true in u) in u) else (fix (\x: Unit . ({a = false , b = 0 }.a) ))) , b = (succ (unfold [ Unit ] (fold [ Bool ] 1 ))) }.b) ) ) (\a: Rec X. X .\b: Bool .b))
({a = (( \f: Bool .((f (case <r = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = (( \f: Bool .((f (let u = true in u) ) (iszero 1) ) ) (\a: Bool .\b: Unit .b)) , c =  (( \f: Unit .((f 0 ) ({a = false , b = 1 }.b) ) ) (\a: Rec X. X .\b: Nat .a)) }.b) > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Bool ] ({a = ({a = 0 , b = true }.a) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) )) }.b) )) ) ) (\a: Unit .\b: Bool .b)) , b = (fix (\x: Rec X. X . (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a)
(pred (unfold [ Bool ] (fold [ Unit ] ({a = (case <l = (pred 0) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Rec X. X .\y: Nat .x) 1 ) true) , b = 0 }.b) }.b) )))
(if (((\x: Bool .\y: Rec X. X .y) (let u = ({a = true , b = 1 }.b) in false) ) (unfold [ Nat ] (fold [ Bool ] true ))) then ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (case <l = (if (unfold [ Rec X. X ] (fold [ Bool ] false )) then (succ (((\x: Nat .\y: Unit .x) 1 ) false)) else ({a = (let u = 0 in 1) , b = ({a = 0 , b = false , c =  1 }.b) }.a)) > as Nat of < l = x > => x | < r = y > => y) )) else ({a = (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in (pred 0)) , b = (((\x: Rec X. X .\y: Rec X. X .y) (fix (\x: Nat . true )) ) (let u = false in ({a = true , b = 1 }.b))) }.b))
(unfold [ Nat ] (fold [ Nat ] (( \f: Bool .((f (let u = (((\x: Rec X. X .\y: Bool .x) 1 ) true) in (((\x: Nat .\y: Unit .y) false ) false)) ) (iszero (let u = false in 0)) ) ) (\a: Nat .\b: Rec X. X .a)) ))
((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = (succ 0) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) , c =  (((\x: Unit .\y: Rec X. X .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) 0) }.b) }.b) ))
(case <r = ({a = (let u = ({a = 0 , b = true , c = 0 }.c) in (( \f: Unit .((f ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) false ) ) (\a: Rec X. X .\b: Unit .b))) , b = (fix (\x: Unit . (succ 0) )) }.a) > as Nat of < l = x > => x | < r = y > => y)
(if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (fix (\x: Bool . ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = true , c =  ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) }.b) )) )) then (let u = (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) in (let u = (((\x: Unit .\y: Bool .y) false ) 1) in (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)))) in u) else (case <r = ({a = (case <r = (let u = 0 in true) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (let u = 0 in true) , b = 0 }.b) }.a) > as Nat of < l = x > => x | < r = y > => y))
(iszero (let u = (pred (succ 0)) in (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = 1 }.b) ))))
({a = (((\x: Bool .\y: Unit .y) ({a = ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (let u = false in true) , c =  (let u = false in 1) }.b) , b = (let u = ({a = true , b = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.b) in (let u = 1 in 0)) }.a) ) (( \f: Unit .((f (let u = true in true) ) ({a = 1 , b = false }.b) ) ) (\a: Unit .\b: Nat .b))) , b = (case <r = (let u = true in false) > as Unit of < l = x > => x | < r = y > => y) }.b)
(((\x: Nat .\y: Rec X. X .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (case <r = (((\x: Nat .\y: Unit .y) (let u = false in false) ) true) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (let u = (let u = (let u = true in false) in false) in ({a = ({a = 0 , b = true }.a) , b = (unfold [ Rec X. X ] (fold [ Nat ] false )) }.b)))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (iszero (fix (\x: Rec X. X . (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ))) ))
(iszero (if (( \f: Rec X. X .((f ({a = 0 , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .a)) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) }.b) ) (let u = true in u) ) ) (\a: Bool .\b: Rec X. X .b)) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (succ (let u = true in 1)) )) else ({a = (let u = ({a = 0 , b = true , c = 0 }.c) in u) , b = (let u = 0 in u) }.b)))
(iszero ({a = ({a = (succ 0) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) , c = 0 }.c) , b = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = (let u = true in false) }.a) }.b))
(succ ({a = (((\x: Bool .\y: Rec X. X .y) (case <r = (let u = 0 in true) > as Nat of < l = x > => x | < r = y > => y) ) (if (let u = ({a = true , b = 0 }.a) in u) then ({a = 0 , b = 1 }.b) else ({a = 0 , b = true , c = 0 }.c))) , b = (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = 1 }.b) ) ({a = 0 , b = false , c =  0 }.b)) }.b))
({a = ({a = (if ({a = (((\x: Nat .\y: Bool .y) true ) 0) , b = ({a = 0 , b = false , c =  0 }.b) }.b) then (fix (\x: Unit . (succ 0) )) else (if (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Unit .b)) then 0 else 0)) , b = (case <r = (unfold [ Rec X. X ] (fold [ Unit ] true )) > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = (((\x: Bool .\y: Nat .x) (let u = 1 in u) ) false) in u) }.b) , b = (pred (let u = (let u = 1 in 1) in ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )))) }.b)
({a = ({a = (( \f: Unit .((f (iszero (fix (\x: Bool . 1 ))) ) ({a = ({a = false , b = 0 }.b) , b = true , c =  1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if ({a = true , b = true }.b) then (if false then false else false) else ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true ))) }.b) , b = (succ (((\x: Unit .\y: Rec X. X .y) ({a = ({a = false , b = 1 }.a) , b = (let u = 1 in false) }.b) ) (succ (let u = 0 in (((\x: Bool .\y: Bool .y) false ) 0))))) }.b)
((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = (if true then true else false) , c = (succ (((\x: Unit .\y: Bool .x) 0 ) false)) }.c) ) (unfold [ Bool ] (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Unit .b)) ))
(unfold [ Unit ] (fold [ Nat ] (iszero (((\x: Nat .\y: Unit .x) ({a = true , b = 1 }.b) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )))) ))
({a = ({a = (((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f (let u = 1 in false) ) false ) ) (\a: Bool .\b: Unit .b)) ) (let u = (unfold [ Nat ] (fold [ Nat ] true )) in ({a = false , b = true }.b))) , b = (( \f: Bool .((f ({a = ({a = 1 , b = false }.a) , b = (fix (\x: Bool . true )) , c = (((\x: Rec X. X .\y: Unit .y) false ) 1) }.c) ) (let u = (unfold [ Bool ] (fold [ Unit ] 1 )) in (fix (\x: Nat . (if false then 1 else 1) ))) ) ) (\a: Unit .\b: Rec X. X .a)) }.b) , b = ({a = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .b)) }.b) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) }.a) }.a)
(( \f: Nat .((f (case <l = (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in u) > as Bool of < l = x > => x | < r = y > => y) ) (succ (((\x: Unit .\y: Bool .y) ({a = true , b = 1 }.a) ) (pred 0))) ) ) (\a: Nat .\b: Rec X. X .a))
((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (if ({a = (unfold [ Nat ] (fold [ Unit ] false )) , b = ({a = 1 , b = ({a = false , b = 0 }.a) , c = ({a = 1 , b = false , c = 0 }.c) }.c) }.a) then (let u = (if ({a = 0 , b = true , c =  0 }.b) then (fix (\x: Nat . false )) else false) in (succ (pred 1))) else ({a = (succ (if ({a = true , b = 1 }.a) then 1 else ({a = true , b = 1 }.b))) , b = (let u = (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in 0) in (fix (\x: Nat . false ))) }.a)) ))
(((\x: Rec X. X .\y: Unit .x) (( \f: Nat .((f (iszero (case <l = (((\x: Bool .\y: Unit .y) true ) 0) > as Nat of < l = x > => x | < r = y > => y)) ) ({a = (((\x: Unit .\y: Nat .x) (case <r = ({a = false , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . false ))) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) }.b) ) ) (\a: Nat .\b: Bool .b)) ) (iszero (let u = ({a = (( \f: Rec X. X .((f (if false then 1 else 0) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (if true then false else true) , c =  (pred 0) }.b) in (pred (if true then 0 else 0)))))
(pred (((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Unit .x) ({a = 0 , b = (if true then false else false) }.b) ) ({a = (((\x: Unit .\y: Nat .x) true ) false) , b = (fix (\x: Nat . true )) }.b)) ) ({a = (let u = (((\x: Bool .\y: Nat .y) true ) 0) in u) , b = (if (let u = 1 in true) then (iszero 1) else (iszero 0)) }.a)))
(succ (let u = (let u = (let u = false in 1) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b))) in (((\x: Nat .\y: Nat .y) (((\x: Unit .\y: Unit .y) true ) true) ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))))
(( \f: Unit .((f (((\x: Nat .\y: Unit .x) ({a = (let u = (let u = 1 in 1) in false) , b = (((\x: Nat .\y: Nat .y) ({a = false , b = true }.b) ) (((\x: Rec X. X .\y: Nat .x) 0 ) false)) }.a) ) ({a = (iszero (unfold [ Unit ] (fold [ Bool ] 0 ))) , b = (((\x: Rec X. X .\y: Unit .y) false ) true) }.b)) ) (((\x: Nat .\y: Unit .x) (let u = true in u) ) (let u = (case <r = ({a = 1 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) in u)) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (( \f: Rec X. X .((f (let u = (if true then 1 else 1) in (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) in false)) ) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 0 , b = true , c = 1 }.c) )) , b = (let u = (let u = true in 1) in false) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) , b = (let u = (let u = 0 in u) in (let u = (fix (\x: Unit . 0 )) in (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)))) }.a)
({a = ({a = (let u = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) ) true ) ) (\a: Bool .\b: Rec X. X .a)) in (unfold [ Unit ] (fold [ Unit ] 1 ))) , b = (fix (\x: Rec X. X . (let u = false in u) )) }.b) , b = ({a = (let u = (case <l = ({a = 1 , b = true }.a) > as Rec X. X of < l = x > => x | < r = y > => y) in (let u = false in 0)) , b = (iszero (if true then ({a = 1 , b = 0 }.b) else (if false then 0 else 0))) , c = (pred (case <l = ({a = 1 , b = false }.a) > as Nat of < l = x > => x | < r = y > => y)) }.c) }.b)
(case <l = (fix (\x: Bool . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (let u = ({a = (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u) , b = ({a = 0 , b = 0 }.b) }.a) in (fix (\x: Nat . (let u = false in 1) ))) ) (if (((\x: Nat .\y: Unit .x) (( \f: Bool .((f true ) (let u = false in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a))) then (((\x: Bool .\y: Unit .y) (((\x: Unit .\y: Unit .x) true ) true) ) (succ 1)) else (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = false }.a) ))) ) ) (\a: Bool .\b: Bool .a))
(let u = (unfold [ Unit ] (fold [ Unit ] (case <l = (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) false ) 0) )) > as Unit of < l = x > => x | < r = y > => y) )) in (case <r = ({a = (unfold [ Rec X. X ] (fold [ Nat ] true )) , b = (((\x: Unit .\y: Nat .x) false ) true) }.b) > as Unit of < l = x > => x | < r = y > => y))
(iszero (fix (\x: Rec X. X . (((\x: Unit .\y: Unit .x) (((\x: Nat .\y: Unit .y) (let u = 0 in false) ) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) ) (( \f: Bool .((f false ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Unit .a))) )))
({a = (pred ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] false )) , b = (((\x: Unit .\y: Nat .x) 0 ) true) }.b)) , b = (((\x: Unit .\y: Unit .x) (( \f: Rec X. X .((f (let u = false in u) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Unit .\y: Bool .y) (((\x: Bool .\y: Rec X. X .x) false ) true) ) (( \f: Bool .((f false ) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) ) (\a: Bool .\b: Unit .a)))) }.a)
(((\x: Unit .\y: Unit .x) (((\x: Bool .\y: Unit .y) ({a = (let u = 0 in 0) , b = (iszero 1) , c =  (let u = 1 in u) }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .x) ({a = 0 , b = 1 }.b) ) true) ))) ) ({a = ({a = (let u = true in false) , b = 1 }.a) , b = (unfold [ Unit ] (fold [ Bool ] ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) )) }.b))
(case <l = (succ (succ ({a = 1 , b = false }.a))) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (fix (\x: Nat . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) )) , b = (( \f: Nat .((f ({a = (pred 0) , b = false }.b) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) ) (\a: Bool .\b: Unit .b)) , c =  (let u = false in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) }.b) , b = (let u = ({a = (let u = false in ({a = 1 , b = 0 }.b)) , b = (( \f: Rec X. X .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) ) 1 ) ) (\a: Bool .\b: Nat .a)) }.b) in u) }.b)
(let u = ({a = (( \f: Unit .((f ({a = ({a = 1 , b = 0 }.b) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.a) ) (((\x: Unit .\y: Unit .x) ({a = 0 , b = false }.a) ) (if false then false else false)) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (unfold [ Bool ] (fold [ Bool ] ({a = true , b = 0 }.a) )) }.b) in (((\x: Nat .\y: Nat .y) ({a = (let u = false in 1) , b = (fix (\x: Nat . true )) , c =  ({a = 0 , b = false , c = 0 }.c) }.b) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = 1 in u) ))))
(succ ({a = (unfold [ Unit ] (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] 1 )) )) , b = (( \f: Nat .((f (fix (\x: Nat . true )) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Bool .\b: Bool .a)) , c = (succ (case <l = ({a = 1 , b = false , c = 1 }.c) > as Nat of < l = x > => x | < r = y > => y)) }.c))
(((\x: Bool .\y: Rec X. X .x) ({a = ({a = ({a = 0 , b = (unfold [ Unit ] (fold [ Nat ] false )) }.a) , b = (unfold [ Bool ] (fold [ Nat ] false )) }.a) , b = ({a = (let u = false in 1) , b = ({a = false , b = false }.b) }.a) }.b) ) ({a = (let u = ({a = 0 , b = 1 }.b) in (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b))) , b = (if (if false then false else true) then true else true) }.b))
(if ({a = (succ ({a = 1 , b = 1 }.b)) , b = (let u = ({a = ({a = false , b = 0 }.b) , b = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .a)) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c) in (fix (\x: Nat . (case <r = false > as Unit of < l = x > => x | < r = y > => y) ))) }.b) then (((\x: Rec X. X .\y: Unit .y) ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = true in u) }.b) ) ({a = ({a = true , b = true }.b) , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) else ({a = (case <l = ({a = 0 , b = false }.a) > as Bool of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Bool .((f (((\x: Rec X. X .\y: Unit .x) true ) true) ) (((\x: Nat .\y: Bool .x) false ) true) ) ) (\a: Bool .\b: Bool .b)) in (let u = true in u)) , c =  ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) true ) true) , c = (let u = 0 in u) }.c) }.b))
({a = (if (iszero (pred 0)) then ({a = (iszero 1) , b = (if false then 1 else 0) }.b) else (succ (let u = 1 in u))) , b = ({a = (( \f: Unit .((f ({a = 0 , b = false , c = 1 }.c) ) (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in 0) ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = false , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) }.b) }.b) , c = (case <l = (( \f: Unit .((f (fix (\x: Rec X. X . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) ) (let u = ({a = 0 , b = true }.a) in (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Rec X. X of < l = x > => x | < r = y > => y) }.c)
(if ({a = (unfold [ Nat ] (fold [ Rec X. X ] (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) )) , b = (iszero (if true then 0 else 1)) }.b) then (if (if ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) then (let u = false in true) else true) then (( \f: Rec X. X .((f (let u = 1 in u) ) ({a = 1 , b = (let u = true in true) , c = (fix (\x: Unit . 0 )) }.c) ) ) (\a: Nat .\b: Rec X. X .b)) else (((\x: Bool .\y: Bool .y) true ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)))) else (succ ({a = (((\x: Nat .\y: Nat .x) true ) false) , b = (case <l = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) }.b)))
(succ (( \f: Rec X. X .((f (pred (unfold [ Nat ] (fold [ Nat ] 0 ))) ) (case <l = (let u = (let u = true in 1) in u) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b)))
(let u = ({a = (((\x: Nat .\y: Bool .x) (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) (fix (\x: Nat . true ))) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) )) }.b) in (((\x: Unit .\y: Nat .y) (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = 1 in false)) ) ({a = (((\x: Unit .\y: Rec X. X .x) 0 ) false) , b = ({a = (if false then 1 else 1) , b = (let u = (((\x: Rec X. X .\y: Unit .y) true ) 0) in true) }.b) }.a)))
(if ({a = (case <l = (((\x: Nat .\y: Bool .x) ({a = 1 , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) }.a) ) (case <r = (if false then false else true) > as Unit of < l = x > => x | < r = y > => y)) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ({a = (let u = false in false) , b = (let u = (let u = 0 in 0) in 1) }.a) ) ({a = (fix (\x: Nat . (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) , b = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) ) (\a: Nat .\b: Bool .b)) , c =  ({a = (( \f: Unit .((f 0 ) (pred 0) ) ) (\a: Bool .\b: Bool .b)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.b) }.b) then (((\x: Nat .\y: Unit .x) (let u = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = (let u = false in u) in (iszero 1))) ) ({a = (iszero (pred 1)) , b = ({a = 1 , b = (iszero 0) , c = ({a = 1 , b = false , c = 0 }.c) }.c) }.a)) else ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = ({a = 0 , b = false , c = 0 }.c) , b = (let u = (iszero 0) in u) }.b) )) , b = (( \f: Nat .((f (( \f: Rec X. X .((f false ) (let u = true in u) ) ) (\a: Nat .\b: Rec X. X .b)) ) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Bool .b)) }.b))
(succ ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (((\x: Bool .\y: Rec X. X .x) 0 ) true) in (unfold [ Nat ] (fold [ Nat ] 0 ))) )))
(succ (((\x: Nat .\y: Unit .y) (unfold [ Unit ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f (fix (\x: Rec X. X . false )) ) ({a = false , b = false }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) )) ) (((\x: Unit .\y: Nat .y) ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = false }.b) ) (( \f: Rec X. X .((f 0 ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Bool .b)))))
(((\x: Bool .\y: Nat .y) (((\x: Unit .\y: Rec X. X .x) (let u = false in false) ) (if true then (fix (\x: Unit . false )) else true)) ) (if (if ({a = true , b = (let u = false in u) }.b) then ({a = true , b = false }.b) else (let u = true in false)) then (unfold [ Unit ] (fold [ Rec X. X ] (pred 0) )) else ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 1 ))))
(fix (\x: Unit . (( \f: Unit .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .y) (if true then false else false) ) false) )) ) (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) ))
(( \f: Rec X. X .((f ({a = (let u = (unfold [ Unit ] (fold [ Rec X. X ] false )) in ({a = true , b = (if false then 0 else 0) }.b)) , b = ({a = (case <r = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Bool .b)) > as Bool of < l = x > => x | < r = y > => y) , b = (if (((\x: Nat .\y: Nat .x) false ) false) then true else (((\x: Rec X. X .\y: Unit .y) true ) false)) }.b) }.a) ) (( \f: Rec X. X .((f (let u = (let u = 1 in (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) in u) ) (succ (succ 0)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Unit .b))
(iszero (((\x: Bool .\y: Bool .x) (( \f: Nat .((f (( \f: Bool .((f 0 ) (unfold [ Nat ] (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Unit .a)) ) (succ 0) ) ) (\a: Nat .\b: Nat .a)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .y) ({a = 1 , b = true }.b) ) true) ))))
({a = (( \f: Rec X. X .((f (let u = ({a = 0 , b = ({a = false , b = 1 }.a) , c =  0 }.b) in (pred (pred 0))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = 1 , b = true , c = 0 }.c) in u) )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Unit .((f (succ ({a = 0 , b = true }.a)) ) (pred ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = false , c = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.c)) ) ) (\a: Bool .\b: Bool .b)) }.b)
(let u = (case <r = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .a)) )) > as Unit of < l = x > => x | < r = y > => y) in (let u = (let u = false in 0) in ({a = 0 , b = false }.b)))
(let u = (let u = (( \f: Nat .((f (( \f: Bool .((f 0 ) (let u = 0 in 1) ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = false in 0) ) ) (\a: Rec X. X .\b: Bool .a)) in (let u = false in u)) in u)
(succ (let u = (if ({a = 1 , b = true , c =  0 }.b) then (succ 0) else (if true then 0 else 1)) in (((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = 1 in false) )) ) (let u = (let u = 1 in 1) in (((\x: Nat .\y: Unit .x) 0 ) false)))))
(pred (( \f: Rec X. X .((f ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 0 , b = 1 }.b) )) , b = (if (let u = 1 in ({a = true , b = true }.b)) then (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) else ({a = 1 , b = false , c = 0 }.c)) }.b) ) ({a = ({a = 1 , b = true }.a) , b = (if true then false else false) , c = ({a = (succ 1) , b = ({a = 0 , b = true }.b) }.a) }.c) ) ) (\a: Unit .\b: Nat .a)))
({a = (let u = ({a = false , b = (succ 0) }.b) in (( \f: Bool .((f 1 ) (pred 1) ) ) (\a: Bool .\b: Rec X. X .a))) , b = (((\x: Unit .\y: Rec X. X .x) (let u = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Nat .a)) , b = 0 }.a) in u) ) ({a = (if true then 1 else 1) , b = (((\x: Nat .\y: Rec X. X .y) false ) true) , c =  (let u = 0 in 0) }.b)) }.a)
(fix (\x: Bool . ({a = (((\x: Rec X. X .\y: Bool .x) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .b)) ) ({a = true , b = 0 }.a)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Unit . false )) )) }.b) ))
(succ ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = (let u = 0 in false) in (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) )))
(((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Unit .x) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) , b = ({a = 1 , b = true }.a) }.a) )) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) ) (( \f: Rec X. X .((f (let u = false in false) ) (let u = true in false) ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .b))) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Nat ] (let u = ({a = 0 , b = 0 }.b) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) )) ) (fix (\x: Rec X. X . ({a = 1 , b = ({a = 1 , b = true }.b) , c =  0 }.b) )) ) ) (\a: Bool .\b: Bool .b)))
(let u = ({a = (if true then 1 else 1) , b = (unfold [ Rec X. X ] (fold [ Unit ] true )) , c = (succ 1) }.c) in u)
(let u = (unfold [ Bool ] (fold [ Unit ] (case <r = (((\x: Unit .\y: Nat .x) true ) false) > as Nat of < l = x > => x | < r = y > => y) )) in (( \f: Unit .((f (if (( \f: Unit .((f (let u = true in true) ) false ) ) (\a: Unit .\b: Rec X. X .a)) then (pred (succ 0)) else (((\x: Unit .\y: Rec X. X .y) (if false then false else false) ) 0)) ) (((\x: Rec X. X .\y: Nat .y) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) (( \f: Unit .((f ({a = 0 , b = 0 }.b) ) 0 ) ) (\a: Bool .\b: Rec X. X .b))) ) ) (\a: Rec X. X .\b: Nat .b)))
(pred (((\x: Bool .\y: Unit .y) (iszero (let u = (( \f: Nat .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) in u)) ) (pred (let u = false in 0))))
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (((\x: Bool .\y: Bool .y) ({a = (let u = 1 in u) , b = ({a = (let u = true in false) , b = true }.b) }.b) ) (let u = (pred 0) in u)) ))
(fix (\x: Unit . (( \f: Unit .((f (if (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Unit .y) true ) false) ) false) then ({a = 0 , b = true }.b) else (fix (\x: Nat . true ))) ) (fix (\x: Nat . ({a = (let u = true in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) , b = (((\x: Unit .\y: Bool .y) true ) (if false then 1 else 1)) }.a) )) ) ) (\a: Bool .\b: Nat .a)) ))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Nat ] ({a = (pred 0) , b = ({a = (((\x: Bool .\y: Unit .x) 0 ) false) , b = ({a = 0 , b = true , c =  0 }.b) , c =  0 }.b) }.a) )) ))
(if (let u = (iszero (( \f: Rec X. X .((f 1 ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Bool .\b: Unit .a))) in u) then (iszero (let u = (let u = (let u = 1 in 1) in u) in ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b))) else ({a = (pred (( \f: Rec X. X .((f ({a = 0 , b = false }.a) ) 0 ) ) (\a: Bool .\b: Bool .b))) , b = (((\x: Bool .\y: Bool .y) (fix (\x: Rec X. X . true )) ) (let u = 0 in false)) , c =  (let u = (((\x: Bool .\y: Rec X. X .y) false ) false) in ({a = (let u = 0 in 0) , b = 0 }.b)) }.b))
(let u = (let u = ({a = (if true then 1 else 0) , b = ({a = 0 , b = 1 }.b) }.b) in u) in ({a = (succ ({a = ({a = 1 , b = false , c =  1 }.b) , b = (let u = false in 0) }.b)) , b = (( \f: Rec X. X .((f (if (if true then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) else false) then (((\x: Bool .\y: Unit .x) true ) true) else ({a = false , b = true }.b)) ) (iszero 0) ) ) (\a: Rec X. X .\b: Unit .b)) }.b))
({a = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = (let u = true in true) , c =  (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) )) )) in ({a = (( \f: Unit .((f (fix (\x: Nat . false )) ) (( \f: Unit .((f (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) false ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) ) ({a = 0 , b = true }.a) ) ) (\a: Nat .\b: Rec X. X .b)) }.b)) , b = (iszero ({a = ({a = false , b = 0 }.b) , b = (let u = true in u) }.a)) }.b)
(let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (fix (\x: Unit . ({a = 0 , b = false , c =  1 }.b) )) in (pred 0)) )) in (fix (\x: Nat . ({a = 0 , b = (if true then true else false) }.b) )))
(((\x: Nat .\y: Bool .y) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .b)) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) }.b) )) ) ({a = ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (((\x: Nat .\y: Bool .x) true ) true) , c =  ({a = 1 , b = false , c = 0 }.c) }.b) , b = (pred ({a = 0 , b = false }.a)) }.a))
(( \f: Bool .((f (((\x: Bool .\y: Unit .y) ({a = (((\x: Nat .\y: Nat .y) true ) false) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] true )) }.b) ) ({a = 0 , b = true }.a)) ) (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f (let u = false in true) ) (((\x: Bool .\y: Nat .y) false ) false) ) ) (\a: Rec X. X .\b: Bool .b)) ) (pred (if (let u = true in true) then ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) else (((\x: Bool .\y: Bool .y) (fix (\x: Nat . false )) ) (unfold [ Unit ] (fold [ Unit ] 0 )))))) ) ) (\a: Unit .\b: Rec X. X .a))
({a = (unfold [ Unit ] (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) )) )) , b = (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = (((\x: Bool .\y: Rec X. X .x) true ) true) , c =  ({a = 0 , b = 0 }.b) }.b) )) )) , c = ({a = ({a = ({a = 0 , b = true , c =  1 }.b) , b = 1 }.b) , b = (let u = true in u) , c = (let u = (((\x: Nat .\y: Bool .x) 0 ) true) in (let u = 0 in u)) }.c) }.c)
(fix (\x: Unit . (fix (\x: Rec X. X . (succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) )) ))
(((\x: Nat .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Nat ] (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) )) ) (( \f: Rec X. X .((f (if (let u = 1 in (fix (\x: Rec X. X . false ))) then (unfold [ Nat ] (fold [ Unit ] (let u = true in false) )) else (let u = ({a = true , b = 1 }.b) in true)) ) (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) false ) false) )) ) (let u = ({a = 0 , b = true , c =  1 }.b) in u) ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .b)))
(( \f: Nat .((f (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Bool .\y: Rec X. X .y) ({a = 1 , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .b)) , c =  (succ 0) }.b) ) ({a = 0 , b = false }.b)) ) (case <l = (pred (let u = 1 in u)) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (succ ({a = 0 , b = 0 }.b)) ) ) (\a: Unit .\b: Bool .a))
({a = (let u = ({a = (((\x: Unit .\y: Nat .y) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] false )) ) (((\x: Unit .\y: Bool .x) 1 ) true)) , b = (let u = ({a = 0 , b = false }.a) in u) }.b) in (fix (\x: Rec X. X . (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .a)) ))) , b = (if (case <r = (let u = 0 in true) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Unit .((f (( \f: Bool .((f ({a = 1 , b = true , c = 1 }.c) ) (succ 0) ) ) (\a: Unit .\b: Bool .b)) ) (pred (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a))) ) ) (\a: Bool .\b: Nat .a)) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .x) 0 ) true) ))) }.b)
(let u = ({a = (let u = false in u) , b = (((\x: Bool .\y: Rec X. X .x) 0 ) (let u = 0 in false)) }.a) in ({a = (succ (unfold [ Nat ] (fold [ Nat ] (if false then 0 else 1) ))) , b = (unfold [ Nat ] (fold [ Nat ] (if false then true else false) )) }.a))
(let u = (((\x: Unit .\y: Bool .y) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) in (if false then (fix (\x: Bool . true )) else true)) ) ({a = 1 , b = ({a = false , b = false }.b) , c =  ({a = 1 , b = false , c = 1 }.c) }.b)) in (unfold [ Unit ] (fold [ Unit ] (fix (\x: Rec X. X . 0 )) )))
(succ (( \f: Unit .((f (((\x: Nat .\y: Nat .y) (let u = (succ 0) in (((\x: Nat .\y: Bool .x) true ) true)) ) ({a = (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) in u) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Nat .a)) }.a)) ) (let u = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) in (((\x: Bool .\y: Unit .y) (case <r = (if false then true else true) > as Bool of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)))) ) ) (\a: Rec X. X .\b: Unit .b)))
(((\x: Rec X. X .\y: Rec X. X .y) ({a = (fix (\x: Bool . (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) in u) )) , b = (case <r = (((\x: Bool .\y: Nat .y) false ) false) > as Unit of < l = x > => x | < r = y > => y) }.b) ) (let u = (let u = (let u = true in u) in (iszero 1)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (if true then 1 else 1) ))))
(case <l = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f (fix (\x: Nat . 1 )) ) 0 ) ) (\a: Nat .\b: Nat .b)) )) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Nat .\y: Rec X. X .y) (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Nat .y) ({a = 1 , b = false , c =  1 }.b) ) (( \f: Unit .((f (let u = 1 in true) ) false ) ) (\a: Nat .\b: Nat .a))) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Nat .x) false ) false) ) (let u = false in false) ) ) (\a: Bool .\b: Unit .a))) ) ({a = (fix (\x: Unit . (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) , b = (((\x: Bool .\y: Bool .x) (let u = false in u) ) ({a = 0 , b = ({a = 0 , b = true }.b) , c =  (fix (\x: Bool . 0 )) }.b)) , c =  (let u = ({a = 1 , b = false }.a) in u) }.b))
({a = ({a = (let u = (((\x: Unit .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Bool ] true )) ) (((\x: Unit .\y: Bool .x) false ) false)) in (let u = (iszero 0) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = (((\x: Bool .\y: Unit .y) true ) false) in (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a))) )) }.b) , b = ({a = (( \f: Nat .((f ({a = (((\x: Rec X. X .\y: Nat .x) 1 ) true) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c = ({a = 1 , b = false , c = 1 }.c) }.c) ) ({a = (let u = 0 in 0) , b = ({a = 1 , b = true }.b) , c = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) }.c) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (pred (((\x: Unit .\y: Rec X. X .y) true ) 1)) }.b) }.b)
(( \f: Nat .((f (let u = (let u = (let u = 0 in 1) in u) in u) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Bool .y) (let u = false in false) ) (let u = true in 1)) )) ) ) (\a: Rec X. X .\b: Bool .a))
({a = (fix (\x: Nat . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = (let u = true in false) , c = (if true then 1 else 1) }.c) )) )) , b = ({a = (( \f: Bool .((f 1 ) (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) , b = ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (let u = true in true) }.a) }.a) }.b) }.a)
(let u = (( \f: Bool .((f (pred (succ 1)) ) ({a = ({a = true , b = 1 }.a) , b = (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = 0 }.b) ) (((\x: Unit .\y: Nat .x) true ) true)) }.b) ) ) (\a: Nat .\b: Bool .a)) in (( \f: Bool .((f (fix (\x: Unit . (let u = false in u) )) ) (iszero (((\x: Bool .\y: Nat .x) 1 ) true)) ) ) (\a: Rec X. X .\b: Rec X. X .a)))
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) )) , b = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = false , b = false }.b) )) , b = (let u = false in u) }.b) }.a)
(if (unfold [ Rec X. X ] (fold [ Unit ] (let u = (iszero 1) in u) )) then (case <r = ({a = (succ 1) , b = (unfold [ Unit ] (fold [ Nat ] false )) , c =  (fix (\x: Unit . 1 )) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) else (let u = (pred (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Nat .y) false ) 1) ))) in ({a = (((\x: Nat .\y: Rec X. X .x) 0 ) false) , b = false , c =  ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.b)))
(( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Unit ] ({a = (succ (fix (\x: Rec X. X . 1 ))) , b = ({a = (let u = 0 in u) , b = ({a = 1 , b = false , c =  0 }.b) }.b) }.b) )) ) (fix (\x: Nat . (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .a)) in true) )) ) ) (\a: Nat .\b: Unit .a))
({a = ({a = (let u = (( \f: Rec X. X .((f 1 ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in u) , b = ({a = ({a = 1 , b = true }.a) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) }.b) , c = (((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f (let u = false in ({a = false , b = true }.b)) ) (if (unfold [ Unit ] (fold [ Bool ] false )) then (let u = false in true) else (iszero 0)) ) ) (\a: Bool .\b: Bool .a)) ) ({a = (((\x: Bool .\y: Bool .x) (((\x: Unit .\y: Unit .y) false ) 1) ) (let u = true in true)) , b = (let u = 1 in 1) }.b)) }.c) , b = (( \f: Rec X. X .((f ({a = true , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) ) (case <r = ({a = 0 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) }.b)
(((\x: Rec X. X .\y: Unit .x) (succ (((\x: Rec X. X .\y: Bool .y) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = false in u) )) ) (let u = false in ({a = 1 , b = true , c = 1 }.c)))) ) (let u = (((\x: Bool .\y: Rec X. X .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) in u))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (pred 1) )) , b = ({a = (let u = ({a = 0 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) }.a) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Rec X. X . false )) )) , c =  (let u = ({a = 0 , b = 1 }.b) in (((\x: Nat .\y: Nat .y) true ) (if false then 1 else 0))) }.b) }.a)
(case <l = (let u = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (((\x: Bool .\y: Unit .y) true ) 1) )) , b = (unfold [ Bool ] (fold [ Unit ] false )) , c = (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) )) }.c) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 1 , b = false , c = 0 }.c) ))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Unit .y) (( \f: Bool .((f (((\x: Nat .\y: Bool .y) ({a = (((\x: Unit .\y: Bool .x) true ) false) , b = (((\x: Nat .\y: Nat .y) ({a = false , b = 1 }.a) ) ({a = 1 , b = true , c =  1 }.b)) }.b) ) (let u = (((\x: Unit .\y: Bool .x) false ) false) in (let u = true in u))) ) ({a = (((\x: Nat .\y: Bool .x) (let u = true in u) ) false) , b = ({a = 0 , b = true , c =  0 }.b) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) ) (((\x: Unit .\y: Nat .y) (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) (if true then true else false) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false ))) )) ) (case <l = ({a = (succ 1) , b = (if true then 1 else 1) }.b) > as Nat of < l = x > => x | < r = y > => y)))
(let u = (( \f: Bool .((f ({a = (let u = (if ({a = true , b = false }.b) then (((\x: Bool .\y: Bool .y) true ) false) else false) in u) , b = (unfold [ Bool ] (fold [ Bool ] (( \f: Nat .((f 0 ) ({a = 0 , b = true }.a) ) ) (\a: Unit .\b: Rec X. X .b)) )) }.b) ) (((\x: Nat .\y: Unit .x) (( \f: Nat .((f (pred 0) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Nat .\b: Nat .a)) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true ))) ) ) (\a: Bool .\b: Bool .a)) in (unfold [ Unit ] (fold [ Rec X. X ] (let u = (((\x: Bool .\y: Rec X. X .y) (iszero 1) ) 1) in (fix (\x: Rec X. X . 1 ))) )))
({a = (let u = (let u = (((\x: Bool .\y: Rec X. X .y) ({a = false , b = true }.b) ) (((\x: Unit .\y: Unit .x) false ) false)) in (let u = false in 0)) in (((\x: Nat .\y: Unit .x) (let u = 1 in true) ) ({a = 1 , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false )) }.b))) , b = (case <r = (((\x: Unit .\y: Nat .x) ({a = (((\x: Nat .\y: Nat .x) 1 ) false) , b = false }.b) ) (if true then (((\x: Unit .\y: Unit .x) false ) false) else true)) > as Unit of < l = x > => x | < r = y > => y) }.b)
({a = (( \f: Rec X. X .((f (let u = (let u = 1 in u) in u) ) (pred ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] 0 ))) ) ) (\a: Unit .\b: Unit .a)) , b = (unfold [ Unit ] (fold [ Nat ] (case <l = ({a = 0 , b = false , c = 1 }.c) > as Unit of < l = x > => x | < r = y > => y) )) }.b)
(let u = ({a = (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) ) true ) ) (\a: Bool .\b: Bool .a)) )) , b = (((\x: Unit .\y: Bool .y) true ) (fix (\x: Rec X. X . 0 ))) }.a) in (case <l = (let u = ({a = 1 , b = false }.a) in u) > as Nat of < l = x > => x | < r = y > => y))
({a = (( \f: Nat .((f (( \f: Nat .((f ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .a)) , b = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) }.b) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .a)) ) ({a = ({a = 1 , b = (if true then 0 else 0) }.b) , b = (fix (\x: Unit . false )) , c = (unfold [ Unit ] (fold [ Nat ] 0 )) }.c) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (iszero (((\x: Unit .\y: Nat .y) (iszero 0) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )))) }.b)
(case <r = (fix (\x: Rec X. X . (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y)
(iszero ({a = (( \f: Unit .((f (let u = 0 in 0) ) (pred 1) ) ) (\a: Nat .\b: Unit .b)) , b = (( \f: Nat .((f (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Rec X. X .x) false ) (let u = false in u)) ) ) (\a: Bool .\b: Nat .a)) }.a))
(((\x: Bool .\y: Bool .x) (let u = ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .a)) }.b) in (fix (\x: Unit . ({a = ({a = false , b = 1 }.b) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) }.a) ))) ) ({a = ({a = (fix (\x: Nat . ({a = true , b = 1 }.a) )) , b = (if (if true then true else false) then false else ({a = 0 , b = true , c =  1 }.b)) }.b) , b = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Bool .a)) }.b) }.b))
(((\x: Bool .\y: Nat .x) (if ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) then ({a = (let u = true in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) , b = (( \f: Rec X. X .((f ({a = true , b = 1 }.b) ) (pred 1) ) ) (\a: Rec X. X .\b: Nat .a)) }.a) else (( \f: Bool .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ({a = 1 , b = true }.b) ) ) (\a: Bool .\b: Unit .a))) ) (( \f: Unit .((f (((\x: Nat .\y: Rec X. X .x) true ) true) ) (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) true ) true) )) in (unfold [ Bool ] (fold [ Nat ] false ))) ) ) (\a: Bool .\b: Unit .a)))
(( \f: Nat .((f (pred (let u = ({a = 1 , b = true , c = (((\x: Nat .\y: Nat .x) 0 ) false) }.c) in u)) ) (((\x: Nat .\y: Rec X. X .y) (fix (\x: Nat . ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) false ) false) )) )) ) (((\x: Unit .\y: Bool .y) true ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (( \f: Nat .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (succ 0) , b = false , c = 1 }.c) )) ) (( \f: Bool .((f (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) ) (((\x: Unit .\y: Bool .x) ({a = 0 , b = false , c = 1 }.c) ) (fix (\x: Nat . true ))) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Bool .\b: Nat .a)) in (let u = ({a = (succ (pred 1)) , b = ({a = true , b = true }.b) , c = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.c) in (case <l = ({a = 1 , b = 0 }.b) > as Bool of < l = x > => x | < r = y > => y)))
(let u = (let u = (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) in (((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .x) false ) false) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .a)))) in (iszero (((\x: Unit .\y: Unit .x) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) ) (if (unfold [ Unit ] (fold [ Bool ] false )) then true else true))))
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = ({a = false , b = 1 }.b) , b = (iszero (let u = 0 in 1)) }.a) ))
(case <l = ({a = ({a = (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in 0) , b = (let u = true in (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) , b = (succ ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 ))) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(iszero (let u = (pred (if (iszero 1) then 1 else (let u = 1 in 0))) in u))
(let u = ({a = (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (let u = 1 in u) , b = (let u = 0 in u) }.b) }.b) in u)
({a = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = ({a = 0 , b = true , c =  (let u = 0 in u) }.b) , c = (pred (let u = 0 in 1)) }.c) , b = (fix (\x: Unit . (let u = (fix (\x: Bool . ({a = 1 , b = 0 }.b) )) in (((\x: Unit .\y: Bool .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) ) false)) )) , c =  (unfold [ Nat ] (fold [ Unit ] (( \f: Nat .((f (let u = true in (((\x: Unit .\y: Nat .x) 1 ) false)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) )) }.b)
(let u = ({a = (fix (\x: Bool . (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) )) }.b) in (let u = (fix (\x: Rec X. X . 0 )) in u))
(( \f: Rec X. X .((f ({a = (( \f: Rec X. X .((f ({a = true , b = (let u = false in u) }.b) ) (fix (\x: Rec X. X . false )) ) ) (\a: Nat .\b: Nat .b)) , b = (( \f: Rec X. X .((f (((\x: Unit .\y: Bool .x) (iszero 0) ) false) ) (( \f: Unit .((f true ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Unit .b)) }.b) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Nat .((f ({a = 0 , b = true , c =  1 }.b) ) (iszero 0) ) ) (\a: Bool .\b: Bool .b)) )) ) ) (\a: Nat .\b: Nat .a))
(succ ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (if false then (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) else (let u = 0 in 1)) )))
(if ({a = (( \f: Nat .((f (fix (\x: Nat . 0 )) ) (succ (((\x: Nat .\y: Bool .x) 0 ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Nat .a)))) ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = (if (((\x: Bool .\y: Rec X. X .x) false ) true) then ({a = 0 , b = true }.b) else true) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = ({a = false , b = 0 }.a) }.a) )) }.a) }.b) then (let u = ({a = 1 , b = true }.a) in ({a = (((\x: Unit .\y: Bool .y) false ) 1) , b = (( \f: Bool .((f (succ 0) ) 1 ) ) (\a: Nat .\b: Nat .a)) }.b)) else (let u = (( \f: Bool .((f ({a = (fix (\x: Nat . 1 )) , b = (if false then (let u = 1 in true) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true ))) }.a) ) ({a = 0 , b = ({a = true , b = 0 }.a) }.a) ) ) (\a: Bool .\b: Nat .b)) in u))
({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = (let u = ({a = 1 , b = true , c = 0 }.c) in (let u = false in true)) in u) )) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] (let u = false in 0) )) )) }.a)
(let u = (if (( \f: Unit .((f ({a = 1 , b = ({a = 0 , b = true , c =  1 }.b) }.b) ) (let u = false in u) ) ) (\a: Nat .\b: Bool .a)) then (let u = (fix (\x: Bool . 0 )) in (fix (\x: Unit . false ))) else (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) in u)
(if (iszero (fix (\x: Bool . 0 ))) then (pred (((\x: Bool .\y: Rec X. X .y) (fix (\x: Bool . false )) ) (((\x: Rec X. X .\y: Bool .y) (let u = false in false) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 ))))) else ({a = (((\x: Bool .\y: Bool .y) (fix (\x: Bool . true )) ) (((\x: Bool .\y: Nat .x) false ) true)) , b = (if (let u = ({a = 1 , b = true , c = 0 }.c) in false) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) else ({a = false , b = 0 }.b)) }.b))
(((\x: Rec X. X .\y: Nat .x) (fix (\x: Rec X. X . (let u = (( \f: Nat .((f (let u = 0 in u) ) (fix (\x: Rec X. X . ({a = 0 , b = false }.a) )) ) ) (\a: Bool .\b: Rec X. X .b)) in (fix (\x: Nat . (fix (\x: Nat . false )) ))) )) ) ({a = ({a = (case <r = ({a = 0 , b = false , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f 0 ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) , b = (((\x: Unit .\y: Bool .x) (((\x: Rec X. X .\y: Unit .y) true ) false) ) (let u = (let u = true in true) in ({a = true , b = true }.b))) }.b))
(case <r = (fix (\x: Bool . (let u = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) ) true ) ) (\a: Nat .\b: Bool .b)) in ({a = false , b = true }.b)) )) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (((\x: Unit .\y: Unit .y) (( \f: Nat .((f (let u = true in u) ) ({a = ({a = 0 , b = 0 }.b) , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ) ({a = (( \f: Unit .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .b)) , b = (iszero (((\x: Rec X. X .\y: Nat .y) false ) 1)) }.b)) , b = (if (( \f: Rec X. X .((f (( \f: Nat .((f (iszero 1) ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Bool .a)) ) (if false then (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) else true) ) ) (\a: Rec X. X .\b: Bool .b)) then (iszero (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) else ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Bool ] true )) ))) }.b)
(( \f: Bool .((f ({a = ({a = (unfold [ Bool ] (fold [ Bool ] 1 )) , b = 1 }.b) , b = (let u = false in (let u = true in true)) }.a) ) (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f (let u = 0 in ({a = 0 , b = false }.a)) ) (let u = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) in (let u = (let u = false in u) in 1)) ) ) (\a: Bool .\b: Nat .b)) )) ) ) (\a: Bool .\b: Unit .b))
(case <l = (((\x: Bool .\y: Bool .y) (if ({a = true , b = false }.b) then ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] false )) else false) ) (succ (succ 1))) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . (( \f: Unit .((f (iszero (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b))) ) (fix (\x: Rec X. X . true )) ) ) (\a: Nat .\b: Unit .b)) ))
((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) )) ))
({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] (if true then 0 else 1) )) )) , b = (pred (case <l = (((\x: Bool .\y: Bool .x) 0 ) false) > as Unit of < l = x > => x | < r = y > => y)) }.b)
({a = ({a = ({a = (iszero (let u = 1 in u)) , b = (( \f: Rec X. X .((f (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) }.a) , b = ({a = (fix (\x: Nat . (((\x: Bool .\y: Rec X. X .y) true ) 1) )) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) ) ({a = true , b = false }.b) ) ) (\a: Nat .\b: Nat .a)) , c =  ({a = (((\x: Bool .\y: Bool .y) true ) 0) , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) , c = 0 }.c) }.b) }.b) , b = (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in u) }.a)
(iszero (let u = (((\x: Bool .\y: Nat .y) (((\x: Nat .\y: Rec X. X .x) (let u = (let u = 0 in 1) in (unfold [ Rec X. X ] (fold [ Bool ] false ))) ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b))) ) (( \f: Bool .((f (fix (\x: Bool . 0 )) ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) in (if (( \f: Bool .((f false ) (iszero 1) ) ) (\a: Bool .\b: Nat .a)) then (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) else ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b))))
(let u = (iszero (( \f: Bool .((f (((\x: Nat .\y: Bool .x) 0 ) (((\x: Nat .\y: Bool .y) true ) true)) ) (let u = 0 in 1) ) ) (\a: Unit .\b: Rec X. X .b))) in u)
(case <r = ({a = (let u = true in false) , b = (case <l = (let u = 0 in 1) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Bool ] (fold [ Unit ] (if (iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) then ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Rec X. X . false )) )) else ({a = (unfold [ Nat ] (fold [ Bool ] (fix (\x: Bool . 1 )) )) , b = ({a = 0 , b = (let u = false in u) , c =  0 }.b) }.b)) ))
(iszero (pred (( \f: Unit .((f (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Unit .x) 0 ) false) )) ) ({a = ({a = true , b = 0 }.b) , b = (let u = 0 in u) }.b) ) ) (\a: Unit .\b: Bool .b))))
(pred (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Bool .x) false ) ({a = 1 , b = true }.b)) ) (( \f: Bool .((f (succ 0) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Rec X. X .\b: Unit .a))))
(iszero (if (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )) in (if true then true else (((\x: Nat .\y: Rec X. X .y) true ) true))) then ({a = (pred 0) , b = (let u = false in (((\x: Bool .\y: Bool .x) false ) true)) }.a) else (( \f: Rec X. X .((f ({a = 0 , b = true , c = 1 }.c) ) (((\x: Nat .\y: Nat .x) 0 ) true) ) ) (\a: Rec X. X .\b: Bool .b))))
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (pred (((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) ({a = (let u = 0 in 1) , b = false , c =  (let u = false in 1) }.b)) ) (let u = (fix (\x: Bool . 1 )) in (succ (let u = 0 in 1))))) ))
(unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f (if ({a = 1 , b = false }.b) then (let u = 1 in 0) else ({a = 1 , b = true }.a)) ) ({a = 1 , b = (fix (\x: Unit . true )) , c = (if false then 0 else 1) }.c) ) ) (\a: Rec X. X .\b: Nat .b)) ))
(( \f: Rec X. X .((f (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) )) in u) ) (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Bool . (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) true) )) )) ) ) (\a: Nat .\b: Unit .b))
(unfold [ Rec X. X ] (fold [ Nat ] ({a = (((\x: Rec X. X .\y: Unit .y) (let u = ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.a) in (case <r = (let u = true in false) > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (if true then 1 else 0) , b = (fix (\x: Bool . (let u = 1 in u) )) }.b)) , b = (fix (\x: Nat . (iszero 0) )) }.a) ))
(case <l = ({a = (succ (( \f: Nat .((f 1 ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))) , b = ({a = (fix (\x: Unit . (fix (\x: Unit . false )) )) , b = (( \f: Bool .((f 1 ) ({a = 0 , b = false }.a) ) ) (\a: Nat .\b: Rec X. X .a)) }.a) , c = (succ (pred (let u = 0 in u))) }.c) > as Rec X. X of < l = x > => x | < r = y > => y)
(let u = ({a = (( \f: Nat .((f ({a = (let u = true in u) , b = ({a = (let u = true in 1) , b = (unfold [ Nat ] (fold [ Rec X. X ] 0 )) }.b) }.a) ) ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) }.a) ) ) (\a: Nat .\b: Bool .b)) , b = (fix (\x: Unit . (let u = ({a = 1 , b = true }.b) in ({a = 1 , b = true }.a)) )) }.a) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Bool .\y: Rec X. X .y) ({a = 1 , b = true , c =  1 }.b) ) ({a = true , b = true }.b)) )))
({a = (iszero (let u = (((\x: Nat .\y: Unit .y) (unfold [ Nat ] (fold [ Nat ] false )) ) (((\x: Unit .\y: Rec X. X .x) 1 ) true)) in ({a = (if (case <r = false > as Nat of < l = x > => x | < r = y > => y) then (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) else 1) , b = (((\x: Bool .\y: Unit .x) 0 ) false) }.b))) , b = ({a = ({a = true , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) }.b) , b = (case <l = ({a = true , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) }.a) }.b)
(let u = (if (fix (\x: Bool . false )) then (unfold [ Unit ] (fold [ Rec X. X ] (if true then 1 else 1) )) else ({a = 1 , b = true , c = (((\x: Unit .\y: Nat .x) 0 ) false) }.c)) in u)
(let u = (let u = (iszero (( \f: Nat .((f (fix (\x: Nat . 1 )) ) (let u = false in 0) ) ) (\a: Rec X. X .\b: Unit .a))) in (((\x: Rec X. X .\y: Unit .y) (fix (\x: Unit . false )) ) (if false then false else true))) in (unfold [ Unit ] (fold [ Bool ] ({a = (((\x: Nat .\y: Bool .y) (((\x: Rec X. X .\y: Nat .y) true ) true) ) false) , b = (let u = 1 in 0) }.b) )))
(case <l = (fix (\x: Rec X. X . (if (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Bool .a)) then (((\x: Rec X. X .\y: Bool .y) true ) 0) else (if ({a = 0 , b = false }.b) then ({a = 0 , b = 0 }.b) else 1)) )) > as Unit of < l = x > => x | < r = y > => y)
(iszero (unfold [ Bool ] (fold [ Unit ] (let u = (if false then (((\x: Bool .\y: Nat .y) false ) 1) else 1) in (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) )))
({a = (( \f: Bool .((f (( \f: Bool .((f (let u = 0 in 0) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) ) ) (\a: Rec X. X .\b: Bool .a)) ) (succ 0) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (((\x: Nat .\y: Unit .x) (let u = (let u = 0 in (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Nat .b))) in u) ) (if false then true else false)) }.a)
(if ({a = ({a = ({a = (let u = 1 in true) , b = (let u = 1 in 0) }.b) , b = (unfold [ Unit ] (fold [ Nat ] (let u = false in u) )) }.a) , b = (((\x: Unit .\y: Unit .y) (((\x: Bool .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) false) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) , c =  (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .x) 1 ) true) ) (pred 1) ) ) (\a: Unit .\b: Unit .a)) }.b) then (pred (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Nat .\y: Unit .x) 1 ) true) ))) else ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (if false then false else true) in false) )) , b = (( \f: Nat .((f ({a = ({a = 1 , b = 1 }.b) , b = (fix (\x: Bool . false )) }.a) ) ({a = (if false then 0 else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 ))) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) , c = (let u = 0 in u) }.c) ) ) (\a: Unit .\b: Bool .a)) }.b))
(if ({a = (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) ) (((\x: Bool .\y: Unit .x) false ) false) ) ) (\a: Bool .\b: Bool .b)) }.b) then (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in 0) )) ) ({a = (let u = (let u = 1 in u) in u) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c = (((\x: Nat .\y: Rec X. X .x) 1 ) true) }.c) ) ) (\a: Rec X. X .\b: Nat .a)) else (fix (\x: Unit . (case <l = (succ 1) > as Rec X. X of < l = x > => x | < r = y > => y) )))
(let u = (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Nat .\y: Unit .y) ({a = 1 , b = false }.b) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b))) )) in ({a = (( \f: Unit .((f (( \f: Nat .((f true ) (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Unit .\b: Rec X. X .b)) ) (((\x: Unit .\y: Bool .y) true ) false) ) ) (\a: Bool .\b: Bool .b)) , b = (case <r = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b))
(let u = (((\x: Bool .\y: Unit .y) (( \f: Rec X. X .((f (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) (if false then false else (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b))) ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Unit .\y: Rec X. X .y) true ) 1)) in ({a = (unfold [ Unit ] (fold [ Unit ] ({a = false , b = 1 }.b) )) , b = ({a = (let u = ({a = false , b = false }.b) in u) , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) }.b) , c = (unfold [ Rec X. X ] (fold [ Bool ] (succ (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a))) )) }.c))
({a = (unfold [ Nat ] (fold [ Bool ] ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (let u = 0 in true) }.a) )) , b = ({a = (let u = true in u) , b = (fix (\x: Bool . ({a = 1 , b = false }.b) )) }.b) , c = (( \f: Nat .((f (((\x: Bool .\y: Nat .x) (pred 1) ) false) ) ({a = 1 , b = ({a = false , b = false }.b) }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.c)
(( \f: Nat .((f (if (unfold [ Bool ] (fold [ Rec X. X ] (iszero ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 ))) )) then (let u = (let u = ({a = false , b = 0 }.b) in false) in ({a = true , b = true }.b)) else (let u = (if (((\x: Nat .\y: Nat .y) true ) false) then ({a = 1 , b = false }.a) else (unfold [ Unit ] (fold [ Bool ] 1 ))) in (fix (\x: Bool . false )))) ) (let u = (iszero (if true then 0 else 1)) in (iszero ({a = 0 , b = 0 }.b))) ) ) (\a: Unit .\b: Nat .b))
(let u = (let u = (fix (\x: Nat . (let u = false in ({a = false , b = 0 }.b)) )) in u) in ({a = ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = true , c =  0 }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) , b = (fix (\x: Unit . 1 )) }.b) , b = (let u = (let u = false in true) in u) , c = ({a = ({a = ({a = (((\x: Unit .\y: Unit .x) 0 ) true) , b = ({a = true , b = 0 }.b) }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) , c = (((\x: Bool .\y: Nat .y) true ) 0) }.c) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.b) }.c))
(let u = (if ({a = ({a = false , b = 0 }.a) , b = (pred 1) }.a) then ({a = ({a = 0 , b = false , c = 1 }.c) , b = (let u = false in u) }.a) else ({a = (((\x: Nat .\y: Nat .x) 1 ) true) , b = 0 }.b)) in (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = false in true) )) in u))
({a = (let u = (if ({a = (let u = 0 in 1) , b = false , c =  (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) then (succ 0) else (fix (\x: Nat . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ))) in (let u = (if true then true else true) in ({a = (let u = 0 in 0) , b = (if true then true else false) , c = 0 }.c))) , b = (succ (pred (let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false )) in (((\x: Unit .\y: Unit .y) false ) 1)))) }.b)
({a = (iszero (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f ({a = true , b = 1 }.b) ) 0 ) ) (\a: Bool .\b: Unit .a)) ))) , b = (if ({a = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Bool .\y: Bool .y) true ) true) }.b) , b = (( \f: Rec X. X .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 1 , b = 1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.a) then (if ({a = 0 , b = false , c =  1 }.b) then (let u = 1 in u) else (( \f: Rec X. X .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 0 )) ) (if ({a = true , b = false }.b) then (unfold [ Unit ] (fold [ Unit ] 1 )) else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Rec X. X .a))) else (let u = (let u = (if true then 0 else 1) in 1) in u)) }.b)
(let u = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = true , b = false }.b) )) , b = (((\x: Unit .\y: Nat .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) true ) 1)) }.a) in u)
(((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Unit ] ({a = 0 , b = true }.b) )) )) ) (unfold [ Unit ] (fold [ Bool ] (let u = (case <r = true > as Unit of < l = x > => x | < r = y > => y) in u) )))
(if (( \f: Bool .((f (case <r = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = (let u = false in u) }.b) )) ) ) (\a: Nat .\b: Unit .b)) then (((\x: Unit .\y: Rec X. X .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (fix (\x: Nat . 1 )) )) ) ({a = ({a = 0 , b = true }.a) , b = true }.b)) else ({a = (let u = (fix (\x: Unit . false )) in (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) , b = (succ (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ) (fix (\x: Unit . 1 )) ) ) (\a: Rec X. X .\b: Unit .a))) }.b))
(let u = ({a = ({a = (if (fix (\x: Nat . true )) then ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = true }.b) else (( \f: Bool .((f ({a = 1 , b = false }.b) ) false ) ) (\a: Nat .\b: Bool .a))) , b = (succ (fix (\x: Unit . 0 ))) }.a) , b = (case <r = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = 1 }.b) }.a) > as Nat of < l = x > => x | < r = y > => y) }.b) in (( \f: Bool .((f ({a = (((\x: Unit .\y: Bool .x) true ) true) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] 1 )) }.a) ) ({a = ({a = (pred 0) , b = (((\x: Nat .\y: Rec X. X .y) false ) true) , c = (let u = 1 in 0) }.c) , b = (iszero 0) , c =  ({a = true , b = 0 }.b) }.b) ) ) (\a: Nat .\b: Rec X. X .b)))
(let u = ({a = (case <l = ({a = ({a = false , b = 0 }.b) , b = (let u = 0 in true) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a) }.a) in u)
({a = ({a = ({a = (iszero 0) , b = (((\x: Unit .\y: Rec X. X .x) 1 ) true) }.b) , b = (((\x: Bool .\y: Rec X. X .y) ({a = (let u = true in 0) , b = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) ({a = (((\x: Bool .\y: Bool .y) true ) 1) , b = true , c =  1 }.b)) , c = (fix (\x: Unit . 1 )) }.c) , b = (fix (\x: Nat . (let u = (unfold [ Unit ] (fold [ Unit ] true )) in (iszero 1)) )) , c =  (fix (\x: Unit . (succ (unfold [ Unit ] (fold [ Bool ] 0 ))) )) }.b)
(succ (case <l = (((\x: Nat .\y: Nat .y) false ) (let u = 0 in 1)) > as Nat of < l = x > => x | < r = y > => y))
({a = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Unit .y) true ) 1) )) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = false in (unfold [ Unit ] (fold [ Nat ] true ))) )) }.b) , b = (case <l = (( \f: Rec X. X .((f (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) (succ (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a))) ) ) (\a: Bool .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(((\x: Unit .\y: Bool .x) (let u = ({a = true , b = false }.b) in ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) ))) ) ({a = (fix (\x: Bool . (fix (\x: Bool . true )) )) , b = (succ 1) }.a))
(unfold [ Nat ] (fold [ Nat ] (iszero ({a = (fix (\x: Rec X. X . (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) )) , b = (((\x: Bool .\y: Nat .y) (((\x: Bool .\y: Rec X. X .y) (let u = 0 in true) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false ))) ) (let u = true in 1)) }.b)) ))
((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ({a = (pred 1) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) }.a) , b = (iszero (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) }.b) ))
(let u = (let u = (fix (\x: Unit . ({a = false , b = 0 }.a) )) in u) in (( \f: Rec X. X .((f ({a = (pred ({a = 1 , b = false , c = 1 }.c)) , b = (case <l = (fix (\x: Rec X. X . 1 )) > as Nat of < l = x > => x | < r = y > => y) }.b) ) ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .b)) , b = ({a = (let u = true in u) , b = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.a) , c = (case <l = (succ (if false then 0 else 1)) > as Unit of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Unit .\b: Bool .a)))
(unfold [ Rec X. X ] (fold [ Rec X. X ] (case <l = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = true , c = 1 }.c) )) > as Nat of < l = x > => x | < r = y > => y) ))
({a = (fix (\x: Nat . ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = (fix (\x: Unit . 1 )) , b = (( \f: Bool .((f true ) (let u = 0 in true) ) ) (\a: Bool .\b: Unit .a)) }.a) )) )) , b = (fix (\x: Bool . (( \f: Unit .((f (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Unit .b)) )) , c =  (succ (case <l = ({a = (((\x: Unit .\y: Unit .y) false ) false) , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y)) }.b)
(((\x: Unit .\y: Nat .x) (let u = ({a = ({a = true , b = true }.b) , b = ({a = 0 , b = true }.a) }.b) in u) ) (((\x: Nat .\y: Bool .y) ({a = (let u = (let u = 1 in u) in 0) , b = ({a = 0 , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) true) , c =  0 }.b) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = true , c = 1 }.c) )) }.b) ) (case <r = (let u = true in false) > as Rec X. X of < l = x > => x | < r = y > => y)))
({a = (let u = ({a = (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) in (let u = true in 0)) , b = (case <l = (((\x: Bool .\y: Bool .x) 1 ) true) > as Nat of < l = x > => x | < r = y > => y) }.b) in (case <l = ({a = (if true then 0 else 1) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a)) }.a) > as Unit of < l = x > => x | < r = y > => y)) , b = (((\x: Unit .\y: Nat .x) (( \f: Unit .((f (pred 0) ) ({a = (if true then 1 else 0) , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) ) (let u = true in false)) }.b)
(let u = (pred (let u = (let u = true in 1) in 1)) in u)
(fix (\x: Nat . ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = 1 in 1) )) , b = (((\x: Unit .\y: Bool .x) (iszero 1) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false ))) }.a) ))
({a = (let u = ({a = ({a = 1 , b = true }.a) , b = true , c =  1 }.b) in (iszero ({a = false , b = 0 }.b))) , b = (let u = ({a = (fix (\x: Nat . (pred 0) )) , b = (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (fix (\x: Bool . (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) )) }.b) in ({a = (case <r = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (let u = 0 in 0) , b = ({a = 0 , b = false }.b) , c = 1 }.c) }.b)) }.b)
(pred (pred (case <l = (((\x: Bool .\y: Nat .x) 1 ) false) > as Unit of < l = x > => x | < r = y > => y)))
(((\x: Unit .\y: Bool .y) (if (fix (\x: Bool . ({a = ({a = true , b = true }.b) , b = false }.b) )) then ({a = (((\x: Nat .\y: Rec X. X .x) (( \f: Bool .((f 0 ) ({a = false , b = 1 }.b) ) ) (\a: Unit .\b: Bool .a)) ) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b))) , b = (fix (\x: Unit . true )) }.b) else (((\x: Rec X. X .\y: Bool .y) (let u = (fix (\x: Bool . false )) in u) ) (fix (\x: Unit . true )))) ) ({a = ({a = (let u = false in 0) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) }.b) , b = (let u = false in ({a = 1 , b = false }.b)) }.a))
(pred (if (case <r = (( \f: Rec X. X .((f (iszero 1) ) false ) ) (\a: Unit .\b: Unit .a)) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = (fix (\x: Nat . ({a = 1 , b = true , c = 0 }.c) )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) , c = (let u = true in 1) }.c) else (let u = 0 in u)))
(fix (\x: Bool . (case <l = ({a = 0 , b = (((\x: Bool .\y: Unit .x) true ) false) }.a) > as Nat of < l = x > => x | < r = y > => y) ))
(fix (\x: Nat . (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (pred 0) )) ) (unfold [ Unit ] (fold [ Nat ] ({a = (fix (\x: Unit . 0 )) , b = (if false then 1 else 1) }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
(let u = (case <r = ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) , b = ({a = 0 , b = false , c =  0 }.b) }.b) > as Nat of < l = x > => x | < r = y > => y) in ({a = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) )) , b = ({a = (let u = (unfold [ Bool ] (fold [ Unit ] 0 )) in ({a = 1 , b = 1 }.b)) , b = (if true then true else true) }.b) }.a) , b = (((\x: Bool .\y: Nat .x) (( \f: Unit .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) ) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) ) (\a: Rec X. X .\b: Bool .a)) ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) }.a))
({a = ({a = (let u = ({a = true , b = true }.b) in u) , b = (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (if false then false else false) )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (fix (\x: Nat . (( \f: Bool .((f (let u = (let u = 0 in 1) in (if true then 1 else 1)) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Unit .b)) )) }.b)
({a = (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ))) , b = (if (((\x: Rec X. X .\y: Unit .x) ({a = true , b = false }.b) ) (let u = false in false)) then (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = false , b = 0 }.b) ))) else (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in (fix (\x: Rec X. X . 1 )))) }.b)
(let u = (let u = (pred 1) in ({a = (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] 1 )) }.b)) in u)
(fix (\x: Rec X. X . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (( \f: Nat .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) ) ) (\a: Unit .\b: Unit .b)) )) ))
(pred (pred (unfold [ Rec X. X ] (fold [ Rec X. X ] (succ (if false then 1 else 1)) ))))
(( \f: Nat .((f (iszero (unfold [ Nat ] (fold [ Bool ] ({a = (fix (\x: Rec X. X . 0 )) , b = 1 }.b) ))) ) (( \f: Bool .((f (let u = 0 in (if false then true else true)) ) (let u = (let u = 1 in 1) in (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Nat .a))
({a = (case <r = (let u = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Rec X. X .b)) in ({a = false , b = false }.b)) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f (let u = (let u = false in false) in ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) , b = (( \f: Nat .((f 1 ) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ) (\a: Unit .\b: Rec X. X .a)) }.b)) ) ({a = (let u = (((\x: Bool .\y: Unit .y) false ) 1) in u) , b = (fix (\x: Unit . false )) , c = (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = 0 }.b) )) }.c) ) ) (\a: Unit .\b: Bool .b)) }.a)
(((\x: Bool .\y: Bool .x) (if ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .a)) }.b) then ({a = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) , b = false }.a) else (if (unfold [ Nat ] (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] false )) )) then ({a = (if true then 0 else 1) , b = 1 }.b) else (succ 1))) ) (let u = (((\x: Unit .\y: Rec X. X .x) (let u = false in u) ) true) in (let u = (let u = true in false) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] false )))))
(( \f: Bool .((f ({a = ({a = (((\x: Rec X. X .\y: Unit .x) true ) true) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.a) , b = (succ 1) }.b) ) ({a = ({a = (((\x: Nat .\y: Nat .x) 0 ) false) , b = (if true then 1 else 0) }.b) , b = (case <r = (unfold [ Unit ] (fold [ Rec X. X ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (succ (((\x: Nat .\y: Bool .x) 1 ) true)) }.c) ) ) (\a: Rec X. X .\b: Nat .b))
(((\x: Unit .\y: Nat .x) (iszero (case <l = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] 0 )) > as Bool of < l = x > => x | < r = y > => y)) ) ({a = ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (if true then 1 else 0) }.b) , b = (let u = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .b)) in ({a = 1 , b = true , c =  1 }.b)) , c =  (unfold [ Bool ] (fold [ Rec X. X ] 0 )) }.b))
({a = (succ (let u = (fix (\x: Nat . 1 )) in u)) , b = (iszero (let u = (let u = (((\x: Bool .\y: Unit .x) 0 ) false) in u) in u)) , c =  (case <l = (((\x: Nat .\y: Nat .y) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = 0 , b = false }.b) )) ) (pred (pred 1))) > as Unit of < l = x > => x | < r = y > => y) }.b)
(( \f: Unit .((f (let u = ({a = true , b = true }.b) in (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a))) ) (if (fix (\x: Unit . ({a = true , b = 0 }.a) )) then (unfold [ Unit ] (fold [ Nat ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )) else (((\x: Unit .\y: Unit .x) ({a = (unfold [ Rec X. X ] (fold [ Unit ] false )) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) }.b) ) ({a = (let u = false in true) , b = (pred 1) }.a))) ) ) (\a: Nat .\b: Bool .a))
({a = (fix (\x: Unit . (let u = (let u = ({a = true , b = 1 }.a) in (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) in (let u = false in 0))) in (( \f: Nat .((f (let u = 0 in u) ) (let u = 0 in 1) ) ) (\a: Nat .\b: Unit .b))) )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] (((\x: Unit .\y: Bool .x) (((\x: Unit .\y: Bool .x) true ) false) ) (fix (\x: Rec X. X . true ))) )) )) }.b)
(fix (\x: Unit . (( \f: Nat .((f ({a = (((\x: Unit .\y: Unit .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . 1 ))) , b = (let u = 0 in u) }.b) ) (let u = (((\x: Bool .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b)) )) ) (((\x: Bool .\y: Bool .x) true ) true)) in (let u = (unfold [ Nat ] (fold [ Nat ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) in u)) ) ) (\a: Unit .\b: Nat .b)) ))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = 0 }.b) ) ({a = (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = false , c = 1 }.c) )) , b = (unfold [ Nat ] (fold [ Unit ] true )) , c =  ({a = false , b = 1 }.b) }.b)) ))
(if ({a = (let u = (((\x: Rec X. X .\y: Nat .y) (((\x: Unit .\y: Rec X. X .x) true ) false) ) (let u = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) in 1)) in (succ (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)))) , b = (iszero (( \f: Unit .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b)) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Bool .\b: Bool .a))) , c =  ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = 1 , b = true }.a) )) }.b) then ({a = (if (let u = 0 in (((\x: Nat .\y: Unit .y) true ) false)) then (let u = (((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .x) true ) false) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a))) in u) else (let u = (fix (\x: Nat . false )) in u)) , b = (succ ({a = 1 , b = (unfold [ Nat ] (fold [ Nat ] false )) }.a)) }.a) else (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) )) in (if ({a = false , b = 0 }.a) then (((\x: Unit .\y: Unit .y) ({a = 0 , b = true }.b) ) false) else (unfold [ Rec X. X ] (fold [ Bool ] false )))))
({a = (let u = (case <r = (if false then false else true) > as Nat of < l = x > => x | < r = y > => y) in (let u = ({a = ({a = 0 , b = true , c = 1 }.c) , b = 1 }.b) in ({a = false , b = 1 }.b))) , b = (let u = (if ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] false )) then (if ({a = false , b = 1 }.a) then 1 else 0) else (fix (\x: Rec X. X . 1 ))) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = 0 }.b) ))) }.b)
({a = (let u = (iszero (succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )))) in ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) , b = (unfold [ Rec X. X ] (fold [ Nat ] true )) , c = (((\x: Rec X. X .\y: Bool .x) 1 ) true) }.c)) , b = ({a = (if (let u = true in u) then ({a = 1 , b = ({a = true , b = 1 }.a) }.b) else ({a = false , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.a)) , b = (let u = (((\x: Rec X. X .\y: Nat .x) 0 ) (let u = 0 in false)) in (fix (\x: Nat . 0 ))) }.a) }.b)
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (if (((\x: Bool .\y: Nat .y) (fix (\x: Nat . false )) ) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Nat .b))) then (fix (\x: Unit . true )) else ({a = ({a = 1 , b = false }.a) , b = (((\x: Nat .\y: Unit .x) true ) true) , c =  ({a = (if true then false else false) , b = 1 }.b) }.b)) ))
(((\x: Unit .\y: Bool .y) (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = true in u) )) in (((\x: Unit .\y: Unit .x) (iszero 0) ) ({a = 1 , b = false , c =  0 }.b))) ) (fix (\x: Bool . ({a = (((\x: Bool .\y: Bool .x) (let u = 1 in false) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true ))) , b = (pred 1) }.a) )))
({a = (unfold [ Bool ] (fold [ Unit ] (case <l = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) > as Bool of < l = x > => x | < r = y > => y) )) , b = ({a = (case <r = ({a = ({a = 1 , b = false }.a) , b = true , c =  0 }.b) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (if (((\x: Bool .\y: Bool .x) false ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a))) then ({a = false , b = 1 }.a) else ({a = 0 , b = true }.b)) , b = (pred (unfold [ Nat ] (fold [ Unit ] 1 ))) }.b) }.a) , c = (((\x: Unit .\y: Nat .y) ({a = (let u = 0 in 1) , b = (if true then true else true) , c =  (pred 0) }.b) ) ({a = (let u = false in false) , b = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b)) }.c)
({a = ({a = ({a = (((\x: Rec X. X .\y: Bool .y) (unfold [ Nat ] (fold [ Rec X. X ] false )) ) 0) , b = (let u = false in u) , c =  (succ ({a = 1 , b = false }.a)) }.b) , b = (((\x: Unit .\y: Unit .x) ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = ({a = true , b = 0 }.a) }.a) ) (let u = (((\x: Rec X. X .\y: Bool .x) true ) true) in true)) }.b) , b = ({a = ({a = (fix (\x: Nat . (unfold [ Nat ] (fold [ Nat ] 0 )) )) , b = (let u = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] true )) ) (let u = true in true) ) ) (\a: Rec X. X .\b: Unit .b)) in (let u = true in (iszero 0))) , c = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (unfold [ Unit ] (fold [ Unit ] 1 )) )) }.c) , b = (unfold [ Unit ] (fold [ Nat ] (fix (\x: Unit . (((\x: Nat .\y: Nat .y) false ) true) )) )) , c = (let u = (let u = true in ({a = 0 , b = true }.b)) in (((\x: Bool .\y: Bool .y) false ) 1)) }.c) }.b)
(( \f: Bool .((f (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (((\x: Unit .\y: Unit .x) (if true then 0 else 0) ) (fix (\x: Bool . false )))) ) (let u = ({a = (let u = true in u) , b = (if true then false else false) }.b) in ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) , b = (fix (\x: Rec X. X . false )) , c = 0 }.c)) ) ) (\a: Bool .\b: Bool .b))
({a = (( \f: Unit .((f ({a = 0 , b = false , c = ({a = 1 , b = 0 }.b) }.c) ) ({a = (fix (\x: Nat . 1 )) , b = ({a = true , b = 1 }.a) , c = (( \f: Unit .((f 1 ) (((\x: Rec X. X .\y: Nat .x) 0 ) true) ) ) (\a: Bool .\b: Unit .b)) }.c) ) ) (\a: Unit .\b: Unit .a)) , b = (unfold [ Bool ] (fold [ Nat ] ({a = ({a = (let u = 0 in false) , b = ({a = true , b = 1 }.b) }.b) , b = ({a = ({a = 1 , b = false , c =  0 }.b) , b = 0 }.a) , c = (( \f: Nat .((f ({a = 0 , b = false }.a) ) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ) (\a: Bool .\b: Bool .a)) }.c) )) }.b)
({a = (((\x: Unit .\y: Bool .y) (let u = (let u = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) in (pred 1)) in (if (iszero 1) then (((\x: Nat .\y: Bool .x) false ) false) else (iszero 0))) ) ({a = (pred 0) , b = ({a = (((\x: Rec X. X .\y: Nat .x) false ) true) , b = (unfold [ Unit ] (fold [ Nat ] (if true then false else false) )) }.b) , c =  (case <l = (let u = (if false then 0 else 0) in u) > as Nat of < l = x > => x | < r = y > => y) }.b)) , b = ({a = (case <l = (let u = 1 in 0) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (iszero (fix (\x: Nat . 1 ))) , c =  (succ (if false then 1 else 0)) }.b) }.b)
(case <r = (if (let u = (let u = 0 in false) in true) then (( \f: Nat .((f ({a = ({a = true , b = true }.b) , b = 1 }.a) ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .b)) ) ) (\a: Unit .\b: Rec X. X .b)) else ({a = (iszero 1) , b = (((\x: Unit .\y: Rec X. X .y) false ) 1) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y)
({a = (if ({a = (let u = (let u = 1 in u) in u) , b = (if (iszero 1) then (( \f: Nat .((f (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) else (let u = 1 in true)) , c =  ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) )) }.b) then ({a = (succ 0) , b = (let u = 1 in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) }.b) else ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 1 )) )) , b = (let u = false in true) }.b)) , b = ({a = (succ (let u = (let u = true in 0) in u)) , b = (fix (\x: Unit . (unfold [ Bool ] (fold [ Unit ] false )) )) }.a) }.b)
((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (let u = (if (case <r = false > as Unit of < l = x > => x | < r = y > => y) then (fix (\x: Bool . (if true then false else true) )) else ({a = 0 , b = true }.b)) in u) ))
(succ (((\x: Bool .\y: Nat .y) ({a = ({a = (let u = false in u) , b = ({a = 0 , b = true , c = 0 }.c) }.a) , b = ({a = 0 , b = true , c =  1 }.b) }.b) ) (pred ({a = 0 , b = true , c = 0 }.c))))
(let u = (if (((\x: Unit .\y: Nat .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = true , b = 1 }.a) )) ) (fix (\x: Rec X. X . true ))) then (case <r = (fix (\x: Nat . false )) > as Unit of < l = x > => x | < r = y > => y) else (( \f: Unit .((f (((\x: Bool .\y: Nat .y) true ) true) ) (iszero 1) ) ) (\a: Nat .\b: Bool .a))) in u)
(let u = (((\x: Bool .\y: Unit .y) ({a = ({a = 0 , b = false }.a) , b = ({a = 0 , b = true , c =  0 }.b) , c =  1 }.b) ) (fix (\x: Unit . (iszero 1) ))) in u)
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (succ (let u = (((\x: Bool .\y: Nat .y) true ) (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) in (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true))) ))
(let u = (( \f: Rec X. X .((f (iszero ({a = true , b = 1 }.b)) ) ({a = ({a = 0 , b = (if true then true else false) }.b) , b = (iszero ({a = 0 , b = true , c = 0 }.c)) }.b) ) ) (\a: Bool .\b: Nat .a)) in ({a = (( \f: Bool .((f (succ 1) ) ({a = 0 , b = true }.a) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (( \f: Rec X. X .((f (let u = false in u) ) (((\x: Bool .\y: Nat .y) true ) true) ) ) (\a: Bool .\b: Bool .b)) , c =  ({a = (let u = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) in 0) , b = (let u = false in true) , c = (fix (\x: Bool . 1 )) }.c) }.b))
(succ (succ (if true then (let u = 0 in u) else (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)))))
(succ (( \f: Nat .((f (succ ({a = 1 , b = false }.a)) ) ({a = (fix (\x: Nat . 1 )) , b = ({a = false , b = 0 }.b) }.b) ) ) (\a: Unit .\b: Unit .a)))
(let u = ({a = (( \f: Nat .((f ({a = 1 , b = false , c = 1 }.c) ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .a)) , b = (( \f: Unit .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true )) ) (let u = 0 in false) ) ) (\a: Bool .\b: Nat .b)) , c =  (if (let u = (iszero 1) in u) then (( \f: Bool .((f 1 ) (fix (\x: Bool . 1 )) ) ) (\a: Nat .\b: Bool .b)) else (if (fix (\x: Nat . true )) then (let u = false in 1) else (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y))) }.b) in u)
(( \f: Bool .((f (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Bool ] (fold [ Unit ] ({a = false , b = 0 }.b) )) )) ) (unfold [ Unit ] (fold [ Unit ] ({a = ({a = 0 , b = false , c = 0 }.c) , b = true }.a) )) ) ) (\a: Rec X. X .\b: Nat .a))
(let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f ({a = (succ 1) , b = ({a = 0 , b = true }.b) , c = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.c) ) (((\x: Nat .\y: Nat .y) true ) 0) ) ) (\a: Bool .\b: Rec X. X .a)) )) in (case <l = ({a = (unfold [ Bool ] (fold [ Nat ] false )) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) > as Nat of < l = x > => x | < r = y > => y))
(( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] (if ({a = (let u = false in u) , b = (let u = 0 in true) }.b) then (case <l = (pred 1) > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = ({a = 1 , b = false }.a) , b = (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b)) )) ) (((\x: Unit .\y: Nat .x) ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) , b = (let u = 1 in 1) }.b) ) (unfold [ Unit ] (fold [ Nat ] (let u = (let u = 1 in false) in u) ))) ) ) (\a: Bool .\b: Nat .a))
(let u = (unfold [ Unit ] (fold [ Bool ] (fix (\x: Nat . (let u = true in true) )) )) in (pred (( \f: Unit .((f ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] 1 )) , b = (let u = false in u) , c = 1 }.c) ) ({a = (let u = 1 in false) , b = (if false then 0 else 0) }.b) ) ) (\a: Bool .\b: Bool .b))))
(case <r = ({a = (let u = (let u = true in 0) in u) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) }.b) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Bool . ({a = ({a = ({a = ({a = true , b = 0 }.a) , b = false }.b) , b = (((\x: Nat .\y: Rec X. X .x) 1 ) (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b))) }.a) , b = ({a = ({a = (case <l = (let u = 0 in u) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (((\x: Bool .\y: Rec X. X .x) 1 ) false) )) }.b) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) , c =  (succ (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) }.b) }.b) ))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] ({a = (pred (pred 1)) , b = (( \f: Rec X. X .((f (( \f: Unit .((f (fix (\x: Unit . false )) ) false ) ) (\a: Bool .\b: Unit .b)) ) ({a = (let u = false in u) , b = true }.b) ) ) (\a: Rec X. X .\b: Nat .a)) , c =  (pred ({a = 1 , b = 1 }.b)) }.b) ))
(unfold [ Unit ] (fold [ Unit ] (iszero ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 1 , b = true , c = 0 }.c) ))) ))
(((\x: Unit .\y: Rec X. X .x) (if (iszero ({a = true , b = 1 }.b)) then ({a = (pred 1) , b = (pred 1) }.b) else ({a = (unfold [ Nat ] (fold [ Bool ] ({a = 1 , b = 0 }.b) )) , b = ({a = true , b = false }.b) , c = ({a = 0 , b = true }.a) }.c)) ) ({a = (let u = ({a = true , b = true }.b) in (fix (\x: Unit . 1 ))) , b = (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Nat .y) true ) false) ) (iszero 1)) ) (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Nat ] (fold [ Nat ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ))) ) ) (\a: Nat .\b: Unit .b)) , c =  ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , c = ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = false , c = 1 }.c) }.c) }.b))
(let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) ({a = true , b = 1 }.a) ) ({a = 0 , b = false , c =  1 }.b)) )) in (if ({a = (succ 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true )) }.b) then (if (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (let u = false in true) )) > as Unit of < l = x > => x | < r = y > => y) then (fix (\x: Nat . (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) )) else (let u = 0 in u)) else ({a = (case <r = (unfold [ Nat ] (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (succ 1) , b = false , c = 1 }.c) }.b)))
({a = ({a = (pred (((\x: Bool .\y: Rec X. X .y) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) 0)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in u) )) , c = (( \f: Nat .((f (let u = (fix (\x: Rec X. X . 1 )) in u) ) (let u = (if true then 0 else 1) in u) ) ) (\a: Bool .\b: Nat .b)) }.c) , b = (( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = false }.b) )) ) ({a = ({a = 1 , b = false , c = 1 }.c) , b = (((\x: Unit .\y: Nat .x) true ) false) , c =  (((\x: Unit .\y: Unit .x) 0 ) ({a = 1 , b = false }.b)) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) }.a)
({a = (let u = (((\x: Bool .\y: Rec X. X .x) (iszero 0) ) ({a = 1 , b = true }.b)) in u) , b = (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Unit ] (iszero 1) )) )) }.b)
(let u = (let u = ({a = (iszero 0) , b = ({a = 0 , b = true }.b) }.b) in u) in u)
(let u = ({a = (if (((\x: Unit .\y: Unit .x) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Unit .x) true ) true)) then (((\x: Bool .\y: Unit .x) (((\x: Unit .\y: Bool .x) 0 ) false) ) (((\x: Rec X. X .\y: Unit .x) true ) false)) else (pred ({a = (if true then 0 else 1) , b = (if true then 0 else 0) }.b))) , b = (pred (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a))) }.b) in u)
(if ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) )) then (let u = ({a = (((\x: Bool .\y: Nat .y) true ) (unfold [ Bool ] (fold [ Unit ] 1 ))) , b = (( \f: Nat .((f (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) false ) ) (\a: Bool .\b: Unit .b)) , c =  (succ 1) }.b) in u) else (((\x: Nat .\y: Unit .y) (unfold [ Bool ] (fold [ Bool ] false )) ) (iszero ({a = true , b = 1 }.b))))
({a = (succ ({a = (let u = true in 0) , b = (((\x: Rec X. X .\y: Nat .y) true ) true) , c = (let u = true in 0) }.c)) , b = (( \f: Rec X. X .((f (iszero (( \f: Rec X. X .((f (fix (\x: Bool . 1 )) ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Unit .a))) ) (((\x: Bool .\y: Nat .y) (case <r = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .a))) ) ) (\a: Bool .\b: Nat .a)) , c =  (((\x: Rec X. X .\y: Unit .y) (iszero (( \f: Bool .((f ({a = 0 , b = false , c = 0 }.c) ) (((\x: Nat .\y: Bool .x) 1 ) false) ) ) (\a: Nat .\b: Rec X. X .b))) ) ({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) in u) , b = (((\x: Nat .\y: Unit .y) (case <r = ({a = true , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) ) ({a = true , b = true }.b)) }.a)) }.b)
({a = (((\x: Unit .\y: Bool .x) (let u = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) in (succ 1)) ) ({a = ({a = 1 , b = false , c =  1 }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) }.b)) , b = ({a = (( \f: Rec X. X .((f true ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) ) ) (\a: Nat .\b: Unit .b)) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] 0 )) , b = (((\x: Bool .\y: Rec X. X .y) true ) false) }.a) }.a) , c = (unfold [ Nat ] (fold [ Rec X. X ] (let u = ({a = false , b = false }.b) in ({a = true , b = 0 }.b)) )) }.c)
(case <l = (let u = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = (( \f: Nat .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Nat .\b: Unit .a)) }.b) in ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 1 )) , b = (case <r = (( \f: Bool .((f (fix (\x: Rec X. X . true )) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) , c = (((\x: Rec X. X .\y: Nat .x) ({a = 1 , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c = 0 }.c) ) ({a = 0 , b = false }.b)) }.c)) > as Nat of < l = x > => x | < r = y > => y)
(succ ({a = (succ (let u = true in 1)) , b = ({a = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Bool .b)) , b = ({a = 0 , b = (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) }.a) }.b) }.b))
(if (if (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) in (let u = false in u)) then (( \f: Unit .((f (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . (let u = true in u) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) else (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Bool .a))) then (unfold [ Nat ] (fold [ Rec X. X ] (let u = (if true then false else true) in u) )) else (( \f: Nat .((f (let u = (fix (\x: Nat . (if (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Nat .a)) then true else (unfold [ Unit ] (fold [ Nat ] true ))) )) in ({a = (( \f: Rec X. X .((f true ) (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (let u = 0 in u) }.a)) ) (if ({a = ({a = 1 , b = 1 }.b) , b = ({a = false , b = false }.b) }.b) then (unfold [ Nat ] (fold [ Unit ] true )) else ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = false in u) ))) ) ) (\a: Unit .\b: Bool .b)))
({a = (let u = ({a = (((\x: Rec X. X .\y: Nat .y) (if true then (let u = false in true) else (fix (\x: Unit . false ))) ) (( \f: Rec X. X .((f (pred 1) ) 0 ) ) (\a: Unit .\b: Unit .a))) , b = (case <r = (((\x: Bool .\y: Unit .y) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) , c = ({a = (fix (\x: Bool . true )) , b = 1 }.b) }.c) in u) , b = ({a = ({a = ({a = false , b = 1 }.b) , b = false , c =  ({a = 0 , b = 0 }.b) }.b) , b = (((\x: Nat .\y: Bool .x) ({a = 1 , b = 1 }.b) ) ({a = true , b = true }.b)) }.a) , c = (let u = (if (let u = 0 in (let u = false in true)) then (let u = 1 in u) else (( \f: Nat .((f (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Rec X. X .\y: Nat .x) 1 ) true) ) ) (\a: Unit .\b: Nat .a))) in u) }.c)
({a = (if (let u = (((\x: Unit .\y: Unit .y) true ) 1) in (if false then false else true)) then (((\x: Bool .\y: Bool .x) (fix (\x: Rec X. X . ({a = 1 , b = 0 }.b) )) ) (fix (\x: Unit . (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ))) else ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (((\x: Nat .\y: Unit .x) false ) false) , c = (let u = 1 in u) }.c) , b = (((\x: Nat .\y: Unit .x) true ) true) }.a)) , b = (unfold [ Bool ] (fold [ Nat ] (((\x: Nat .\y: Unit .x) false ) true) )) , c =  (( \f: Nat .((f ({a = 0 , b = 0 }.b) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b)) }.b)
(fix (\x: Unit . (case <r = (let u = (if (((\x: Nat .\y: Bool .y) (unfold [ Bool ] (fold [ Rec X. X ] false )) ) true) then ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) else ({a = ({a = false , b = true }.b) , b = (succ 0) }.b)) in ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in false) ))) > as Rec X. X of < l = x > => x | < r = y > => y) ))
({a = ({a = (unfold [ Nat ] (fold [ Unit ] (( \f: Unit .((f ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = 0 }.b) ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = (case <r = (( \f: Bool .((f (if true then false else true) ) (let u = 0 in false) ) ) (\a: Bool .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) }.a) , b = (( \f: Nat .((f (((\x: Nat .\y: Unit .y) ({a = false , b = false }.b) ) (((\x: Nat .\y: Bool .y) ({a = 1 , b = false , c =  0 }.b) ) true)) ) ({a = (let u = 1 in false) , b = (if false then false else true) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) , c = ({a = (case <l = (( \f: Rec X. X .((f (if false then 1 else 0) ) (let u = 1 in 1) ) ) (\a: Bool .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y) , b = ({a = (case <l = (let u = 1 in u) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (succ 1) , b = (let u = false in u) }.b) , c =  (pred (succ 1)) }.b) , c = (((\x: Nat .\y: Bool .y) (unfold [ Unit ] (fold [ Rec X. X ] true )) ) (if false then 0 else 1)) }.c) }.c)
(fix (\x: Rec X. X . (((\x: Nat .\y: Unit .x) (( \f: Unit .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Nat .b)) ) (case <r = (fix (\x: Unit . (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) > as Bool of < l = x > => x | < r = y > => y)) ))
(iszero (let u = (((\x: Nat .\y: Nat .y) (iszero 1) ) ({a = false , b = 1 }.b)) in (pred ({a = 0 , b = 1 }.b))))
({a = (iszero (unfold [ Nat ] (fold [ Nat ] 1 ))) , b = (let u = (succ (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) in (unfold [ Bool ] (fold [ Bool ] (let u = 1 in 1) ))) }.a)
(unfold [ Bool ] (fold [ Nat ] (if (let u = true in true) then (((\x: Unit .\y: Nat .x) (unfold [ Rec X. X ] (fold [ Nat ] true )) ) ({a = 0 , b = false }.b)) else ({a = 1 , b = ({a = false , b = 0 }.a) , c =  (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.b)) ))
(fix (\x: Nat . (let u = (let u = (((\x: Rec X. X .\y: Unit .y) false ) 0) in 0) in (succ (((\x: Bool .\y: Nat .y) false ) 0))) ))
(if (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) false ) ({a = 1 , b = false , c =  1 }.b)) ) (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] false )) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) ) (\a: Unit .\b: Nat .a)) then ({a = ({a = (( \f: Rec X. X .((f (succ 1) ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = (let u = false in u) , c =  (let u = 0 in 0) }.b) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (pred 0) )) }.a) else ({a = ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Nat .a)) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (iszero (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) , c =  ({a = (case <r = (case <r = false > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = false in 1) )) }.b) }.b))
(((\x: Bool .\y: Bool .x) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (pred (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .b))) )) ) (iszero (let u = (let u = (((\x: Nat .\y: Unit .x) true ) true) in 1) in (case <l = ({a = 1 , b = (let u = 1 in 0) }.b) > as Bool of < l = x > => x | < r = y > => y))))
((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (case <r = (unfold [ Nat ] (fold [ Bool ] (iszero 0) )) > as Unit of < l = x > => x | < r = y > => y) ))
(if (let u = (( \f: Nat .((f (iszero (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b))) ) ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .b)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) }.b) ) ) (\a: Unit .\b: Nat .b)) in u) then (unfold [ Nat ] (fold [ Nat ] (let u = (( \f: Unit .((f (let u = 0 in (unfold [ Nat ] (fold [ Bool ] 0 ))) ) (let u = 1 in u) ) ) (\a: Bool .\b: Nat .b)) in (((\x: Bool .\y: Bool .x) (( \f: Bool .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Unit .a)) ) (( \f: Rec X. X .((f true ) (let u = 1 in false) ) ) (\a: Nat .\b: Unit .b)))) )) else (((\x: Bool .\y: Rec X. X .y) ({a = 1 , b = ({a = 0 , b = true , c =  1 }.b) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b)) }.b) ) (pred (let u = 0 in 1))))
(( \f: Unit .((f (((\x: Bool .\y: Unit .x) (let u = (fix (\x: Unit . 0 )) in (((\x: Rec X. X .\y: Unit .x) false ) false)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .y) true ) false) ))) ) ({a = (let u = ({a = 0 , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.a) in (let u = false in u)) , b = (if (case <r = true > as Bool of < l = x > => x | < r = y > => y) then (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) else (let u = true in 1)) }.a) ) ) (\a: Rec X. X .\b: Nat .a))
(let u = ({a = ({a = (if false then 0 else 0) , b = (case <r = (iszero 1) > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (let u = (fix (\x: Unit . true )) in u) }.b) in (succ (unfold [ Unit ] (fold [ Rec X. X ] (if (((\x: Nat .\y: Unit .x) true ) false) then (let u = 1 in 1) else 0) ))))
(let u = (let u = ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c = 1 }.c) in u) in (let u = ({a = ({a = true , b = 0 }.a) , b = ({a = 1 , b = true , c =  1 }.b) }.b) in ({a = (( \f: Unit .((f ({a = 0 , b = true , c =  0 }.b) ) true ) ) (\a: Nat .\b: Unit .b)) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b)))
(fix (\x: Bool . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred (if (unfold [ Rec X. X ] (fold [ Bool ] true )) then (let u = false in 1) else (let u = 0 in u))) )) ))
(( \f: Nat .((f ({a = (((\x: Bool .\y: Bool .x) (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false )) in 1) ) ({a = 0 , b = true , c =  1 }.b)) , b = ({a = (( \f: Nat .((f true ) (let u = true in false) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (let u = (iszero 0) in (if false then 1 else 1)) }.a) }.b) ) (if (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Nat ] true )) ) (if true then true else (fix (\x: Nat . false ))) ) ) (\a: Bool .\b: Rec X. X .b)) then ({a = false , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.a) else ({a = ({a = 0 , b = false }.a) , b = false }.b)) ) ) (\a: Nat .\b: Bool .a))
(let u = ({a = (case <r = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (if false then 0 else (((\x: Rec X. X .\y: Nat .y) false ) 1)) }.b) in (( \f: Rec X. X .((f (case <r = (fix (\x: Unit . ({a = false , b = 1 }.a) )) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f false ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Rec X. X .b)))
((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (pred (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) in (let u = true in 0))) )) ))
({a = (pred (pred (((\x: Bool .\y: Nat .y) false ) 1))) , b = (let u = (( \f: Unit .((f (pred (let u = 0 in u)) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) 0) ) ) (\a: Nat .\b: Nat .a)) in (fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false )) )) ))) , c =  (pred (( \f: Nat .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (let u = false in 0) ) ) (\a: Unit .\b: Bool .a))) }.b)
(pred (((\x: Unit .\y: Rec X. X .x) (succ (( \f: Bool .((f ({a = 0 , b = 0 }.b) ) 0 ) ) (\a: Unit .\b: Unit .a))) ) ({a = ({a = (if false then true else true) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) }.a) , b = (( \f: Bool .((f (succ 1) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Rec X. X .\b: Nat .b)) }.a)))
(((\x: Nat .\y: Nat .x) (((\x: Rec X. X .\y: Bool .y) ({a = (iszero 1) , b = (iszero (pred 1)) }.b) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) ({a = (case <r = (fix (\x: Bool . ({a = true , b = 0 }.a) )) > as Bool of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (succ ({a = true , b = 0 }.b)) )) }.a))
(let u = (if ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , b = (((\x: Nat .\y: Nat .x) true ) true) }.b) then (let u = (((\x: Rec X. X .\y: Bool .y) false ) true) in (succ 0)) else ({a = (( \f: Rec X. X .((f (if true then false else false) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Unit .b)) , b = (succ ({a = 0 , b = true }.a)) }.b)) in ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) in ({a = 1 , b = 0 }.b)) )))
(let u = (let u = (let u = (((\x: Bool .\y: Bool .y) (let u = false in u) ) true) in u) in u) in ({a = (if (if (((\x: Nat .\y: Unit .y) true ) false) then (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .x) false ) true) ) ({a = true , b = false }.b) ) ) (\a: Bool .\b: Rec X. X .b)) else (((\x: Rec X. X .\y: Bool .y) true ) false)) then (let u = ({a = 1 , b = 1 }.b) in u) else (((\x: Unit .\y: Nat .y) (fix (\x: Nat . false )) ) (unfold [ Nat ] (fold [ Bool ] 1 )))) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (if ({a = 0 , b = false }.b) then ({a = false , b = 1 }.a) else false) )) , c =  ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) )) }.b))
(fix (\x: Rec X. X . (( \f: Unit .((f (pred (let u = 1 in u)) ) (((\x: Unit .\y: Nat .x) (let u = true in 0) ) (((\x: Unit .\y: Bool .x) true ) false)) ) ) (\a: Unit .\b: Rec X. X .b)) ))
(( \f: Rec X. X .((f (((\x: Unit .\y: Nat .y) (if ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] true )) then ({a = true , b = true }.b) else (((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Nat .y) true ) true) ) ({a = 1 , b = true , c =  0 }.b))) ) (( \f: Unit .((f (unfold [ Bool ] (fold [ Bool ] false )) ) (((\x: Bool .\y: Unit .x) (let u = false in u) ) true) ) ) (\a: Nat .\b: Rec X. X .a))) ) (fix (\x: Nat . (fix (\x: Unit . (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) )) )) ) ) (\a: Rec X. X .\b: Nat .a))
(( \f: Bool .((f ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred 0) )) , b = (unfold [ Unit ] (fold [ Unit ] (( \f: Nat .((f ({a = 0 , b = true }.b) ) (let u = ({a = 1 , b = false }.a) in ({a = true , b = 0 }.a)) ) ) (\a: Rec X. X .\b: Unit .a)) )) , c =  ({a = (iszero 1) , b = (( \f: Rec X. X .((f ({a = 1 , b = 1 }.b) ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.b) }.b) ) (case <r = (( \f: Nat .((f (let u = 1 in true) ) true ) ) (\a: Bool .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b))
(case <l = (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 1 , b = true }.a) )) ) (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) in u) ) ) (\a: Rec X. X .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y)
({a = (succ (((\x: Rec X. X .\y: Unit .x) (let u = false in 0) ) ({a = true , b = false }.b))) , b = (iszero ({a = (if false then 1 else 1) , b = ({a = ({a = 0 , b = false }.a) , b = (let u = false in u) , c =  1 }.b) }.a)) , c = (pred (fix (\x: Unit . (((\x: Bool .\y: Nat .x) 0 ) (((\x: Nat .\y: Rec X. X .x) true ) true)) ))) }.c)
(((\x: Nat .\y: Bool .x) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (pred 0) )) )) )) ) (((\x: Rec X. X .\y: Unit .y) (((\x: Nat .\y: Nat .y) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) ) (( \f: Unit .((f (( \f: Rec X. X .((f (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = true , b = 0 }.a) ) ) (\a: Bool .\b: Unit .a)) ) (if true then (((\x: Bool .\y: Nat .y) false ) true) else true) ) ) (\a: Bool .\b: Rec X. X .b))))
(((\x: Nat .\y: Nat .y) (fix (\x: Unit . (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (case <r = (fix (\x: Unit . ({a = true , b = 1 }.a) )) > as Unit of < l = x > => x | < r = y > => y) )))
(let u = (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Unit .\y: Rec X. X .y) (((\x: Bool .\y: Rec X. X .y) false ) false) ) (unfold [ Unit ] (fold [ Unit ] (iszero 1) ))) ) (unfold [ Unit ] (fold [ Unit ] (iszero (fix (\x: Rec X. X . 0 ))) ))) in (fix (\x: Bool . (case <r = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) , c =  1 }.b) > as Nat of < l = x > => x | < r = y > => y) )))
(let u = (iszero (let u = 1 in u)) in (( \f: Bool .((f (( \f: Unit .((f ({a = true , b = 0 }.a) ) (let u = 0 in false) ) ) (\a: Nat .\b: Nat .a)) ) (iszero 1) ) ) (\a: Nat .\b: Bool .a)))
(iszero (((\x: Bool .\y: Bool .y) (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Rec X. X .b)) )) ) ({a = 1 , b = false }.a)))
(let u = (case <r = (let u = (case <r = ({a = true , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y) in u) > as Nat of < l = x > => x | < r = y > => y) in ({a = (fix (\x: Unit . (if false then true else (let u = false in u)) )) , b = ({a = (let u = (unfold [ Rec X. X ] (fold [ Bool ] false )) in (((\x: Rec X. X .\y: Unit .y) true ) 1)) , b = (unfold [ Bool ] (fold [ Bool ] false )) , c =  (unfold [ Unit ] (fold [ Unit ] 1 )) }.b) }.b))
({a = (((\x: Unit .\y: Unit .x) ({a = ({a = 1 , b = 0 }.b) , b = ({a = (let u = 1 in u) , b = (((\x: Bool .\y: Unit .x) false ) true) , c =  (succ 0) }.b) }.b) ) (if (iszero (let u = false in ({a = 0 , b = false }.a))) then (let u = ({a = 0 , b = false , c = 1 }.c) in (let u = ({a = false , b = true }.b) in u)) else ({a = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Rec X. X .y) true ) false) }.b))) , b = (let u = (case <l = (fix (\x: Unit . (((\x: Rec X. X .\y: Unit .x) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 )) ) false) )) > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Bool .((f ({a = 1 , b = true , c = 0 }.c) ) ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = (iszero 1) , c = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) }.c) ) ) (\a: Rec X. X .\b: Unit .a))) }.b)
(( \f: Nat .((f (fix (\x: Unit . (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) ) (((\x: Nat .\y: Bool .x) (let u = ({a = (( \f: Rec X. X .((f (pred 1) ) (((\x: Unit .\y: Bool .y) false ) 0) ) ) (\a: Nat .\b: Unit .b)) , b = (let u = 0 in true) }.a) in u) ) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (if false then false else true) )) , b = (if false then 0 else 0) }.a)) ) ) (\a: Rec X. X .\b: Unit .b))
({a = (fix (\x: Nat . ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] ({a = 1 , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) }.a) )) )) , b = ({a = (if false then false else ({a = 0 , b = true }.b)) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 0 , b = false }.b) ) ({a = 1 , b = true , c =  1 }.b)) }.b) }.a)
(( \f: Nat .((f (( \f: Bool .((f (succ (unfold [ Unit ] (fold [ Unit ] (if true then 0 else 1) ))) ) (( \f: Unit .((f (( \f: Bool .((f ({a = 0 , b = false , c = 1 }.c) ) 0 ) ) (\a: Nat .\b: Nat .a)) ) (case <l = (pred 0) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Unit .b)) ) (pred ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = 1 }.b) ))) ) ) (\a: Bool .\b: Rec X. X .b))
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (pred (let u = 0 in u)) }.b) ))
(((\x: Rec X. X .\y: Rec X. X .y) (if (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) (iszero ({a = 0 , b = true }.a))) then ({a = ({a = (fix (\x: Unit . 0 )) , b = false }.a) , b = (fix (\x: Unit . true )) }.b) else (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) > as Unit of < l = x > => x | < r = y > => y)) ) (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Rec X. X . true )) )) ) (let u = (pred 1) in (fix (\x: Bool . false ))) ) ) (\a: Unit .\b: Rec X. X .b)))
(fix (\x: Nat . (let u = (( \f: Bool .((f ({a = (let u = 0 in false) , b = 0 }.b) ) (if true then 1 else 1) ) ) (\a: Bool .\b: Rec X. X .a)) in (let u = ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = (if false then (let u = true in 0) else 1) }.b) in (((\x: Rec X. X .\y: Bool .x) false ) false))) ))
(fix (\x: Unit . (((\x: Unit .\y: Rec X. X .y) (fix (\x: Bool . (let u = false in false) )) ) ({a = 0 , b = (((\x: Nat .\y: Rec X. X .y) false ) true) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .a)) }.b)) ))
(((\x: Unit .\y: Rec X. X .y) ({a = ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.b) , b = ({a = 0 , b = true }.b) }.b) ) (((\x: Unit .\y: Unit .x) ({a = (((\x: Nat .\y: Rec X. X .y) false ) (pred 1)) , b = ({a = false , b = 0 }.a) }.b) ) (let u = (let u = true in (((\x: Rec X. X .\y: Rec X. X .y) true ) 0)) in (if true then false else (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Nat .b))))))
(let u = (case <r = ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b)) in false) }.b) > as Bool of < l = x > => x | < r = y > => y) in u)
({a = ({a = (( \f: Unit .((f (((\x: Unit .\y: Rec X. X .x) (((\x: Unit .\y: Bool .x) 0 ) ({a = 0 , b = true }.b)) ) (iszero 1)) ) (fix (\x: Nat . ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 0 )) )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (case <l = (let u = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) in (succ 1)) > as Nat of < l = x > => x | < r = y > => y) }.b) , b = (case <l = (fix (\x: Nat . (pred 0) )) > as Unit of < l = x > => x | < r = y > => y) }.b)
(let u = (let u = (unfold [ Unit ] (fold [ Rec X. X ] (let u = (((\x: Unit .\y: Nat .y) false ) 1) in u) )) in (fix (\x: Rec X. X . (iszero 1) ))) in u)
({a = (let u = (( \f: Bool .((f (iszero (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) ) ({a = (let u = ({a = 0 , b = false , c =  1 }.b) in true) , b = ({a = false , b = true }.b) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) in (( \f: Unit .((f ({a = ({a = false , b = 0 }.b) , b = ({a = false , b = 1 }.a) , c = 0 }.c) ) ({a = 1 , b = true , c = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.c) ) ) (\a: Unit .\b: Bool .a))) , b = ({a = ({a = ({a = ({a = true , b = false }.b) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) }.b) , b = (let u = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .b)) in u) }.b) , c =  ({a = (if (let u = true in u) then (unfold [ Rec X. X ] (fold [ Unit ] 1 )) else (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b))) , b = (let u = ({a = (let u = 0 in false) , b = 1 }.b) in (if false then 1 else 0)) }.b) }.b)
(((\x: Rec X. X .\y: Rec X. X .y) (( \f: Bool .((f (let u = (((\x: Unit .\y: Unit .x) false ) true) in u) ) ({a = ({a = true , b = 1 }.a) , b = (if (fix (\x: Unit . ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) )) then (fix (\x: Nat . false )) else ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false ))) }.b) ) ) (\a: Unit .\b: Bool .a)) ) ({a = (let u = (let u = ({a = 1 , b = true }.a) in ({a = 1 , b = true }.a)) in (let u = (succ 0) in u)) , b = ({a = 0 , b = ({a = 0 , b = 1 }.b) }.b) }.b))
(((\x: Nat .\y: Bool .y) ({a = (((\x: Nat .\y: Unit .x) (unfold [ Unit ] (fold [ Bool ] true )) ) (((\x: Rec X. X .\y: Unit .y) false ) true)) , b = ({a = (((\x: Unit .\y: Unit .y) ({a = 1 , b = false }.b) ) ({a = 0 , b = true }.a)) , b = ({a = true , b = true }.b) }.b) }.b) ) (let u = (((\x: Nat .\y: Nat .x) ({a = 1 , b = ({a = true , b = 0 }.a) , c =  ({a = 0 , b = false }.a) }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Bool .b))) in (let u = (((\x: Unit .\y: Rec X. X .x) ({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 1 )) , b = false , c = 0 }.c) ) (((\x: Rec X. X .\y: Nat .y) (let u = 0 in true) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)))) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) true ) true) )))))
(unfold [ Rec X. X ] (fold [ Unit ] (case <l = (((\x: Bool .\y: Nat .x) (let u = 1 in u) ) (((\x: Unit .\y: Unit .y) (let u = 0 in true) ) false)) > as Bool of < l = x > => x | < r = y > => y) ))
(( \f: Bool .((f ({a = (((\x: Bool .\y: Rec X. X .y) (((\x: Nat .\y: Bool .x) false ) false) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f (if false then false else true) ) (fix (\x: Rec X. X . (if false then false else false) )) ) ) (\a: Nat .\b: Unit .a)) )) }.b) ) (case <r = (( \f: Unit .((f false ) (unfold [ Rec X. X ] (fold [ Unit ] true )) ) ) (\a: Bool .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a))
(let u = ({a = (( \f: Nat .((f (let u = 1 in 0) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Unit .a)) , b = (((\x: Nat .\y: Nat .x) ({a = (pred 1) , b = false , c =  0 }.b) ) ({a = false , b = false }.b)) , c = (succ (let u = ({a = true , b = 0 }.b) in (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)))) }.c) in u)
(pred (let u = ({a = (((\x: Bool .\y: Nat .x) 1 ) false) , b = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = true }.b) , c = (case <l = (((\x: Rec X. X .\y: Unit .x) 0 ) false) > as Bool of < l = x > => x | < r = y > => y) }.c) in (unfold [ Rec X. X ] (fold [ Bool ] ({a = 0 , b = ({a = 1 , b = false , c =  1 }.b) , c = (let u = 0 in 1) }.c) ))))
(( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] (fix (\x: Bool . ({a = true , b = 0 }.a) )) )) ) (case <r = ({a = ({a = true , b = false }.b) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) , b = false , c =  0 }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a))
(( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) (( \f: Unit .((f ({a = (let u = false in true) , b = false }.b) ) (((\x: Rec X. X .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .x) false ) true) ) (case <r = (fix (\x: Bool . false )) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Nat .a)) ) (let u = (let u = false in true) in (fix (\x: Rec X. X . (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) )))) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Nat . (if false then 1 else 0) )) )) ) ) (\a: Rec X. X .\b: Nat .a))
(fix (\x: Unit . (case <l = (succ (((\x: Bool .\y: Unit .y) false ) 0)) > as Rec X. X of < l = x > => x | < r = y > => y) ))
(((\x: Unit .\y: Unit .x) (if (unfold [ Nat ] (fold [ Rec X. X ] (iszero 0) )) then (((\x: Bool .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = false in false)) else (case <r = ({a = (let u = 0 in u) , b = true }.b) > as Bool of < l = x > => x | < r = y > => y)) ) (if (fix (\x: Nat . (let u = (let u = false in u) in false) )) then (if (fix (\x: Bool . false )) then ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) )) , b = (case <r = (((\x: Bool .\y: Rec X. X .y) true ) true) > as Nat of < l = x > => x | < r = y > => y) , c =  (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.b) else ({a = (pred 1) , b = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) , c =  ({a = 0 , b = false }.a) }.b)) else (iszero ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = (unfold [ Unit ] (fold [ Bool ] 1 )) }.b) )))))
(( \f: Bool .((f (( \f: Rec X. X .((f ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = (fix (\x: Rec X. X . (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) }.a) ) (let u = (unfold [ Unit ] (fold [ Unit ] false )) in (let u = true in u)) ) ) (\a: Bool .\b: Rec X. X .b)) ) ({a = ({a = (if false then 0 else 1) , b = (((\x: Bool .\y: Bool .x) true ) true) }.b) , b = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)) , b = (if true then (let u = 0 in true) else (let u = true in u)) }.b) }.b) ) ) (\a: Nat .\b: Unit .b))
(pred (((\x: Bool .\y: Nat .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) ) (if true then 1 else 1)))
(((\x: Bool .\y: Rec X. X .x) (let u = ({a = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = 1 , b = true , c = 1 }.c) }.a) in ({a = ({a = 1 , b = false }.b) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.a)) ) ({a = (case <r = (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Bool .y) (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y) ) (unfold [ Nat ] (fold [ Bool ] true ))) }.b))
({a = ({a = (fix (\x: Bool . ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] true )) )) , b = (let u = ({a = (succ 0) , b = (let u = false in u) }.b) in u) }.b) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = (let u = true in false) in true) )) )) }.b)
(((\x: Bool .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .y) (iszero (pred 0)) ) ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f ({a = 1 , b = true , c =  0 }.b) ) false ) ) (\a: Bool .\b: Rec X. X .b)) , c =  (pred (((\x: Unit .\y: Bool .x) 0 ) true)) }.b)) ) ({a = (fix (\x: Bool . (if true then 1 else 0) )) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (if (if (iszero 1) then (let u = true in false) else (let u = 0 in true)) then (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) 1 ) ) (\a: Bool .\b: Nat .b)) else (let u = false in 0)) )) }.b))
(case <l = (fix (\x: Bool . (if true then 0 else 0) )) > as Nat of < l = x > => x | < r = y > => y)
(let u = ({a = (let u = (let u = (if false then 1 else 1) in (let u = false in 1)) in u) , b = (let u = (((\x: Nat .\y: Rec X. X .x) ({a = false , b = 1 }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y)) in (fix (\x: Bool . (if false then 0 else 1) ))) }.b) in (( \f: Bool .((f ({a = (let u = (succ 0) in ({a = false , b = 0 }.b)) , b = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) ) 0 ) ) (\a: Nat .\b: Bool .a)) }.b) ) (pred (unfold [ Bool ] (fold [ Unit ] 0 ))) ) ) (\a: Nat .\b: Bool .a)))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .b)) in u) in u) ))
(case <l = ({a = (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in (pred (if false then 0 else 1))) , b = (case <r = (((\x: Unit .\y: Unit .y) false ) ({a = 1 , b = false , c =  1 }.b)) > as Unit of < l = x > => x | < r = y > => y) , c = (((\x: Unit .\y: Unit .y) (let u = 0 in true) ) (((\x: Unit .\y: Rec X. X .y) false ) 0)) }.c) > as Nat of < l = x > => x | < r = y > => y)
(( \f: Bool .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (fix (\x: Rec X. X . (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) )) ) ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) 1 ) false) )) , b = ({a = (case <r = (let u = 0 in true) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (( \f: Nat .((f 1 ) (((\x: Bool .\y: Rec X. X .x) 1 ) false) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (fix (\x: Rec X. X . true )) }.a) }.a) }.b) ) ) (\a: Bool .\b: Nat .b))
(case <l = (( \f: Bool .((f (if (let u = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) in (if true then false else false)) then (unfold [ Bool ] (fold [ Bool ] (pred 1) )) else (case <l = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] 0 )) > as Unit of < l = x > => x | < r = y > => y)) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Unit . 0 )) )) ) ) (\a: Rec X. X .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y)
(((\x: Rec X. X .\y: Nat .y) (case <r = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) true ) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Unit .b))) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Nat .y) (iszero (pred 1)) ) (if (let u = true in ({a = 1 , b = false , c =  1 }.b)) then (unfold [ Bool ] (fold [ Unit ] true )) else (iszero 0))))
({a = ({a = (if ({a = (let u = false in u) , b = (succ 1) }.a) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in 1) )) else ({a = 0 , b = 1 }.b)) , b = (((\x: Rec X. X .\y: Nat .x) (unfold [ Nat ] (fold [ Nat ] false )) ) (unfold [ Nat ] (fold [ Unit ] true ))) }.a) , b = (case <r = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] false )) , c =  ({a = 1 , b = true }.a) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.a)
(unfold [ Rec X. X ] (fold [ Unit ] (if ({a = (( \f: Unit .((f (let u = true in 0) ) 1 ) ) (\a: Unit .\b: Rec X. X .a)) , b = (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (let u = false in true) ) ) (\a: Rec X. X .\b: Nat .b)) }.b) then (fix (\x: Unit . (if (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) then ({a = true , b = false }.b) else true) )) else ({a = (( \f: Nat .((f ({a = 0 , b = true , c =  1 }.b) ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Bool .a)) , b = (let u = 1 in 0) }.a)) ))
(let u = ({a = (((\x: Nat .\y: Rec X. X .x) (( \f: Bool .((f 1 ) (succ 0) ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = (let u = 0 in true) in ({a = 0 , b = false , c =  1 }.b))) , b = (let u = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 1 )) in u) in (let u = (if (fix (\x: Unit . false )) then (let u = false in u) else (((\x: Bool .\y: Nat .y) false ) true)) in (if (unfold [ Unit ] (fold [ Bool ] true )) then 0 else ({a = 0 , b = false }.a)))) }.b) in ({a = (fix (\x: Bool . (succ 0) )) , b = (case <r = ({a = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) , c =  (succ (let u = (((\x: Nat .\y: Bool .x) true ) false) in (let u = false in 1))) }.b))
(let u = (pred (let u = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ({a = ({a = 0 , b = true }.a) , b = true , c = 1 }.c))) in (( \f: Bool .((f (unfold [ Unit ] (fold [ Rec X. X ] (let u = (((\x: Nat .\y: Bool .y) true ) false) in u) )) ) ({a = ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = 1 }.b) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) , c =  (let u = 0 in 1) }.b) ) ) (\a: Rec X. X .\b: Nat .a)))
({a = (pred (succ ({a = 1 , b = (((\x: Bool .\y: Unit .y) false ) 0) }.b))) , b = (( \f: Bool .((f ({a = (let u = 1 in 1) , b = ({a = 0 , b = true , c =  0 }.b) }.b) ) (( \f: Nat .((f (if ({a = true , b = false }.b) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) else false) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .a)) , c =  (((\x: Bool .\y: Bool .x) (pred (((\x: Bool .\y: Bool .x) 0 ) true)) ) (let u = (let u = (iszero 1) in u) in (((\x: Unit .\y: Unit .y) false ) false))) }.b)
({a = ({a = (let u = ({a = false , b = false }.b) in (fix (\x: Bool . 0 ))) , b = (let u = 0 in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) }.a) , b = (succ ({a = (succ 0) , b = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a)) }.a)) }.b)
(( \f: Rec X. X .((f (if (let u = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Bool .a)) in u) then ({a = (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Nat .a)) , b = 1 }.b) else (let u = (let u = false in 1) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] 1 )))) ) (if (((\x: Unit .\y: Bool .x) (let u = (let u = 0 in true) in true) ) (((\x: Bool .\y: Rec X. X .y) (fix (\x: Nat . true )) ) (let u = true in u))) then (let u = 1 in u) else (( \f: Unit .((f ({a = (let u = 0 in u) , b = true }.a) ) (((\x: Nat .\y: Nat .y) false ) 1) ) ) (\a: Nat .\b: Bool .b))) ) ) (\a: Unit .\b: Nat .a))
(( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Bool .((f (let u = true in u) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] false )) ) ) (\a: Nat .\b: Bool .a)) )) ) (let u = (((\x: Unit .\y: Rec X. X .y) (( \f: Unit .((f false ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) ) (let u = (succ 1) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y))) in (iszero (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] 1 ))))) ) ) (\a: Nat .\b: Unit .b))
({a = ({a = (let u = (((\x: Nat .\y: Nat .y) ({a = true , b = 0 }.a) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b))) in (((\x: Nat .\y: Bool .x) false ) true)) , b = (( \f: Unit .((f ({a = 0 , b = 1 }.b) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) ) (\a: Rec X. X .\b: Nat .b)) }.a) , b = (( \f: Unit .((f (pred (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b))) ) (fix (\x: Rec X. X . (((\x: Nat .\y: Unit .x) (pred 1) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true ))) )) ) ) (\a: Bool .\b: Rec X. X .a)) }.a)
(if ({a = (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) , b = (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Bool .\b: Nat .a)) in (((\x: Bool .\y: Unit .y) false ) 0)) }.a) then (let u = (case <l = (unfold [ Bool ] (fold [ Bool ] 0 )) > as Nat of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (if ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] false )) then ({a = 0 , b = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , c =  (succ 1) }.b) else (if (if false then false else false) then true else true)) ))) else (if ({a = ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = false , c =  (((\x: Nat .\y: Unit .y) false ) 1) }.b) , b = (succ 0) }.a) then (( \f: Unit .((f true ) (iszero 1) ) ) (\a: Unit .\b: Bool .b)) else (if ({a = false , b = true }.b) then (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .b)) else true)))
(fix (\x: Bool . ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = ({a = (fix (\x: Unit . 1 )) , b = false , c =  (((\x: Bool .\y: Rec X. X .x) 1 ) true) }.b) }.b) ))
(let u = (let u = (let u = (let u = true in 1) in (((\x: Nat .\y: Bool .y) (if true then true else false) ) (unfold [ Unit ] (fold [ Bool ] 1 )))) in u) in ({a = (case <l = ({a = 0 , b = true }.a) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = ({a = 1 , b = 0 }.b) in ({a = 0 , b = true , c =  0 }.b)) }.b))
({a = (pred (((\x: Unit .\y: Nat .y) (unfold [ Bool ] (fold [ Bool ] true )) ) 0)) , b = (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] false )) ) (( \f: Unit .((f (fix (\x: Unit . false )) ) true ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (((\x: Unit .\y: Nat .x) (let u = (succ (let u = 1 in 0)) in ({a = true , b = 1 }.b)) ) ({a = ({a = ({a = true , b = 1 }.b) , b = (((\x: Unit .\y: Nat .y) true ) false) , c =  ({a = 0 , b = true }.a) }.b) , b = (fix (\x: Unit . (pred 0) )) }.a)) }.c)
({a = (fix (\x: Bool . ({a = 1 , b = 0 }.b) )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = (if false then true else false) > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a)
(((\x: Rec X. X .\y: Unit .y) (( \f: Nat .((f ({a = (((\x: Unit .\y: Rec X. X .y) true ) (succ 0)) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) , c =  ({a = 0 , b = true , c = 1 }.c) }.b) ) (if ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) then ({a = false , b = (iszero 0) }.b) else (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) false ) false) ))) ) ) (\a: Bool .\b: Bool .a)) ) (((\x: Unit .\y: Unit .y) ({a = ({a = 1 , b = true }.a) , b = (fix (\x: Unit . false )) }.b) ) (( \f: Nat .((f (( \f: Nat .((f (if true then false else false) ) (((\x: Nat .\y: Rec X. X .y) (if true then false else true) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false ))) ) ) (\a: Unit .\b: Bool .a)) ) (let u = ({a = 1 , b = true , c = 1 }.c) in (case <r = false > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Rec X. X .a))))
(( \f: Nat .((f (( \f: Bool .((f (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Bool .x) true ) true) )) ) (case <r = (((\x: Bool .\y: Unit .x) false ) true) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) ) (let u = (iszero 1) in u) ) ) (\a: Rec X. X .\b: Nat .b))
(((\x: Bool .\y: Bool .x) (((\x: Bool .\y: Unit .y) (case <r = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Rec X. X .((f (case <l = (if false then 0 else 0) > as Nat of < l = x > => x | < r = y > => y) ) (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b))) ) (if (let u = ({a = false , b = false }.b) in (unfold [ Rec X. X ] (fold [ Bool ] false ))) then (( \f: Rec X. X .((f (fix (\x: Nat . false )) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .a)) else (let u = false in (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)))))
({a = (((\x: Rec X. X .\y: Bool .x) (unfold [ Nat ] (fold [ Rec X. X ] (case <r = ({a = 0 , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) )) ) (( \f: Nat .((f ({a = false , b = 0 }.a) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Rec X. X .b))) , b = ({a = (( \f: Bool .((f (((\x: Bool .\y: Bool .y) true ) 1) ) (( \f: Unit .((f 1 ) ({a = 1 , b = false , c = 0 }.c) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Unit .\b: Nat .a)) , b = (case <r = (((\x: Bool .\y: Unit .y) (let u = 0 in true) ) (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b))) > as Bool of < l = x > => x | < r = y > => y) }.a) }.a)
(unfold [ Nat ] (fold [ Unit ] ({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) (((\x: Unit .\y: Bool .x) true ) true)) in (let u = (unfold [ Rec X. X ] (fold [ Nat ] true )) in ({a = true , b = 0 }.a))) , b = (let u = (((\x: Nat .\y: Rec X. X .x) (((\x: Nat .\y: Bool .y) true ) 1) ) (let u = false in u)) in (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .a))) }.b) ))
(pred (((\x: Bool .\y: Bool .y) ({a = (if ({a = 0 , b = true , c =  0 }.b) then (let u = false in false) else false) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) }.b) ) (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a)) ))))
(let u = ({a = (( \f: Nat .((f (pred 1) ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Bool .\b: Bool .b)) , b = (((\x: Nat .\y: Bool .x) (fix (\x: Rec X. X . false )) ) ({a = 1 , b = (unfold [ Unit ] (fold [ Unit ] false )) , c =  (unfold [ Unit ] (fold [ Rec X. X ] 0 )) }.b)) , c = ({a = ({a = (((\x: Nat .\y: Rec X. X .y) true ) 0) , b = false , c = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) }.c) , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a)) , c = (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) }.c) }.c) in u)
({a = (iszero (( \f: Bool .((f (fix (\x: Bool . 1 )) ) ({a = 0 , b = true }.a) ) ) (\a: Unit .\b: Bool .a))) , b = ({a = (((\x: Unit .\y: Bool .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Rec X. X .\y: Nat .x) 0 ) false) )) ) (if false then false else true)) , b = ({a = (fix (\x: Unit . 0 )) , b = ({a = false , b = 1 }.a) }.b) }.a) }.a)
(((\x: Unit .\y: Unit .y) (( \f: Unit .((f (iszero (((\x: Nat .\y: Unit .x) (if true then (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) else ({a = 1 , b = false , c = 0 }.c)) ) ({a = 1 , b = false }.b))) ) (( \f: Rec X. X .((f (( \f: Nat .((f (let u = true in u) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) ) (unfold [ Unit ] (fold [ Nat ] true )) ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Unit .a)) ) (unfold [ Bool ] (fold [ Unit ] ({a = (case <r = (iszero 1) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Bool .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) 0) }.a) )))
({a = (if (case <r = (case <r = true > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) then (let u = (iszero ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 0 ))) in u) else (let u = ({a = false , b = 1 }.b) in (iszero 1))) , b = (pred (if (((\x: Nat .\y: Bool .y) true ) false) then ({a = 0 , b = 1 }.b) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )))) }.b)
({a = (unfold [ Bool ] (fold [ Unit ] (( \f: Unit .((f ({a = 0 , b = true , c = 1 }.c) ) (((\x: Unit .\y: Unit .y) true ) 1) ) ) (\a: Nat .\b: Nat .a)) )) , b = (((\x: Rec X. X .\y: Nat .y) (iszero (pred 1)) ) (case <r = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y)) }.a)
({a = ({a = (((\x: Unit .\y: Bool .x) (fix (\x: Rec X. X . false )) ) false) , b = (if (((\x: Bool .\y: Unit .y) false ) (iszero 1)) then (unfold [ Nat ] (fold [ Rec X. X ] 1 )) else (let u = (let u = 1 in 1) in u)) }.a) , b = ({a = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in (iszero 1)) , b = (let u = (if (iszero 1) then 0 else (if false then 1 else 1)) in u) }.b) }.a)
({a = (( \f: Bool .((f (((\x: Nat .\y: Unit .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) ) ({a = true , b = true }.b)) ) (((\x: Unit .\y: Bool .y) (((\x: Nat .\y: Nat .x) true ) ({a = false , b = 1 }.a)) ) (if (if true then true else false) then (if true then true else true) else false)) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Unit ] ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Nat .b)) , c = ({a = (((\x: Unit .\y: Unit .y) false ) 0) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.b) }.c) )) ) ({a = (if (((\x: Rec X. X .\y: Bool .y) false ) true) then 0 else (((\x: Bool .\y: Unit .x) 1 ) true)) , b = ({a = false , b = 1 }.a) , c = ({a = true , b = 0 }.b) }.c) ) ) (\a: Unit .\b: Unit .a)) }.a)
({a = ({a = (succ ({a = 1 , b = true , c = ({a = 0 , b = 1 }.b) }.c)) , b = (((\x: Nat .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) (unfold [ Unit ] (fold [ Rec X. X ] 1 ))) }.b) , b = (let u = ({a = (if false then 1 else 1) , b = (let u = false in true) , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.c) in ({a = ({a = true , b = false }.b) , b = (succ 0) }.a)) }.b)
(( \f: Unit .((f ({a = (( \f: Nat .((f (let u = true in u) ) true ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = (let u = 0 in u) , b = true , c =  1 }.b) }.b) ) (( \f: Nat .((f ({a = 0 , b = true }.b) ) (((\x: Bool .\y: Unit .x) true ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Bool .b))
(iszero (let u = ({a = (( \f: Unit .((f false ) (let u = true in u) ) ) (\a: Unit .\b: Bool .a)) , b = ({a = ({a = (((\x: Unit .\y: Unit .x) 1 ) true) , b = (iszero 0) , c = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.c) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 1 )) }.b) }.b) in (fix (\x: Unit . (((\x: Unit .\y: Nat .y) (((\x: Rec X. X .\y: Unit .x) true ) false) ) 1) ))))
({a = (pred (case <l = ({a = false , b = 1 }.b) > as Unit of < l = x > => x | < r = y > => y)) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] (case <l = ({a = (let u = false in true) , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y) )) }.b)
({a = ({a = ({a = ({a = 1 , b = (let u = false in u) }.a) , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] false )) }.b) , b = (pred (unfold [ Bool ] (fold [ Rec X. X ] 0 ))) }.b) , b = (( \f: Nat .((f (let u = (fix (\x: Bool . true )) in ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] true ))) ) ({a = (iszero (let u = false in 1)) , b = ({a = 1 , b = true }.a) }.a) ) ) (\a: Bool .\b: Unit .a)) }.b)
(unfold [ Bool ] (fold [ Unit ] ({a = (let u = (pred 0) in (unfold [ Unit ] (fold [ Unit ] 1 ))) , b = (let u = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Rec X. X .x) false ) false) }.a) in (fix (\x: Bool . (let u = true in u) ))) }.a) ))
({a = (fix (\x: Nat . (let u = (if (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) then 0 else (((\x: Nat .\y: Rec X. X .y) false ) 1)) in (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = true in u) )) then ({a = 1 , b = ({a = true , b = true }.b) , c = 0 }.c) else ({a = ({a = 0 , b = true }.a) , b = true , c = ({a = 0 , b = true }.a) }.c))) )) , b = ({a = (fix (\x: Unit . (unfold [ Unit ] (fold [ Unit ] false )) )) , b = (let u = (let u = true in u) in (unfold [ Unit ] (fold [ Nat ] (((\x: Bool .\y: Nat .y) true ) false) ))) }.b) , c = (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .x) (pred 1) ) true) )) }.c)
(fix (\x: Nat . (( \f: Rec X. X .((f (iszero (fix (\x: Rec X. X . 0 ))) ) (let u = (((\x: Nat .\y: Rec X. X .y) true ) true) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
(case <l = (((\x: Bool .\y: Bool .x) (let u = (pred 1) in 0) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) > as Rec X. X of < l = x > => x | < r = y > => y)
(( \f: Bool .((f (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f (let u = false in 0) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Rec X. X .\y: Nat .x) ({a = true , b = 0 }.a) ) (let u = true in true))) ) (let u = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Rec X. X .y) false ) true) )) in ({a = (pred 0) , b = (if true then true else true) }.b)) in (let u = (succ 1) in (let u = 1 in 1))) ) ) (\a: Unit .\b: Unit .a))
(let u = (((\x: Bool .\y: Rec X. X .x) (let u = true in u) ) (case <r = (unfold [ Nat ] (fold [ Unit ] true )) > as Unit of < l = x > => x | < r = y > => y)) in (let u = (((\x: Rec X. X .\y: Unit .y) ({a = (iszero 1) , b = (((\x: Nat .\y: Bool .y) true ) true) }.b) ) ({a = (((\x: Nat .\y: Unit .y) true ) true) , b = 1 }.b)) in (pred ({a = (((\x: Unit .\y: Unit .y) false ) 0) , b = (let u = true in true) }.a))))
(let u = ({a = (let u = (if true then false else true) in (iszero 1)) , b = (((\x: Unit .\y: Bool .x) (unfold [ Bool ] (fold [ Unit ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) )) ) ({a = (let u = true in false) , b = true }.b)) }.a) in (fix (\x: Bool . ({a = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) , b = (if false then 0 else 0) }.a) )))
(( \f: Nat .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (if ({a = false , b = 1 }.a) then (let u = true in u) else (let u = false in u)) )) ) ({a = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Bool .b)) , b = (if false then ({a = 1 , b = true }.a) else 1) }.a) ) ) (\a: Nat .\b: Unit .b))
(fix (\x: Rec X. X . (unfold [ Bool ] (fold [ Unit ] ({a = (iszero 1) , b = (((\x: Bool .\y: Nat .y) false ) (if false then 1 else 1)) }.a) )) ))
(let u = (((\x: Nat .\y: Bool .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (succ 1) , b = false , c =  0 }.b) )) ) (((\x: Unit .\y: Bool .x) (let u = (((\x: Bool .\y: Rec X. X .y) false ) true) in 1) ) ({a = 0 , b = true , c =  1 }.b))) in (case <l = (((\x: Rec X. X .\y: Bool .y) false ) 1) > as Nat of < l = x > => x | < r = y > => y))
(pred (((\x: Rec X. X .\y: Rec X. X .x) (pred ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = true , c = 1 }.c) , b = ({a = true , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) }.b) , c = (((\x: Rec X. X .\y: Nat .y) ({a = 0 , b = true }.b) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) }.c)) ) (let u = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ({a = true , b = true }.b))))
({a = ({a = ({a = (let u = 1 in 1) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] true )) , c =  (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . 1 )) )) }.b) , b = ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = 0 in (iszero 0)) }.b) }.b) , b = (if ({a = (if false then false else true) , b = ({a = (unfold [ Nat ] (fold [ Bool ] 0 )) , b = true , c =  1 }.b) }.b) then (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) else (unfold [ Unit ] (fold [ Nat ] (let u = 1 in u) ))) }.a)
(fix (\x: Unit . (let u = (let u = (let u = (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y) in (if (fix (\x: Rec X. X . true )) then 1 else 1)) in (( \f: Bool .((f 1 ) (succ 0) ) ) (\a: Nat .\b: Unit .b))) in (let u = ({a = true , b = true }.b) in (((\x: Nat .\y: Unit .x) false ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false ))))) ))
(let u = (pred (let u = (let u = ({a = 0 , b = false , c = 1 }.c) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 ))) in (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)))) in ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = ({a = 0 , b = 1 }.b) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) }.b) , b = (let u = true in u) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) )))
(fix (\x: Rec X. X . ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Unit .\y: Rec X. X .y) false ) 0) )) , b = (( \f: Unit .((f ({a = 0 , b = false , c =  1 }.b) ) ({a = (iszero 0) , b = (((\x: Bool .\y: Bool .y) false ) 0) }.a) ) ) (\a: Rec X. X .\b: Nat .a)) , c =  (( \f: Bool .((f (let u = 1 in u) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Unit .\b: Bool .a)) }.b) ))
(unfold [ Nat ] (fold [ Unit ] (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) false) ) (((\x: Bool .\y: Bool .x) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) ) true)) ))
(pred ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = 0 in 1) )) , b = (iszero 0) , c = (succ 1) }.c))
(succ (let u = (let u = 0 in 1) in (fix (\x: Bool . (case <l = (succ 0) > as Unit of < l = x > => x | < r = y > => y) ))))
(let u = (( \f: Nat .((f ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (let u = 1 in true) in true) }.b) ) ({a = (let u = false in u) , b = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) }.a) ) ) (\a: Rec X. X .\b: Nat .a)) in u)
(((\x: Unit .\y: Bool .y) (if ({a = ({a = false , b = false }.b) , b = ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = ({a = false , b = true }.b) , c =  1 }.b) }.b) then ({a = (succ (let u = 0 in u)) , b = (if (fix (\x: Nat . false )) then true else true) }.b) else (( \f: Nat .((f ({a = false , b = true }.b) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) ) ) (\a: Unit .\b: Bool .a))) ) (( \f: Unit .((f (((\x: Nat .\y: Unit .y) (((\x: Rec X. X .\y: Bool .y) false ) false) ) ({a = 1 , b = (((\x: Nat .\y: Bool .y) false ) true) }.b)) ) (( \f: Unit .((f (if false then true else false) ) (if true then true else false) ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Bool .\b: Unit .b)))
(case <l = (((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Rec X. X .x) (let u = 1 in false) ) (((\x: Bool .\y: Bool .x) true ) true)) ) (( \f: Rec X. X .((f ({a = 0 , b = true }.a) ) (fix (\x: Bool . (if false then 0 else 0) )) ) ) (\a: Rec X. X .\b: Unit .b))) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = ({a = 0 , b = false , c = 1 }.c) in (succ ({a = 0 , b = 0 }.b))) in u)
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (iszero (let u = (((\x: Unit .\y: Unit .x) true ) true) in (((\x: Nat .\y: Bool .y) ({a = 0 , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  ({a = 1 , b = true , c = 0 }.c) }.b) ) ({a = false , b = 0 }.b)))) ))
({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (if (let u = false in false) then (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 ))) )) , b = (let u = (fix (\x: Bool . (((\x: Bool .\y: Rec X. X .y) (unfold [ Nat ] (fold [ Unit ] true )) ) true) )) in ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = 1 }.a)) , c =  (unfold [ Unit ] (fold [ Bool ] ({a = (( \f: Nat .((f ({a = 1 , b = 1 }.b) ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = (( \f: Unit .((f (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) ) 0 ) ) (\a: Unit .\b: Bool .a)) }.b) )) }.b)
(let u = (( \f: Bool .((f (let u = (let u = (let u = 0 in false) in u) in (( \f: Unit .((f true ) (((\x: Bool .\y: Rec X. X .x) false ) false) ) ) (\a: Unit .\b: Bool .b))) ) ({a = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = (if true then 0 else 1) }.a) ) ) (\a: Nat .\b: Rec X. X .a)) in u)
({a = (( \f: Bool .((f (let u = ({a = 1 , b = true , c =  1 }.b) in u) ) (fix (\x: Nat . true )) ) ) (\a: Unit .\b: Nat .a)) , b = (((\x: Nat .\y: Bool .y) (( \f: Nat .((f (let u = true in u) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Nat .\b: Nat .b)) ) (let u = 1 in u)) }.b)
(case <l = ({a = (let u = (((\x: Bool .\y: Nat .y) true ) false) in (((\x: Nat .\y: Rec X. X .x) 0 ) true)) , b = ({a = ({a = true , b = 1 }.b) , b = (let u = 1 in false) , c =  0 }.b) , c = (if true then 1 else 0) }.c) > as Nat of < l = x > => x | < r = y > => y)
({a = (( \f: Unit .((f (pred (let u = (let u = false in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 ))) in u)) ) (let u = (fix (\x: Rec X. X . (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) )) in ({a = (pred 1) , b = 0 }.b)) ) ) (\a: Unit .\b: Unit .a)) , b = (((\x: Unit .\y: Rec X. X .x) (let u = ({a = ({a = 0 , b = 1 }.b) , b = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) }.b) in (fix (\x: Rec X. X . (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) ))) ) (( \f: Unit .((f (if true then true else false) ) (let u = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) in (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .a))) ) ) (\a: Rec X. X .\b: Unit .b))) , c = ({a = (( \f: Unit .((f true ) (((\x: Rec X. X .\y: Unit .x) false ) false) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (let u = ({a = 1 , b = true }.b) in (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b))) }.b) }.c)
(( \f: Unit .((f (( \f: Nat .((f (( \f: Unit .((f (let u = ({a = false , b = true }.b) in ({a = true , b = 1 }.a)) ) ({a = (let u = 1 in u) , b = (let u = false in (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b))) }.b) ) ) (\a: Nat .\b: Nat .a)) ) ({a = ({a = 0 , b = true , c = 0 }.c) , b = (( \f: Bool .((f true ) ({a = false , b = 0 }.a) ) ) (\a: Unit .\b: Bool .a)) , c =  (let u = 1 in u) }.b) ) ) (\a: Rec X. X .\b: Nat .a)) ) ({a = ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = false in u) , c =  (let u = 0 in (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) }.b) , b = (iszero (unfold [ Unit ] (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] 1 )) ))) }.b) ) ) (\a: Bool .\b: Nat .a))
(((\x: Nat .\y: Unit .x) (pred (( \f: Unit .((f (case <l = (let u = true in 0) > as Unit of < l = x > => x | < r = y > => y) ) (succ 0) ) ) (\a: Bool .\b: Rec X. X .b))) ) (let u = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = (((\x: Unit .\y: Bool .x) true ) (fix (\x: Unit . true ))) }.b) in (let u = ({a = false , b = 1 }.a) in (case <r = true > as Nat of < l = x > => x | < r = y > => y))))
(let u = (unfold [ Nat ] (fold [ Unit ] ({a = 1 , b = true }.a) )) in (let u = (iszero (let u = false in 1)) in (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a))))
(unfold [ Unit ] (fold [ Unit ] (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) )) in (let u = (((\x: Rec X. X .\y: Nat .y) (((\x: Bool .\y: Bool .y) false ) false) ) true) in (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) ))
({a = (iszero (fix (\x: Rec X. X . (((\x: Unit .\y: Bool .x) 1 ) true) ))) , b = (((\x: Bool .\y: Rec X. X .x) (let u = (let u = ({a = false , b = 0 }.b) in u) in (let u = ({a = 0 , b = true }.b) in u)) ) (let u = (pred (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) in (let u = ({a = 1 , b = true }.b) in u))) }.b)
({a = (let u = (unfold [ Unit ] (fold [ Unit ] ({a = true , b = 1 }.b) )) in (let u = 0 in ({a = 0 , b = false }.b))) , b = (let u = (((\x: Rec X. X .\y: Nat .y) (((\x: Unit .\y: Bool .y) (unfold [ Bool ] (fold [ Nat ] false )) ) false) ) (( \f: Bool .((f ({a = ({a = 1 , b = true , c = 1 }.c) , b = false }.b) ) ({a = 0 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Bool .a))) in u) }.b)
({a = (if ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = 1 }.a) then (let u = ({a = 0 , b = (((\x: Bool .\y: Rec X. X .y) false ) false) , c = 1 }.c) in ({a = ({a = 1 , b = false , c = 1 }.c) , b = true }.b)) else (unfold [ Nat ] (fold [ Unit ] (let u = true in u) ))) , b = (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) ) ) (\a: Unit .\b: Rec X. X .b)) ) (iszero (fix (\x: Bool . (let u = true in 0) )))) }.b)
(case <r = (let u = (if (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .b)) then ({a = 0 , b = 0 }.b) else (((\x: Bool .\y: Rec X. X .y) false ) 0)) in (fix (\x: Rec X. X . (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) ))) > as Unit of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Nat .x) (fix (\x: Unit . ({a = (let u = 1 in false) , b = 1 }.b) )) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Rec X. X . true )) )) )))
(((\x: Rec X. X .\y: Unit .y) (fix (\x: Bool . (if (if (let u = (unfold [ Bool ] (fold [ Rec X. X ] true )) in u) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] true )) else (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Unit .a))) then (case <r = false > as Unit of < l = x > => x | < r = y > => y) else ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) }.b)) )) ) (if ({a = ({a = true , b = false }.b) , b = (if true then 1 else (if true then 1 else 1)) }.a) then (let u = (((\x: Nat .\y: Rec X. X .y) ({a = true , b = 0 }.a) ) true) in (let u = 1 in false)) else (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Bool .x) (let u = 0 in true) ) true) ))))
(((\x: Nat .\y: Rec X. X .x) ({a = (if (let u = 0 in true) then (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Nat .b)) else ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] true ))) , b = ({a = ({a = 0 , b = 1 }.b) , b = true }.a) }.b) ) (let u = ({a = (unfold [ Bool ] (fold [ Bool ] false )) , b = false }.b) in u))
(((\x: Bool .\y: Nat .x) (let u = (unfold [ Unit ] (fold [ Unit ] (pred 1) )) in u) ) (if ({a = (let u = 0 in false) , b = (iszero 1) }.b) then (((\x: Bool .\y: Unit .x) (((\x: Rec X. X .\y: Rec X. X .y) true ) false) ) (iszero 1)) else (fix (\x: Nat . ({a = 0 , b = false , c =  0 }.b) ))))
(if ({a = (unfold [ Nat ] (fold [ Nat ] false )) , b = (( \f: Unit .((f ({a = (let u = 1 in true) , b = false }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Bool .b)) }.b) then (unfold [ Nat ] (fold [ Unit ] (let u = false in false) )) else (case <r = (if (iszero ({a = 0 , b = false }.a)) then (let u = 0 in false) else ({a = 1 , b = false , c =  0 }.b)) > as Bool of < l = x > => x | < r = y > => y))
(( \f: Bool .((f (unfold [ Nat ] (fold [ Bool ] (( \f: Unit .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) )) ) (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true )) in ({a = (((\x: Bool .\y: Unit .y) false ) 0) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) }.b)) ) ) (\a: Bool .\b: Nat .b))
(( \f: Bool .((f (let u = ({a = (let u = 0 in true) , b = (if true then 1 else 1) }.b) in u) ) (((\x: Rec X. X .\y: Nat .y) ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] true )) , b = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Unit .a)) }.b) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] ({a = false , b = 0 }.b) ))) ) ) (\a: Bool .\b: Unit .a))
(unfold [ Bool ] (fold [ Rec X. X ] (if ({a = ({a = 1 , b = false }.b) , b = (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.a) then ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (let u = false in u) )) else ({a = ({a = 1 , b = false , c =  0 }.b) , b = (let u = false in 0) }.a)) ))
(unfold [ Nat ] (fold [ Bool ] (let u = (if (unfold [ Nat ] (fold [ Unit ] true )) then (iszero 0) else (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a))) in ({a = 0 , b = (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)) ))
(((\x: Nat .\y: Rec X. X .y) ({a = (if (( \f: Unit .((f (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) in false) ) ({a = true , b = false }.b) ) ) (\a: Rec X. X .\b: Nat .a)) then (let u = ({a = false , b = false }.b) in (unfold [ Rec X. X ] (fold [ Rec X. X ] false ))) else ({a = ({a = (pred 1) , b = 1 }.b) , b = (let u = false in u) , c =  (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) }.b)) , b = (( \f: Rec X. X .((f ({a = (((\x: Bool .\y: Nat .x) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) true) , b = (fix (\x: Unit . true )) , c =  (if true then (if false then 0 else 0) else 1) }.b) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = 0 , b = false , c =  0 }.b) )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b) ) ({a = (iszero (if false then 1 else 0)) , b = (unfold [ Nat ] (fold [ Bool ] ({a = false , b = ({a = 1 , b = false }.a) }.a) )) }.b))
(( \f: Rec X. X .((f ({a = (let u = (((\x: Rec X. X .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true ))) in (let u = 1 in false)) , b = (fix (\x: Bool . (((\x: Unit .\y: Bool .x) 0 ) false) )) }.a) ) (((\x: Unit .\y: Nat .x) ({a = (let u = true in ({a = 1 , b = true }.b)) , b = (pred 1) }.a) ) (((\x: Nat .\y: Rec X. X .x) ({a = false , b = false }.b) ) ({a = 1 , b = false , c =  0 }.b))) ) ) (\a: Unit .\b: Rec X. X .a))
(( \f: Nat .((f ({a = (( \f: Rec X. X .((f (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (( \f: Unit .((f ({a = false , b = false }.b) ) (( \f: Rec X. X .((f (let u = 1 in true) ) (let u = false in false) ) ) (\a: Nat .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .a)) , b = ({a = (if false then 1 else 1) , b = (pred 1) }.b) }.a) ) (let u = ({a = (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] 1 )) in (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b))) , b = (( \f: Bool .((f (let u = 0 in u) ) (fix (\x: Nat . 0 )) ) ) (\a: Nat .\b: Unit .a)) }.a) in (let u = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) false ) true) ) true ) ) (\a: Unit .\b: Rec X. X .a)) in (let u = false in true))) ) ) (\a: Nat .\b: Rec X. X .a))
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f (((\x: Unit .\y: Unit .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a)) )) ) ({a = 1 , b = (unfold [ Unit ] (fold [ Bool ] true )) , c =  0 }.b)) ) (((\x: Nat .\y: Bool .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = false , c =  1 }.b) )) ) (unfold [ Bool ] (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] false )) ))) ) ) (\a: Nat .\b: Nat .b)) ))
({a = (((\x: Unit .\y: Unit .y) ({a = (fix (\x: Unit . 0 )) , b = true }.b) ) (iszero (if ({a = 0 , b = true }.b) then (let u = 1 in 1) else (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b))))) , b = (( \f: Nat .((f (fix (\x: Unit . ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (succ 1) )) )) ) (let u = (pred (if true then 0 else 1)) in u) ) ) (\a: Unit .\b: Bool .a)) }.a)
((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (iszero ({a = 0 , b = false }.a)) ))
(if (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Bool .\y: Unit .y) ({a = 1 , b = true , c =  0 }.b) ) (if true then false else false)) )) then (if ({a = (pred 0) , b = (((\x: Nat .\y: Nat .y) false ) true) }.b) then ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) , b = ({a = 1 , b = false }.b) }.b) else (( \f: Nat .((f (((\x: Unit .\y: Unit .y) true ) true) ) false ) ) (\a: Rec X. X .\b: Bool .a))) else ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (case <r = (if true then true else ({a = false , b = 0 }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) )))
(pred ({a = (((\x: Unit .\y: Rec X. X .y) ({a = (unfold [ Nat ] (fold [ Unit ] false )) , b = false }.b) ) (((\x: Unit .\y: Nat .y) (iszero 0) ) ({a = 0 , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) , c = 1 }.c))) , b = (case <l = ({a = true , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.b))
(let u = (( \f: Unit .((f (case <l = (let u = 1 in (((\x: Unit .\y: Rec X. X .y) false ) 0)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (pred (let u = ({a = 1 , b = true }.a) in u)) ) ) (\a: Unit .\b: Unit .b)) in u)
(( \f: Rec X. X .((f (((\x: Rec X. X .\y: Unit .x) (( \f: Nat .((f (if (iszero 0) then (case <r = true > as Nat of < l = x > => x | < r = y > => y) else ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) ) (( \f: Unit .((f (fix (\x: Nat . true )) ) (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Nat .\b: Nat .a)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = ({a = true , b = 1 }.a) , b = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) in true) }.b) ))) ) (((\x: Rec X. X .\y: Nat .y) (let u = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .b)) in ({a = true , b = 0 }.a)) ) ({a = false , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b)) ) ) (\a: Unit .\b: Rec X. X .b))
({a = (iszero (pred (((\x: Nat .\y: Unit .y) ({a = 0 , b = (iszero 1) }.b) ) (((\x: Nat .\y: Nat .y) (let u = true in u) ) (((\x: Nat .\y: Bool .y) true ) 0))))) , b = (((\x: Unit .\y: Rec X. X .y) (fix (\x: Unit . ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b)) , b = true , c =  1 }.b) )) ) (( \f: Nat .((f 1 ) (unfold [ Bool ] (fold [ Rec X. X ] 1 )) ) ) (\a: Rec X. X .\b: Bool .a))) }.b)
(let u = (case <r = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in ({a = false , b = 1 }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) ({a = (fix (\x: Unit . false )) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 1 )) }.a) ) (((\x: Nat .\y: Unit .x) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .b)) ) ({a = (fix (\x: Nat . true )) , b = (((\x: Rec X. X .\y: Bool .x) (((\x: Unit .\y: Bool .x) 1 ) true) ) true) }.a))) ))
(let u = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .y) (let u = (let u = true in u) in u) ) (let u = false in (((\x: Nat .\y: Bool .x) false ) false))) )) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (((\x: Unit .\y: Rec X. X .y) (let u = false in u) ) false) )))
(((\x: Unit .\y: Rec X. X .y) (((\x: Unit .\y: Nat .y) ({a = (succ 1) , b = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , c =  (pred 1) }.b) ) ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = true in true) }.b)) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Rec X. X .\y: Bool .y) false ) (let u = 0 in 1)) ) (unfold [ Rec X. X ] (fold [ Nat ] false ))) in u))
(unfold [ Nat ] (fold [ Bool ] ({a = ({a = (( \f: Unit .((f (((\x: Unit .\y: Unit .x) 1 ) true) ) (((\x: Nat .\y: Bool .y) false ) 1) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (let u = 1 in u) }.b) , b = ({a = (fix (\x: Bool . 0 )) , b = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .a)) , c =  ({a = false , b = ({a = 0 , b = true , c = 1 }.c) }.b) }.b) }.b) ))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .y) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] ({a = true , b = 0 }.a) )) , b = (if (( \f: Rec X. X .((f ({a = true , b = true }.b) ) true ) ) (\a: Rec X. X .\b: Unit .a)) then ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] false )) else (let u = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) in (fix (\x: Nat . true )))) }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = false in u) ))) ))
({a = ({a = (fix (\x: Bool . 1 )) , b = (unfold [ Nat ] (fold [ Bool ] ({a = 0 , b = true , c = 1 }.c) )) }.b) , b = (( \f: Rec X. X .((f ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) , b = (let u = true in u) }.b) ) ({a = (case <l = (unfold [ Unit ] (fold [ Bool ] 1 )) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (( \f: Rec X. X .((f false ) (if true then false else true) ) ) (\a: Nat .\b: Unit .b)) ) (((\x: Nat .\y: Nat .y) true ) false) ) ) (\a: Bool .\b: Unit .a)) , c =  (let u = false in 0) }.b) ) ) (\a: Nat .\b: Unit .a)) , c = (( \f: Unit .((f (((\x: Unit .\y: Unit .y) ({a = true , b = true }.b) ) ({a = 1 , b = 1 }.b)) ) (let u = (let u = false in 0) in ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = false }.a)) ) ) (\a: Unit .\b: Unit .b)) }.c)
({a = (unfold [ Rec X. X ] (fold [ Nat ] (if (if false then true else false) then (if true then 0 else (pred 0)) else (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) )) , b = ({a = (if (unfold [ Nat ] (fold [ Rec X. X ] true )) then (let u = 1 in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) else (fix (\x: Bool . (let u = 0 in u) ))) , b = (iszero (let u = false in 1)) }.b) }.a)
({a = (fix (\x: Bool . (unfold [ Nat ] (fold [ Nat ] (let u = 0 in false) )) )) , b = (((\x: Unit .\y: Bool .y) (((\x: Nat .\y: Unit .x) (((\x: Rec X. X .\y: Bool .x) true ) true) ) (if true then false else true)) ) (( \f: Bool .((f true ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Unit .\b: Nat .b))) }.b)
(((\x: Nat .\y: Unit .y) ({a = (succ (((\x: Bool .\y: Nat .y) (fix (\x: Rec X. X . true )) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )))) , b = (unfold [ Unit ] (fold [ Rec X. X ] ({a = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) , b = (let u = true in u) , c =  (pred 1) }.b) )) }.b) ) (case <l = (pred (let u = 0 in u)) > as Bool of < l = x > => x | < r = y > => y))
(if ({a = (unfold [ Bool ] (fold [ Nat ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) , b = (let u = ({a = ({a = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , b = (if false then true else false) }.b) , b = (pred 0) }.b) in (iszero ({a = 1 , b = false , c = 0 }.c))) , c =  (fix (\x: Bool . ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 )) )) }.b) then (if (let u = (fix (\x: Bool . false )) in u) then (((\x: Rec X. X .\y: Bool .y) true ) ({a = true , b = 0 }.a)) else (let u = true in false)) else (unfold [ Unit ] (fold [ Rec X. X ] ({a = ({a = (iszero 0) , b = (if false then 0 else 0) }.b) , b = ({a = true , b = false }.b) , c =  (( \f: Unit .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .b)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) )))
({a = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = (pred 1) , b = (if false then (if true then false else true) else (fix (\x: Rec X. X . false ))) , c = (let u = true in 0) }.c) )) , b = (succ ({a = ({a = (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = false }.a) , b = ({a = 0 , b = true }.a) }.b)) }.b)
(case <r = (let u = (iszero 0) in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] true ))) > as Nat of < l = x > => x | < r = y > => y)
(if (((\x: Bool .\y: Unit .y) (let u = 1 in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) ) (((\x: Rec X. X .\y: Bool .y) (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = false , b = true }.b))) then (unfold [ Nat ] (fold [ Nat ] (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) )) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) ) ) (\a: Rec X. X .\b: Nat .b)) )) else ({a = (if ({a = 1 , b = (((\x: Unit .\y: Rec X. X .x) false ) false) , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) then ({a = 1 , b = false , c =  0 }.b) else (let u = (let u = 0 in u) in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] true )))) , b = (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Unit .y) true ) false) ) true) }.b))
(unfold [ Rec X. X ] (fold [ Nat ] (pred (pred (if (iszero 1) then (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) else 1))) ))
(case <r = (fix (\x: Bool . (((\x: Nat .\y: Nat .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] false )) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (if ({a = false , b = true }.b) then ({a = false , b = 0 }.b) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) )) in (case <r = ({a = ({a = 0 , b = 0 }.b) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true )) , c =  (((\x: Unit .\y: Nat .x) 0 ) false) }.b) > as Unit of < l = x > => x | < r = y > => y))
(unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Nat .x) (fix (\x: Unit . false )) ) (case <r = (((\x: Unit .\y: Rec X. X .x) true ) false) > as Nat of < l = x > => x | < r = y > => y)) ))
(let u = (((\x: Bool .\y: Rec X. X .x) ({a = ({a = 1 , b = 1 }.b) , b = (( \f: Unit .((f true ) (if true then false else true) ) ) (\a: Rec X. X .\b: Unit .b)) }.b) ) (let u = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) in ({a = 1 , b = false , c =  0 }.b))) in u)
(let u = (( \f: Bool .((f (unfold [ Bool ] (fold [ Bool ] ({a = 1 , b = true , c =  1 }.b) )) ) (let u = (fix (\x: Unit . 1 )) in (fix (\x: Rec X. X . (let u = true in u) ))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in u)
(((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f (( \f: Nat .((f (if true then true else (((\x: Nat .\y: Unit .x) false ) false)) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Nat .\y: Nat .y) (let u = true in true) ) (unfold [ Nat ] (fold [ Nat ] false ))) ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = ({a = (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Bool .a)) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) in (( \f: Nat .((f (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) (fix (\x: Unit . true )) ) ) (\a: Rec X. X .\b: Bool .a))))
(unfold [ Unit ] (fold [ Nat ] (unfold [ Unit ] (fold [ Rec X. X ] (iszero (unfold [ Unit ] (fold [ Nat ] 1 ))) )) ))
(case <l = ({a = (let u = ({a = true , b = 0 }.a) in 1) , b = (if ({a = ({a = true , b = 1 }.b) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Unit .a)) }.b) then (if ({a = false , b = true }.b) then ({a = true , b = 1 }.a) else ({a = 1 , b = false , c =  1 }.b)) else (iszero (((\x: Nat .\y: Rec X. X .y) false ) 1))) }.a) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = (unfold [ Bool ] (fold [ Unit ] (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) )) , b = (case <l = (let u = false in (unfold [ Rec X. X ] (fold [ Unit ] 1 ))) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = ({a = (succ 1) , b = (iszero 1) , c = (((\x: Unit .\y: Rec X. X .y) ({a = 0 , b = (fix (\x: Rec X. X . true )) , c =  1 }.b) ) (if ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) then 1 else (unfold [ Nat ] (fold [ Rec X. X ] 0 )))) }.c) }.b)
(((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Bool .x) ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) , b = true }.b) ) ({a = (let u = 1 in false) , b = (((\x: Nat .\y: Bool .y) true ) true) }.b)) ) (let u = (( \f: Bool .((f (let u = true in 1) ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y)))
(if (let u = ({a = (case <r = (fix (\x: Nat . true )) > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Rec X. X .x) (fix (\x: Nat . (if false then true else true) )) ) (fix (\x: Rec X. X . false ))) }.b) in ({a = ({a = false , b = 1 }.a) , b = (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Rec X. X .b)) }.b)) then (let u = ({a = ({a = ({a = false , b = 1 }.b) , b = ({a = (pred 1) , b = false , c =  1 }.b) , c = (succ (unfold [ Unit ] (fold [ Nat ] 1 ))) }.c) , b = ({a = false , b = ({a = true , b = 0 }.a) }.b) }.a) in (((\x: Unit .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) (unfold [ Bool ] (fold [ Bool ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )))) else (fix (\x: Bool . ({a = 1 , b = false }.b) )))
(let u = (((\x: Rec X. X .\y: Unit .y) ({a = (let u = 1 in (if false then 0 else 0)) , b = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .a)) , c =  (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) ) (let u = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) in ({a = (((\x: Nat .\y: Rec X. X .x) true ) true) , b = ({a = 0 , b = true }.a) }.a))) in (((\x: Unit .\y: Bool .y) (( \f: Unit .((f (if (fix (\x: Unit . false )) then (let u = false in true) else (( \f: Rec X. X .((f true ) ({a = true , b = 1 }.a) ) ) (\a: Bool .\b: Unit .b))) ) (iszero (fix (\x: Nat . 1 ))) ) ) (\a: Bool .\b: Rec X. X .a)) ) (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Unit .\y: Nat .y) (iszero 1) ) (unfold [ Bool ] (fold [ Unit ] true ))) ))))
(if (let u = (let u = 1 in true) in u) then (fix (\x: Nat . (( \f: Nat .((f (pred ({a = 1 , b = true , c = 0 }.c)) ) (let u = 0 in u) ) ) (\a: Nat .\b: Rec X. X .a)) )) else (unfold [ Bool ] (fold [ Unit ] (if (unfold [ Nat ] (fold [ Bool ] true )) then (if true then 1 else 0) else ({a = true , b = 1 }.b)) )))
(((\x: Rec X. X .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Unit ] ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Nat .y) true ) true) }.b) )) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (if (iszero 1) then (let u = true in u) else (unfold [ Unit ] (fold [ Nat ] false ))) )))
({a = (let u = (iszero ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) , b = true , c = 0 }.c)) in u) , b = (fix (\x: Bool . ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] false )) )) }.b)
(let u = (let u = (let u = ({a = true , b = (succ 1) }.b) in (if ({a = 1 , b = true , c =  0 }.b) then true else (iszero 0))) in u) in u)
(if ({a = ({a = ({a = 1 , b = false }.a) , b = (let u = false in u) }.b) , b = (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Rec X. X .x) true ) false) )) }.b) then (iszero (case <l = (let u = 0 in 1) > as Nat of < l = x > => x | < r = y > => y)) else (let u = (succ ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (pred 0) ))) in (case <r = (let u = true in u) > as Unit of < l = x > => x | < r = y > => y)))
(let u = (fix (\x: Rec X. X . (( \f: Nat .((f 1 ) (let u = 1 in 1) ) ) (\a: Nat .\b: Unit .b)) )) in ({a = (fix (\x: Bool . (if true then true else true) )) , b = (( \f: Rec X. X .((f (succ ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 ))) ) ({a = 0 , b = false }.a) ) ) (\a: Bool .\b: Rec X. X .a)) }.b))
({a = (unfold [ Nat ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] ({a = 0 , b = true }.a) )) )) , b = (((\x: Bool .\y: Unit .y) ({a = (iszero 0) , b = (let u = 1 in 0) }.a) ) (let u = (let u = false in u) in u)) , c =  (( \f: Rec X. X .((f (pred (( \f: Nat .((f 0 ) (((\x: Bool .\y: Nat .y) true ) 1) ) ) (\a: Bool .\b: Unit .a))) ) (fix (\x: Unit . ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 0 )) )) ) ) (\a: Rec X. X .\b: Bool .a)) }.b)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] ({a = (if false then 1 else 1) , b = (( \f: Unit .((f ({a = 1 , b = ({a = 1 , b = true }.b) }.b) ) (((\x: Bool .\y: Unit .x) false ) false) ) ) (\a: Unit .\b: Bool .a)) }.b) )) ))
(let u = (( \f: Nat .((f ({a = (fix (\x: Rec X. X . (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) 1) )) , b = (((\x: Unit .\y: Rec X. X .y) (((\x: Nat .\y: Nat .y) true ) false) ) (let u = ({a = 0 , b = false , c =  1 }.b) in u)) , c = ({a = false , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.b) }.c) ) (( \f: Nat .((f (pred (((\x: Bool .\y: Bool .y) false ) 1)) ) (let u = (fix (\x: Unit . false )) in ({a = 1 , b = true }.a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Unit .b)) in (let u = ({a = ({a = false , b = 1 }.a) , b = (let u = false in true) }.b) in (unfold [ Bool ] (fold [ Rec X. X ] ({a = ({a = 1 , b = true }.a) , b = false }.a) ))))
(unfold [ Bool ] (fold [ Nat ] ({a = (((\x: Nat .\y: Bool .y) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b))) , b = ({a = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] 0 )) , b = ({a = true , b = true }.b) , c = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) }.c) , b = (case <l = (let u = 0 in 0) > as Nat of < l = x > => x | < r = y > => y) }.b) }.b) ))
(fix (\x: Nat . (((\x: Nat .\y: Rec X. X .x) ({a = (unfold [ Nat ] (fold [ Unit ] 0 )) , b = ({a = 1 , b = (let u = true in false) , c =  0 }.b) , c =  (( \f: Bool .((f (let u = 0 in u) ) (pred 0) ) ) (\a: Bool .\b: Unit .a)) }.b) ) (case <r = ({a = ({a = true , b = true }.b) , b = 0 }.a) > as Bool of < l = x > => x | < r = y > => y)) ))
(( \f: Bool .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Bool .((f (( \f: Nat .((f (fix (\x: Unit . true )) ) false ) ) (\a: Nat .\b: Rec X. X .a)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) ) ) (\a: Nat .\b: Bool .a)) )) ) (unfold [ Unit ] (fold [ Nat ] ({a = (iszero 0) , b = (if true then ({a = true , b = 1 }.b) else (((\x: Unit .\y: Rec X. X .x) 0 ) true)) }.a) )) ) ) (\a: Bool .\b: Rec X. X .b))
({a = (let u = ({a = (case <r = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.a) in (((\x: Unit .\y: Unit .x) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) (iszero 1))) , b = ({a = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Bool .a)) , b = (let u = 1 in true) , c = (((\x: Bool .\y: Rec X. X .x) 1 ) false) }.c) , b = (case <r = (let u = true in true) > as Bool of < l = x > => x | < r = y > => y) }.b) }.b)
(fix (\x: Unit . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Unit .\y: Bool .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) false) )) ))
(((\x: Rec X. X .\y: Rec X. X .x) (let u = ({a = (pred 0) , b = false }.a) in u) ) (iszero (((\x: Nat .\y: Rec X. X .x) (let u = 1 in u) ) (let u = false in true))))
({a = (pred (let u = ({a = 0 , b = false }.b) in (pred 1))) , b = (( \f: Bool .((f (iszero 0) ) (( \f: Nat .((f (((\x: Rec X. X .\y: Bool .x) true ) false) ) (iszero 1) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Unit .\b: Rec X. X .b)) }.a)
(let u = (if (((\x: Bool .\y: Rec X. X .y) (if (((\x: Nat .\y: Rec X. X .x) false ) true) then (((\x: Unit .\y: Unit .x) true ) true) else true) ) (let u = false in true)) then (iszero (let u = (((\x: Unit .\y: Bool .x) 0 ) false) in (let u = 1 in u))) else (((\x: Rec X. X .\y: Bool .x) (let u = true in false) ) ({a = false , b = 0 }.a))) in (let u = (pred (let u = true in 1)) in u))
(case <r = (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Rec X. X ] ({a = (let u = false in u) , b = (let u = 0 in false) }.b) )) )) > as Unit of < l = x > => x | < r = y > => y)
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (let u = ({a = false , b = 1 }.b) in ({a = 1 , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b)) )) in (let u = (fix (\x: Unit . (( \f: Nat .((f 1 ) (fix (\x: Bool . 0 )) ) ) (\a: Nat .\b: Unit .a)) )) in u))
(pred (case <l = (pred 1) > as Bool of < l = x > => x | < r = y > => y))
(pred (let u = ({a = 0 , b = false }.a) in (((\x: Nat .\y: Unit .x) (let u = 1 in 1) ) ({a = 0 , b = false }.b))))
(fix (\x: Bool . (case <r = ({a = (let u = true in 0) , b = (((\x: Unit .\y: Rec X. X .y) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) ) (let u = true in u)) , c =  ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.b) > as Unit of < l = x > => x | < r = y > => y) ))
(let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = ({a = 0 , b = true , c =  1 }.b) , b = (succ (let u = 0 in 1)) }.a) )) in ({a = (( \f: Bool .((f (pred 0) ) 1 ) ) (\a: Nat .\b: Rec X. X .a)) , b = (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) }.b))
({a = (succ (let u = (((\x: Unit .\y: Unit .x) false ) (((\x: Nat .\y: Rec X. X .y) false ) true)) in (pred 1))) , b = (((\x: Nat .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Bool ] (if false then true else (fix (\x: Unit . false ))) )) ) (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Bool .x) true ) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = 1 in 1))) }.b)
({a = (case <l = (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a)) ) (case <l = ({a = 1 , b = true }.a) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Unit .b)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (let u = true in u) , b = (( \f: Unit .((f (fix (\x: Nat . 0 )) ) (pred 1) ) ) (\a: Nat .\b: Nat .b)) }.b) }.b)
(unfold [ Unit ] (fold [ Bool ] (if (((\x: Unit .\y: Unit .x) false ) (if true then true else false)) then (( \f: Nat .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .b)) )) ) (let u = false in false) ) ) (\a: Unit .\b: Unit .b)) else ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = (((\x: Nat .\y: Unit .x) true ) false) }.b)) ))
({a = ({a = ({a = (succ 1) , b = (iszero 1) , c =  ({a = (let u = false in false) , b = 0 }.b) }.b) , b = (succ (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Bool .a))) }.a) , b = ({a = (fix (\x: Unit . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] false )) )) , b = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = ({a = false , b = true }.b) , c = (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) }.c) }.b) }.b)
(let u = (fix (\x: Unit . (succ (case <l = 0 > as Bool of < l = x > => x | < r = y > => y)) )) in ({a = ({a = (((\x: Unit .\y: Rec X. X .y) false ) true) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.a) , b = ({a = false , b = 0 }.b) }.b))
(let u = (let u = ({a = false , b = true }.b) in (let u = true in true)) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Bool ] (let u = ({a = true , b = true }.b) in 0) )) )))
(((\x: Nat .\y: Nat .x) ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (pred (( \f: Unit .((f 1 ) 0 ) ) (\a: Nat .\b: Rec X. X .a))) )) , b = ({a = (fix (\x: Unit . false )) , b = (let u = ({a = true , b = 0 }.b) in u) }.a) , c =  (unfold [ Unit ] (fold [ Rec X. X ] (if ({a = 1 , b = true }.b) then (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) else (((\x: Bool .\y: Bool .y) false ) 1)) )) }.b) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (( \f: Nat .((f (if ({a = true , b = 1 }.a) then (((\x: Unit .\y: Rec X. X .y) true ) true) else (iszero 0)) ) (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Rec X. X .b)) )))
(if (let u = ({a = ({a = true , b = 1 }.a) , b = (unfold [ Unit ] (fold [ Nat ] 0 )) }.a) in ({a = (((\x: Nat .\y: Bool .x) false ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a)) then ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (let u = true in u) )) , b = ({a = (if true then true else false) , b = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 0 )) }.b) }.a) )) else (((\x: Nat .\y: Unit .y) ({a = (unfold [ Nat ] (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) 1 ) true) )) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .a)) , c =  ({a = (succ 1) , b = (let u = (iszero 0) in u) }.a) }.b) ) (iszero (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) )))))
({a = (((\x: Nat .\y: Bool .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] true )) ) ({a = (case <r = true > as Nat of < l = x > => x | < r = y > => y) , b = (if true then false else true) }.b)) , b = (let u = ({a = (pred 1) , b = (let u = 1 in false) }.a) in u) }.a)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Bool .((f ({a = 1 , b = 1 }.b) ) (((\x: Unit .\y: Nat .x) 0 ) false) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(fix (\x: Bool . (if ({a = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) , b = (((\x: Unit .\y: Nat .x) ({a = 1 , b = false }.b) ) false) , c =  (((\x: Rec X. X .\y: Unit .y) (((\x: Unit .\y: Rec X. X .y) true ) true) ) (succ 0)) }.b) then ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Nat .a)) )) else ({a = (( \f: Nat .((f false ) ({a = 0 , b = true , c =  1 }.b) ) ) (\a: Bool .\b: Nat .a)) , b = (succ (fix (\x: Rec X. X . 0 ))) }.a)) ))
(pred (((\x: Nat .\y: Rec X. X .y) (case <r = ({a = 0 , b = false }.b) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Bool .y) (let u = 1 in true) ) (fix (\x: Unit . 0 )))))
(fix (\x: Unit . (unfold [ Nat ] (fold [ Bool ] (let u = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in (( \f: Nat .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] false )) ) true ) ) (\a: Nat .\b: Nat .a))) in ({a = false , b = false }.b)) )) ))
({a = (((\x: Bool .\y: Unit .y) (case <r = (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then ({a = false , b = (let u = 1 in 1) }.a) else (((\x: Bool .\y: Rec X. X .x) false ) false)) > as Nat of < l = x > => x | < r = y > => y) ) (fix (\x: Rec X. X . ({a = ({a = 1 , b = false }.b) , b = (((\x: Nat .\y: Bool .y) false ) true) }.b) ))) , b = (fix (\x: Unit . ({a = (fix (\x: Unit . 1 )) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) )) }.a)
(let u = (if (((\x: Unit .\y: Rec X. X .y) (let u = ({a = 0 , b = false }.b) in ({a = true , b = true }.b)) ) ({a = 0 , b = true , c =  1 }.b)) then ({a = (pred 0) , b = ({a = 0 , b = false , c =  0 }.b) }.a) else ({a = (fix (\x: Bool . true )) , b = (unfold [ Bool ] (fold [ Nat ] 1 )) }.b)) in u)
(( \f: Rec X. X .((f ({a = ({a = ({a = 1 , b = true , c = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .b)) }.c) , b = (case <r = ({a = 0 , b = (let u = 0 in true) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) }.a) , b = (case <r = (if (fix (\x: Bool . (fix (\x: Rec X. X . false )) )) then ({a = (let u = true in false) , b = (let u = 1 in true) }.b) else (let u = false in u)) > as Rec X. X of < l = x > => x | < r = y > => y) , c = (pred (let u = 0 in u)) }.c) ) (fix (\x: Bool . (if ({a = true , b = false }.b) then ({a = 0 , b = ({a = 0 , b = false }.a) }.b) else (pred 0)) )) ) ) (\a: Bool .\b: Bool .b))
({a = (fix (\x: Bool . (( \f: Nat .((f (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) , b = (fix (\x: Nat . (succ (if true then 1 else 1)) )) }.a)
(case <r = (let u = (let u = ({a = 1 , b = false }.a) in u) in (( \f: Rec X. X .((f (if true then false else false) ) (iszero 1) ) ) (\a: Bool .\b: Bool .a))) > as Bool of < l = x > => x | < r = y > => y)
(let u = ({a = (let u = (((\x: Bool .\y: Rec X. X .x) false ) false) in (unfold [ Bool ] (fold [ Nat ] (fix (\x: Rec X. X . 0 )) ))) , b = (( \f: Nat .((f ({a = false , b = 1 }.a) ) (let u = 0 in ({a = false , b = false }.b)) ) ) (\a: Rec X. X .\b: Unit .b)) , c = ({a = ({a = false , b = 1 }.b) , b = (let u = true in false) }.a) }.c) in (fix (\x: Bool . ({a = ({a = 1 , b = true }.a) , b = ({a = false , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) }.b) }.b) )))
(succ ({a = (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] true )) in ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 ))) , b = ({a = 0 , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) }.a) }.b))
({a = (((\x: Nat .\y: Bool .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Rec X. X .((f 1 ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Unit .\b: Bool .b)) )) ) (iszero (fix (\x: Bool . 0 )))) , b = ({a = ({a = ({a = (((\x: Bool .\y: Rec X. X .y) false ) false) , b = true }.b) , b = (let u = (((\x: Nat .\y: Bool .x) 0 ) true) in (if false then 1 else 1)) }.b) , b = (let u = (let u = (let u = false in true) in true) in (iszero (let u = ({a = false , b = 0 }.a) in (let u = 1 in 1)))) , c =  ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = (((\x: Unit .\y: Unit .y) true ) 0) }.b) }.b) }.b)
(let u = (case <r = (((\x: Unit .\y: Rec X. X .y) ({a = true , b = 1 }.a) ) (unfold [ Rec X. X ] (fold [ Nat ] false ))) > as Rec X. X of < l = x > => x | < r = y > => y) in u)
(let u = ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (((\x: Bool .\y: Bool .y) false ) 0) , b = false , c = 0 }.c) )) , b = (((\x: Nat .\y: Rec X. X .y) (fix (\x: Nat . true )) ) ({a = 0 , b = (let u = true in true) , c =  1 }.b)) , c = ({a = (let u = 1 in 0) , b = (iszero 1) }.a) }.c) in (let u = (fix (\x: Rec X. X . (pred 0) )) in (let u = (((\x: Unit .\y: Unit .y) true ) 0) in (unfold [ Bool ] (fold [ Rec X. X ] true )))))
(case <r = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (let u = (((\x: Bool .\y: Nat .x) true ) false) in (let u = 0 in 1)) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (iszero ({a = true , b = 0 }.b)) )) , c =  ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (let u = true in 1) )) , b = (unfold [ Unit ] (fold [ Bool ] true )) }.a) }.b) )) > as Nat of < l = x > => x | < r = y > => y)
({a = ({a = ({a = (if (let u = 0 in true) then 0 else (let u = 1 in 0)) , b = (( \f: Rec X. X .((f (let u = ({a = 0 , b = true , c = 1 }.c) in false) ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Bool .\b: Bool .a)) }.a) , b = (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Nat .x) true ) true) )) }.a) , b = ({a = (if (let u = false in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true ))) then (succ 0) else ({a = (iszero 1) , b = 0 }.b)) , b = (iszero (let u = 1 in 0)) }.b) }.a)
(let u = (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Nat . ({a = 0 , b = 1 }.b) )) )) in ({a = ({a = (case <r = (if true then false else true) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = true in 0) }.a) , b = ({a = (fix (\x: Bool . 0 )) , b = ({a = 0 , b = false }.b) , c = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.c) }.b))
(let u = (iszero (let u = ({a = 1 , b = true }.a) in 1)) in ({a = (( \f: Bool .((f (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .y) (unfold [ Nat ] (fold [ Bool ] false )) ) (let u = 1 in u)) )) ) (let u = (if (((\x: Rec X. X .\y: Rec X. X .x) true ) false) then 1 else 0) in ({a = 1 , b = 0 }.b)) ) ) (\a: Unit .\b: Unit .b)) , b = (let u = (fix (\x: Rec X. X . ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] false )) )) in u) , c =  ({a = (iszero 0) , b = (((\x: Unit .\y: Nat .y) (((\x: Unit .\y: Nat .y) false ) true) ) 1) }.b) }.b))
(let u = (case <r = (iszero (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) in u)
(( \f: Unit .((f ({a = (case <l = (let u = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) in 0) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (let u = (let u = 0 in false) in (pred 0)) in u) }.b) ) ({a = (let u = ({a = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b)) , b = ({a = 1 , b = true , c = 0 }.c) }.b) in (if (if false then false else true) then (let u = 1 in false) else false)) , b = ({a = (unfold [ Nat ] (fold [ Bool ] (((\x: Unit .\y: Nat .y) false ) 0) )) , b = (unfold [ Rec X. X ] (fold [ Bool ] ({a = false , b = 1 }.a) )) , c = ({a = 0 , b = 0 }.b) }.c) }.b) ) ) (\a: Unit .\b: Unit .a))
(((\x: Unit .\y: Unit .y) ({a = ({a = (succ 0) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) }.b) , b = (let u = (let u = (unfold [ Bool ] (fold [ Bool ] false )) in (let u = 1 in u)) in (if false then false else false)) }.b) ) ({a = (succ (let u = (let u = true in 0) in 1)) , b = (((\x: Unit .\y: Nat .x) (let u = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Bool .a)) in (let u = 1 in false)) ) (( \f: Nat .((f true ) ({a = 1 , b = false , c =  0 }.b) ) ) (\a: Unit .\b: Unit .a))) }.b))
(( \f: Bool .((f (case <r = (fix (\x: Rec X. X . (((\x: Rec X. X .\y: Unit .x) ({a = 1 , b = false , c =  1 }.b) ) true) )) > as Unit of < l = x > => x | < r = y > => y) ) ({a = (pred (((\x: Unit .\y: Rec X. X .y) true ) 0)) , b = ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .b)) , b = ({a = false , b = 0 }.a) , c =  ({a = true , b = 0 }.b) }.b) }.b) ) ) (\a: Unit .\b: Nat .a))
(if (unfold [ Rec X. X ] (fold [ Unit ] (let u = ({a = 1 , b = true , c =  0 }.b) in u) )) then ({a = (((\x: Nat .\y: Bool .x) ({a = false , b = 0 }.b) ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a))) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] false )) , c =  (let u = (( \f: Bool .((f true ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) in (let u = 1 in u)) }.b) else (((\x: Bool .\y: Bool .y) ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Nat .b)) )) ) (( \f: Bool .((f (unfold [ Unit ] (fold [ Unit ] false )) ) ({a = ({a = true , b = 1 }.b) , b = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .a)) }.b) ) ) (\a: Nat .\b: Bool .b))))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (if (let u = 0 in false) then ({a = true , b = ({a = 1 , b = 1 }.b) }.b) else (fix (\x: Rec X. X . 1 ))) )) , b = (fix (\x: Rec X. X . (fix (\x: Bool . ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = ({a = 0 , b = 1 }.b) }.a) )) )) }.b)
(iszero (( \f: Unit .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (((\x: Bool .\y: Nat .x) (pred 1) ) (((\x: Bool .\y: Nat .x) false ) false)) )) ) (fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] 0 )) )) ) ) (\a: Bool .\b: Bool .b)))
({a = ({a = (let u = (((\x: Bool .\y: Rec X. X .x) ({a = 0 , b = true }.a) ) (if true then true else false)) in ({a = (( \f: Unit .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .a)) , b = (pred (let u = 1 in u)) }.b)) , b = (( \f: Nat .((f ({a = 1 , b = false }.b) ) (( \f: Rec X. X .((f (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)) ) (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Rec X. X .\b: Bool .b)) }.a) , b = ({a = ({a = (((\x: Unit .\y: Rec X. X .y) true ) false) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (fix (\x: Bool . (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) )) , c =  (( \f: Unit .((f (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) in u) ) (pred 1) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) , c =  ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = (let u = ({a = 0 , b = false }.a) in (if true then 0 else (if true then 1 else 0))) , b = (((\x: Rec X. X .\y: Bool .y) (( \f: Bool .((f (let u = false in false) ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) (pred 1)) }.b) )) }.b)
(((\x: Bool .\y: Rec X. X .y) (if (((\x: Unit .\y: Nat .y) (if (fix (\x: Unit . false )) then false else true) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .y) false ) true) ))) then (((\x: Bool .\y: Bool .x) ({a = false , b = false }.b) ) (case <r = true > as Nat of < l = x > => x | < r = y > => y)) else (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in (( \f: Rec X. X .((f (((\x: Unit .\y: Rec X. X .x) false ) (let u = false in u)) ) (let u = (let u = 1 in true) in false) ) ) (\a: Rec X. X .\b: Bool .a)))) ) (fix (\x: Bool . ({a = (fix (\x: Bool . 1 )) , b = ({a = 0 , b = true }.b) }.b) )))
(let u = (let u = (let u = (((\x: Unit .\y: Bool .y) (( \f: Unit .((f (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .b)) ) (if true then false else true) ) ) (\a: Nat .\b: Rec X. X .b)) ) ({a = 0 , b = 0 }.b)) in ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = true in u) ))) in (let u = (let u = (fix (\x: Bool . 0 )) in 0) in ({a = 0 , b = 0 }.b))) in (( \f: Nat .((f (let u = (iszero 0) in (fix (\x: Bool . 1 ))) ) (((\x: Rec X. X .\y: Bool .y) true ) 1) ) ) (\a: Rec X. X .\b: Nat .b)))
(if (( \f: Nat .((f (( \f: Bool .((f ({a = (let u = false in true) , b = 1 }.a) ) (let u = true in u) ) ) (\a: Unit .\b: Unit .b)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = true in u) )) ) ) (\a: Nat .\b: Bool .b)) then ({a = (( \f: Rec X. X .((f (let u = (succ 0) in u) ) (if false then 1 else 1) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (succ 1) )) in (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) in false)) }.a) else ({a = (((\x: Nat .\y: Rec X. X .y) ({a = true , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) }.a) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] 0 ))) , b = ({a = ({a = false , b = 0 }.b) , b = (fix (\x: Unit . false )) , c =  (let u = 0 in u) }.b) }.a))
({a = (((\x: Unit .\y: Nat .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (fix (\x: Nat . (( \f: Bool .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .b)) ))) , b = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = ({a = (((\x: Nat .\y: Unit .y) (let u = (fix (\x: Nat . 0 )) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a))) , b = (let u = (((\x: Rec X. X .\y: Bool .x) false ) false) in u) }.b) , c =  ({a = (((\x: Rec X. X .\y: Nat .x) (let u = false in 0) ) (iszero 0)) , b = (if (if false then false else false) then (((\x: Rec X. X .\y: Unit .y) true ) false) else (fix (\x: Nat . false ))) }.a) }.b) , c =  ({a = (iszero (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y)) , b = (fix (\x: Nat . 0 )) }.b) }.b)
({a = (( \f: Rec X. X .((f (iszero (pred 1)) ) ({a = ({a = 1 , b = true , c =  0 }.b) , b = (let u = 1 in u) }.a) ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Nat .\y: Unit .x) (let u = (let u = (if false then 1 else 0) in u) in u) ) (let u = (((\x: Rec X. X .\y: Nat .y) true ) true) in ({a = false , b = false }.b))) }.a)
(let u = (fix (\x: Nat . ({a = ({a = (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = (if false then 0 else 1) }.a) , b = (((\x: Nat .\y: Nat .x) true ) false) }.b) )) in (if (((\x: Nat .\y: Rec X. X .x) (let u = true in u) ) (unfold [ Bool ] (fold [ Unit ] (fix (\x: Unit . true )) ))) then (((\x: Bool .\y: Bool .x) (( \f: Nat .((f true ) true ) ) (\a: Bool .\b: Bool .a)) ) false) else ({a = (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = true }.b) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) , b = (unfold [ Rec X. X ] (fold [ Nat ] true )) }.b)))
(((\x: Nat .\y: Rec X. X .y) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Bool ] (fold [ Rec X. X ] (iszero 1) )) )) ) ({a = ({a = (let u = 0 in 1) , b = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .a)) , c =  ({a = (let u = false in u) , b = 0 }.b) }.b) , b = (let u = (succ (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b))) in ({a = ({a = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) , b = (let u = false in true) }.a) , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.b)) }.b))
(let u = (iszero (((\x: Bool .\y: Rec X. X .y) (case <r = ({a = false , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f (unfold [ Nat ] (fold [ Unit ] 1 )) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) ) ) (\a: Bool .\b: Unit .b)))) in u)
(let u = (( \f: Rec X. X .((f ({a = (let u = 0 in u) , b = (iszero 0) , c = 0 }.c) ) ({a = true , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 0 )) }.b) ) ) (\a: Unit .\b: Bool .a)) in ({a = (((\x: Rec X. X .\y: Rec X. X .x) (( \f: Nat .((f (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) ) 1 ) ) (\a: Nat .\b: Unit .b)) ) ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Bool .b)) , b = (((\x: Unit .\y: Bool .y) false ) true) }.b)) , b = ({a = (( \f: Nat .((f ({a = 0 , b = false , c = 0 }.c) ) (fix (\x: Bool . 1 )) ) ) (\a: Unit .\b: Rec X. X .a)) , b = (case <r = ({a = 1 , b = false , c =  1 }.b) > as Unit of < l = x > => x | < r = y > => y) , c =  (case <l = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.a))
(let u = (fix (\x: Nat . (let u = (let u = (((\x: Unit .\y: Unit .x) true ) true) in 1) in (let u = (((\x: Bool .\y: Unit .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) ) false) in (((\x: Unit .\y: Rec X. X .y) true ) (((\x: Rec X. X .\y: Unit .x) false ) false)))) )) in ({a = (unfold [ Bool ] (fold [ Bool ] (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) , b = (( \f: Bool .((f ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , b = ({a = 0 , b = true }.a) }.a) ) ({a = (let u = (let u = 1 in true) in (((\x: Unit .\y: Bool .y) false ) false)) , b = (unfold [ Bool ] (fold [ Nat ] true )) }.b) ) ) (\a: Unit .\b: Bool .a)) , c =  (unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Bool ] (fold [ Rec X. X ] 0 )) )) }.b))
(fix (\x: Unit . (fix (\x: Unit . (let u = ({a = 1 , b = true , c =  0 }.b) in u) )) ))
(pred (let u = (let u = (if (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b)) then true else true) in (succ 1)) in ({a = (fix (\x: Bool . false )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (let u = 0 in u) )) }.b)))
(((\x: Rec X. X .\y: Rec X. X .x) (((\x: Bool .\y: Nat .y) ({a = ({a = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .b)) , b = (((\x: Bool .\y: Bool .x) 0 ) true) }.b) , b = (iszero 0) , c =  (let u = 0 in 0) }.b) ) (((\x: Unit .\y: Nat .x) (((\x: Nat .\y: Bool .x) true ) true) ) true)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (case <r = (unfold [ Nat ] (fold [ Unit ] (let u = 1 in true) )) > as Rec X. X of < l = x > => x | < r = y > => y) )))
(if ({a = (let u = (succ ({a = 1 , b = 1 }.b)) in u) , b = (((\x: Rec X. X .\y: Nat .y) (( \f: Rec X. X .((f (let u = false in u) ) (if true then true else false) ) ) (\a: Nat .\b: Bool .b)) ) (let u = (((\x: Unit .\y: Unit .y) true ) false) in u)) }.b) then (if (( \f: Rec X. X .((f (((\x: Bool .\y: Rec X. X .x) (let u = ({a = true , b = 1 }.a) in u) ) (((\x: Bool .\y: Bool .y) true ) true)) ) ({a = 0 , b = (let u = true in u) , c =  0 }.b) ) ) (\a: Unit .\b: Unit .b)) then (iszero ({a = true , b = 0 }.b)) else (if (unfold [ Bool ] (fold [ Unit ] false )) then (unfold [ Rec X. X ] (fold [ Nat ] true )) else (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = false , b = 1 }.a) )))) else (case <r = (((\x: Unit .\y: Unit .x) (( \f: Unit .((f false ) (iszero 1) ) ) (\a: Unit .\b: Unit .b)) ) (let u = (let u = true in 0) in true)) > as Rec X. X of < l = x > => x | < r = y > => y))
(((\x: Nat .\y: Nat .y) ({a = ({a = ({a = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) , b = false }.a) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (((\x: Rec X. X .\y: Bool .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] false )) ) (let u = 1 in u)) }.b) , b = (fix (\x: Nat . (iszero 1) )) }.b) ) ({a = (unfold [ Nat ] (fold [ Unit ] (((\x: Bool .\y: Unit .y) (iszero 0) ) 0) )) , b = (( \f: Bool .((f (let u = (unfold [ Bool ] (fold [ Unit ] false )) in (( \f: Unit .((f 0 ) ({a = false , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b))) ) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = (((\x: Rec X. X .\y: Unit .y) false ) false) , c = (let u = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) in u) }.c) ) ) (\a: Unit .\b: Rec X. X .a)) }.b))
({a = ({a = (( \f: Nat .((f (let u = 0 in ({a = true , b = 1 }.b)) ) (fix (\x: Bool . (( \f: Bool .((f 1 ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Unit .\b: Unit .b)) )) ) ) (\a: Nat .\b: Nat .a)) , b = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Bool .((f (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) ) (let u = (((\x: Rec X. X .\y: Bool .x) false ) false) in (iszero 1)) ) ) (\a: Unit .\b: Rec X. X .b)) )) }.a) , b = (iszero (( \f: Rec X. X .((f 1 ) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b))) , c = (unfold [ Bool ] (fold [ Rec X. X ] (( \f: Nat .((f ({a = true , b = 1 }.b) ) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) false) ) ) (\a: Rec X. X .\b: Nat .b)) )) }.c)
(case <r = (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) > as Unit of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .b)) then (if false then 1 else 0) else 0) in u) in (unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f (case <r = (if true then true else true) > as Bool of < l = x > => x | < r = y > => y) ) (let u = false in false) ) ) (\a: Rec X. X .\b: Bool .a)) )))
(let u = (fix (\x: Unit . (((\x: Unit .\y: Nat .x) ({a = 1 , b = false , c = 1 }.c) ) true) )) in (( \f: Bool .((f (fix (\x: Rec X. X . ({a = (let u = false in false) , b = false }.b) )) ) ({a = ({a = 1 , b = false , c = 1 }.c) , b = (((\x: Nat .\y: Unit .x) true ) false) , c =  (pred (succ 0)) }.b) ) ) (\a: Unit .\b: Unit .b)))
(fix (\x: Unit . ({a = (pred (succ ({a = 0 , b = true , c = 0 }.c))) , b = (((\x: Unit .\y: Bool .x) 1 ) (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Unit .b))) }.b) ))
(let u = ({a = (let u = (fix (\x: Rec X. X . (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) in u) , b = (let u = ({a = (let u = 1 in false) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.a) in (if (((\x: Bool .\y: Nat .x) true ) true) then 1 else 1)) }.a) in (fix (\x: Nat . (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) false) in (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] false )) ) (if true then false else true) ) ) (\a: Bool .\b: Rec X. X .b))) )))
(let u = (fix (\x: Unit . ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 )) , b = (((\x: Bool .\y: Unit .y) true ) 1) }.b) )) in u)
({a = (case <r = (( \f: Rec X. X .((f (iszero ({a = true , b = 0 }.b)) ) (iszero (let u = ({a = 0 , b = true }.a) in 0)) ) ) (\a: Rec X. X .\b: Unit .a)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Bool .\y: Nat .y) (let u = true in u) ) ({a = false , b = 1 }.a)) , b = (fix (\x: Bool . ({a = 1 , b = true , c = 0 }.c) )) }.b) }.a)
(((\x: Nat .\y: Rec X. X .y) (let u = (let u = ({a = (let u = true in u) , b = (pred 1) }.a) in ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] 1 ))) in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Bool ] false )) ))) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) false ) true) )) )))
({a = (succ ({a = ({a = true , b = 1 }.a) , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b)) , b = ({a = (unfold [ Bool ] (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) )) , b = (if ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Nat .\y: Nat .y) true ) false) )) then ({a = 1 , b = false }.b) else ({a = 0 , b = false , c =  0 }.b)) , c =  ({a = (let u = 0 in 0) , b = (unfold [ Nat ] (fold [ Bool ] (let u = true in false) )) }.a) }.b) }.a)
(let u = (( \f: Bool .((f ({a = (let u = (( \f: Unit .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) in u) , b = (fix (\x: Unit . 0 )) }.b) ) (((\x: Rec X. X .\y: Nat .x) ({a = (let u = 0 in u) , b = (let u = 0 in u) }.b) ) (fix (\x: Nat . (fix (\x: Unit . false )) ))) ) ) (\a: Bool .\b: Unit .a)) in (((\x: Unit .\y: Nat .x) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = (fix (\x: Unit . false )) }.a) ) (case <r = (let u = 1 in false) > as Unit of < l = x > => x | < r = y > => y)))
(let u = ({a = ({a = (((\x: Nat .\y: Nat .y) (((\x: Nat .\y: Rec X. X .y) true ) true) ) (( \f: Rec X. X .((f (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Bool .b)) ) ) (\a: Unit .\b: Bool .a))) , b = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .a)) in u) }.b) , b = (if ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] false )) then (((\x: Rec X. X .\y: Unit .x) (let u = true in true) ) true) else (((\x: Nat .\y: Bool .x) (let u = 1 in true) ) (let u = true in true))) , c = ({a = ({a = true , b = false }.b) , b = (fix (\x: Rec X. X . ({a = 0 , b = (let u = false in false) }.a) )) }.b) }.c) in (( \f: Unit .((f ({a = 1 , b = (if true then true else true) }.b) ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) ) (\a: Unit .\b: Unit .a)))
({a = (let u = (let u = 0 in u) in (iszero ({a = 0 , b = true }.a))) , b = (((\x: Rec X. X .\y: Unit .y) (let u = ({a = false , b = 1 }.a) in ({a = true , b = 1 }.a)) ) (((\x: Rec X. X .\y: Rec X. X .y) (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) then (fix (\x: Nat . false )) else (let u = true in false)) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Unit .\b: Unit .a)))) }.b)
(( \f: Unit .((f (fix (\x: Rec X. X . (case <l = ({a = false , b = ({a = 1 , b = 1 }.b) }.b) > as Nat of < l = x > => x | < r = y > => y) )) ) (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .b)) )) ) ) (\a: Nat .\b: Unit .b))
(if (iszero ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = true }.a) ))) then ({a = (case <r = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (pred 1) )) , b = (let u = true in (case <r = false > as Nat of < l = x > => x | < r = y > => y)) , c =  (unfold [ Rec X. X ] (fold [ Nat ] 0 )) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Unit .x) (let u = true in 0) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true ))) }.a) else (iszero ({a = (let u = true in 1) , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) , c = 1 }.c)))
({a = (((\x: Bool .\y: Nat .x) ({a = (if true then false else true) , b = 0 }.b) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = true , c =  0 }.b) ))) , b = (if ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (((\x: Bool .\y: Unit .y) true ) (unfold [ Rec X. X ] (fold [ Bool ] true ))) )) then (iszero (unfold [ Bool ] (fold [ Bool ] 1 ))) else ({a = ({a = (((\x: Nat .\y: Nat .x) 0 ) true) , b = true }.b) , b = (( \f: Unit .((f (unfold [ Rec X. X ] (fold [ Bool ] 1 )) ) (let u = false in 0) ) ) (\a: Unit .\b: Rec X. X .b)) }.a)) , c = (unfold [ Nat ] (fold [ Bool ] (fix (\x: Bool . (let u = 0 in u) )) )) }.c)
(let u = (let u = ({a = ({a = 1 , b = true }.b) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) }.a) in (let u = (unfold [ Bool ] (fold [ Bool ] false )) in u)) in (unfold [ Unit ] (fold [ Bool ] (unfold [ Bool ] (fold [ Bool ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) )))
(( \f: Rec X. X .((f ({a = (succ (succ 1)) , b = (succ (fix (\x: Bool . 1 ))) }.b) ) (let u = (pred ({a = 0 , b = true }.a)) in (let u = 0 in u)) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = ({a = (fix (\x: Rec X. X . (let u = 1 in 1) )) , b = ({a = (pred 0) , b = (iszero 1) , c =  (case <l = ({a = 1 , b = true , c = 1 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.b) in ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = false , b = ({a = 1 , b = 0 }.b) }.b) )) , b = ({a = 0 , b = ({a = false , b = 0 }.a) , c =  0 }.b) , c = (( \f: Bool .((f 0 ) (if false then 1 else 1) ) ) (\a: Nat .\b: Unit .a)) }.c))
(case <l = (if ({a = ({a = false , b = 0 }.b) , b = (let u = ({a = 0 , b = true }.b) in true) , c =  (pred 0) }.b) then (let u = ({a = 1 , b = (let u = 0 in true) , c =  1 }.b) in (let u = 0 in u)) else (if ({a = (let u = true in false) , b = ({a = true , b = 0 }.b) }.a) then ({a = 0 , b = false }.a) else (case <l = (( \f: Bool .((f 0 ) (let u = 0 in u) ) ) (\a: Unit .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y))) > as Unit of < l = x > => x | < r = y > => y)
(( \f: Nat .((f (let u = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Bool ] false )) )) in u) in (( \f: Rec X. X .((f (( \f: Bool .((f ({a = 0 , b = 1 }.b) ) (let u = 1 in 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))) ) ({a = ({a = (((\x: Rec X. X .\y: Nat .x) 0 ) false) , b = ({a = 1 , b = false , c = 0 }.c) }.b) , b = (((\x: Bool .\y: Nat .y) (let u = (fix (\x: Nat . false )) in u) ) (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a))) }.a) ) ) (\a: Unit .\b: Rec X. X .b))
(unfold [ Bool ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) true ) (((\x: Bool .\y: Nat .y) false ) 0)) ) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] true )) , b = 0 }.b) ) ) (\a: Unit .\b: Nat .a)) ))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = (let u = (let u = false in 0) in u) , b = (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = true , c =  1 }.b) ) (fix (\x: Bool . true ))) }.b) , b = (( \f: Rec X. X .((f (let u = (let u = 1 in 0) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] true ))) ) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Rec X. X .a)) }.b) ))
(( \f: Bool .((f (case <r = (fix (\x: Bool . (( \f: Bool .((f (fix (\x: Rec X. X . true )) ) (unfold [ Nat ] (fold [ Nat ] true )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = (let u = (((\x: Rec X. X .\y: Unit .y) true ) 1) in (((\x: Unit .\y: Rec X. X .y) ({a = true , b = 0 }.a) ) (((\x: Rec X. X .\y: Nat .x) true ) (let u = true in false)))) , b = (( \f: Bool .((f (let u = ({a = true , b = 1 }.a) in false) ) (((\x: Unit .\y: Unit .x) ({a = 1 , b = true }.b) ) ({a = false , b = 0 }.a)) ) ) (\a: Nat .\b: Bool .a)) }.b) ) ) (\a: Bool .\b: Rec X. X .b))
({a = ({a = (let u = ({a = (pred 1) , b = false }.b) in ({a = (((\x: Rec X. X .\y: Bool .y) (let u = false in true) ) 1) , b = ({a = 0 , b = true }.b) , c = (((\x: Nat .\y: Bool .y) true ) 0) }.c)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = true }.b) )) , c = (case <l = (unfold [ Bool ] (fold [ Unit ] 0 )) > as Bool of < l = x > => x | < r = y > => y) }.c) , b = (succ (let u = (((\x: Rec X. X .\y: Nat .y) true ) 0) in (let u = false in 1))) }.b)
(( \f: Rec X. X .((f (( \f: Nat .((f (let u = (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) in (((\x: Rec X. X .\y: Bool .x) 0 ) (fix (\x: Bool . true )))) ) ({a = 0 , b = (if true then 1 else 0) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ) (((\x: Nat .\y: Unit .x) ({a = (succ 1) , b = true }.a) ) (case <r = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) > as Nat of < l = x > => x | < r = y > => y)) ) ) (\a: Bool .\b: Bool .b))
(case <r = ({a = (case <r = ({a = 1 , b = true }.b) > as Bool of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ({a = true , b = 0 }.a) )) }.b) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (fix (\x: Rec X. X . (let u = (( \f: Unit .((f ({a = (let u = 1 in false) , b = (iszero 0) }.b) ) (let u = false in u) ) ) (\a: Nat .\b: Unit .b)) in (let u = (((\x: Nat .\y: Unit .x) 0 ) true) in false)) )) ))
(((\x: Unit .\y: Rec X. X .y) (unfold [ Bool ] (fold [ Bool ] (iszero 1) )) ) (succ (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) ))))
(( \f: Bool .((f (pred (((\x: Rec X. X .\y: Bool .x) ({a = 1 , b = 0 }.b) ) false)) ) ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (unfold [ Bool ] (fold [ Rec X. X ] false )) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) false) }.b) )) , b = ({a = (fix (\x: Unit . ({a = false , b = 0 }.b) )) , b = (let u = (if false then false else false) in (((\x: Unit .\y: Nat .x) false ) false)) , c = (((\x: Nat .\y: Nat .x) ({a = 0 , b = 1 }.b) ) false) }.c) }.b) ) ) (\a: Bool .\b: Nat .b))
(let u = (fix (\x: Unit . (( \f: Bool .((f (let u = 1 in (unfold [ Unit ] (fold [ Rec X. X ] true ))) ) (let u = (succ 1) in (if false then true else true)) ) ) (\a: Unit .\b: Bool .b)) )) in u)
({a = (case <l = ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = false , c =  0 }.b) )) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 )) }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (let u = (((\x: Unit .\y: Bool .x) (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = false , b = true }.b)) in (fix (\x: Bool . (((\x: Nat .\y: Nat .y) false ) (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ))) }.a)
(case <r = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = 1 , b = (iszero 0) , c =  ({a = 1 , b = false , c = 1 }.c) }.b) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (fix (\x: Bool . (let u = (let u = true in true) in u) )) , b = ({a = ({a = ({a = 0 , b = 1 }.b) , b = ({a = 1 , b = false , c =  1 }.b) }.b) , b = ({a = (let u = false in false) , b = 0 }.b) }.a) }.b)
(let u = (let u = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) , b = ({a = 1 , b = 0 }.b) }.b) in (fix (\x: Unit . ({a = 0 , b = true }.b) ))) in ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred 1) )) )) , b = (( \f: Unit .((f ({a = false , b = (((\x: Nat .\y: Unit .y) false ) false) }.b) ) (( \f: Unit .((f (((\x: Unit .\y: Bool .x) true ) false) ) (let u = false in (iszero 1)) ) ) (\a: Nat .\b: Nat .a)) ) ) (\a: Unit .\b: Unit .b)) }.b))
(((\x: Bool .\y: Unit .x) (unfold [ Bool ] (fold [ Unit ] ({a = (iszero 1) , b = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) }.b) )) ) (if (((\x: Bool .\y: Rec X. X .x) (fix (\x: Nat . false )) ) (let u = true in u)) then (case <r = true > as Nat of < l = x > => x | < r = y > => y) else (let u = (unfold [ Unit ] (fold [ Rec X. X ] (let u = false in u) )) in u)))
(( \f: Nat .((f (fix (\x: Rec X. X . (let u = (let u = ({a = 0 , b = true , c =  1 }.b) in u) in (succ (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y))) )) ) (case <l = ({a = true , b = (let u = 1 in 0) }.b) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b))
(let u = (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Bool ] (fold [ Bool ] (let u = 1 in u) )) )) in ({a = (let u = (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Rec X. X .y) (fix (\x: Rec X. X . true )) ) 0)) , b = (let u = (((\x: Rec X. X .\y: Nat .x) false ) (iszero 0)) in (case <r = true > as Bool of < l = x > => x | < r = y > => y)) , c = (case <l = (fix (\x: Unit . (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) > as Unit of < l = x > => x | < r = y > => y) }.c))
(( \f: Bool .((f (((\x: Nat .\y: Unit .y) (iszero (case <l = (let u = 0 in 0) > as Nat of < l = x > => x | < r = y > => y)) ) (if (let u = ({a = true , b = 0 }.b) in (case <r = ({a = false , b = 1 }.a) > as Unit of < l = x > => x | < r = y > => y)) then (let u = false in ({a = true , b = 0 }.a)) else (if true then ({a = 0 , b = false }.b) else (unfold [ Rec X. X ] (fold [ Unit ] false ))))) ) ({a = ({a = ({a = ({a = (let u = 0 in false) , b = 0 }.a) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = false , c = 0 }.c) )) }.a) , b = (iszero (let u = false in 1)) }.b) , b = (iszero (( \f: Bool .((f (succ 1) ) 0 ) ) (\a: Bool .\b: Bool .a))) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(fix (\x: Nat . (if ({a = ({a = 0 , b = (unfold [ Bool ] (fold [ Rec X. X ] false )) , c = 0 }.c) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Unit .a)) , c =  (unfold [ Bool ] (fold [ Rec X. X ] 0 )) }.b) then ({a = (((\x: Nat .\y: Unit .y) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) , b = (if (let u = 1 in false) then ({a = false , b = 0 }.b) else ({a = ({a = false , b = 1 }.b) , b = ({a = false , b = 1 }.b) }.b)) }.b) else (let u = (( \f: Unit .((f ({a = ({a = 1 , b = true , c = 0 }.c) , b = (unfold [ Nat ] (fold [ Bool ] true )) }.b) ) (let u = ({a = true , b = true }.b) in u) ) ) (\a: Unit .\b: Rec X. X .a)) in (unfold [ Rec X. X ] (fold [ Nat ] ({a = true , b = 0 }.b) )))) ))
(((\x: Rec X. X .\y: Rec X. X .x) (succ ({a = (fix (\x: Unit . 1 )) , b = false , c = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.c)) ) (let u = (let u = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) , b = (if false then false else false) , c = ({a = true , b = 1 }.b) }.c) in (( \f: Bool .((f (((\x: Nat .\y: Bool .y) (fix (\x: Rec X. X . true )) ) (let u = true in 1)) ) (unfold [ Unit ] (fold [ Bool ] (((\x: Bool .\y: Nat .y) true ) 1) )) ) ) (\a: Rec X. X .\b: Bool .a))) in (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Nat .b)) in (unfold [ Unit ] (fold [ Unit ] (iszero 0) )))))
(( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] (((\x: Nat .\y: Nat .x) false ) true) )) )) ) (if ({a = (iszero 0) , b = (((\x: Bool .\y: Bool .x) false ) true) }.b) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else (((\x: Bool .\y: Unit .x) ({a = true , b = false }.b) ) (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Nat .a)))) ) ) (\a: Unit .\b: Unit .a))
({a = (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = (((\x: Rec X. X .\y: Unit .x) true ) true) , c =  ({a = true , b = 1 }.b) }.b) ) (((\x: Rec X. X .\y: Unit .y) true ) true)) ) (let u = (unfold [ Bool ] (fold [ Unit ] true )) in u) ) ) (\a: Nat .\b: Unit .a)) , b = ({a = (let u = true in u) , b = ({a = 0 , b = 0 }.b) }.b) }.a)
(( \f: Nat .((f ({a = (let u = (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f false ) false ) ) (\a: Rec X. X .\b: Bool .a)) )) in u) , b = ({a = (fix (\x: Unit . (let u = 0 in 0) )) , b = (((\x: Bool .\y: Rec X. X .y) (let u = false in u) ) (fix (\x: Nat . false ))) }.b) }.b) ) (( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .y) ({a = 1 , b = false , c =  1 }.b) ) (let u = true in u)) ) ({a = true , b = (fix (\x: Bool . 0 )) }.a)) ) ({a = (( \f: Unit .((f 0 ) ({a = 0 , b = 1 }.b) ) ) (\a: Unit .\b: Unit .a)) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] true )) , c =  ({a = false , b = 1 }.b) }.b) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Bool .\b: Unit .b))
(((\x: Bool .\y: Bool .y) (iszero (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .a))) ) (let u = (if ({a = (let u = 1 in true) , b = (((\x: Nat .\y: Bool .y) true ) 0) }.a) then (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) else (pred 1)) in u))
({a = ({a = (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Nat .a)) , b = (let u = 0 in (((\x: Unit .\y: Unit .y) true ) true)) }.b) , b = (( \f: Nat .((f (( \f: Unit .((f (if (((\x: Unit .\y: Nat .y) false ) false) then 1 else 0) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Unit .\b: Bool .a)) ) (let u = ({a = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] false )) ) (( \f: Unit .((f false ) false ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (pred 1) }.b) in u) ) ) (\a: Bool .\b: Bool .a)) }.b)
(case <r = (case <r = ({a = (let u = (let u = true in u) in 0) , b = ({a = 0 , b = true }.b) }.b) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y)
(let u = (let u = (( \f: Bool .((f (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) (let u = 1 in false) ) ) (\a: Unit .\b: Bool .b)) in (((\x: Rec X. X .\y: Unit .x) 0 ) false)) in (fix (\x: Unit . (( \f: Bool .((f (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (let u = 0 in (let u = true in true)) ) ) (\a: Bool .\b: Rec X. X .a)) )))
({a = ({a = (case <l = (fix (\x: Unit . 1 )) > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Nat .\y: Unit .x) (( \f: Bool .((f (let u = true in true) ) ({a = 0 , b = false }.b) ) ) (\a: Bool .\b: Unit .a)) ) (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in true)) , c = ({a = (((\x: Bool .\y: Bool .x) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 1 )) ) false) , b = (if (((\x: Nat .\y: Rec X. X .y) true ) false) then false else (((\x: Nat .\y: Nat .x) false ) false)) , c = (let u = 1 in u) }.c) }.c) , b = (let u = (( \f: Nat .((f false ) false ) ) (\a: Nat .\b: Nat .b)) in (case <r = (((\x: Bool .\y: Rec X. X .x) true ) false) > as Rec X. X of < l = x > => x | < r = y > => y)) }.a)
(iszero (((\x: Bool .\y: Rec X. X .y) (((\x: Unit .\y: Unit .x) (fix (\x: Unit . true )) ) ({a = 0 , b = false }.b)) ) (let u = ({a = (((\x: Unit .\y: Nat .y) false ) false) , b = (((\x: Bool .\y: Unit .x) 0 ) false) }.b) in ({a = false , b = 0 }.b))))
(((\x: Unit .\y: Nat .x) (let u = (succ ({a = 0 , b = false }.a)) in u) ) (((\x: Rec X. X .\y: Bool .y) (if (((\x: Nat .\y: Bool .x) true ) false) then true else (let u = true in u)) ) (case <r = (let u = ({a = 1 , b = true }.a) in (let u = false in true)) > as Rec X. X of < l = x > => x | < r = y > => y)))
({a = (fix (\x: Nat . ({a = (let u = ({a = 1 , b = false , c = 0 }.c) in u) , b = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) }.b) )) , b = (if (let u = (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) true) in (succ 0)) in (( \f: Unit .((f (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .b)) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Unit .a))) then (let u = (((\x: Nat .\y: Unit .y) (let u = (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) in true) ) ({a = 0 , b = false , c =  1 }.b)) in u) else (((\x: Nat .\y: Bool .x) ({a = false , b = 0 }.a) ) ({a = 1 , b = true }.b))) }.b)
({a = (if (((\x: Bool .\y: Unit .x) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) ) (fix (\x: Unit . (let u = 1 in true) ))) then (let u = (let u = (fix (\x: Bool . ({a = 1 , b = 0 }.b) )) in (if false then true else false)) in (let u = (pred 0) in (let u = 0 in 0))) else (let u = (fix (\x: Rec X. X . (let u = false in 0) )) in (unfold [ Nat ] (fold [ Unit ] (pred 1) )))) , b = (fix (\x: Nat . ({a = (let u = ({a = 0 , b = (let u = false in u) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] 0 ))) , b = (let u = (pred 0) in u) }.b) )) }.b)
({a = (if (((\x: Nat .\y: Bool .y) (iszero 1) ) (let u = true in true)) then (let u = (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) in (( \f: Unit .((f ({a = 1 , b = true , c = 1 }.c) ) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a))) else ({a = 1 , b = 1 }.b)) , b = ({a = (((\x: Bool .\y: Bool .x) (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in u) ) (iszero 1)) , b = (( \f: Unit .((f ({a = (succ 1) , b = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Unit .b)) , c =  ({a = 0 , b = 0 }.b) }.b) ) (( \f: Nat .((f true ) false ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Nat .\b: Nat .a)) , c =  (pred ({a = false , b = 1 }.b)) }.b) , c = ({a = (let u = (let u = false in (let u = 0 in u)) in (( \f: Rec X. X .((f 0 ) (let u = 1 in u) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (case <r = (((\x: Bool .\y: Rec X. X .y) (let u = true in false) ) (((\x: Bool .\y: Rec X. X .x) false ) false)) > as Nat of < l = x > => x | < r = y > => y) , c = (((\x: Rec X. X .\y: Nat .y) ({a = true , b = true }.b) ) (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a))) }.c) }.c)
(if (unfold [ Rec X. X ] (fold [ Nat ] (( \f: Bool .((f (((\x: Unit .\y: Rec X. X .y) false ) true) ) ({a = true , b = true }.b) ) ) (\a: Rec X. X .\b: Nat .b)) )) then (succ (( \f: Nat .((f ({a = (let u = true in 0) , b = ({a = ({a = true , b = false }.b) , b = ({a = 0 , b = false , c =  1 }.b) }.b) , c = ({a = (((\x: Bool .\y: Bool .y) false ) 1) , b = false , c = (let u = 1 in u) }.c) }.c) ) ({a = 0 , b = (let u = false in false) , c = 1 }.c) ) ) (\a: Nat .\b: Bool .a))) else (pred (succ (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] 0 )) in u))))
(let u = ({a = ({a = (((\x: Unit .\y: Unit .x) (let u = 0 in 0) ) true) , b = ({a = false , b = false }.b) }.a) , b = (case <l = ({a = 0 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c = 0 }.c) > as Bool of < l = x > => x | < r = y > => y) }.b) in ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) , b = (let u = true in u) }.b) )))
({a = (((\x: Rec X. X .\y: Unit .x) (((\x: Nat .\y: Bool .x) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = false in u)) ) (iszero 0)) , b = (let u = (((\x: Rec X. X .\y: Nat .x) ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , b = (unfold [ Rec X. X ] (fold [ Bool ] (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) ))) in ({a = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.a) , b = (((\x: Bool .\y: Rec X. X .y) true ) true) }.b)) , c =  ({a = (succ ({a = 0 , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) }.b)) , b = (iszero 0) }.a) }.b)
({a = ({a = ({a = (if false then (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) else 1) , b = (if (let u = 1 in (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Unit .b))) then (((\x: Unit .\y: Nat .y) false ) true) else (( \f: Nat .((f false ) (((\x: Bool .\y: Unit .x) true ) true) ) ) (\a: Bool .\b: Unit .b))) }.b) , b = (( \f: Rec X. X .((f (if ({a = 1 , b = false }.b) then (let u = true in 0) else (case <l = ({a = 0 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (( \f: Nat .((f (pred 0) ) (((\x: Bool .\y: Bool .x) 0 ) true) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ) (\a: Nat .\b: Nat .a)) }.b) , b = (( \f: Unit .((f (iszero 1) ) (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Nat . true )) ) (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Bool .b))) ) ) (\a: Unit .\b: Bool .a)) }.a)
(( \f: Unit .((f (let u = (( \f: Bool .((f ({a = true , b = 1 }.b) ) 1 ) ) (\a: Unit .\b: Unit .a)) in (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Unit .y) true ) 1) ) false)) ) (let u = (((\x: Rec X. X .\y: Nat .x) (( \f: Nat .((f (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = 0 in u) ) ) (\a: Unit .\b: Nat .b)) ) (unfold [ Unit ] (fold [ Rec X. X ] ({a = false , b = 0 }.a) ))) in u) ) ) (\a: Bool .\b: Rec X. X .b))
(if ({a = ({a = (((\x: Nat .\y: Rec X. X .y) true ) 1) , b = (( \f: Nat .((f ({a = true , b = 1 }.a) ) (let u = (let u = false in u) in u) ) ) (\a: Nat .\b: Unit .a)) , c =  (fix (\x: Nat . ({a = 0 , b = 1 }.b) )) }.b) , b = ({a = (pred ({a = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Bool .x) 1 ) false) }.b)) , b = (unfold [ Nat ] (fold [ Bool ] 1 )) }.b) }.a) then ({a = ({a = true , b = 0 }.b) , b = (((\x: Rec X. X .\y: Nat .x) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) false) , c = (((\x: Nat .\y: Bool .x) (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .a)) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) }.c) else ({a = (let u = (iszero 0) in u) , b = (if (if true then true else true) then (((\x: Nat .\y: Bool .x) 0 ) true) else ({a = 1 , b = true }.a)) }.b))
(((\x: Unit .\y: Rec X. X .x) (pred ({a = (( \f: Nat .((f 1 ) (((\x: Bool .\y: Unit .y) true ) 0) ) ) (\a: Unit .\b: Unit .a)) , b = ({a = 1 , b = (fix (\x: Unit . false )) }.b) , c = (((\x: Rec X. X .\y: Unit .y) false ) (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)) }.c)) ) (fix (\x: Unit . (((\x: Rec X. X .\y: Rec X. X .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] false )) ) (if (let u = false in u) then (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )))) )))
(case <r = (((\x: Rec X. X .\y: Rec X. X .y) (unfold [ Unit ] (fold [ Nat ] false )) ) ({a = (pred 1) , b = ({a = true , b = false }.b) , c =  (let u = 0 in (let u = false in 0)) }.b)) > as Nat of < l = x > => x | < r = y > => y)
({a = (let u = (((\x: Rec X. X .\y: Unit .x) (let u = ({a = 1 , b = true }.a) in (((\x: Nat .\y: Bool .y) false ) 0)) ) ({a = (unfold [ Rec X. X ] (fold [ Unit ] 0 )) , b = true , c =  0 }.b)) in ({a = (((\x: Unit .\y: Rec X. X .x) 0 ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) , b = (( \f: Bool .((f false ) false ) ) (\a: Nat .\b: Unit .b)) , c =  ({a = false , b = 0 }.b) }.b)) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] (( \f: Unit .((f false ) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Nat .a)) )) }.b)
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (( \f: Nat .((f (if (fix (\x: Bool . true )) then ({a = true , b = 0 }.b) else (if true then 0 else 1)) ) (let u = (((\x: Unit .\y: Unit .y) true ) 1) in u) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
({a = (case <r = (( \f: Nat .((f (fix (\x: Rec X. X . true )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] ({a = 0 , b = true , c =  0 }.b) )) ) ) (\a: Unit .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (unfold [ Unit ] (fold [ Unit ] 1 )) in u) }.b)
(unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Bool . (case <r = ({a = 1 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) ))
(( \f: Rec X. X .((f (let u = ({a = (((\x: Unit .\y: Rec X. X .y) (iszero 0) ) 1) , b = (let u = (let u = false in true) in (((\x: Rec X. X .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) true)) , c =  ({a = 1 , b = ({a = 0 , b = true }.a) }.b) }.b) in (case <r = (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y)) ) (let u = ({a = ({a = 0 , b = false }.a) , b = (let u = true in u) }.a) in (case <r = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b)) > as Rec X. X of < l = x > => x | < r = y > => y)) ) ) (\a: Rec X. X .\b: Unit .b))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (( \f: Rec X. X .((f (let u = 0 in u) ) (let u = 0 in 1) ) ) (\a: Bool .\b: Bool .a)) , b = (let u = 1 in ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] true ))) }.a) )) ))
(iszero (pred (succ ({a = 0 , b = 0 }.b))))
(((\x: Bool .\y: Unit .y) ({a = (let u = true in u) , b = (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] false )) > as Unit of < l = x > => x | < r = y > => y) }.b) ) ({a = ({a = ({a = 0 , b = false , c = 0 }.c) , b = (let u = 1 in u) }.b) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Nat .b)) }.b))
(((\x: Unit .\y: Rec X. X .x) ({a = ({a = (if true then true else false) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) }.a) , b = (succ (((\x: Unit .\y: Unit .y) true ) 0)) }.a) ) ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] (if false then true else false) )) , b = (let u = false in 0) }.a))
({a = (((\x: Unit .\y: Rec X. X .y) ({a = (iszero 0) , b = ({a = 1 , b = false }.a) }.a) ) ({a = (fix (\x: Nat . 0 )) , b = (if (iszero 1) then (fix (\x: Bool . false )) else (if true then true else true)) }.b)) , b = (pred (( \f: Rec X. X .((f (fix (\x: Bool . 0 )) ) ({a = 0 , b = true }.a) ) ) (\a: Rec X. X .\b: Unit .b))) }.b)
(let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] (if false then false else true) )) )) in (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .y) (iszero 1) ) (( \f: Nat .((f (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Unit .a)) ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Nat .b))) ) (let u = (pred 1) in (( \f: Bool .((f false ) (unfold [ Bool ] (fold [ Unit ] false )) ) ) (\a: Nat .\b: Unit .b))) ) ) (\a: Nat .\b: Nat .b)))
(unfold [ Rec X. X ] (fold [ Nat ] (if (let u = (pred 1) in (fix (\x: Nat . ({a = (pred 1) , b = true , c =  (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) }.b) ))) then (let u = (unfold [ Nat ] (fold [ Nat ] 1 )) in (((\x: Unit .\y: Bool .x) (iszero 0) ) (let u = 0 in true))) else (( \f: Rec X. X .((f (( \f: Nat .((f (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Unit .\y: Unit .y) false ) false) ) ) (\a: Bool .\b: Bool .a)) ) (( \f: Unit .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Rec X. X .\y: Nat .y) (fix (\x: Nat . false )) ) true) ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Bool .b))) ))
({a = (if (let u = (((\x: Rec X. X .\y: Unit .y) false ) true) in u) then (let u = ({a = 1 , b = 0 }.b) in (( \f: Nat .((f ({a = true , b = 1 }.b) ) (let u = 1 in 1) ) ) (\a: Bool .\b: Bool .a))) else ({a = 1 , b = false , c = 1 }.c)) , b = ({a = (((\x: Unit .\y: Nat .x) (((\x: Unit .\y: Nat .x) 0 ) true) ) (( \f: Bool .((f ({a = true , b = true }.b) ) ({a = true , b = 1 }.a) ) ) (\a: Unit .\b: Nat .b))) , b = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = false in u) }.b) , c =  (succ ({a = 1 , b = 0 }.b)) }.b) , c =  (let u = ({a = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (if true then 1 else 1) }.b) in u) }.b)
({a = (( \f: Bool .((f (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (if true then 0 else 1) )) in ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] false ))) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] false )) ) ) (\a: Bool .\b: Nat .a)) , b = (( \f: Nat .((f ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = ({a = 1 , b = true , c =  0 }.b) in u) )) ) (((\x: Rec X. X .\y: Bool .x) (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = true , b = false }.b) )) ) (((\x: Unit .\y: Nat .y) false ) true)) ) ) (\a: Bool .\b: Rec X. X .a)) }.b)
(succ ({a = ({a = (iszero 0) , b = (((\x: Nat .\y: Nat .y) false ) false) }.b) , b = ({a = (let u = 0 in 0) , b = (let u = (iszero 1) in 1) }.b) }.b))
({a = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .x) 1 ) (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b))) ) (fix (\x: Bool . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) )) ) ) (\a: Bool .\b: Unit .a)) , b = (unfold [ Nat ] (fold [ Rec X. X ] (case <r = (let u = false in u) > as Rec X. X of < l = x > => x | < r = y > => y) )) , c =  (pred (( \f: Nat .((f 1 ) (((\x: Bool .\y: Unit .y) false ) 1) ) ) (\a: Rec X. X .\b: Bool .a))) }.b)
(let u = ({a = (let u = (let u = 0 in u) in u) , b = (succ (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Bool .x) 0 ) true) ) (let u = (if true then true else false) in false))) }.b) in u)
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (pred ({a = 1 , b = (if false then false else false) , c = 1 }.c)) ))
(( \f: Bool .((f ({a = ({a = (let u = 1 in 0) , b = (let u = 1 in true) , c = 0 }.c) , b = (((\x: Nat .\y: Nat .y) true ) true) }.b) ) (( \f: Bool .((f (let u = (let u = (let u = (((\x: Nat .\y: Bool .y) true ) 0) in true) in u) in ({a = (((\x: Bool .\y: Rec X. X .y) (let u = true in false) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))) , b = ({a = 0 , b = true , c =  1 }.b) , c =  (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .x) false ) false) ) 0) }.b)) ) (if (if ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) then (if true then false else true) else ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false ))) then (if true then false else true) else ({a = false , b = 1 }.a)) ) ) (\a: Unit .\b: Bool .b)) ) ) (\a: Nat .\b: Rec X. X .b))
(((\x: Nat .\y: Unit .y) (unfold [ Nat ] (fold [ Bool ] ({a = ({a = false , b = 1 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = true }.b) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] false ))) , c =  (succ 0) }.b) )) ) (( \f: Rec X. X .((f (let u = (((\x: Nat .\y: Unit .y) (iszero 1) ) (((\x: Nat .\y: Rec X. X .x) true ) true)) in u) ) (((\x: Bool .\y: Rec X. X .y) ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) , b = true }.b) ) ({a = true , b = false }.b)) ) ) (\a: Rec X. X .\b: Nat .b)))
({a = (fix (\x: Unit . ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Nat .x) 1 ) false) )) )) , b = (if (( \f: Rec X. X .((f ({a = (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) , b = (let u = 0 in u) }.a) ) ({a = 1 , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) }.b) ) ) (\a: Unit .\b: Rec X. X .a)) then (unfold [ Nat ] (fold [ Nat ] (let u = (((\x: Nat .\y: Bool .y) true ) false) in u) )) else (( \f: Unit .((f (( \f: Unit .((f (if ({a = 1 , b = true }.b) then true else false) ) (let u = true in false) ) ) (\a: Bool .\b: Unit .b)) ) ({a = ({a = true , b = 1 }.b) , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .b))) , c = (let u = (unfold [ Bool ] (fold [ Nat ] false )) in ({a = (let u = 1 in u) , b = (iszero 0) }.a)) }.c)
(fix (\x: Nat . ({a = (case <l = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = (case <r = ({a = true , b = 0 }.a) > as Nat of < l = x > => x | < r = y > => y) in ({a = false , b = 1 }.a)) }.a) ))
(if (if (if (case <r = (unfold [ Rec X. X ] (fold [ Nat ] false )) > as Nat of < l = x > => x | < r = y > => y) then (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Nat .b)) else (if ({a = 1 , b = true , c =  1 }.b) then (((\x: Nat .\y: Bool .y) false ) true) else (fix (\x: Bool . false )))) then (unfold [ Bool ] (fold [ Nat ] ({a = 0 , b = false , c =  0 }.b) )) else (( \f: Nat .((f ({a = 1 , b = (((\x: Unit .\y: Nat .y) true ) false) }.b) ) (( \f: Unit .((f false ) ({a = true , b = false }.b) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Unit .\b: Nat .b))) then (( \f: Nat .((f (fix (\x: Bool . (((\x: Rec X. X .\y: Rec X. X .x) true ) true) )) ) (((\x: Bool .\y: Nat .y) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (let u = false in u) )) ) ({a = 1 , b = ({a = 1 , b = true }.b) }.b)) ) ) (\a: Bool .\b: Bool .b)) else (let u = (unfold [ Bool ] (fold [ Unit ] (case <r = (if false then true else (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b))) > as Rec X. X of < l = x > => x | < r = y > => y) )) in (((\x: Bool .\y: Bool .x) (if (case <r = true > as Nat of < l = x > => x | < r = y > => y) then (let u = false in u) else ({a = false , b = false }.b)) ) ({a = true , b = false }.b))))
(fix (\x: Unit . (((\x: Bool .\y: Rec X. X .y) (unfold [ Rec X. X ] (fold [ Unit ] (let u = 0 in ({a = false , b = true }.b)) )) ) (fix (\x: Nat . ({a = true , b = 1 }.b) ))) ))
((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (( \f: Bool .((f (if (let u = false in u) then 0 else 1) ) ({a = 1 , b = 1 }.b) ) ) (\a: Bool .\b: Unit .a)) , b = (let u = (let u = true in ({a = false , b = false }.b)) in (unfold [ Bool ] (fold [ Bool ] ({a = true , b = false }.b) ))) }.b) ))
(((\x: Nat .\y: Nat .x) (unfold [ Bool ] (fold [ Nat ] (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) )) ) (iszero (( \f: Nat .((f (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = true }.a) )) ) ({a = false , b = 0 }.b) ) ) (\a: Bool .\b: Bool .b))))
(((\x: Unit .\y: Rec X. X .y) (iszero (if (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Unit .b)) then ({a = 1 , b = true }.a) else ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )))) ) (fix (\x: Bool . (((\x: Rec X. X .\y: Unit .y) false ) 0) )))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (( \f: Bool .((f (let u = ({a = 0 , b = true , c = 1 }.c) in true) ) (((\x: Nat .\y: Rec X. X .x) (case <r = (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) ) (let u = 1 in (let u = true in u))) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , b = (( \f: Nat .((f ({a = ({a = 1 , b = 0 }.b) , b = false }.b) ) ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = true }.b) ) ) (\a: Nat .\b: Nat .b)) }.b)
(((\x: Nat .\y: Unit .x) (let u = (unfold [ Rec X. X ] (fold [ Unit ] ({a = 1 , b = false , c = 0 }.c) )) in ({a = ({a = 1 , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .b)) }.a) , b = (let u = true in true) , c = (((\x: Unit .\y: Unit .x) 1 ) ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] false ))) }.c)) ) (( \f: Bool .((f (iszero ({a = 0 , b = false , c = 0 }.c)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Unit .\b: Rec X. X .b)))
(let u = (unfold [ Unit ] (fold [ Bool ] (let u = (fix (\x: Unit . (let u = 0 in u) )) in (unfold [ Unit ] (fold [ Rec X. X ] (let u = 0 in false) ))) )) in ({a = (((\x: Nat .\y: Nat .x) (if true then 0 else (if true then 0 else 1)) ) (fix (\x: Nat . true ))) , b = (fix (\x: Nat . (let u = true in u) )) }.a))
({a = (fix (\x: Bool . ({a = ({a = (fix (\x: Nat . false )) , b = ({a = false , b = 0 }.b) }.b) , b = (iszero 0) }.b) )) , b = (fix (\x: Rec X. X . (case <l = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) > as Unit of < l = x > => x | < r = y > => y) )) }.a)
(case <r = (if (let u = ({a = (let u = 0 in u) , b = true , c =  1 }.b) in u) then (unfold [ Rec X. X ] (fold [ Bool ] (case <r = ({a = 0 , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) )) else (iszero 0)) > as Rec X. X of < l = x > => x | < r = y > => y)
(unfold [ Unit ] (fold [ Rec X. X ] (iszero (((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Bool .y) false ) (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) ) (((\x: Unit .\y: Nat .y) ({a = 1 , b = false , c =  0 }.b) ) (((\x: Bool .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Bool ] true )) ) false)))) ))
(((\x: Nat .\y: Bool .y) ({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = ({a = false , b = 0 }.a) , b = false }.b) )) , b = (succ (let u = true in 0)) }.a) ) (let u = (case <r = (case <r = (let u = ({a = 0 , b = true }.b) in u) > as Unit of < l = x > => x | < r = y > => y) > as Unit of < l = x > => x | < r = y > => y) in (succ (if (if false then true else true) then (let u = 0 in 1) else (unfold [ Nat ] (fold [ Nat ] 1 ))))))
(((\x: Rec X. X .\y: Rec X. X .x) (if (let u = ({a = 0 , b = true }.b) in u) then (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Rec X. X .y) false ) ({a = 1 , b = false }.b)) )) else ({a = (fix (\x: Bool . (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Bool .a)) in 1) )) , b = (( \f: Bool .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (if true then true else false) )) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b)) }.b)) ) ({a = ({a = (if true then false else (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .a))) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) , b = (let u = (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .a)) in true) }.b))
(iszero ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = (pred 0) }.b) )))
(let u = (case <l = (( \f: Nat .((f ({a = ({a = true , b = 0 }.a) , b = (pred 1) }.b) ) (( \f: Nat .((f (succ 1) ) ({a = 0 , b = false }.a) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Nat .\b: Rec X. X .b)) > as Bool of < l = x > => x | < r = y > => y) in ({a = ({a = true , b = 1 }.b) , b = (pred 0) }.b))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (if (case <r = ({a = (((\x: Nat .\y: Bool .x) 1 ) (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Unit .a))) , b = (let u = 1 in false) , c =  (( \f: Unit .((f 1 ) (let u = 0 in u) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) > as Rec X. X of < l = x > => x | < r = y > => y) then ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) )) , b = (((\x: Rec X. X .\y: Unit .x) (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) (case <r = (unfold [ Nat ] (fold [ Bool ] true )) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b) else (succ (((\x: Unit .\y: Bool .y) (let u = true in true) ) ({a = true , b = 1 }.b)))) ))
(pred (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Rec X. X .x) ({a = ({a = true , b = 0 }.a) , b = 1 }.b) ) (if false then false else true)) ) ({a = (fix (\x: Rec X. X . (if true then 0 else 1) )) , b = ({a = (( \f: Rec X. X .((f (let u = true in false) ) (unfold [ Nat ] (fold [ Rec X. X ] true )) ) ) (\a: Nat .\b: Bool .a)) , b = ({a = true , b = 1 }.a) }.b) , c = (((\x: Rec X. X .\y: Rec X. X .x) (((\x: Unit .\y: Bool .x) ({a = 1 , b = true , c = 1 }.c) ) false) ) (if false then ({a = true , b = 1 }.a) else (case <r = true > as Unit of < l = x > => x | < r = y > => y))) }.c) ) ) (\a: Nat .\b: Nat .a)))
(( \f: Unit .((f (iszero ({a = (((\x: Bool .\y: Bool .x) (( \f: Bool .((f 0 ) (let u = true in 1) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (let u = (fix (\x: Rec X. X . 1 )) in true)) , b = ({a = true , b = false }.b) , c = (unfold [ Bool ] (fold [ Unit ] (unfold [ Unit ] (fold [ Unit ] 1 )) )) }.c)) ) (fix (\x: Unit . (unfold [ Nat ] (fold [ Nat ] ({a = false , b = true }.b) )) )) ) ) (\a: Rec X. X .\b: Nat .a))
({a = (case <l = (fix (\x: Bool . (pred ({a = (((\x: Bool .\y: Rec X. X .x) 0 ) false) , b = ({a = false , b = false }.b) , c = ({a = 0 , b = false }.a) }.c)) )) > as Nat of < l = x > => x | < r = y > => y) , b = (((\x: Bool .\y: Nat .y) (unfold [ Bool ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) true ) true) )) ) (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Bool .\y: Rec X. X .x) false ) false))) , c = ({a = ({a = ({a = ({a = (let u = 1 in true) , b = 1 }.a) , b = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.a) , b = (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in 1) )) }.b) , b = ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Nat .\y: Rec X. X .y) true ) 0) , b = false , c =  (let u = true in 1) }.b) , c = (unfold [ Nat ] (fold [ Bool ] 0 )) }.c) }.b) }.c)
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (( \f: Nat .((f ({a = (fix (\x: Nat . 1 )) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .x) true ) true) )) }.a) ) (fix (\x: Nat . (if (( \f: Bool .((f true ) true ) ) (\a: Bool .\b: Bool .a)) then 0 else (((\x: Bool .\y: Rec X. X .x) 1 ) false)) )) ) ) (\a: Nat .\b: Unit .a)) ))
(fix (\x: Nat . (let u = (case <r = (unfold [ Rec X. X ] (fold [ Unit ] (case <r = (if true then true else false) > as Unit of < l = x > => x | < r = y > => y) )) > as Bool of < l = x > => x | < r = y > => y) in u) ))
({a = (case <r = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (let u = 1 in u) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ({a = ({a = ({a = true , b = 0 }.a) , b = (let u = (let u = false in u) in u) }.b) , b = (succ (unfold [ Unit ] (fold [ Unit ] (let u = 0 in u) ))) }.a) }.b)
({a = ({a = ({a = (case <l = ({a = 0 , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) , b = (if true then true else true) , c = (((\x: Rec X. X .\y: Nat .y) true ) 1) }.c) , b = (pred ({a = 1 , b = ({a = 1 , b = true , c =  0 }.b) }.a)) }.b) , b = (fix (\x: Rec X. X . ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.a) )) , c =  (((\x: Unit .\y: Bool .y) (iszero 1) ) (succ (pred 1))) }.b)
(let u = (if (let u = (((\x: Rec X. X .\y: Unit .x) 0 ) false) in (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a))) then (let u = (((\x: Rec X. X .\y: Bool .y) true ) ({a = true , b = 1 }.a)) in (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a))) else (let u = true in 0)) in u)
(((\x: Bool .\y: Bool .x) (( \f: Unit .((f ({a = ({a = 1 , b = false , c = 0 }.c) , b = (fix (\x: Unit . ({a = 1 , b = false }.b) )) , c =  (( \f: Rec X. X .((f (unfold [ Bool ] (fold [ Nat ] 1 )) ) (let u = 1 in 0) ) ) (\a: Bool .\b: Nat .a)) }.b) ) ({a = (let u = ({a = 0 , b = true }.a) in (( \f: Rec X. X .((f true ) false ) ) (\a: Nat .\b: Nat .a))) , b = (((\x: Nat .\y: Rec X. X .x) 0 ) false) }.a) ) ) (\a: Bool .\b: Rec X. X .a)) ) (( \f: Nat .((f (let u = 1 in false) ) (fix (\x: Bool . false )) ) ) (\a: Unit .\b: Bool .b)))
(((\x: Bool .\y: Rec X. X .y) (if (unfold [ Unit ] (fold [ Bool ] true )) then (fix (\x: Unit . ({a = false , b = false }.b) )) else (((\x: Nat .\y: Nat .x) ({a = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) , b = (( \f: Nat .((f true ) false ) ) (\a: Bool .\b: Bool .a)) , c =  0 }.b) ) (if ({a = true , b = true }.b) then (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) else (((\x: Nat .\y: Rec X. X .y) false ) false)))) ) ({a = (iszero (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false)) , b = (( \f: Rec X. X .((f ({a = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Unit .a)) , b = (fix (\x: Nat . 1 )) }.a) ) (iszero 1) ) ) (\a: Unit .\b: Unit .a)) }.b))
({a = ({a = ({a = (let u = (let u = false in u) in (( \f: Bool .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) ) 0 ) ) (\a: Rec X. X .\b: Nat .a))) , b = (( \f: Bool .((f ({a = 1 , b = true }.b) ) (fix (\x: Nat . true )) ) ) (\a: Bool .\b: Nat .a)) , c = (let u = (unfold [ Nat ] (fold [ Unit ] true )) in (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a))) }.c) , b = (let u = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .a)) in (let u = 0 in true)) }.a) , b = (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Bool .\y: Rec X. X .x) ({a = 1 , b = true }.b) ) (let u = (unfold [ Nat ] (fold [ Unit ] true )) in u)) )) , c =  ({a = (((\x: Rec X. X .\y: Nat .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 0 , b = ({a = 0 , b = true , c =  1 }.b) }.a)) , b = (iszero (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) , c = ({a = (((\x: Nat .\y: Rec X. X .x) 1 ) false) , b = (unfold [ Bool ] (fold [ Bool ] true )) , c = ({a = 0 , b = false , c = (let u = 1 in 1) }.c) }.c) }.c) }.b)
(((\x: Nat .\y: Nat .x) (( \f: Rec X. X .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = true in 1) )) ) (((\x: Nat .\y: Unit .x) 0 ) (let u = true in u)) ) ) (\a: Unit .\b: Unit .b)) ) (case <r = (case <r = ({a = false , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y))
(let u = (( \f: Nat .((f (pred (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 1 )) in u)) ) ({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (fix (\x: Nat . 0 )) )) , b = (( \f: Bool .((f (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) }.b) ) ) (\a: Bool .\b: Rec X. X .b)) in (( \f: Nat .((f (let u = (case <r = (if true then false else false) > as Bool of < l = x > => x | < r = y > => y) in ({a = (unfold [ Nat ] (fold [ Unit ] 1 )) , b = ({a = false , b = 0 }.a) }.b)) ) (unfold [ Bool ] (fold [ Nat ] true )) ) ) (\a: Bool .\b: Nat .b)))
(if (fix (\x: Bool . (let u = ({a = (let u = 0 in u) , b = (let u = 0 in 1) }.b) in (((\x: Rec X. X .\y: Nat .y) (let u = false in u) ) (((\x: Unit .\y: Unit .y) true ) true))) )) then ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Nat .\y: Unit .y) (case <r = false > as Unit of < l = x > => x | < r = y > => y) ) (((\x: Bool .\y: Bool .y) false ) (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)))) )) else (let u = (((\x: Rec X. X .\y: Bool .y) (( \f: Unit .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true )) ) (unfold [ Nat ] (fold [ Unit ] true )) ) ) (\a: Unit .\b: Unit .a)) ) ({a = 1 , b = 0 }.b)) in (fix (\x: Bool . ({a = 0 , b = 1 }.b) ))))
(unfold [ Nat ] (fold [ Bool ] (fix (\x: Rec X. X . (let u = ({a = false , b = 1 }.a) in (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y)) )) ))
(if (iszero (unfold [ Bool ] (fold [ Unit ] ({a = (let u = (let u = false in false) in 1) , b = ({a = true , b = (let u = false in u) }.b) }.a) ))) then (let u = (((\x: Rec X. X .\y: Unit .x) (let u = true in true) ) false) in ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Unit .b)) ))) else ({a = (succ ({a = 0 , b = false }.a)) , b = ({a = ({a = 0 , b = false }.a) , b = (((\x: Rec X. X .\y: Nat .y) false ) true) , c = ({a = 0 , b = true }.a) }.c) }.b))
(let u = (iszero (fix (\x: Rec X. X . 1 ))) in (((\x: Nat .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Rec X. X .\y: Unit .x) true ) false) )) ) (fix (\x: Unit . ({a = ({a = false , b = false }.b) , b = ({a = false , b = 1 }.b) }.a) ))))
({a = (( \f: Unit .((f ({a = (fix (\x: Unit . false )) , b = ({a = 0 , b = ({a = true , b = 0 }.b) }.b) }.b) ) ({a = 0 , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Unit .\b: Rec X. X .b)) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (fix (\x: Bool . (unfold [ Nat ] (fold [ Nat ] true )) )) )) }.b)
(( \f: Bool .((f (if (fix (\x: Rec X. X . false )) then (let u = (((\x: Unit .\y: Unit .y) false ) 0) in 1) else ({a = (let u = 0 in 1) , b = (fix (\x: Bool . false )) , c = (let u = true in 1) }.c)) ) (let u = (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in (((\x: Unit .\y: Bool .x) 1 ) false)) in u) ) ) (\a: Nat .\b: Rec X. X .b))
(let u = (fix (\x: Bool . (( \f: Rec X. X .((f 1 ) (let u = false in 0) ) ) (\a: Nat .\b: Unit .b)) )) in u)
(case <l = (let u = (let u = ({a = (let u = true in 0) , b = 1 }.b) in (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .b))) in (( \f: Unit .((f 1 ) (pred 1) ) ) (\a: Nat .\b: Nat .b))) > as Unit of < l = x > => x | < r = y > => y)
(case <r = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = false , b = true }.b) )) , b = (( \f: Bool .((f true ) (case <r = true > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a)) }.b) > as Unit of < l = x > => x | < r = y > => y)
(case <r = (if ({a = ({a = (if true then false else false) , b = (( \f: Rec X. X .((f (let u = 0 in u) ) (((\x: Bool .\y: Nat .y) true ) 1) ) ) (\a: Bool .\b: Unit .a)) }.a) , b = (case <r = (let u = false in true) > as Unit of < l = x > => x | < r = y > => y) }.b) then ({a = (pred 0) , b = (let u = ({a = 1 , b = false }.b) in ({a = true , b = 1 }.a)) , c =  ({a = 1 , b = 1 }.b) }.b) else ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] (fix (\x: Unit . false )) ))) > as Nat of < l = x > => x | < r = y > => y)
(((\x: Unit .\y: Nat .y) ({a = (fix (\x: Nat . (let u = 1 in false) )) , b = (let u = (fix (\x: Unit . true )) in u) }.b) ) ({a = ({a = (((\x: Nat .\y: Bool .x) 0 ) ({a = true , b = 0 }.a)) , b = (fix (\x: Nat . false )) }.b) , b = (( \f: Bool .((f ({a = 0 , b = true }.b) ) (fix (\x: Unit . (let u = false in u) )) ) ) (\a: Bool .\b: Unit .a)) }.b))
(( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Bool .\y: Rec X. X .y) ({a = (if true then false else true) , b = ({a = 0 , b = (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Nat .b)) }.b) }.a) ) (succ ({a = 1 , b = 1 }.b))) )) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (if (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Unit .b)) then (((\x: Nat .\y: Unit .x) 1 ) true) else ({a = 0 , b = false , c = 1 }.c)) )) ) ) (\a: Bool .\b: Rec X. X .b))
(let u = (((\x: Unit .\y: Nat .x) ({a = (((\x: Unit .\y: Rec X. X .x) true ) true) , b = (fix (\x: Bool . 1 )) }.a) ) (fix (\x: Unit . (if false then false else false) ))) in ({a = (case <r = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] true )) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Unit .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (pred ({a = false , b = 0 }.b)) )) ) (unfold [ Bool ] (fold [ Unit ] 0 )) ) ) (\a: Unit .\b: Unit .b)) }.b))
(let u = (let u = (let u = (if (iszero 1) then 0 else 0) in (( \f: Rec X. X .((f 0 ) (let u = true in 0) ) ) (\a: Rec X. X .\b: Nat .a))) in (let u = ({a = 0 , b = true }.b) in u)) in ({a = (let u = ({a = true , b = 1 }.b) in (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) , b = (if (fix (\x: Rec X. X . true )) then ({a = ({a = 0 , b = 0 }.b) , b = true , c =  0 }.b) else (let u = false in u)) }.b))
(succ (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = ({a = 1 , b = false }.b) , b = (pred (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b))) }.b) )))
(unfold [ Rec X. X ] (fold [ Unit ] (( \f: Unit .((f ({a = (fix (\x: Rec X. X . 0 )) , b = (let u = false in false) , c = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.c) ) (( \f: Bool .((f (( \f: Rec X. X .((f (fix (\x: Unit . 1 )) ) 1 ) ) (\a: Nat .\b: Bool .b)) ) (case <l = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Bool .b)) ))
({a = ({a = (( \f: Nat .((f ({a = (let u = 1 in 1) , b = (let u = true in u) , c =  (( \f: Bool .((f (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.b) ) ({a = (let u = 0 in true) , b = false }.b) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = ({a = false , b = true }.b) in u) )) }.b) , b = (((\x: Bool .\y: Rec X. X .x) (pred (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .x) 0 ) true) ))) ) (( \f: Bool .((f (case <r = ({a = 0 , b = true }.b) > as Unit of < l = x > => x | < r = y > => y) ) (if (iszero 0) then (if false then false else false) else true) ) ) (\a: Rec X. X .\b: Bool .a))) }.b)
({a = (case <l = (( \f: Bool .((f (fix (\x: Bool . (unfold [ Unit ] (fold [ Rec X. X ] 1 )) )) ) (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) , c =  (((\x: Unit .\y: Rec X. X .x) (fix (\x: Rec X. X . (fix (\x: Bool . (( \f: Bool .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) )) )) ) (((\x: Bool .\y: Nat .y) (let u = 1 in false) ) (((\x: Rec X. X .\y: Unit .x) true ) false))) }.b)
(let u = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 1 , b = false }.b) )) in (let u = (((\x: Nat .\y: Unit .y) (((\x: Bool .\y: Rec X. X .x) false ) true) ) 1) in (( \f: Unit .((f (let u = false in ({a = false , b = false }.b)) ) (let u = true in u) ) ) (\a: Bool .\b: Nat .b)))) in (succ (unfold [ Nat ] (fold [ Bool ] (if (let u = 0 in true) then 1 else ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 ))) ))))
(((\x: Rec X. X .\y: Bool .x) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (((\x: Nat .\y: Rec X. X .y) true ) 0) )) , b = (let u = (unfold [ Bool ] (fold [ Unit ] (let u = 1 in false) )) in ({a = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Rec X. X .a)) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.b)) }.b) ) (if (iszero ({a = ({a = 1 , b = 1 }.b) , b = true }.a)) then (( \f: Rec X. X .((f (iszero ({a = 1 , b = true }.a)) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Nat .b)) else (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in true)))
(((\x: Unit .\y: Rec X. X .y) (let u = (unfold [ Unit ] (fold [ Nat ] (succ (unfold [ Nat ] (fold [ Rec X. X ] 0 ))) )) in (let u = (fix (\x: Bool . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] 1 )) )) in ({a = 0 , b = false }.b))) ) (case <l = (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Nat . (unfold [ Nat ] (fold [ Rec X. X ] 1 )) )) )) > as Unit of < l = x > => x | < r = y > => y))
({a = (if (unfold [ Bool ] (fold [ Rec X. X ] (let u = false in true) )) then (let u = ({a = false , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.a) in (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .x) 1 ) true) ) 0 ) ) (\a: Unit .\b: Nat .b))) else ({a = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] 0 )) ) 1 ) ) (\a: Nat .\b: Nat .b)) , b = (let u = (let u = 1 in false) in u) , c = (if (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Rec X. X .a)) then 1 else 0) }.c)) , b = (if (let u = (((\x: Bool .\y: Rec X. X .y) false ) true) in ({a = (if false then true else true) , b = false }.b)) then ({a = (case <r = (iszero ({a = 0 , b = true , c = 1 }.c)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (pred 0) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) ) (\a: Nat .\b: Rec X. X .a)) }.a) else (( \f: Bool .((f ({a = ({a = 0 , b = (( \f: Unit .((f 1 ) 1 ) ) (\a: Unit .\b: Unit .b)) }.b) , b = (unfold [ Unit ] (fold [ Rec X. X ] true )) }.b) ) (let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] true )) in true) ) ) (\a: Nat .\b: Rec X. X .a))) }.b)
(( \f: Rec X. X .((f ({a = (((\x: Unit .\y: Nat .x) (((\x: Bool .\y: Rec X. X .y) false ) 0) ) (((\x: Unit .\y: Nat .x) ({a = true , b = 1 }.a) ) (((\x: Nat .\y: Unit .y) true ) false))) , b = (let u = (succ 0) in ({a = false , b = 0 }.b)) }.b) ) ({a = ({a = ({a = true , b = 1 }.a) , b = (succ 0) }.b) , b = (fix (\x: Unit . (((\x: Nat .\y: Bool .x) (iszero 0) ) false) )) , c = ({a = (((\x: Unit .\y: Unit .y) (let u = false in u) ) 0) , b = (( \f: Nat .((f (let u = false in true) ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Bool .b)) , c = (unfold [ Unit ] (fold [ Rec X. X ] ({a = 1 , b = false }.a) )) }.c) }.c) ) ) (\a: Nat .\b: Nat .a))
(case <r = (((\x: Nat .\y: Unit .y) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = true , b = 0 }.a) )) ) ({a = (if true then false else true) , b = false }.b)) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (((\x: Nat .\y: Bool .x) true ) (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) in (((\x: Rec X. X .\y: Rec X. X .y) (iszero 1) ) ({a = false , b = true }.b))) in (case <r = ({a = (let u = 1 in 1) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false )) }.b) > as Bool of < l = x > => x | < r = y > => y))
(((\x: Unit .\y: Rec X. X .y) (( \f: Bool .((f ({a = (fix (\x: Unit . (let u = 1 in u) )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) }.b) ) (fix (\x: Rec X. X . (iszero (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .b))) )) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Unit .\y: Rec X. X .y) ({a = ({a = 0 , b = false , c = 1 }.c) , b = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = true }.b) }.b) ) ({a = ({a = true , b = 1 }.b) , b = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Bool .b)) , c =  ({a = 1 , b = true , c = 1 }.c) }.b)))
(let u = ({a = ({a = ({a = 0 , b = 1 }.b) , b = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Bool .a)) }.a) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Rec X. X .x) false ) false) )) , c =  (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y) }.b) in (iszero (fix (\x: Bool . ({a = 1 , b = (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) , c = 0 }.c) ))))
((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = (let u = (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Bool .b)) in ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) , b = (((\x: Unit .\y: Bool .y) true ) true) , c = (pred 0) }.c)) , b = (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) (case <l = ({a = (unfold [ Bool ] (fold [ Unit ] 1 )) , b = false , c = 0 }.c) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b)) }.b) ))
(let u = (unfold [ Bool ] (fold [ Bool ] (succ (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) )) in ({a = (succ (succ (((\x: Nat .\y: Rec X. X .x) 1 ) true))) , b = (fix (\x: Rec X. X . (( \f: Bool .((f (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Nat .\b: Bool .a)) )) }.a))
(((\x: Nat .\y: Bool .y) (unfold [ Nat ] (fold [ Nat ] (fix (\x: Unit . (case <r = false > as Unit of < l = x > => x | < r = y > => y) )) )) ) ({a = (( \f: Unit .((f (let u = 1 in u) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) )) ) ) (\a: Bool .\b: Nat .b)) , b = (case <r = ({a = 0 , b = (( \f: Bool .((f false ) false ) ) (\a: Rec X. X .\b: Bool .b)) , c =  (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) > as Unit of < l = x > => x | < r = y > => y) , c = ({a = (((\x: Unit .\y: Nat .y) false ) (fix (\x: Bool . 1 ))) , b = (unfold [ Nat ] (fold [ Bool ] true )) }.a) }.c))
(fix (\x: Rec X. X . (if (iszero (fix (\x: Rec X. X . 1 ))) then (let u = (fix (\x: Unit . (if true then true else true) )) in ({a = (let u = 1 in 1) , b = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , c =  0 }.b)) else (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = true }.b) )) ))) ))
(case <l = (let u = ({a = (iszero (succ 0)) , b = (succ (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b))) }.b) in (let u = (let u = ({a = true , b = 1 }.b) in (let u = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )) in (let u = 0 in true))) in (unfold [ Nat ] (fold [ Rec X. X ] (if false then 1 else 0) )))) > as Rec X. X of < l = x > => x | < r = y > => y)
(if (((\x: Bool .\y: Bool .y) (((\x: Rec X. X .\y: Nat .x) (unfold [ Nat ] (fold [ Rec X. X ] true )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] true ))) ) (((\x: Unit .\y: Rec X. X .x) ({a = 0 , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] true )) , c =  0 }.b) ) ({a = (let u = false in true) , b = false }.b))) then ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (fix (\x: Rec X. X . (unfold [ Nat ] (fold [ Unit ] false )) )) )) else ({a = (fix (\x: Nat . (((\x: Rec X. X .\y: Rec X. X .x) true ) (let u = true in false)) )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 1 , b = true , c = 0 }.c) )) }.a))
(succ ({a = (if (((\x: Rec X. X .\y: Bool .x) (((\x: Nat .\y: Unit .x) true ) true) ) ({a = (fix (\x: Bool . false )) , b = true }.b)) then (((\x: Unit .\y: Rec X. X .x) (((\x: Bool .\y: Nat .y) true ) 0) ) (((\x: Bool .\y: Nat .y) false ) true)) else (((\x: Unit .\y: Unit .x) (let u = 0 in 0) ) (iszero 0))) , b = ({a = (( \f: Nat .((f true ) (let u = true in u) ) ) (\a: Unit .\b: Unit .b)) , b = (((\x: Rec X. X .\y: Bool .x) false ) true) }.b) }.a))
(if (let u = ({a = true , b = (unfold [ Unit ] (fold [ Rec X. X ] false )) }.b) in (if false then false else ({a = true , b = 1 }.a))) then (let u = ({a = (unfold [ Nat ] (fold [ Nat ] (unfold [ Bool ] (fold [ Bool ] false )) )) , b = ({a = 1 , b = false , c = 0 }.c) }.a) in (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) else (if (let u = (unfold [ Rec X. X ] (fold [ Bool ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) in (((\x: Unit .\y: Rec X. X .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = 1 , b = true }.b) )) ) (iszero 0))) then (iszero (case <l = ({a = (fix (\x: Unit . 0 )) , b = true }.a) > as Nat of < l = x > => x | < r = y > => y)) else (unfold [ Nat ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Nat ] false )) ))))
(let u = (( \f: Nat .((f (((\x: Nat .\y: Unit .x) (( \f: Unit .((f (unfold [ Unit ] (fold [ Unit ] true )) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Nat .b)) ) (fix (\x: Bool . false ))) ) (((\x: Unit .\y: Rec X. X .x) (let u = 0 in true) ) (unfold [ Unit ] (fold [ Nat ] (((\x: Nat .\y: Bool .y) true ) false) ))) ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Bool .\y: Bool .y) ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = (if false then true else true) }.b) ) (iszero (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)))))
(( \f: Nat .((f (let u = (((\x: Unit .\y: Rec X. X .y) ({a = true , b = false }.b) ) 0) in (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = 1 }.b) )) ) (fix (\x: Bool . 1 )) ) ) (\a: Nat .\b: Bool .b))) ) (unfold [ Bool ] (fold [ Bool ] (case <l = ({a = 0 , b = (iszero 1) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) )) ) ) (\a: Bool .\b: Unit .a))
({a = (iszero (fix (\x: Rec X. X . 0 ))) , b = ({a = (( \f: Rec X. X .((f (let u = false in 0) ) (let u = false in 0) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = (unfold [ Rec X. X ] (fold [ Unit ] true )) , b = (unfold [ Bool ] (fold [ Bool ] false )) }.b) }.b) }.b)
(((\x: Nat .\y: Unit .y) (iszero (((\x: Bool .\y: Rec X. X .y) (( \f: Unit .((f (unfold [ Nat ] (fold [ Nat ] false )) ) true ) ) (\a: Unit .\b: Bool .a)) ) (unfold [ Rec X. X ] (fold [ Nat ] 0 )))) ) (( \f: Rec X. X .((f (((\x: Bool .\y: Unit .y) true ) true) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)))
(pred (case <l = ({a = 1 , b = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.b) > as Nat of < l = x > => x | < r = y > => y))
(((\x: Unit .\y: Bool .x) ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (( \f: Bool .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .b)) )) , b = (unfold [ Rec X. X ] (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Nat ] false )) )) , c = (let u = 0 in (fix (\x: Unit . 1 ))) }.c) ) ({a = ({a = ({a = true , b = true }.b) , b = true }.b) , b = (if (if true then true else false) then (((\x: Nat .\y: Nat .y) (fix (\x: Rec X. X . false )) ) (let u = true in 1)) else ({a = true , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) }.b)) }.a))
({a = (pred ({a = (succ 1) , b = (( \f: Unit .((f 1 ) ({a = true , b = 1 }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b)) }.b)) , b = (fix (\x: Bool . (((\x: Unit .\y: Rec X. X .x) (( \f: Rec X. X .((f (fix (\x: Bool . true )) ) (((\x: Nat .\y: Nat .y) false ) false) ) ) (\a: Rec X. X .\b: Bool .b)) ) (((\x: Bool .\y: Rec X. X .x) (let u = 0 in true) ) true)) )) , c = (unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (succ 0) , b = (unfold [ Unit ] (fold [ Bool ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )) }.a) )) }.c)
(( \f: Unit .((f (( \f: Nat .((f (pred (let u = (if false then true else false) in 1)) ) (((\x: Rec X. X .\y: Nat .x) (if true then 0 else 0) ) (let u = false in u)) ) ) (\a: Unit .\b: Unit .a)) ) (((\x: Unit .\y: Nat .x) (succ (((\x: Unit .\y: Bool .y) (( \f: Nat .((f (let u = 1 in false) ) (((\x: Bool .\y: Nat .x) false ) false) ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = false , b = ({a = true , b = 0 }.b) }.b))) ) (if ({a = (((\x: Rec X. X .\y: Nat .x) false ) true) , b = (((\x: Nat .\y: Unit .x) true ) false) }.b) then ({a = (fix (\x: Bool . 0 )) , b = (let u = false in u) , c =  ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) }.b) else (fix (\x: Nat . (((\x: Bool .\y: Bool .y) false ) true) )))) ) ) (\a: Unit .\b: Bool .b))
(case <r = ({a = (((\x: Nat .\y: Rec X. X .x) (((\x: Rec X. X .\y: Unit .y) (unfold [ Unit ] (fold [ Bool ] true )) ) ({a = 0 , b = false , c =  1 }.b)) ) (fix (\x: Bool . false ))) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (pred (if false then 0 else 0)) )) }.a) > as Unit of < l = x > => x | < r = y > => y)
(let u = (( \f: Nat .((f (let u = (let u = false in true) in (let u = 1 in u)) ) (unfold [ Nat ] (fold [ Bool ] (((\x: Bool .\y: Nat .y) true ) (( \f: Nat .((f 0 ) 0 ) ) (\a: Unit .\b: Rec X. X .b))) )) ) ) (\a: Unit .\b: Nat .b)) in u)
(succ ({a = (succ ({a = 1 , b = true }.a)) , b = (let u = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) in ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] 1 ))) }.b))
({a = (let u = (( \f: Unit .((f (case <r = false > as Bool of < l = x > => x | < r = y > => y) ) ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] false )) ) ) (\a: Rec X. X .\b: Unit .b)) in u) , b = (case <r = (let u = (fix (\x: Bool . false )) in u) > as Unit of < l = x > => x | < r = y > => y) }.b)
(fix (\x: Unit . (case <l = (fix (\x: Rec X. X . ({a = 0 , b = true , c = 0 }.c) )) > as Bool of < l = x > => x | < r = y > => y) ))
(let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] (unfold [ Nat ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = false in u) )) )) )) in (succ (if (let u = 0 in false) then (fix (\x: Nat . (succ 1) )) else (let u = false in (let u = 1 in u)))))
(( \f: Rec X. X .((f (( \f: Unit .((f (( \f: Nat .((f (let u = (succ 1) in (pred 0)) ) (((\x: Unit .\y: Rec X. X .x) 0 ) false) ) ) (\a: Unit .\b: Nat .a)) ) (((\x: Unit .\y: Bool .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Nat .\y: Rec X. X .x) (((\x: Unit .\y: Rec X. X .x) false ) true) ) false) )) ) (fix (\x: Nat . ({a = (((\x: Unit .\y: Rec X. X .y) true ) true) , b = ({a = true , b = 0 }.b) }.b) ))) ) ) (\a: Unit .\b: Unit .b)) ) (((\x: Rec X. X .\y: Bool .x) (let u = (pred 0) in u) ) ({a = (let u = ({a = 1 , b = false , c =  0 }.b) in u) , b = (((\x: Bool .\y: Rec X. X .y) true ) 1) }.a)) ) ) (\a: Bool .\b: Unit .b))
(if (let u = (case <r = (fix (\x: Nat . true )) > as Nat of < l = x > => x | < r = y > => y) in (iszero (((\x: Bool .\y: Bool .y) (fix (\x: Bool . false )) ) (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b))))) then (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .x) (( \f: Bool .((f true ) (if false then true else true) ) ) (\a: Nat .\b: Bool .b)) ) (iszero (case <l = 0 > as Bool of < l = x > => x | < r = y > => y))) )) else ({a = (case <r = ({a = 0 , b = true }.b) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f (if (fix (\x: Unit . true )) then (pred 0) else 0) ) (fix (\x: Bool . (pred 0) )) ) ) (\a: Unit .\b: Bool .b)) }.a))
(((\x: Unit .\y: Nat .x) (fix (\x: Nat . (((\x: Bool .\y: Bool .y) (( \f: Rec X. X .((f (((\x: Unit .\y: Unit .x) true ) true) ) true ) ) (\a: Nat .\b: Rec X. X .b)) ) (fix (\x: Rec X. X . true ))) )) ) (let u = ({a = (((\x: Unit .\y: Bool .y) ({a = true , b = true }.b) ) 1) , b = (((\x: Rec X. X .\y: Unit .x) (let u = ({a = 0 , b = true }.a) in (unfold [ Bool ] (fold [ Rec X. X ] false ))) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .x) true ) false) ))) , c =  (if (((\x: Nat .\y: Rec X. X .y) true ) true) then 0 else (let u = false in 0)) }.b) in u))
(case <r = (fix (\x: Nat . (let u = (iszero (if (unfold [ Nat ] (fold [ Unit ] true )) then 1 else ({a = false , b = 0 }.b))) in u) )) > as Bool of < l = x > => x | < r = y > => y)
(let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (((\x: Unit .\y: Nat .x) 1 ) false) )) in (( \f: Nat .((f (( \f: Bool .((f (((\x: Nat .\y: Nat .x) 1 ) true) ) (pred 1) ) ) (\a: Nat .\b: Rec X. X .a)) ) ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = ({a = 1 , b = true }.a) }.b) ) ) (\a: Nat .\b: Unit .b)))
(case <r = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = false , b = false }.b) )) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] ({a = false , b = 0 }.a) )) ) ) (\a: Unit .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y)
(let u = (unfold [ Rec X. X ] (fold [ Bool ] ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = true in u) )) )) in (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) in u))
(((\x: Bool .\y: Unit .y) (( \f: Nat .((f (iszero ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (let u = 0 in u) ))) ) ({a = (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) , b = (iszero 1) }.b) ) ) (\a: Nat .\b: Nat .a)) ) (case <r = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] false )) > as Unit of < l = x > => x | < r = y > => y))
(let u = (case <r = (((\x: Bool .\y: Unit .x) (((\x: Bool .\y: Bool .y) true ) false) ) (iszero 0)) > as Nat of < l = x > => x | < r = y > => y) in ({a = (fix (\x: Bool . (((\x: Bool .\y: Unit .x) true ) true) )) , b = (unfold [ Unit ] (fold [ Nat ] (succ 0) )) }.a))
(( \f: Bool .((f (succ (let u = (unfold [ Bool ] (fold [ Nat ] 1 )) in ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) , b = 1 }.b))) ) (unfold [ Nat ] (fold [ Nat ] (let u = ({a = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .a)) , b = ({a = 1 , b = true }.b) , c = 0 }.c) in (( \f: Rec X. X .((f (pred 1) ) ({a = 0 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a))) )) ) ) (\a: Nat .\b: Nat .b))
(succ ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (pred (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b))) )))
(( \f: Unit .((f (if ({a = ({a = 1 , b = true , c = 1 }.c) , b = (unfold [ Unit ] (fold [ Nat ] false )) }.b) then (((\x: Nat .\y: Bool .y) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) ) (( \f: Rec X. X .((f 1 ) (let u = true in 0) ) ) (\a: Nat .\b: Nat .a))) else (let u = (( \f: Rec X. X .((f 1 ) (if true then 0 else 1) ) ) (\a: Nat .\b: Nat .a)) in (((\x: Bool .\y: Unit .x) ({a = 1 , b = false , c = 1 }.c) ) (((\x: Unit .\y: Rec X. X .y) true ) false)))) ) (pred (unfold [ Rec X. X ] (fold [ Nat ] (pred 0) ))) ) ) (\a: Nat .\b: Nat .a))
(((\x: Rec X. X .\y: Bool .y) (( \f: Rec X. X .((f ({a = ({a = 1 , b = true , c =  1 }.b) , b = 0 }.a) ) ({a = ({a = false , b = 0 }.b) , b = (let u = false in true) , c =  ({a = (if false then 1 else 0) , b = ({a = 1 , b = true , c =  1 }.b) , c = 0 }.c) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = ({a = (let u = 1 in u) , b = ({a = ({a = true , b = 1 }.b) , b = 0 }.b) }.b) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (((\x: Unit .\y: Unit .x) false ) true) in (((\x: Bool .\y: Nat .x) 1 ) true)) )) }.b))
({a = (pred (if (let u = false in u) then (( \f: Nat .((f (let u = true in 1) ) ({a = false , b = 1 }.b) ) ) (\a: Unit .\b: Bool .a)) else ({a = 1 , b = false }.a))) , b = ({a = (( \f: Nat .((f ({a = (unfold [ Unit ] (fold [ Unit ] true )) , b = ({a = true , b = (((\x: Bool .\y: Bool .y) true ) 0) }.a) }.b) ) (let u = true in u) ) ) (\a: Bool .\b: Rec X. X .b)) , b = ({a = ({a = 0 , b = (unfold [ Nat ] (fold [ Nat ] true )) }.b) , b = ({a = (let u = 1 in u) , b = (let u = 1 in false) , c =  ({a = false , b = 0 }.b) }.b) }.b) }.b) , c =  (unfold [ Nat ] (fold [ Unit ] ({a = (if (iszero 0) then 1 else (if true then 0 else 0)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] 1 )) }.b) )) }.b)
(( \f: Bool .((f ({a = (let u = (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) in ({a = (if true then (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) else (unfold [ Rec X. X ] (fold [ Nat ] 0 ))) , b = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Nat .a)) , c =  (succ 0) }.b)) , b = (((\x: Bool .\y: Nat .x) ({a = ({a = false , b = 1 }.a) , b = (let u = false in u) }.b) ) ({a = ({a = 1 , b = true }.a) , b = (let u = 0 in ({a = false , b = 0 }.a)) }.b)) }.b) ) (unfold [ Bool ] (fold [ Rec X. X ] (((\x: Unit .\y: Rec X. X .x) (let u = 0 in false) ) (let u = true in true)) )) ) ) (\a: Unit .\b: Nat .b))
(( \f: Bool .((f (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Bool . ({a = (fix (\x: Unit . true )) , b = (iszero 1) }.b) )) ) (unfold [ Rec X. X ] (fold [ Nat ] (((\x: Rec X. X .\y: Unit .x) false ) (iszero 0)) ))) ) ({a = ({a = (((\x: Bool .\y: Nat .x) false ) false) , b = (let u = true in false) }.b) , b = (fix (\x: Unit . ({a = 1 , b = false , c =  1 }.b) )) }.b) ) ) (\a: Unit .\b: Unit .b))
({a = (let u = (let u = (((\x: Nat .\y: Rec X. X .x) (succ 0) ) (let u = 0 in false)) in ({a = ({a = true , b = 1 }.a) , b = (let u = 1 in 1) }.b)) in ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] false )) , b = true }.b)) , b = (( \f: Unit .((f ({a = (if true then false else false) , b = ({a = 1 , b = false }.a) }.a) ) ({a = ({a = (let u = true in u) , b = (((\x: Rec X. X .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Bool .b))) }.b) , b = ({a = (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = ({a = false , b = true }.b) , b = (let u = 0 in false) }.b) }.b) }.b) ) ) (\a: Nat .\b: Nat .a)) }.b)
({a = (((\x: Nat .\y: Unit .x) (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] true )) ) (let u = true in false) ) ) (\a: Unit .\b: Rec X. X .b)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true ))) , b = (let u = (fix (\x: Unit . (if false then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 0 )) else (if true then 0 else 1)) )) in (((\x: Rec X. X .\y: Nat .y) (unfold [ Nat ] (fold [ Rec X. X ] (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) )) ) (case <r = (if (iszero 1) then false else false) > as Bool of < l = x > => x | < r = y > => y))) }.b)
(( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] (let u = (( \f: Bool .((f (let u = true in false) ) false ) ) (\a: Rec X. X .\b: Nat .b)) in (( \f: Nat .((f (let u = (if true then 0 else 0) in u) ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] 0 )) ) ) (\a: Bool .\b: Unit .a))) )) ) (let u = (let u = (fix (\x: Unit . (pred 1) )) in u) in (succ (((\x: Nat .\y: Rec X. X .x) 0 ) true))) ) ) (\a: Nat .\b: Rec X. X .a))
(if (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) (let u = (((\x: Rec X. X .\y: Bool .x) true ) false) in u) ) ({a = (if false then false else false) , b = 1 }.a)) )) then (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) in u) else (case <r = ({a = (if (((\x: Rec X. X .\y: Rec X. X .y) false ) true) then (unfold [ Unit ] (fold [ Bool ] 1 )) else 1) , b = ({a = (let u = 0 in u) , b = ({a = true , b = 1 }.a) , c =  (fix (\x: Bool . 1 )) }.b) , c =  (((\x: Bool .\y: Bool .y) (fix (\x: Rec X. X . false )) ) (if false then 0 else 1)) }.b) > as Unit of < l = x > => x | < r = y > => y))
(iszero (succ ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))))
(if (let u = (let u = (let u = false in u) in (fix (\x: Bool . true ))) in u) then (( \f: Nat .((f (( \f: Rec X. X .((f (((\x: Bool .\y: Bool .y) ({a = false , b = true }.b) ) true) ) (unfold [ Rec X. X ] (fold [ Bool ] false )) ) ) (\a: Nat .\b: Nat .a)) ) (case <r = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b)) else (if ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] ({a = 1 , b = ({a = true , b = false }.b) }.b) )) , b = (unfold [ Unit ] (fold [ Nat ] (let u = true in 0) )) }.a) then (fix (\x: Unit . (( \f: Rec X. X .((f (if false then true else true) ) (let u = false in false) ) ) (\a: Bool .\b: Bool .b)) )) else (case <r = ({a = 1 , b = ({a = true , b = false }.b) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)))
(succ (let u = (fix (\x: Rec X. X . (let u = 0 in u) )) in u))
(case <r = ({a = (case <l = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) , b = (((\x: Rec X. X .\y: Bool .y) (fix (\x: Bool . (iszero 0) )) ) ({a = false , b = 1 }.a)) , c =  (let u = (((\x: Bool .\y: Rec X. X .y) true ) true) in (((\x: Unit .\y: Unit .x) 0 ) (((\x: Rec X. X .\y: Bool .y) true ) true))) }.b) > as Unit of < l = x > => x | < r = y > => y)
(let u = (succ ({a = (((\x: Rec X. X .\y: Nat .y) false ) false) , b = 0 }.b)) in (if (let u = true in u) then (let u = (unfold [ Unit ] (fold [ Nat ] 1 )) in (let u = 0 in 1)) else (if true then (((\x: Nat .\y: Rec X. X .y) true ) 1) else 0)))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Unit ] (fold [ Unit ] (unfold [ Nat ] (fold [ Unit ] (( \f: Bool .((f (((\x: Unit .\y: Nat .x) false ) false) ) (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Nat .\b: Unit .b)) )) )) ))
(( \f: Nat .((f (unfold [ Nat ] (fold [ Bool ] ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Bool .((f (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Bool .b)) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) )) )) ) ({a = ({a = (let u = (((\x: Bool .\y: Bool .y) false ) true) in true) , b = (let u = (let u = ({a = 0 , b = 1 }.b) in (succ 1)) in (iszero 1)) }.b) , b = (let u = (let u = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) in (case <r = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) > as Unit of < l = x > => x | < r = y > => y)) in ({a = ({a = 0 , b = (fix (\x: Nat . false )) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) }.c) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.a)) }.b) ) ) (\a: Bool .\b: Nat .a))
({a = (let u = (let u = (( \f: Bool .((f (((\x: Nat .\y: Nat .x) true ) true) ) (let u = 1 in true) ) ) (\a: Bool .\b: Unit .a)) in u) in ({a = (unfold [ Unit ] (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) false ) true) )) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = true in 0) )) }.b)) , b = ({a = (( \f: Nat .((f ({a = false , b = 1 }.b) ) ({a = 1 , b = true , c = 1 }.c) ) ) (\a: Bool .\b: Nat .b)) , b = (iszero 1) , c =  (fix (\x: Nat . 1 )) }.b) , c =  ({a = ({a = (fix (\x: Rec X. X . (fix (\x: Nat . 0 )) )) , b = (let u = ({a = 0 , b = false , c = 1 }.c) in (let u = 1 in 1)) }.b) , b = (unfold [ Nat ] (fold [ Rec X. X ] ({a = (if false then true else false) , b = true }.b) )) }.a) }.b)
(let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Unit . (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b))) )) )) in (case <r = (( \f: Rec X. X .((f (( \f: Unit .((f (let u = true in u) ) ({a = 0 , b = true , c =  0 }.b) ) ) (\a: Bool .\b: Unit .a)) ) (iszero ({a = 0 , b = 0 }.b)) ) ) (\a: Rec X. X .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y))
({a = (((\x: Bool .\y: Unit .x) (if true then (if false then 0 else 0) else ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] 1 ))) ) (if false then (case <r = false > as Nat of < l = x > => x | < r = y > => y) else (let u = 1 in false))) , b = (case <l = (succ (let u = (((\x: Unit .\y: Rec X. X .x) 0 ) false) in 0)) > as Bool of < l = x > => x | < r = y > => y) }.b)
(pred (((\x: Unit .\y: Rec X. X .x) (let u = (pred 0) in (if (((\x: Rec X. X .\y: Rec X. X .y) false ) true) then 1 else 1)) ) (unfold [ Unit ] (fold [ Bool ] (((\x: Nat .\y: Rec X. X .x) (let u = true in true) ) true) ))))
(if (let u = (case <l = ({a = false , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) in (fix (\x: Rec X. X . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 1 , b = true }.b) )) ))) then (iszero ({a = (unfold [ Unit ] (fold [ Bool ] (let u = 1 in 0) )) , b = ({a = 0 , b = true }.b) }.a)) else (((\x: Unit .\y: Nat .x) (let u = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) in u) ) (if ({a = false , b = false }.b) then true else false)))
(case <r = (if (((\x: Nat .\y: Nat .x) ({a = 1 , b = false , c =  1 }.b) ) true) then ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] (if (unfold [ Nat ] (fold [ Nat ] true )) then false else ({a = 0 , b = true }.b)) )) else (( \f: Nat .((f (((\x: Unit .\y: Nat .x) true ) true) ) (((\x: Bool .\y: Rec X. X .y) (if false then true else true) ) false) ) ) (\a: Rec X. X .\b: Rec X. X .b))) > as Bool of < l = x > => x | < r = y > => y)
(fix (\x: Nat . ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (case <l = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) )) ))
({a = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = ({a = 1 , b = false , c =  0 }.b) in ({a = 1 , b = false , c = 0 }.c)) )) , b = (let u = ({a = (let u = false in 1) , b = ({a = (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = 0 , b = true }.b) }.b) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Unit .((f (if true then true else false) ) false ) ) (\a: Rec X. X .\b: Bool .b)) ))) }.a)
(let u = (let u = (let u = 1 in false) in u) in (if (let u = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) in (let u = (pred 1) in true)) then (let u = 1 in (((\x: Bool .\y: Rec X. X .x) false ) false)) else (unfold [ Nat ] (fold [ Unit ] (let u = true in false) ))))
(((\x: Bool .\y: Rec X. X .x) ({a = (((\x: Nat .\y: Bool .x) (if true then (let u = 1 in 1) else 0) ) (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Unit .a))) , b = ({a = ({a = (fix (\x: Unit . 1 )) , b = (fix (\x: Unit . (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Nat .b)) )) }.a) , b = (((\x: Unit .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .y) false ) true) ) (fix (\x: Nat . false ))) }.b) }.b) ) (let u = ({a = (iszero 0) , b = (let u = 1 in u) }.a) in u))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Unit .((f 0 ) (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Rec X. X .b)) )) , b = (unfold [ Unit ] (fold [ Rec X. X ] (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a) ))
(iszero ({a = (if (if false then false else false) then 1 else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (let u = (if ({a = 0 , b = false }.b) then true else (fix (\x: Rec X. X . true ))) in u) , c = (let u = (let u = 1 in u) in u) }.c))
(fix (\x: Nat . (let u = ({a = (let u = 0 in 0) , b = (((\x: Rec X. X .\y: Nat .y) true ) 1) }.b) in u) ))
(succ (let u = (let u = false in 1) in u))
(case <r = (fix (\x: Bool . (fix (\x: Unit . (case <r = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .b)) > as Rec X. X of < l = x > => x | < r = y > => y) )) )) > as Bool of < l = x > => x | < r = y > => y)
({a = (( \f: Nat .((f (if ({a = (case <r = false > as Unit of < l = x > => x | < r = y > => y) , b = ({a = ({a = 0 , b = true , c =  1 }.b) , b = 0 }.b) }.a) then (if (( \f: Bool .((f false ) (iszero 0) ) ) (\a: Rec X. X .\b: Rec X. X .a)) then ({a = 0 , b = false , c = 1 }.c) else (case <l = (((\x: Unit .\y: Bool .x) 0 ) false) > as Rec X. X of < l = x > => x | < r = y > => y)) else (if true then 0 else ({a = 0 , b = false }.a))) ) (case <l = (let u = false in ({a = 0 , b = 0 }.b)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a)) , b = (let u = (if (let u = (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = false }.b) )) in ({a = (((\x: Rec X. X .\y: Bool .y) false ) 0) , b = true }.b)) then (fix (\x: Bool . (if false then true else true) )) else (let u = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) in false)) in u) , c = ({a = (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in (pred 0)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] ({a = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) , b = (if true then true else true) }.b) )) , c = ({a = ({a = true , b = 0 }.b) , b = true , c = (succ 1) }.c) }.c) }.c)
(if ({a = ({a = (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Bool .a)) , b = (let u = true in false) }.b) , b = (case <r = (let u = 1 in false) > as Bool of < l = x > => x | < r = y > => y) }.b) then (fix (\x: Unit . ({a = true , b = (pred 1) }.b) )) else (( \f: Nat .((f (pred ({a = 1 , b = true , c = 0 }.c)) ) (let u = ({a = 0 , b = 0 }.b) in ({a = (let u = 0 in 0) , b = true , c = 1 }.c)) ) ) (\a: Unit .\b: Nat .a)))
(let u = ({a = (fix (\x: Bool . (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) , b = (let u = (case <r = (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Nat .a)) > as Unit of < l = x > => x | < r = y > => y) in ({a = (fix (\x: Bool . 0 )) , b = false }.b)) }.b) in (((\x: Unit .\y: Nat .y) ({a = (unfold [ Unit ] (fold [ Unit ] (( \f: Nat .((f ({a = true , b = false }.b) ) true ) ) (\a: Nat .\b: Nat .b)) )) , b = (let u = 1 in (let u = true in false)) }.b) ) (( \f: Rec X. X .((f (case <l = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) > as Unit of < l = x > => x | < r = y > => y) ) (let u = (let u = true in u) in (((\x: Nat .\y: Rec X. X .y) false ) 1)) ) ) (\a: Bool .\b: Rec X. X .a))))
(let u = (let u = ({a = ({a = (((\x: Nat .\y: Bool .y) true ) 0) , b = (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Unit .b)) }.a) , b = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) }.b) in u) in u)
(if ({a = (((\x: Nat .\y: Unit .x) ({a = ({a = 1 , b = false }.a) , b = ({a = 1 , b = true }.b) }.a) ) ({a = true , b = true }.b)) , b = (iszero (pred 1)) , c =  (unfold [ Nat ] (fold [ Rec X. X ] (let u = (fix (\x: Unit . true )) in 0) )) }.b) then (((\x: Rec X. X .\y: Unit .y) ({a = (( \f: Rec X. X .((f (unfold [ Unit ] (fold [ Unit ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) ) (pred 1) ) ) (\a: Nat .\b: Unit .a)) , b = (let u = (let u = 0 in true) in u) }.b) ) (let u = ({a = false , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.a) in (fix (\x: Rec X. X . 1 )))) else (fix (\x: Bool . ({a = (let u = (let u = (iszero 0) in u) in (let u = 1 in u)) , b = (((\x: Bool .\y: Nat .x) (((\x: Rec X. X .\y: Rec X. X .x) 0 ) false) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (let u = false in u) ))) }.b) )))
(succ ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (succ 1) )) , b = (( \f: Rec X. X .((f ({a = 0 , b = 0 }.b) ) (((\x: Unit .\y: Bool .y) true ) 1) ) ) (\a: Nat .\b: Unit .b)) }.b))
(let u = (( \f: Rec X. X .((f ({a = 0 , b = 0 }.b) ) (case <l = (unfold [ Bool ] (fold [ Bool ] 0 )) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (fix (\x: Unit . ({a = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) , b = false }.b) )))
({a = (( \f: Nat .((f ({a = ({a = true , b = 1 }.b) , b = false , c = ({a = 1 , b = 1 }.b) }.c) ) (succ ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Bool .a)) , b = true , c = 1 }.c)) ) ) (\a: Bool .\b: Rec X. X .b)) , b = (if ({a = (( \f: Rec X. X .((f ({a = (let u = 1 in u) , b = (let u = false in u) }.b) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = (let u = (((\x: Bool .\y: Nat .y) false ) 1) in true) in (let u = (((\x: Unit .\y: Bool .x) 1 ) true) in (let u = true in u))) }.b) then ({a = ({a = (let u = true in 1) , b = (unfold [ Rec X. X ] (fold [ Bool ] true )) , c =  1 }.b) , b = (((\x: Rec X. X .\y: Unit .x) true ) true) }.b) else (fix (\x: Unit . (( \f: Nat .((f (let u = 1 in true) ) false ) ) (\a: Bool .\b: Rec X. X .a)) ))) }.b)
(iszero (((\x: Unit .\y: Unit .x) (((\x: Unit .\y: Nat .y) (let u = true in u) ) (fix (\x: Bool . ({a = 0 , b = false , c = 1 }.c) ))) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Bool .y) ({a = 1 , b = false , c =  0 }.b) ) (let u = 1 in false)) ))))
({a = (let u = ({a = 0 , b = (fix (\x: Nat . false )) , c = (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Rec X. X .a)) }.c) in (let u = ({a = 0 , b = true }.b) in u)) , b = ({a = (( \f: Nat .((f ({a = true , b = 0 }.a) ) (let u = 0 in false) ) ) (\a: Rec X. X .\b: Nat .a)) , b = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .b)) }.a) }.b)
({a = (( \f: Rec X. X .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = 0 , b = false }.a) )) ) (succ (let u = ({a = 0 , b = true }.a) in u)) ) ) (\a: Unit .\b: Nat .b)) , b = ({a = (let u = ({a = (((\x: Bool .\y: Rec X. X .x) true ) false) , b = (( \f: Nat .((f (let u = 1 in 0) ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) }.b) in u) , b = (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] 1 )) in ({a = true , b = ({a = 1 , b = false }.b) }.b)) }.b) }.a)
(succ (( \f: Nat .((f (fix (\x: Rec X. X . 1 )) ) (((\x: Unit .\y: Nat .x) (let u = 1 in u) ) (fix (\x: Unit . false ))) ) ) (\a: Rec X. X .\b: Bool .b)))
(let u = ({a = ({a = (let u = (( \f: Unit .((f false ) true ) ) (\a: Bool .\b: Bool .b)) in (unfold [ Rec X. X ] (fold [ Bool ] true ))) , b = ({a = (let u = true in ({a = 0 , b = true }.b)) , b = (let u = false in 0) }.a) }.b) , b = (let u = (iszero ({a = 1 , b = (iszero 0) , c = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.c)) in (( \f: Bool .((f (pred 0) ) (succ 1) ) ) (\a: Rec X. X .\b: Rec X. X .b))) }.b) in u)
(( \f: Nat .((f ({a = ({a = ({a = 1 , b = 1 }.b) , b = (((\x: Nat .\y: Nat .y) false ) true) , c =  ({a = 0 , b = (((\x: Unit .\y: Rec X. X .y) false ) true) }.a) }.b) , b = (( \f: Rec X. X .((f (( \f: Bool .((f (pred 1) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) (if (unfold [ Bool ] (fold [ Bool ] true )) then 0 else 1) ) ) (\a: Unit .\b: Bool .a)) }.a) ) (let u = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true )) in (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .b))) in u) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(((\x: Bool .\y: Rec X. X .y) (let u = ({a = ({a = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) }.b) , b = (((\x: Nat .\y: Unit .y) false ) (pred 0)) }.a) in u) ) ({a = (((\x: Bool .\y: Unit .y) ({a = true , b = 1 }.a) ) ({a = (let u = (let u = false in 1) in ({a = 0 , b = true , c = 0 }.c)) , b = ({a = (if true then 0 else 0) , b = (((\x: Bool .\y: Nat .y) false ) false) , c =  ({a = 0 , b = false }.a) }.b) , c = (((\x: Unit .\y: Rec X. X .x) 0 ) true) }.c)) , b = (iszero (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Unit .a))) }.a))
({a = ({a = (unfold [ Rec X. X ] (fold [ Nat ] ({a = 1 , b = 0 }.b) )) , b = (fix (\x: Unit . (if false then true else true) )) , c = ({a = false , b = ({a = 0 , b = 0 }.b) }.b) }.c) , b = (if (case <r = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y) then (((\x: Rec X. X .\y: Nat .y) (( \f: Nat .((f true ) (unfold [ Nat ] (fold [ Nat ] false )) ) ) (\a: Bool .\b: Rec X. X .b)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true ))) else (fix (\x: Rec X. X . ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] true )) ))) , c = (if (( \f: Rec X. X .((f (iszero 1) ) (((\x: Bool .\y: Rec X. X .x) (((\x: Unit .\y: Rec X. X .y) false ) false) ) (let u = false in u)) ) ) (\a: Rec X. X .\b: Nat .b)) then ({a = 1 , b = (fix (\x: Bool . false )) }.a) else (let u = ({a = false , b = true }.b) in 1)) }.c)
(case <r = ({a = (( \f: Unit .((f (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)) ) ({a = true , b = 0 }.b) ) ) (\a: Nat .\b: Bool .b)) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] false )) )) }.b) > as Unit of < l = x > => x | < r = y > => y)
(fix (\x: Bool . (let u = (( \f: Rec X. X .((f (( \f: Rec X. X .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) ) ({a = 0 , b = false }.b) ) ) (\a: Nat .\b: Rec X. X .b)) ) (let u = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) in ({a = 0 , b = (let u = 1 in true) , c =  ({a = false , b = 1 }.b) }.b)) ) ) (\a: Nat .\b: Rec X. X .a)) in ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] false )) , b = (let u = ({a = false , b = 1 }.a) in ({a = true , b = 1 }.b)) }.a)) ))
(((\x: Rec X. X .\y: Nat .x) (fix (\x: Rec X. X . (((\x: Unit .\y: Rec X. X .x) (unfold [ Rec X. X ] (fold [ Unit ] (iszero 0) )) ) (( \f: Rec X. X .((f ({a = false , b = true }.b) ) false ) ) (\a: Bool .\b: Unit .b))) )) ) (if (((\x: Bool .\y: Bool .x) (if true then true else false) ) (unfold [ Nat ] (fold [ Bool ] (let u = 0 in false) ))) then ({a = (let u = 0 in 0) , b = true }.b) else (iszero (unfold [ Rec X. X ] (fold [ Bool ] 1 )))))
(( \f: Rec X. X .((f (iszero (let u = (let u = (( \f: Nat .((f ({a = 0 , b = 1 }.b) ) (fix (\x: Bool . 1 )) ) ) (\a: Unit .\b: Unit .b)) in (((\x: Bool .\y: Nat .x) 0 ) false)) in u)) ) (let u = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) , b = ({a = false , b = 0 }.a) }.b) in u) ) ) (\a: Unit .\b: Unit .a))
(iszero (( \f: Bool .((f (let u = (iszero (unfold [ Nat ] (fold [ Rec X. X ] 1 ))) in (succ (unfold [ Nat ] (fold [ Rec X. X ] 0 )))) ) (case <l = ({a = 1 , b = true }.a) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .b)))
(succ ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Unit . (fix (\x: Bool . 0 )) )) )))
(case <r = (case <r = ({a = (let u = (((\x: Bool .\y: Bool .x) (iszero 0) ) false) in u) , b = ({a = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] true )) , b = 1 }.b) }.a) > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)
(fix (\x: Rec X. X . (case <r = (unfold [ Unit ] (fold [ Rec X. X ] (fix (\x: Unit . ({a = 1 , b = true , c =  0 }.b) )) )) > as Nat of < l = x > => x | < r = y > => y) ))
(iszero (let u = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) in ({a = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) , b = (((\x: Bool .\y: Rec X. X .y) true ) true) , c = ({a = 0 , b = false , c = ({a = 1 , b = 1 }.b) }.c) }.c)))
({a = (let u = (let u = (iszero (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .a))) in (let u = (if false then 1 else 0) in (let u = 1 in true))) in (( \f: Bool .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) ({a = 1 , b = 0 }.b) ) ) (\a: Rec X. X .\b: Nat .a))) , b = (let u = (((\x: Nat .\y: Unit .y) (( \f: Nat .((f false ) true ) ) (\a: Nat .\b: Unit .b)) ) (pred 1)) in (if false then true else true)) }.b)
(let u = ({a = (case <l = ({a = ({a = true , b = (((\x: Rec X. X .\y: Unit .x) 0 ) false) }.a) , b = (unfold [ Unit ] (fold [ Bool ] 0 )) }.b) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = (((\x: Nat .\y: Nat .x) 1 ) false) , b = (let u = true in false) }.b) , c = ({a = (let u = (iszero 1) in false) , b = (((\x: Unit .\y: Rec X. X .x) 0 ) false) }.b) }.c) in (iszero (( \f: Rec X. X .((f (if false then 0 else 0) ) (( \f: Bool .((f 1 ) (((\x: Bool .\y: Bool .x) 0 ) true) ) ) (\a: Bool .\b: Bool .a)) ) ) (\a: Unit .\b: Unit .a))))
(unfold [ Nat ] (fold [ Unit ] (if (case <r = (let u = 0 in true) > as Rec X. X of < l = x > => x | < r = y > => y) then (( \f: Unit .((f (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .x) false ) false) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Nat .b)) ) ) (\a: Bool .\b: Nat .b)) ) ({a = (case <r = (iszero 0) > as Unit of < l = x > => x | < r = y > => y) , b = (succ (let u = 0 in u)) }.a) ) ) (\a: Bool .\b: Nat .b)) else (iszero ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] 0 )))) ))
((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] (let u = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) false ) true) )) in ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = 1 , b = (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , c = ({a = (pred 1) , b = (iszero (let u = true in 0)) }.a) }.c)) ))
(let u = (((\x: Nat .\y: Rec X. X .x) (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) in u) ) (let u = ({a = true , b = 0 }.b) in (((\x: Unit .\y: Bool .y) false ) true))) in (succ ({a = 1 , b = true }.a)))
((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] (let u = (if (let u = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) in true) then (((\x: Unit .\y: Rec X. X .x) 0 ) false) else ({a = (let u = 0 in 1) , b = ({a = 0 , b = 1 }.b) }.b)) in u) ))
({a = (fix (\x: Nat . ({a = ({a = 1 , b = false , c = 0 }.c) , b = (unfold [ Bool ] (fold [ Unit ] true )) }.a) )) , b = ({a = (fix (\x: Bool . ({a = (unfold [ Bool ] (fold [ Nat ] 0 )) , b = true }.b) )) , b = (let u = (unfold [ Nat ] (fold [ Bool ] true )) in u) }.b) }.a)
(((\x: Rec X. X .\y: Nat .y) ({a = (((\x: Unit .\y: Unit .x) true ) false) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) }.b) ) (( \f: Unit .((f ({a = true , b = (unfold [ Nat ] (fold [ Rec X. X ] true )) }.b) ) (if (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b)) then true else true) ) ) (\a: Unit .\b: Nat .b)))
(if (let u = (let u = (let u = ({a = 0 , b = false , c =  0 }.b) in u) in u) in (let u = (unfold [ Unit ] (fold [ Rec X. X ] 0 )) in ({a = 1 , b = true , c =  (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.b))) then ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] ({a = false , b = (iszero 0) }.b) )) else (unfold [ Bool ] (fold [ Bool ] (case <r = (let u = (let u = true in u) in (unfold [ Unit ] (fold [ Nat ] false ))) > as Nat of < l = x > => x | < r = y > => y) )))
(( \f: Unit .((f ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (pred (fix (\x: Nat . 1 ))) )) ) (let u = (let u = ({a = false , b = false }.b) in (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) in (((\x: Unit .\y: Rec X. X .y) ({a = 1 , b = false }.b) ) 1)) ) ) (\a: Rec X. X .\b: Rec X. X .b))
({a = (( \f: Unit .((f (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) ) ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) )) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = ({a = (((\x: Nat .\y: Rec X. X .y) true ) 0) , b = true , c = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .a)) }.c) , b = (iszero ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))) }.b) }.b)
(succ ({a = (if (((\x: Rec X. X .\y: Nat .x) (fix (\x: Bool . false )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] false ))) then (let u = 0 in 1) else (let u = ({a = 0 , b = true }.a) in ({a = 1 , b = true , c = 0 }.c))) , b = (fix (\x: Unit . (( \f: Unit .((f (let u = true in false) ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , c = (((\x: Unit .\y: Unit .x) (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true ))) }.c))
({a = (( \f: Nat .((f (( \f: Rec X. X .((f (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) 1 ) false) ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) ) (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Nat .b)) in u) ) ) (\a: Unit .\b: Bool .a)) ) (if ({a = true , b = 1 }.a) then (pred ({a = false , b = 0 }.b)) else (( \f: Unit .((f (if false then 0 else 1) ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Bool .b))) ) ) (\a: Bool .\b: Unit .b)) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (case <r = (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b)) > as Nat of < l = x > => x | < r = y > => y) )) }.b)
(if ({a = (unfold [ Rec X. X ] (fold [ Nat ] (fix (\x: Unit . (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) )) )) , b = (iszero ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (succ 0) }.b)) }.b) then ({a = (iszero (let u = true in 1)) , b = (( \f: Nat .((f (case <l = ({a = 1 , b = 0 }.b) > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Rec X. X ] (fold [ Nat ] 1 )) ) ) (\a: Unit .\b: Rec X. X .b)) }.a) else ({a = (pred (unfold [ Bool ] (fold [ Rec X. X ] ({a = 1 , b = 0 }.b) ))) , b = (if (((\x: Unit .\y: Nat .y) true ) true) then (fix (\x: Nat . false )) else ({a = 0 , b = false , c =  0 }.b)) , c =  (((\x: Rec X. X .\y: Unit .x) (succ 0) ) (unfold [ Rec X. X ] (fold [ Bool ] (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Bool .a)) ))) }.b))
(let u = ({a = (let u = (fix (\x: Bool . (let u = 1 in u) )) in (fix (\x: Nat . (fix (\x: Unit . 1 )) ))) , b = (((\x: Unit .\y: Nat .y) false ) false) }.b) in (pred (succ ({a = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) , b = ({a = 0 , b = true }.b) , c = 0 }.c))))
(let u = ({a = ({a = ({a = true , b = false }.b) , b = (let u = false in true) }.b) , b = (case <l = (((\x: Unit .\y: Nat .x) 1 ) false) > as Bool of < l = x > => x | < r = y > => y) }.b) in u)
((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (pred ({a = (((\x: Nat .\y: Nat .x) false ) true) , b = (((\x: Unit .\y: Rec X. X .x) 0 ) false) }.b)) ))
({a = ({a = (if true then 1 else 0) , b = (((\x: Nat .\y: Nat .y) false ) (let u = true in 1)) }.b) , b = (if ({a = (((\x: Unit .\y: Unit .x) (( \f: Nat .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) ) (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Nat .a))) , b = (iszero 0) }.b) then ({a = ({a = ({a = 0 , b = true , c =  1 }.b) , b = false }.b) , b = ({a = (succ (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Unit .b))) , b = (let u = 0 in 0) }.b) }.b) else ({a = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = false }.b) ) true) , b = ({a = 1 , b = false }.a) }.b)) }.b)
(pred (if (let u = (pred 1) in (((\x: Rec X. X .\y: Rec X. X .x) (fix (\x: Rec X. X . false )) ) (iszero 1))) then ({a = (if true then 0 else 1) , b = (iszero (let u = false in 1)) }.a) else (if (unfold [ Unit ] (fold [ Nat ] true )) then (let u = 0 in 0) else (let u = false in 1))))
(unfold [ Nat ] (fold [ Bool ] ({a = ({a = (((\x: Bool .\y: Bool .x) 0 ) false) , b = (let u = false in u) , c =  (if true then 0 else (((\x: Rec X. X .\y: Unit .x) 1 ) true)) }.b) , b = (case <l = (succ 1) > as Unit of < l = x > => x | < r = y > => y) }.b) ))
(( \f: Nat .((f (( \f: Nat .((f (succ ({a = 1 , b = true , c = 0 }.c)) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ) ({a = (( \f: Bool .((f (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (((\x: Unit .\y: Nat .y) true ) true) ) true ) ) (\a: Unit .\b: Unit .b)) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = (case <l = ({a = 1 , b = false }.a) > as Unit of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(( \f: Nat .((f (if (unfold [ Unit ] (fold [ Bool ] ({a = 1 , b = true }.b) )) then (fix (\x: Nat . (((\x: Rec X. X .\y: Nat .y) (iszero 1) ) true) )) else ({a = (let u = 0 in ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] 1 ))) , b = ({a = true , b = false }.b) , c =  (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = false }.a) )) }.b)) ) (unfold [ Unit ] (fold [ Unit ] (((\x: Unit .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Nat ] (((\x: Nat .\y: Bool .y) false ) true) )) ) (let u = true in false)) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (( \f: Unit .((f (( \f: Nat .((f ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] ({a = 1 , b = 1 }.b) )) ) (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .a)) ) (case <l = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) ))
(unfold [ Rec X. X ] (fold [ Bool ] (( \f: Bool .((f ({a = (pred (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) , b = (((\x: Bool .\y: Bool .x) true ) true) }.a) ) (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) ({a = 0 , b = false }.a)) in (if true then 0 else 0)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ))
(((\x: Unit .\y: Bool .y) (if (fix (\x: Bool . (let u = ({a = 0 , b = false }.b) in (((\x: Bool .\y: Nat .x) (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) ) (if true then false else true))) )) then (let u = ({a = (( \f: Unit .((f 0 ) ({a = 1 , b = true }.a) ) ) (\a: Unit .\b: Bool .a)) , b = (if (unfold [ Rec X. X ] (fold [ Unit ] false )) then false else false) }.b) in u) else (if (unfold [ Bool ] (fold [ Rec X. X ] false )) then (fix (\x: Unit . (fix (\x: Unit . true )) )) else (fix (\x: Bool . (case <r = ({a = true , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) )))) ) ({a = ({a = (((\x: Rec X. X .\y: Unit .y) (let u = false in u) ) ({a = true , b = false }.b)) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] false )) }.b) , b = (let u = ({a = (pred (((\x: Nat .\y: Nat .x) 0 ) true)) , b = ({a = (let u = 0 in 1) , b = false }.b) , c = ({a = 1 , b = 1 }.b) }.c) in u) }.a))
({a = (let u = (let u = false in 0) in (if (( \f: Nat .((f ({a = false , b = true }.b) ) true ) ) (\a: Unit .\b: Bool .a)) then (let u = true in 1) else (unfold [ Unit ] (fold [ Nat ] 1 )))) , b = (unfold [ Bool ] (fold [ Nat ] (let u = ({a = (((\x: Bool .\y: Bool .x) 0 ) false) , b = true , c = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 0 )) }.c) in (fix (\x: Rec X. X . false ))) )) , c =  (( \f: Nat .((f (let u = 1 in 0) ) (let u = false in (let u = 0 in 1)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) }.b)
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (let u = ({a = 1 , b = true }.b) in u) in ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .b)) )) , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .b)) }.b)) ))
(let u = (((\x: Bool .\y: Bool .y) (let u = (pred (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b))) in (unfold [ Rec X. X ] (fold [ Rec X. X ] true ))) ) (case <r = (let u = 1 in false) > as Rec X. X of < l = x > => x | < r = y > => y)) in (if ({a = (let u = true in u) , b = (let u = ({a = 0 , b = true }.b) in (pred 0)) }.a) then (pred (((\x: Bool .\y: Unit .y) true ) 0)) else (let u = true in 0)))
(iszero (((\x: Bool .\y: Nat .x) (((\x: Nat .\y: Rec X. X .y) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) (( \f: Bool .((f ({a = false , b = (succ 0) }.b) ) (let u = false in 0) ) ) (\a: Nat .\b: Nat .a))) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Nat . ({a = true , b = 0 }.a) )) ))))
(let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .a)) , b = (unfold [ Nat ] (fold [ Rec X. X ] 1 )) }.b) )) in (if ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 0 , b = true }.b) )) then ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = 1 }.b) else ({a = ({a = 1 , b = false }.a) , b = 0 }.b)))
(let u = (if (case <r = (((\x: Bool .\y: Unit .y) ({a = (if true then 1 else 0) , b = false , c =  1 }.b) ) (let u = 1 in true)) > as Bool of < l = x > => x | < r = y > => y) then (succ (fix (\x: Nat . 1 ))) else (let u = ({a = (pred (let u = 1 in 0)) , b = (let u = 1 in u) }.b) in (((\x: Unit .\y: Nat .x) (let u = 1 in u) ) ((\x: Unit . unfold [ Bool ] x) (fold [ Bool ] true ))))) in (let u = (( \f: Rec X. X .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] 1 )) ) (let u = true in 0) ) ) (\a: Unit .\b: Unit .a)) in u))
(let u = (let u = ({a = (let u = true in u) , b = (fix (\x: Nat . true )) }.b) in u) in u)
(pred (unfold [ Bool ] (fold [ Unit ] (let u = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .a)) in (let u = 1 in 1)) )))
(case <r = (case <r = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] true )) in u) > as Bool of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y)
({a = (pred (( \f: Nat .((f (fix (\x: Unit . (let u = false in 0) )) ) (case <l = ({a = 0 , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Rec X. X .a))) , b = (unfold [ Nat ] (fold [ Unit ] (let u = ((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (unfold [ Nat ] (fold [ Bool ] true )) )) in (( \f: Unit .((f (((\x: Bool .\y: Unit .y) true ) true) ) (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) ) (\a: Unit .\b: Unit .b))) )) , c =  (if (unfold [ Nat ] (fold [ Bool ] ({a = (( \f: Nat .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) , b = (unfold [ Nat ] (fold [ Nat ] false )) }.b) )) then ({a = (let u = false in false) , b = ({a = 0 , b = true }.a) }.b) else (((\x: Nat .\y: Rec X. X .y) (((\x: Unit .\y: Rec X. X .y) ({a = false , b = 1 }.a) ) (let u = false in true)) ) (((\x: Nat .\y: Bool .y) (((\x: Bool .\y: Bool .y) true ) true) ) 1))) }.b)
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = (pred (let u = 0 in u)) in u) ))
(case <l = ({a = (((\x: Rec X. X .\y: Unit .x) (let u = false in (let u = 0 in u)) ) ({a = 0 , b = (let u = true in u) }.b)) , b = (( \f: Unit .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) ({a = 0 , b = false }.a) ) ) (\a: Bool .\b: Nat .a)) }.b) > as Unit of < l = x > => x | < r = y > => y)
(if (( \f: Rec X. X .((f (((\x: Nat .\y: Bool .y) ({a = true , b = 0 }.a) ) (iszero (let u = 0 in u))) ) (( \f: Rec X. X .((f (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Nat .a)) ) ({a = false , b = 0 }.a) ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Nat .b)) then (((\x: Unit .\y: Rec X. X .y) (let u = true in u) ) (let u = ({a = true , b = true }.b) in u)) else ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (case <r = (unfold [ Bool ] (fold [ Bool ] false )) > as Rec X. X of < l = x > => x | < r = y > => y) )))
(case <r = (let u = (case <r = ({a = (let u = 1 in 1) , b = (let u = 0 in true) }.b) > as Unit of < l = x > => x | < r = y > => y) in u) > as Bool of < l = x > => x | < r = y > => y)
({a = ({a = (((\x: Bool .\y: Nat .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = 0 , b = false , c =  1 }.b) )) ) (pred 1)) , b = (let u = (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .b)) in (((\x: Bool .\y: Bool .y) false ) false)) , c = (let u = (if true then true else false) in (((\x: Unit .\y: Nat .y) true ) 1)) }.c) , b = (if (let u = (unfold [ Unit ] (fold [ Unit ] true )) in true) then (((\x: Bool .\y: Unit .x) (((\x: Rec X. X .\y: Bool .y) false ) true) ) (let u = (( \f: Unit .((f true ) true ) ) (\a: Bool .\b: Bool .b)) in u)) else (( \f: Unit .((f ({a = 1 , b = true }.b) ) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Bool .b))) }.a)
(pred ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (succ (((\x: Nat .\y: Nat .y) true ) 1)) )))
(unfold [ Unit ] (fold [ Bool ] ({a = (unfold [ Nat ] (fold [ Unit ] false )) , b = (fix (\x: Unit . ({a = false , b = 1 }.b) )) }.b) ))
(let u = (let u = (( \f: Rec X. X .((f (case <l = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] 0 )) > as Nat of < l = x > => x | < r = y > => y) ) (let u = 0 in u) ) ) (\a: Bool .\b: Bool .a)) in u) in (case <l = (let u = ({a = 1 , b = 1 }.b) in u) > as Rec X. X of < l = x > => x | < r = y > => y))
(pred ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (fix (\x: Bool . 0 )) )))
(case <r = (((\x: Nat .\y: Nat .x) ({a = (if ({a = 1 , b = false }.b) then (let u = false in 1) else (succ 1)) , b = (((\x: Bool .\y: Nat .y) true ) ({a = false , b = 1 }.a)) , c =  (pred ({a = 1 , b = false , c = 1 }.c)) }.b) ) (unfold [ Nat ] (fold [ Unit ] (iszero 1) ))) > as Bool of < l = x > => x | < r = y > => y)
((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (if (let u = true in u) then (pred 1) else (( \f: Unit .((f (succ 0) ) ({a = (let u = 0 in 0) , b = (let u = false in true) , c = (succ 0) }.c) ) ) (\a: Unit .\b: Bool .a))) ))
(((\x: Nat .\y: Nat .x) (let u = (( \f: Bool .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) (if true then false else (fix (\x: Rec X. X . true ))) ) ) (\a: Rec X. X .\b: Bool .a)) in (unfold [ Unit ] (fold [ Unit ] (fix (\x: Rec X. X . 1 )) ))) ) (iszero (((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Unit .x) false ) (((\x: Bool .\y: Bool .x) false ) true)) ) (( \f: Nat .((f (let u = 0 in 1) ) 1 ) ) (\a: Unit .\b: Unit .a)))))
(let u = (case <l = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] (( \f: Unit .((f (pred 0) ) (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) > as Nat of < l = x > => x | < r = y > => y) in (case <r = (case <r = (((\x: Rec X. X .\y: Bool .y) true ) false) > as Rec X. X of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y))
(let u = (( \f: Nat .((f (let u = (if true then 1 else 1) in u) ) ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Bool .b)) , b = ({a = (pred 0) , b = (case <r = ({a = 1 , b = false }.b) > as Bool of < l = x > => x | < r = y > => y) , c = ({a = 1 , b = true , c = 1 }.c) }.c) }.b) ) ) (\a: Bool .\b: Unit .b)) in (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] false )) ) (unfold [ Unit ] (fold [ Nat ] (let u = false in u) )) ) ) (\a: Nat .\b: Rec X. X .b)) ) (((\x: Bool .\y: Nat .y) (let u = ({a = false , b = false }.b) in u) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )))))
({a = (unfold [ Unit ] (fold [ Nat ] (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Bool .a)) in ({a = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , b = 0 }.b)) )) , b = (let u = ({a = (let u = ({a = 0 , b = 0 }.b) in 1) , b = (((\x: Rec X. X .\y: Unit .x) false ) false) , c = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) }.c) in (let u = false in u)) }.a)
({a = ({a = (succ ({a = 0 , b = true }.a)) , b = (unfold [ Rec X. X ] (fold [ Bool ] ({a = false , b = true }.b) )) , c =  ({a = (let u = (let u = true in u) in (let u = 0 in 0)) , b = (let u = (( \f: Nat .((f ({a = 0 , b = false }.a) ) (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Rec X. X .\b: Unit .a)) in (if false then true else (iszero 0))) , c = ({a = ({a = false , b = 0 }.b) , b = ({a = true , b = 1 }.a) , c = ({a = 1 , b = 0 }.b) }.c) }.c) }.b) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] ({a = (((\x: Bool .\y: Rec X. X .y) true ) true) , b = (succ 1) }.a) )) }.b)
(succ (if (((\x: Rec X. X .\y: Nat .x) (((\x: Unit .\y: Unit .y) (let u = 1 in false) ) ({a = false , b = true }.b)) ) (if ({a = 0 , b = true }.b) then false else (((\x: Unit .\y: Unit .y) true ) true))) then (unfold [ Unit ] (fold [ Rec X. X ] 1 )) else (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y) else (let u = (let u = false in true) in 0))))
(if ({a = (((\x: Unit .\y: Rec X. X .x) ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] true )) ) (if ({a = 0 , b = true , c =  0 }.b) then (((\x: Nat .\y: Unit .y) false ) true) else true)) , b = (unfold [ Nat ] (fold [ Nat ] ((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) )) }.b) then (fix (\x: Rec X. X . (let u = (let u = 1 in true) in u) )) else ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = false , b = false }.b) )))
(fix (\x: Unit . ({a = (fix (\x: Nat . (let u = 1 in 0) )) , b = ({a = (( \f: Unit .((f ((\x: Unit . unfold [ Unit ] x) (fold [ Bool ] true )) ) false ) ) (\a: Bool .\b: Nat .a)) , b = (((\x: Bool .\y: Rec X. X .y) ({a = false , b = 0 }.a) ) (if false then false else false)) }.b) , c = (let u = (fix (\x: Bool . (( \f: Nat .((f 1 ) 1 ) ) (\a: Nat .\b: Nat .b)) )) in u) }.c) ))
(((\x: Unit .\y: Unit .y) (case <r = (unfold [ Unit ] (fold [ Rec X. X ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) > as Nat of < l = x > => x | < r = y > => y) ) (pred ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (let u = false in 0) ))))
(if ({a = (( \f: Rec X. X .((f ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] ({a = 1 , b = true , c =  1 }.b) )) , b = (fix (\x: Nat . 1 )) }.a) ) (iszero (let u = 1 in u)) ) ) (\a: Rec X. X .\b: Unit .b)) , b = (unfold [ Nat ] (fold [ Rec X. X ] (let u = 0 in false) )) }.b) then (((\x: Nat .\y: Unit .x) (succ (pred 0)) ) (iszero (succ 1))) else (let u = ({a = (fix (\x: Rec X. X . false )) , b = (let u = 1 in true) }.b) in (case <l = (case <l = (let u = true in 0) > as Rec X. X of < l = x > => x | < r = y > => y) > as Rec X. X of < l = x > => x | < r = y > => y)))
({a = (let u = ({a = (unfold [ Bool ] (fold [ Unit ] ({a = 0 , b = true , c = 1 }.c) )) , b = ({a = 1 , b = false , c =  (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) }.b) in u) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = (pred 1) }.c) , b = (iszero 1) }.a) )) }.a)
({a = (let u = (case <l = (let u = false in ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 0 ))) > as Unit of < l = x > => x | < r = y > => y) in u) , b = (( \f: Rec X. X .((f (((\x: Nat .\y: Unit .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) (( \f: Nat .((f (let u = 1 in false) ) true ) ) (\a: Nat .\b: Unit .a))) ) (let u = (unfold [ Nat ] (fold [ Bool ] ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] true )) )) in (fix (\x: Nat . ({a = (((\x: Unit .\y: Bool .x) 0 ) true) , b = true }.b) ))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) , c = (let u = (pred (succ ({a = false , b = 1 }.b))) in u) }.c)
(iszero (let u = (let u = ({a = false , b = 1 }.a) in u) in ({a = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .b)) , c = (( \f: Nat .((f 1 ) 0 ) ) (\a: Bool .\b: Nat .a)) }.c)))
(fix (\x: Nat . ({a = (((\x: Nat .\y: Bool .y) (if true then true else true) ) true) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Bool .((f 1 ) (((\x: Rec X. X .\y: Unit .x) 0 ) false) ) ) (\a: Unit .\b: Bool .b)) )) }.b) ))
({a = (((\x: Unit .\y: Unit .x) (let u = (( \f: Nat .((f false ) (fix (\x: Unit . true )) ) ) (\a: Unit .\b: Rec X. X .a)) in u) ) (iszero ({a = 1 , b = false }.a))) , b = ({a = (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a)) in (unfold [ Nat ] (fold [ Rec X. X ] false ))) , b = (( \f: Nat .((f (((\x: Nat .\y: Rec X. X .x) 0 ) false) ) ({a = 1 , b = 0 }.b) ) ) (\a: Bool .\b: Unit .a)) }.a) }.b)
({a = (unfold [ Bool ] (fold [ Rec X. X ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (pred 1) )) )) , b = (( \f: Nat .((f (if (let u = (let u = true in 0) in ({a = false , b = true }.b)) then (let u = ({a = ({a = 1 , b = 1 }.b) , b = (fix (\x: Nat . false )) }.b) in u) else (iszero 0)) ) ({a = (let u = 0 in u) , b = ({a = 1 , b = false }.b) }.b) ) ) (\a: Bool .\b: Bool .b)) }.b)
(succ (if (iszero (case <l = (let u = 0 in u) > as Bool of < l = x > => x | < r = y > => y)) then ({a = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )) , b = (if true then true else true) }.a) , b = (((\x: Unit .\y: Bool .x) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) true) }.b) else ({a = (let u = (succ 1) in u) , b = (((\x: Nat .\y: Bool .x) (pred 0) ) ({a = 0 , b = true }.b)) }.b)))
({a = (if ({a = 0 , b = (unfold [ Bool ] (fold [ Bool ] false )) , c =  (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) then ({a = ({a = true , b = 1 }.b) , b = (let u = false in u) , c =  ({a = true , b = 0 }.b) }.b) else (((\x: Nat .\y: Nat .x) (iszero 0) ) ({a = (((\x: Bool .\y: Bool .x) 0 ) false) , b = ({a = true , b = 0 }.a) }.b))) , b = (pred (let u = (if false then true else false) in (pred 0))) }.a)
({a = (fix (\x: Unit . (let u = ({a = (let u = 1 in u) , b = false }.b) in u) )) , b = (unfold [ Rec X. X ] (fold [ Unit ] (let u = (succ 1) in (let u = 0 in u)) )) }.a)
(case <l = ({a = (let u = (((\x: Nat .\y: Rec X. X .y) false ) 1) in u) , b = (( \f: Nat .((f (((\x: Nat .\y: Bool .y) true ) 1) ) (fix (\x: Bool . (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) )) ) ) (\a: Nat .\b: Nat .a)) }.b) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (pred (pred 1)) in u) in u)
({a = (case <l = (((\x: Bool .\y: Rec X. X .y) (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .a)) ) (((\x: Rec X. X .\y: Rec X. X .x) 1 ) true)) > as Bool of < l = x > => x | < r = y > => y) , b = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (let u = 0 in u) , b = true }.a) )) , b = (let u = true in (iszero 1)) , c =  ({a = (if false then 0 else 0) , b = (let u = 0 in false) , c = (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Bool .\b: Bool .a)) }.c) }.b) }.a)
(unfold [ Nat ] (fold [ Unit ] ({a = ({a = (((\x: Bool .\y: Unit .y) true ) true) , b = (let u = false in 1) }.b) , b = (( \f: Rec X. X .((f false ) ({a = 1 , b = true }.b) ) ) (\a: Unit .\b: Rec X. X .b)) }.b) ))
(((\x: Unit .\y: Rec X. X .y) (fix (\x: Unit . (iszero (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b))) )) ) ({a = ({a = (((\x: Unit .\y: Bool .y) (let u = false in u) ) (((\x: Rec X. X .\y: Rec X. X .x) true ) true)) , b = (let u = (if false then false else true) in (unfold [ Bool ] (fold [ Nat ] 0 ))) }.a) , b = (succ (let u = 0 in u)) }.b))
(let u = (let u = (( \f: Bool .((f (fix (\x: Unit . false )) ) ({a = (let u = 0 in u) , b = false , c =  (unfold [ Bool ] (fold [ Rec X. X ] 0 )) }.b) ) ) (\a: Bool .\b: Nat .a)) in u) in ({a = ({a = ({a = 0 , b = false }.a) , b = 1 }.b) , b = (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) }.a))
(iszero (( \f: Bool .((f ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (let u = 1 in (let u = true in 0)) )) ) (((\x: Unit .\y: Unit .y) (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Unit .b)) ) (let u = 0 in 1)) ) ) (\a: Bool .\b: Unit .a)))
(fix (\x: Unit . (((\x: Rec X. X .\y: Unit .x) (let u = ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = (((\x: Unit .\y: Nat .y) true ) 1) }.b) in (let u = ({a = true , b = true }.b) in u)) ) (iszero (case <l = (pred 1) > as Unit of < l = x > => x | < r = y > => y))) ))
(unfold [ Rec X. X ] (fold [ Nat ] (unfold [ Rec X. X ] (fold [ Unit ] (let u = false in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) )) ))
({a = (((\x: Unit .\y: Unit .y) (((\x: Unit .\y: Bool .y) (let u = 1 in true) ) (iszero 0)) ) ({a = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = true in ({a = false , b = false }.b)) }.a)) , b = (let u = (let u = (if (iszero (let u = 1 in 0)) then (unfold [ Unit ] (fold [ Nat ] 1 )) else (case <l = 0 > as Nat of < l = x > => x | < r = y > => y)) in ({a = (fix (\x: Unit . 0 )) , b = (fix (\x: Nat . true )) , c = 1 }.c)) in (((\x: Rec X. X .\y: Nat .x) ({a = ({a = 0 , b = 1 }.b) , b = 0 }.b) ) ({a = 0 , b = true }.b))) }.b)
(case <l = (pred ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Bool .x) 0 ) false) ))) > as Nat of < l = x > => x | < r = y > => y)
(succ (succ ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = 1 in u) )) , b = (unfold [ Unit ] (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) 0 ) true) )) }.b)))
(unfold [ Unit ] (fold [ Bool ] ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Rec X. X ] (( \f: Rec X. X .((f (let u = false in true) ) (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) )) ))
((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] (( \f: Nat .((f (if ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a)) , b = (unfold [ Bool ] (fold [ Nat ] false )) , c =  0 }.b) then (unfold [ Unit ] (fold [ Unit ] (let u = 0 in false) )) else ({a = false , b = 1 }.a)) ) (let u = (((\x: Unit .\y: Bool .x) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) ) (unfold [ Rec X. X ] (fold [ Unit ] true ))) in u) ) ) (\a: Nat .\b: Nat .a)) ))
(((\x: Rec X. X .\y: Rec X. X .x) (let u = (case <l = (let u = 0 in u) > as Nat of < l = x > => x | < r = y > => y) in ({a = (let u = (((\x: Bool .\y: Bool .x) false ) false) in ({a = true , b = 0 }.b)) , b = (let u = ({a = 0 , b = true }.b) in u) }.a)) ) (if ({a = 1 , b = false , c =  (fix (\x: Unit . 1 )) }.b) then (fix (\x: Nat . (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) )) else (if (((\x: Bool .\y: Nat .y) true ) (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b))) then ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] true )) else (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Unit .b)))))
(iszero ({a = ({a = ({a = (let u = (case <r = false > as Nat of < l = x > => x | < r = y > => y) in true) , b = ({a = (((\x: Bool .\y: Bool .x) true ) true) , b = 1 }.b) }.b) , b = (let u = (let u = false in false) in u) }.b) , b = (( \f: Unit .((f (((\x: Nat .\y: Bool .x) 0 ) false) ) ({a = false , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b) ) ) (\a: Bool .\b: Nat .a)) }.b))
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (iszero 0) )) , b = (if false then true else ({a = 1 , b = true , c =  0 }.b)) }.b) ))
(( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Rec X. X ] (((\x: Unit .\y: Unit .y) ({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] true )) , b = 0 }.a) ) (if (((\x: Bool .\y: Bool .x) false ) false) then (( \f: Unit .((f false ) (fix (\x: Unit . true )) ) ) (\a: Unit .\b: Rec X. X .a)) else (if true then false else true))) )) ) (( \f: Nat .((f (let u = (let u = 1 in false) in u) ) ({a = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) , b = (if true then true else false) }.b) ) ) (\a: Nat .\b: Bool .a)) ) ) (\a: Unit .\b: Bool .a))
({a = (let u = (let u = (iszero 0) in u) in u) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) , b = 1 }.b) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] (unfold [ Nat ] (fold [ Unit ] (( \f: Bool .((f (((\x: Bool .\y: Rec X. X .y) false ) false) ) ({a = true , b = 0 }.a) ) ) (\a: Nat .\b: Rec X. X .a)) )) )) , c = ({a = ({a = 0 , b = 0 }.b) , b = ({a = 1 , b = true }.a) }.b) }.c) }.b)
({a = (((\x: Unit .\y: Nat .x) (pred ({a = (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = (if false then true else true) }.a)) ) ({a = (let u = 0 in false) , b = (let u = true in 1) }.a)) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Unit .\y: Bool .x) ({a = ({a = 0 , b = false , c = 1 }.c) , b = (( \f: Nat .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) }.b) ) (iszero ({a = 0 , b = 0 }.b))) )) , c =  (fix (\x: Unit . (( \f: Bool .((f ({a = (if true then 1 else 0) , b = true , c = 0 }.c) ) ({a = 0 , b = false , c = 1 }.c) ) ) (\a: Unit .\b: Unit .b)) )) }.b)
(((\x: Rec X. X .\y: Unit .x) ({a = (pred ({a = 0 , b = 1 }.b)) , b = (( \f: Nat .((f (fix (\x: Nat . (fix (\x: Bool . 1 )) )) ) (((\x: Unit .\y: Nat .x) (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Rec X. X .b)) ) false) ) ) (\a: Unit .\b: Unit .a)) }.b) ) (if (iszero ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] 0 ))) then (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Nat . (( \f: Rec X. X .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) )) )) else (if ({a = (let u = false in u) , b = ({a = 1 , b = true , c =  1 }.b) }.b) then ({a = ({a = 1 , b = false }.a) , b = false , c =  (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Rec X. X .a)) }.b) else ({a = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Bool .b)) , b = (((\x: Bool .\y: Rec X. X .x) (let u = 1 in 0) ) (let u = false in false)) }.a))))
({a = (let u = (((\x: Rec X. X .\y: Rec X. X .y) (( \f: Nat .((f ({a = 0 , b = false }.b) ) (((\x: Unit .\y: Nat .x) true ) false) ) ) (\a: Nat .\b: Bool .a)) ) ({a = ({a = 0 , b = true , c = 1 }.c) , b = false }.b)) in (((\x: Rec X. X .\y: Rec X. X .y) false ) (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .b)))) , b = (succ ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] 0 )) )) ))) }.a)
({a = (fix (\x: Unit . (succ 1) )) , b = (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Nat . (fix (\x: Unit . (let u = 1 in false) )) )) )) }.a)
({a = (fix (\x: Rec X. X . (( \f: Rec X. X .((f (let u = 0 in 1) ) (pred 1) ) ) (\a: Bool .\b: Unit .b)) )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] (( \f: Bool .((f ({a = (if ({a = true , b = 0 }.a) then false else false) , b = ({a = 0 , b = true , c = 0 }.c) }.a) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Bool .\y: Unit .x) false ) false) )) ) ) (\a: Rec X. X .\b: Rec X. X .a)) )) , c = (let u = (let u = (succ 1) in (succ (( \f: Unit .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .a)))) in (let u = (if false then 1 else 0) in u)) }.c)
(unfold [ Rec X. X ] (fold [ Bool ] (let u = (((\x: Bool .\y: Bool .y) ({a = false , b = false }.b) ) ({a = (let u = ({a = true , b = 0 }.b) in true) , b = ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] true )) }.b)) in (case <l = (succ 1) > as Nat of < l = x > => x | < r = y > => y)) ))
(((\x: Unit .\y: Bool .x) (let u = ({a = (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] true )) in u) , b = (((\x: Unit .\y: Unit .y) (let u = true in false) ) 1) }.a) in u) ) (((\x: Nat .\y: Unit .x) (((\x: Bool .\y: Rec X. X .y) (let u = true in u) ) ({a = true , b = 0 }.a)) ) (( \f: Bool .((f (((\x: Unit .\y: Unit .y) (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Nat .b)) ) (let u = true in u)) ) ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] (( \f: Bool .((f false ) true ) ) (\a: Bool .\b: Unit .a)) )) ) ) (\a: Nat .\b: Bool .a))))
(fix (\x: Bool . (let u = (let u = (let u = false in u) in u) in u) ))
(if (( \f: Unit .((f (((\x: Rec X. X .\y: Bool .y) (let u = false in u) ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] (if false then false else false) ))) ) (case <r = (((\x: Bool .\y: Rec X. X .y) true ) false) > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) then (( \f: Unit .((f (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) ) (let u = (unfold [ Nat ] (fold [ Rec X. X ] (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) )) in u) ) ) (\a: Bool .\b: Bool .b)) else (((\x: Unit .\y: Bool .x) ({a = (let u = ({a = 1 , b = false , c =  0 }.b) in 0) , b = ({a = 0 , b = true }.a) }.b) ) (((\x: Unit .\y: Rec X. X .y) (( \f: Nat .((f false ) true ) ) (\a: Rec X. X .\b: Unit .a)) ) ({a = (fix (\x: Nat . false )) , b = (iszero 1) }.b))))
(let u = (( \f: Nat .((f (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = false , c = 0 }.c) )) ) (fix (\x: Unit . 0 )) ) ) (\a: Unit .\b: Rec X. X .b)) in u)
({a = (((\x: Bool .\y: Unit .y) ({a = (let u = 1 in u) , b = ({a = false , b = false }.b) }.b) ) (let u = (((\x: Bool .\y: Bool .x) 1 ) true) in u)) , b = (fix (\x: Unit . (let u = (unfold [ Rec X. X ] (fold [ Bool ] 1 )) in (if true then ({a = 1 , b = false }.a) else (( \f: Bool .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .a)))) )) }.b)
(pred (pred (let u = ({a = true , b = 1 }.a) in 1)))
((\x: Unit . unfold [ Unit ] x) (fold [ Nat ] (let u = (case <l = (if (iszero 0) then (let u = 0 in 1) else (((\x: Unit .\y: Nat .y) false ) 1)) > as Bool of < l = x > => x | < r = y > => y) in ({a = ({a = 1 , b = false , c = 1 }.c) , b = (if true then true else false) }.b)) ))
({a = ({a = (fix (\x: Bool . (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) )) , b = (let u = 1 in u) }.b) , b = (let u = ({a = (let u = 0 in false) , b = (((\x: Nat .\y: Unit .x) ({a = 0 , b = true , c = 1 }.c) ) (((\x: Rec X. X .\y: Unit .y) true ) true)) }.a) in (let u = (((\x: Nat .\y: Nat .x) (let u = false in u) ) true) in u)) , c = (fix (\x: Unit . ({a = (pred 1) , b = (( \f: Nat .((f 0 ) 0 ) ) (\a: Bool .\b: Nat .b)) }.b) )) }.c)
({a = (succ ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) , b = (let u = 0 in u) }.b)) , b = (((\x: Bool .\y: Bool .x) (case <r = false > as Nat of < l = x > => x | < r = y > => y) ) (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .a))) }.a)
(pred (case <l = (pred (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) > as Rec X. X of < l = x > => x | < r = y > => y))
(((\x: Unit .\y: Rec X. X .y) (( \f: Nat .((f ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) )) ) (unfold [ Bool ] (fold [ Rec X. X ] (fix (\x: Unit . false )) )) ) ) (\a: Bool .\b: Nat .a)) ) (let u = (let u = (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Unit of < l = x > => x | < r = y > => y) )) in u) in (((\x: Nat .\y: Rec X. X .y) (let u = (fix (\x: Unit . true )) in ({a = false , b = 1 }.a)) ) (fix (\x: Rec X. X . false )))))
(let u = (fix (\x: Bool . ({a = (let u = true in true) , b = (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y)) }.a) )) in ({a = (let u = (((\x: Rec X. X .\y: Nat .y) (fix (\x: Unit . false )) ) (iszero 0)) in (if true then false else false)) , b = (let u = (pred (pred 0)) in (let u = 1 in 0)) }.b))
(((\x: Bool .\y: Nat .y) (if ({a = (let u = 1 in true) , b = 0 }.a) then (( \f: Rec X. X .((f true ) false ) ) (\a: Unit .\b: Unit .a)) else (fix (\x: Nat . (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Nat .a)) ))) ) (( \f: Bool .((f (fix (\x: Nat . (pred 1) )) ) (succ (case <l = 1 > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Nat .b)))
(( \f: Bool .((f ({a = ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .b)) , b = ({a = 1 , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) , c = ({a = 1 , b = true , c = 0 }.c) }.c) }.b) , b = ({a = (( \f: Unit .((f 0 ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Unit .\b: Nat .a)) , b = (let u = 1 in false) , c =  ({a = false , b = 1 }.b) }.b) }.b) ) (((\x: Rec X. X .\y: Rec X. X .y) (let u = (((\x: Unit .\y: Unit .y) false ) false) in u) ) (iszero (pred 1))) ) ) (\a: Nat .\b: Unit .b))
(( \f: Unit .((f (let u = (let u = ({a = 0 , b = false }.b) in u) in u) ) (let u = (((\x: Nat .\y: Unit .x) (((\x: Nat .\y: Nat .y) true ) true) ) (((\x: Bool .\y: Rec X. X .y) false ) true)) in u) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = (let u = (((\x: Nat .\y: Nat .y) ({a = (succ 0) , b = ({a = 0 , b = false , c =  0 }.b) , c =  ({a = false , b = 0 }.b) }.b) ) (pred (fix (\x: Nat . 1 )))) in u) in u)
(unfold [ Unit ] (fold [ Unit ] (let u = (let u = (( \f: Unit .((f ({a = ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] true )) , b = 0 }.b) ) (( \f: Nat .((f 0 ) 1 ) ) (\a: Bool .\b: Unit .a)) ) ) (\a: Unit .\b: Nat .a)) in (((\x: Rec X. X .\y: Nat .y) (let u = true in u) ) (((\x: Bool .\y: Nat .y) false ) false))) in u) ))
({a = (( \f: Bool .((f (( \f: Nat .((f (((\x: Bool .\y: Nat .x) true ) false) ) (unfold [ Nat ] (fold [ Nat ] (let u = false in u) )) ) ) (\a: Bool .\b: Bool .b)) ) (((\x: Rec X. X .\y: Nat .x) (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Nat .b)) ) (( \f: Bool .((f ({a = 0 , b = false }.b) ) false ) ) (\a: Rec X. X .\b: Unit .b))) ) ) (\a: Nat .\b: Rec X. X .b)) , b = (((\x: Unit .\y: Unit .x) (let u = (succ 1) in 0) ) (case <r = false > as Bool of < l = x > => x | < r = y > => y)) }.a)
({a = ({a = (succ 0) , b = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = false }.b) )) , c = (let u = (((\x: Bool .\y: Rec X. X .x) 0 ) true) in u) }.c) , b = (fix (\x: Nat . (let u = (let u = 0 in ({a = 0 , b = false , c = 1 }.c)) in (( \f: Bool .((f (let u = 0 in false) ) false ) ) (\a: Nat .\b: Rec X. X .b))) )) }.b)
({a = (((\x: Nat .\y: Unit .y) (if (( \f: Unit .((f (let u = true in false) ) (let u = true in false) ) ) (\a: Unit .\b: Rec X. X .a)) then (fix (\x: Unit . false )) else (fix (\x: Bool . false ))) ) (((\x: Unit .\y: Unit .y) true ) (let u = true in u))) , b = ({a = (( \f: Unit .((f (pred 1) ) (( \f: Bool .((f (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) 1 ) ) (\a: Nat .\b: Unit .a)) ) ) (\a: Unit .\b: Bool .b)) , b = (iszero (let u = ({a = 0 , b = true , c =  0 }.b) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Unit .b)))) , c = ({a = (( \f: Nat .((f ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) ) ({a = true , b = 1 }.b) ) ) (\a: Bool .\b: Bool .a)) , b = ({a = 0 , b = false , c = 1 }.c) }.b) }.c) }.a)
(( \f: Unit .((f (let u = (let u = (( \f: Unit .((f (unfold [ Nat ] (fold [ Nat ] 0 )) ) (let u = 1 in u) ) ) (\a: Bool .\b: Rec X. X .a)) in u) in u) ) (let u = (let u = 0 in u) in u) ) ) (\a: Bool .\b: Nat .b))
({a = ({a = (if ({a = true , b = 1 }.a) then (let u = false in 0) else (case <l = (unfold [ Nat ] (fold [ Nat ] 1 )) > as Bool of < l = x > => x | < r = y > => y)) , b = ({a = ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (if true then true else false) )) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (let u = true in true) )) }.b) , c = ({a = 1 , b = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) }.c) , b = ({a = ({a = ({a = 0 , b = false , c = 1 }.c) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) }.b) , b = (( \f: Rec X. X .((f 1 ) ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] 0 )) ) ) (\a: Bool .\b: Unit .a)) }.b) }.b)
(let u = (( \f: Nat .((f (succ ({a = true , b = 0 }.b)) ) (pred (( \f: Nat .((f ({a = false , b = 1 }.b) ) (let u = true in 0) ) ) (\a: Bool .\b: Rec X. X .a))) ) ) (\a: Nat .\b: Nat .a)) in (((\x: Bool .\y: Nat .x) ({a = 1 , b = true , c =  0 }.b) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (let u = ({a = 1 , b = false }.b) in u) ))))
(let u = ({a = (case <l = (let u = (if true then true else true) in (succ 0)) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Nat . ({a = 1 , b = true }.a) )) }.b) in (((\x: Nat .\y: Unit .y) ({a = ({a = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .b)) , b = (let u = false in u) }.b) , b = ({a = (let u = 1 in 1) , b = 1 }.b) }.a) ) (( \f: Nat .((f (unfold [ Bool ] (fold [ Rec X. X ] ({a = 0 , b = false , c = 0 }.c) )) ) (if false then 0 else 0) ) ) (\a: Rec X. X .\b: Rec X. X .a))))
(iszero (unfold [ Nat ] (fold [ Rec X. X ] (succ (((\x: Nat .\y: Nat .x) (pred 0) ) (unfold [ Bool ] (fold [ Bool ] true )))) )))
(( \f: Bool .((f (if (let u = ({a = false , b = (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b) in (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Bool .b))) then (case <l = ({a = 0 , b = true , c = 0 }.c) > as Unit of < l = x > => x | < r = y > => y) else (( \f: Unit .((f (pred 0) ) 0 ) ) (\a: Nat .\b: Nat .a))) ) (succ ({a = ({a = 1 , b = true }.b) , b = (fix (\x: Nat . 1 )) }.b)) ) ) (\a: Rec X. X .\b: Unit .b))
(fix (\x: Rec X. X . ({a = ({a = (if true then ({a = 0 , b = false , c = 1 }.c) else (let u = 0 in 1)) , b = (fix (\x: Nat . (( \f: Bool .((f (unfold [ Bool ] (fold [ Rec X. X ] true )) ) false ) ) (\a: Unit .\b: Rec X. X .b)) )) }.a) , b = ({a = (let u = 0 in u) , b = (unfold [ Bool ] (fold [ Bool ] ({a = false , b = 1 }.a) )) }.b) }.a) ))
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] (let u = ({a = (fix (\x: Nat . (((\x: Nat .\y: Unit .x) false ) false) )) , b = (let u = true in u) }.b) in (((\x: Unit .\y: Rec X. X .y) (let u = (let u = 1 in 1) in (((\x: Unit .\y: Rec X. X .x) true ) false)) ) ({a = ({a = true , b = 0 }.b) , b = (if false then false else true) }.b))) ))
(fix (\x: Bool . (((\x: Unit .\y: Nat .y) (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Bool ] true )) ) (((\x: Nat .\y: Rec X. X .x) false ) false) ) ) (\a: Unit .\b: Unit .b)) ) (pred 0)) ))
({a = (case <r = (fix (\x: Nat . (let u = ({a = ({a = true , b = false }.b) , b = (let u = 1 in false) }.b) in u) )) > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (pred ({a = 0 , b = 1 }.b)) )) ) (case <l = ({a = (((\x: Rec X. X .\y: Nat .x) false ) false) , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Rec X. X .b)) }.a)
(((\x: Bool .\y: Rec X. X .y) (( \f: Rec X. X .((f (iszero ((\x: Unit . unfold [ Unit ] x) (fold [ Unit ] (let u = 0 in 0) ))) ) (let u = (( \f: Rec X. X .((f ({a = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) , b = false , c =  1 }.b) ) (fix (\x: Bool . (( \f: Nat .((f false ) true ) ) (\a: Unit .\b: Unit .b)) )) ) ) (\a: Nat .\b: Bool .b)) in u) ) ) (\a: Unit .\b: Bool .b)) ) (succ ({a = (pred 0) , b = (unfold [ Nat ] (fold [ Rec X. X ] (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) )) }.b)))
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Unit ] ({a = (( \f: Bool .((f true ) true ) ) (\a: Nat .\b: Nat .a)) , b = 1 }.b) )) ))
(( \f: Rec X. X .((f (( \f: Bool .((f (if true then ({a = true , b = 0 }.a) else false) ) (let u = (unfold [ Nat ] (fold [ Nat ] false )) in u) ) ) (\a: Bool .\b: Unit .b)) ) (let u = (if (((\x: Bool .\y: Rec X. X .y) false ) false) then (((\x: Nat .\y: Bool .x) (let u = 1 in u) ) ({a = 1 , b = true , c =  0 }.b)) else (fix (\x: Bool . 1 ))) in (let u = (unfold [ Unit ] (fold [ Bool ] false )) in u)) ) ) (\a: Rec X. X .\b: Rec X. X .a))
({a = (let u = ({a = (((\x: Nat .\y: Unit .x) (let u = 0 in u) ) (iszero (unfold [ Bool ] (fold [ Nat ] 1 )))) , b = (( \f: Bool .((f ({a = 0 , b = false , c =  (succ 1) }.b) ) (iszero 1) ) ) (\a: Unit .\b: Rec X. X .b)) }.a) in u) , b = ({a = (case <l = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) > as Bool of < l = x > => x | < r = y > => y) , b = (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f true ) (if true then true else false) ) ) (\a: Nat .\b: Rec X. X .a)) )) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = (iszero 0) , b = (fix (\x: Rec X. X . 1 )) }.b) )) }.b) }.b)
({a = (let u = (let u = (let u = true in true) in u) in u) , b = ({a = (((\x: Unit .\y: Unit .x) (unfold [ Bool ] (fold [ Nat ] 0 )) ) (case <r = (((\x: Nat .\y: Unit .y) true ) false) > as Unit of < l = x > => x | < r = y > => y)) , b = ({a = ({a = true , b = true }.b) , b = (let u = false in ((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] true ))) }.b) }.a) }.a)
({a = (let u = ({a = ({a = ({a = ({a = 0 , b = true , c = 0 }.c) , b = false }.b) , b = (case <l = (((\x: Rec X. X .\y: Bool .y) false ) 0) > as Nat of < l = x > => x | < r = y > => y) }.a) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] (unfold [ Unit ] (fold [ Nat ] (fix (\x: Nat . false )) )) )) }.b) in (( \f: Nat .((f ({a = (if false then false else true) , b = (succ 1) }.a) ) (let u = ({a = false , b = 1 }.b) in true) ) ) (\a: Rec X. X .\b: Nat .b))) , b = ({a = ({a = 1 , b = false }.b) , b = ({a = ({a = false , b = (pred 1) }.a) , b = (let u = true in false) }.b) }.b) }.b)
(let u = (pred (unfold [ Nat ] (fold [ Rec X. X ] ({a = 1 , b = false }.a) ))) in ({a = (((\x: Nat .\y: Unit .y) (let u = false in u) ) (succ 0)) , b = (((\x: Nat .\y: Unit .y) (let u = false in (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Rec X. X .a))) ) (unfold [ Unit ] (fold [ Nat ] 0 ))) }.b))
((\x: Nat . unfold [ Nat ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Nat ] ({a = (((\x: Bool .\y: Nat .y) false ) true) , b = ({a = 1 , b = (let u = true in 1) }.b) }.a) )) ))
(iszero ({a = ({a = ({a = (((\x: Nat .\y: Nat .x) false ) ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] true ))) , b = (fix (\x: Rec X. X . 1 )) }.a) , b = (if ({a = true , b = 0 }.a) then ({a = 1 , b = true }.a) else ({a = 0 , b = (((\x: Unit .\y: Nat .x) false ) false) , c = (unfold [ Unit ] (fold [ Nat ] 0 )) }.c)) }.b) , b = (fix (\x: Bool . (((\x: Bool .\y: Nat .x) (let u = true in false) ) ({a = true , b = true }.b)) )) , c = ({a = (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) , b = ({a = ({a = 0 , b = false , c =  1 }.b) , b = (let u = true in true) }.b) , c = (pred (((\x: Unit .\y: Bool .x) (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = 1 , b = false }.b))) }.c) }.c))
(( \f: Rec X. X .((f ({a = (fix (\x: Unit . (fix (\x: Rec X. X . false )) )) , b = ({a = (let u = (let u = 1 in (let u = 0 in 0)) in (pred (let u = 0 in u))) , b = ({a = (let u = true in true) , b = (if false then false else true) }.b) , c = (succ 0) }.c) }.a) ) (unfold [ Nat ] (fold [ Bool ] (iszero (pred 1)) )) ) ) (\a: Nat .\b: Nat .a))
(( \f: Unit .((f (unfold [ Bool ] (fold [ Rec X. X ] (let u = (let u = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) in false) in (let u = false in u)) )) ) (fix (\x: Rec X. X . (let u = (case <r = false > as Bool of < l = x > => x | < r = y > => y) in (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y)) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (((\x: Rec X. X .\y: Nat .y) true ) ({a = 1 , b = true }.b)) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] true )) ) ) (\a: Unit .\b: Rec X. X .a)) ))
(let u = (case <l = ({a = (let u = ({a = 1 , b = true , c =  0 }.b) in 0) , b = (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a)) , c = (((\x: Unit .\y: Nat .y) false ) 0) }.c) > as Bool of < l = x > => x | < r = y > => y) in ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Rec X. X .\y: Unit .x) false ) false) )) , b = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) }.b))
(( \f: Nat .((f ({a = (if ({a = (unfold [ Rec X. X ] (fold [ Bool ] false )) , b = (((\x: Nat .\y: Bool .y) true ) true) }.b) then (pred 1) else (( \f: Unit .((f 1 ) 1 ) ) (\a: Nat .\b: Rec X. X .b))) , b = (if (((\x: Rec X. X .\y: Rec X. X .y) false ) false) then (fix (\x: Unit . (if false then false else false) )) else (let u = true in ({a = false , b = 1 }.a))) , c = (let u = (((\x: Bool .\y: Bool .y) false ) 0) in (let u = ({a = 0 , b = true }.a) in 0)) }.c) ) (((\x: Unit .\y: Nat .x) ({a = (pred 0) , b = (((\x: Rec X. X .\y: Bool .x) false ) true) }.a) ) ({a = (( \f: Bool .((f true ) ({a = 1 , b = false }.b) ) ) (\a: Bool .\b: Bool .a)) , b = (let u = true in false) }.b)) ) ) (\a: Nat .\b: Bool .a))
(( \f: Unit .((f (( \f: Unit .((f (iszero (unfold [ Rec X. X ] (fold [ Unit ] 0 ))) ) (let u = (( \f: Unit .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) in (unfold [ Bool ] (fold [ Rec X. X ] true ))) ) ) (\a: Unit .\b: Bool .a)) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (fix (\x: Bool . true )) )) ) ) (\a: Rec X. X .\b: Rec X. X .a))
((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (let u = (succ (let u = 1 in u)) in (pred 0)) ))
({a = (case <r = (( \f: Nat .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] true )) ) (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Unit .\b: Nat .b)) > as Nat of < l = x > => x | < r = y > => y) , b = ({a = (let u = (iszero 1) in (case <l = ({a = false , b = 1 }.b) > as Nat of < l = x > => x | < r = y > => y)) , b = (let u = (succ 1) in (( \f: Unit .((f false ) false ) ) (\a: Rec X. X .\b: Unit .b))) }.b) }.b)
(let u = (unfold [ Nat ] (fold [ Unit ] ({a = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 0 )) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = 1 in true) , b = true }.b) )) }.b) )) in (case <l = ({a = (let u = 0 in 0) , b = (((\x: Bool .\y: Nat .x) true ) true) , c = (((\x: Bool .\y: Unit .x) 1 ) false) }.c) > as Unit of < l = x > => x | < r = y > => y))
(iszero ({a = (let u = (((\x: Unit .\y: Nat .x) (let u = false in u) ) false) in u) , b = ({a = (let u = false in true) , b = (pred 1) }.b) }.b))
(((\x: Nat .\y: Rec X. X .x) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = (case <l = (let u = 1 in 0) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (fix (\x: Unit . (case <r = false > as Bool of < l = x > => x | < r = y > => y) )) }.b) )) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] ({a = (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) (case <l = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Nat ] 1 )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .a)) , b = (let u = 0 in false) }.b) )))
(succ (succ ({a = ({a = false , b = false }.b) , b = (let u = false in 0) }.b)))
(( \f: Nat .((f (fix (\x: Rec X. X . (( \f: Rec X. X .((f (if false then true else false) ) (let u = ({a = false , b = 1 }.b) in (case <r = true > as Unit of < l = x > => x | < r = y > => y)) ) ) (\a: Unit .\b: Nat .b)) )) ) (case <r = (fix (\x: Rec X. X . (let u = ({a = 0 , b = false , c = 0 }.c) in true) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Bool .b))
(pred (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 )) in ((\x: Bool . unfold [ Nat ] x) (fold [ Unit ] 1 ))))
(unfold [ Rec X. X ] (fold [ Unit ] (case <r = ({a = 1 , b = false }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ))
((\x: Unit . unfold [ Nat ] x) (fold [ Unit ] (pred (let u = ({a = (fix (\x: Unit . 0 )) , b = ({a = true , b = false }.b) }.a) in (let u = (unfold [ Unit ] (fold [ Bool ] false )) in (let u = (fix (\x: Unit . 1 )) in u)))) ))
(( \f: Rec X. X .((f (let u = (let u = ({a = ({a = true , b = 0 }.b) , b = ({a = false , b = 0 }.b) }.b) in u) in ({a = ({a = true , b = 0 }.b) , b = ({a = false , b = (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Unit .b)) }.b) }.b)) ) (( \f: Nat .((f (( \f: Bool .((f (succ (((\x: Nat .\y: Bool .y) true ) 0)) ) ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] ({a = true , b = ({a = false , b = 1 }.b) }.b) )) ) ) (\a: Bool .\b: Unit .a)) ) (((\x: Bool .\y: Unit .y) (((\x: Rec X. X .\y: Rec X. X .x) (unfold [ Unit ] (fold [ Nat ] true )) ) (if true then false else false)) ) (((\x: Rec X. X .\y: Bool .x) 0 ) false)) ) ) (\a: Unit .\b: Unit .a)) ) ) (\a: Nat .\b: Bool .a))
(( \f: Nat .((f (case <r = (let u = (let u = (iszero 0) in u) in (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a))) > as Bool of < l = x > => x | < r = y > => y) ) (case <r = (iszero ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 0 , b = true , c = 0 }.c) ))) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .b))
({a = ({a = ({a = (( \f: Nat .((f 0 ) (if true then 0 else 0) ) ) (\a: Bool .\b: Bool .a)) , b = (unfold [ Bool ] (fold [ Bool ] ({a = true , b = 0 }.a) )) }.a) , b = (let u = ({a = ({a = true , b = 1 }.b) , b = (let u = false in u) }.a) in (iszero (((\x: Unit .\y: Bool .y) true ) 1))) , c =  (succ ({a = 1 , b = 0 }.b)) }.b) , b = ({a = (fix (\x: Nat . (fix (\x: Nat . 1 )) )) , b = (((\x: Bool .\y: Nat .y) false ) true) }.a) }.a)
(if ({a = ({a = (iszero ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 0 ))) , b = (let u = 0 in u) }.a) , b = (unfold [ Bool ] (fold [ Unit ] (((\x: Rec X. X .\y: Unit .x) (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .b)) ) true) )) }.b) then (case <r = ({a = ({a = false , b = 0 }.a) , b = (fix (\x: Bool . true )) }.b) > as Unit of < l = x > => x | < r = y > => y) else (if (unfold [ Bool ] (fold [ Bool ] ({a = 0 , b = false }.b) )) then (((\x: Nat .\y: Bool .y) ({a = false , b = 0 }.a) ) false) else ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Unit .\b: Unit .b)) , b = (if true then true else false) }.b)))
(( \f: Rec X. X .((f (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] (let u = 1 in u) ))) ) (iszero (( \f: Nat .((f ({a = 1 , b = false }.a) ) (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .a))) ) ) (\a: Rec X. X .\b: Nat .a))
(let u = ({a = ({a = ({a = false , b = 1 }.b) , b = (((\x: Bool .\y: Rec X. X .x) true ) false) }.b) , b = (case <l = ({a = ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] 1 )) , b = (let u = true in u) , c = (case <l = 0 > as Nat of < l = x > => x | < r = y > => y) }.c) , b = ({a = (fix (\x: Nat . false )) , b = (let u = 1 in u) }.a) , c = (fix (\x: Nat . 1 )) }.c) > as Nat of < l = x > => x | < r = y > => y) }.a) in u)
(case <l = (( \f: Bool .((f (let u = 1 in ({a = 1 , b = 1 }.b)) ) (((\x: Unit .\y: Nat .y) ({a = (fix (\x: Bool . 0 )) , b = false , c =  1 }.b) ) (fix (\x: Rec X. X . 0 ))) ) ) (\a: Rec X. X .\b: Bool .a)) > as Bool of < l = x > => x | < r = y > => y)
(iszero (( \f: Rec X. X .((f (( \f: Unit .((f (unfold [ Nat ] (fold [ Nat ] 1 )) ) (let u = (((\x: Nat .\y: Bool .x) 1 ) false) in 1) ) ) (\a: Nat .\b: Rec X. X .b)) ) (unfold [ Nat ] (fold [ Rec X. X ] (if true then 1 else 1) )) ) ) (\a: Unit .\b: Rec X. X .a)))
(fix (\x: Nat . (( \f: Unit .((f (case <l = (let u = 0 in 1) > as Unit of < l = x > => x | < r = y > => y) ) (let u = 0 in u) ) ) (\a: Bool .\b: Bool .b)) ))
(pred (let u = (let u = ({a = (pred 1) , b = true , c =  0 }.b) in (let u = true in 1)) in u))
((\x: Unit . unfold [ Nat ] x) (fold [ Bool ] ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] false )) in u) )) , b = (((\x: Rec X. X .\y: Nat .x) (fix (\x: Bool . ({a = 1 , b = false }.a) )) ) (((\x: Nat .\y: Rec X. X .x) true ) (fix (\x: Unit . false )))) }.a) ))
(pred (case <l = (( \f: Rec X. X .((f (let u = (if true then 1 else 0) in 0) ) (let u = false in 0) ) ) (\a: Nat .\b: Bool .b)) > as Rec X. X of < l = x > => x | < r = y > => y))
(if (((\x: Rec X. X .\y: Bool .x) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (fix (\x: Unit . 1 )) )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] true )) , c =  (succ (let u = 0 in 1)) }.b) ) ({a = 0 , b = false , c =  1 }.b)) then (( \f: Bool .((f (let u = (unfold [ Rec X. X ] (fold [ Rec X. X ] false )) in (let u = 0 in true)) ) (((\x: Unit .\y: Bool .y) (case <r = (iszero 0) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = 1 , b = false }.b)) ) ) (\a: Unit .\b: Unit .a)) else ((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] (case <r = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Bool .a)) > as Unit of < l = x > => x | < r = y > => y) )))
(let u = (((\x: Bool .\y: Unit .x) (fix (\x: Rec X. X . false )) ) (((\x: Unit .\y: Unit .y) (fix (\x: Bool . true )) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Rec X. X .b)))) in (if (let u = ({a = (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .b)) , b = ({a = true , b = true }.b) }.b) in (let u = (fix (\x: Rec X. X . (( \f: Bool .((f 1 ) 0 ) ) (\a: Bool .\b: Bool .b)) )) in ({a = 1 , b = ({a = 0 , b = false , c =  1 }.b) }.b))) then (let u = ({a = (case <r = true > as Bool of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f 1 ) 1 ) ) (\a: Bool .\b: Nat .b)) }.b) in (iszero (succ 1))) else (iszero (((\x: Nat .\y: Nat .y) false ) (fix (\x: Bool . 0 ))))))
({a = ({a = (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a)) in u) , b = (if ({a = true , b = 1 }.a) then 0 else 0) }.b) , b = ({a = (unfold [ Nat ] (fold [ Unit ] (if (case <r = true > as Unit of < l = x > => x | < r = y > => y) then 1 else 0) )) , b = ({a = ({a = (((\x: Nat .\y: Nat .x) false ) true) , b = (case <r = true > as Nat of < l = x > => x | < r = y > => y) }.b) , b = ((\x: Bool . unfold [ Bool ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Nat .y) false ) 1) )) }.b) }.b) }.b)
(( \f: Nat .((f (if (fix (\x: Unit . (let u = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )) in (let u = true in u)) )) then (fix (\x: Unit . (((\x: Rec X. X .\y: Bool .x) (iszero 0) ) (( \f: Bool .((f false ) true ) ) (\a: Nat .\b: Bool .a))) )) else ({a = (((\x: Nat .\y: Bool .y) (unfold [ Nat ] (fold [ Unit ] false )) ) (fix (\x: Bool . true ))) , b = (pred (((\x: Nat .\y: Nat .x) 0 ) false)) }.a)) ) (let u = ({a = (let u = 0 in u) , b = ({a = 0 , b = true , c = 1 }.c) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] (fix (\x: Nat . ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] false )) )) ))) ) ) (\a: Rec X. X .\b: Nat .b))
(pred (((\x: Unit .\y: Nat .x) (( \f: Unit .((f (let u = (((\x: Unit .\y: Rec X. X .y) false ) 1) in u) ) (case <l = (let u = 1 in u) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Unit .a)) ) ({a = ({a = (((\x: Nat .\y: Unit .x) (if true then 0 else 0) ) (let u = false in u)) , b = (case <r = false > as Nat of < l = x > => x | < r = y > => y) , c =  (let u = true in (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .b))) }.b) , b = (((\x: Nat .\y: Unit .y) (((\x: Unit .\y: Nat .x) true ) true) ) (( \f: Unit .((f true ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Unit .\b: Unit .a))) }.b)))
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ({a = (((\x: Bool .\y: Bool .y) true ) 0) , b = (let u = 0 in true) , c = (let u = ({a = 1 , b = true }.b) in (succ 0)) }.c) , b = (if (let u = true in true) then (let u = false in false) else (fix (\x: Nat . (iszero 1) ))) }.b) ))
(((\x: Rec X. X .\y: Bool .x) ({a = (let u = (let u = true in 0) in (pred 0)) , b = (if (( \f: Nat .((f true ) false ) ) (\a: Rec X. X .\b: Nat .b)) then (( \f: Bool .((f ({a = false , b = 0 }.b) ) (((\x: Nat .\y: Nat .x) 1 ) false) ) ) (\a: Bool .\b: Unit .b)) else (((\x: Rec X. X .\y: Bool .x) 1 ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Bool .b)))) }.b) ) (fix (\x: Unit . (((\x: Nat .\y: Rec X. X .x) false ) false) )))
({a = (((\x: Nat .\y: Bool .y) ({a = (unfold [ Bool ] (fold [ Rec X. X ] 1 )) , b = (if true then true else true) , c =  (unfold [ Rec X. X ] (fold [ Nat ] 1 )) }.b) ) ({a = (let u = 0 in 0) , b = (case <r = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) > as Bool of < l = x > => x | < r = y > => y) , c = (case <l = 1 > as Unit of < l = x > => x | < r = y > => y) }.c)) , b = (( \f: Nat .((f ({a = 0 , b = true }.a) ) ({a = 0 , b = true , c = 1 }.c) ) ) (\a: Bool .\b: Bool .a)) }.b)
(succ (((\x: Unit .\y: Bool .y) (if (if true then true else true) then ({a = true , b = true }.b) else (((\x: Nat .\y: Nat .x) false ) false)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (( \f: Nat .((f (unfold [ Bool ] (fold [ Unit ] 1 )) ) 1 ) ) (\a: Unit .\b: Nat .b)) ))))
(( \f: Nat .((f (fix (\x: Unit . (( \f: Bool .((f (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (unfold [ Unit ] (fold [ Bool ] 1 )) ) ) (\a: Unit .\b: Unit .a)) )) ) (case <l = (fix (\x: Unit . (((\x: Bool .\y: Rec X. X .y) false ) ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] 0 ))) )) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Nat .a))
(unfold [ Unit ] (fold [ Nat ] (iszero (unfold [ Unit ] (fold [ Nat ] (let u = (if true then false else false) in (((\x: Nat .\y: Rec X. X .x) ({a = 1 , b = false , c = 0 }.c) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] true )))) ))) ))
((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f (let u = (let u = (iszero 1) in u) in u) ) (let u = (iszero 1) in u) ) ) (\a: Unit .\b: Bool .a)) ))
(let u = ({a = (succ (( \f: Unit .((f 1 ) 1 ) ) (\a: Bool .\b: Unit .a))) , b = (let u = true in u) , c = ({a = ({a = (let u = 0 in 0) , b = (if true then true else true) , c = 1 }.c) , b = ({a = 1 , b = false }.b) }.a) }.c) in u)
(( \f: Rec X. X .((f (( \f: Bool .((f ({a = (let u = 0 in ({a = 0 , b = true , c = 1 }.c)) , b = (fix (\x: Bool . 1 )) }.b) ) (fix (\x: Bool . ({a = ({a = 1 , b = false }.b) , b = (pred 1) }.b) )) ) ) (\a: Bool .\b: Rec X. X .a)) ) (unfold [ Bool ] (fold [ Unit ] ({a = ({a = 1 , b = true }.a) , b = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) }.b) )) ) ) (\a: Nat .\b: Nat .b))
({a = (let u = (iszero 1) in u) , b = (( \f: Unit .((f (case <r = ({a = 1 , b = ({a = false , b = 1 }.a) }.b) > as Unit of < l = x > => x | < r = y > => y) ) (if (let u = true in true) then (((\x: Bool .\y: Bool .y) false ) true) else (let u = ({a = 0 , b = true }.b) in (fix (\x: Rec X. X . false )))) ) ) (\a: Rec X. X .\b: Unit .a)) }.b)
(if (fix (\x: Nat . (((\x: Rec X. X .\y: Bool .x) (let u = (( \f: Unit .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) in u) ) ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] false ))) )) then (fix (\x: Rec X. X . (let u = (fix (\x: Unit . false )) in u) )) else ({a = (unfold [ Nat ] (fold [ Bool ] (iszero 1) )) , b = ((\x: Bool . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Unit . ({a = true , b = 0 }.a) )) )) }.b))
(let u = (fix (\x: Bool . (((\x: Rec X. X .\y: Nat .y) (unfold [ Bool ] (fold [ Nat ] true )) ) (if false then true else false)) )) in u)
((\x: Rec X. X . unfold [ Nat ] x) (fold [ Bool ] ({a = ({a = (if (let u = true in true) then 1 else (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Rec X. X .b))) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = (unfold [ Unit ] (fold [ Unit ] 0 )) }.c) , b = (fix (\x: Bool . (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) }.b) ))
(let u = (( \f: Bool .((f ({a = ({a = 1 , b = 1 }.b) , b = (fix (\x: Nat . false )) }.a) ) (( \f: Nat .((f (( \f: Bool .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) ) ({a = (iszero 1) , b = 1 }.b) ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Bool .\b: Bool .a)) in ({a = (let u = (case <r = true > as Nat of < l = x > => x | < r = y > => y) in false) , b = (((\x: Nat .\y: Nat .y) false ) 1) }.b))
(pred (( \f: Bool .((f ({a = 0 , b = 0 }.b) ) (succ 1) ) ) (\a: Rec X. X .\b: Nat .a)))
(fix (\x: Bool . ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) , b = (iszero 0) , c =  (pred 1) }.b) ))
({a = ((\x: Bool . unfold [ Unit ] x) (fold [ Unit ] ({a = (let u = false in (pred 0)) , b = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Nat .a)) }.b) )) , b = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = ({a = false , b = 1 }.b) , b = (let u = (let u = 0 in false) in false) }.a) )) }.a)
(let u = (((\x: Unit .\y: Unit .x) (case <r = (((\x: Unit .\y: Bool .x) false ) (fix (\x: Rec X. X . false ))) > as Nat of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Unit .y) (if true then true else false) ) ({a = true , b = 0 }.a))) in (if (let u = (fix (\x: Rec X. X . true )) in (fix (\x: Unit . false ))) then ({a = (iszero ({a = false , b = 0 }.b)) , b = ({a = (iszero ({a = 0 , b = true }.a)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] 1 )) }.b) }.b) else (let u = (let u = (((\x: Rec X. X .\y: Rec X. X .y) true ) 1) in (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y)) in u)))
(((\x: Nat .\y: Rec X. X .y) (let u = (fix (\x: Bool . (fix (\x: Rec X. X . true )) )) in (iszero (if true then 1 else 0))) ) (succ (let u = 1 in u)))
(( \f: Rec X. X .((f ((\x: Nat . unfold [ Nat ] x) (fold [ Bool ] (let u = (unfold [ Bool ] (fold [ Nat ] false )) in (((\x: Rec X. X .\y: Nat .y) false ) true)) )) ) (let u = (( \f: Rec X. X .((f (let u = (fix (\x: Rec X. X . true )) in u) ) (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .a)) ) ) (\a: Nat .\b: Bool .b)) in ((\x: Bool . unfold [ Bool ] x) (fold [ Nat ] (((\x: Nat .\y: Bool .y) true ) (let u = true in u)) ))) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = (case <l = (if (((\x: Rec X. X .\y: Rec X. X .y) true ) false) then (succ (if false then 0 else 0)) else (case <l = (((\x: Rec X. X .\y: Rec X. X .y) false ) 1) > as Unit of < l = x > => x | < r = y > => y)) > as Nat of < l = x > => x | < r = y > => y) in u)
(let u = (iszero (case <l = ({a = true , b = 1 }.b) > as Rec X. X of < l = x > => x | < r = y > => y)) in u)
(( \f: Bool .((f (case <l = (let u = ({a = (case <l = (let u = 1 in u) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (let u = 1 in u) }.b) in (pred 1)) > as Nat of < l = x > => x | < r = y > => y) ) ({a = ({a = (let u = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) in u) , b = (((\x: Bool .\y: Unit .y) true ) (let u = 1 in u)) }.b) , b = (case <l = ({a = (succ 0) , b = ({a = 1 , b = false }.b) }.a) > as Nat of < l = x > => x | < r = y > => y) }.b) ) ) (\a: Bool .\b: Unit .a))
({a = (let u = (let u = (unfold [ Unit ] (fold [ Nat ] 0 )) in ({a = true , b = 1 }.b)) in (unfold [ Rec X. X ] (fold [ Rec X. X ] (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 )) ))) , b = (( \f: Rec X. X .((f (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) true ) false) ) (case <r = false > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .b)) ) ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Bool ] true )) ) ) (\a: Bool .\b: Nat .a)) , c = (let u = (( \f: Nat .((f ({a = (let u = 0 in 0) , b = 0 }.b) ) (( \f: Nat .((f ({a = ({a = 0 , b = 1 }.b) , b = (((\x: Bool .\y: Nat .y) true ) false) , c = (pred 1) }.c) ) (fix (\x: Rec X. X . 1 )) ) ) (\a: Bool .\b: Bool .b)) ) ) (\a: Rec X. X .\b: Unit .a)) in (let u = (( \f: Bool .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .b)) in u)) }.c)
(let u = (let u = ({a = ({a = true , b = false }.b) , b = (((\x: Nat .\y: Nat .x) 1 ) (let u = false in u)) }.b) in ({a = (let u = 1 in false) , b = (((\x: Bool .\y: Bool .x) (unfold [ Nat ] (fold [ Rec X. X ] 1 )) ) ({a = 0 , b = true }.b)) }.b)) in (((\x: Bool .\y: Rec X. X .y) (((\x: Rec X. X .\y: Bool .x) ({a = 0 , b = false , c =  1 }.b) ) false) ) (((\x: Bool .\y: Rec X. X .y) ({a = 0 , b = false , c =  0 }.b) ) (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Nat .\b: Nat .b)))))
({a = ({a = ({a = (let u = ({a = 0 , b = 1 }.b) in u) , b = (case <l = (fix (\x: Bool . (((\x: Unit .\y: Nat .x) 0 ) true) )) > as Unit of < l = x > => x | < r = y > => y) }.b) , b = (((\x: Nat .\y: Rec X. X .y) ({a = 0 , b = true , c =  1 }.b) ) (let u = 1 in true)) }.a) , b = (((\x: Unit .\y: Nat .y) (iszero (((\x: Nat .\y: Rec X. X .y) true ) 1)) ) ({a = true , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.a)) , c =  (pred (((\x: Unit .\y: Unit .x) (let u = (succ 1) in u) ) ({a = 1 , b = true , c =  0 }.b))) }.b)
({a = (( \f: Rec X. X .((f ({a = 1 , b = true , c =  0 }.b) ) (let u = ({a = false , b = 0 }.a) in u) ) ) (\a: Rec X. X .\b: Bool .a)) , b = ({a = ({a = 1 , b = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Bool .b)) }.a) , b = (let u = ({a = 0 , b = false , c =  0 }.b) in (((\x: Nat .\y: Bool .y) (((\x: Nat .\y: Bool .y) false ) false) ) true)) }.b) }.b)
({a = (fix (\x: Unit . ({a = ({a = 1 , b = 1 }.b) , b = (( \f: Bool .((f ({a = 1 , b = true }.b) ) (iszero 1) ) ) (\a: Unit .\b: Nat .a)) , c =  (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .b)) }.b) )) , b = ({a = ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] (((\x: Unit .\y: Bool .x) true ) false) )) , b = (pred (( \f: Nat .((f (if true then 0 else 1) ) (((\x: Rec X. X .\y: Bool .x) 1 ) true) ) ) (\a: Bool .\b: Nat .a))) }.b) }.b)
(let u = (let u = ({a = (unfold [ Rec X. X ] (fold [ Nat ] 1 )) , b = ({a = (let u = true in true) , b = false }.b) }.b) in (unfold [ Rec X. X ] (fold [ Bool ] (((\x: Rec X. X .\y: Unit .x) (pred 1) ) (if true then false else false)) ))) in ({a = (((\x: Nat .\y: Unit .y) (if false then true else true) ) true) , b = (if ({a = 1 , b = true , c =  1 }.b) then ({a = 1 , b = true }.a) else (succ 1)) }.b))
({a = (fix (\x: Rec X. X . (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = (succ 1) }.b) ) ({a = 0 , b = true }.b)) ) (let u = (( \f: Rec X. X .((f false ) true ) ) (\a: Bool .\b: Unit .a)) in (succ 1)) ) ) (\a: Rec X. X .\b: Unit .a)) )) , b = ({a = ({a = (( \f: Bool .((f 1 ) 1 ) ) (\a: Unit .\b: Nat .a)) , b = ({a = false , b = false }.b) , c =  (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) }.b) , b = (let u = (if false then true else false) in (let u = 0 in u)) }.b) }.b)
(((\x: Bool .\y: Bool .x) (((\x: Rec X. X .\y: Rec X. X .y) ({a = (unfold [ Rec X. X ] (fold [ Rec X. X ] (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) )) , b = (( \f: Rec X. X .((f (( \f: Nat .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) ) ((\x: Nat . unfold [ Unit ] x) (fold [ Bool ] 0 )) ) ) (\a: Nat .\b: Unit .a)) }.a) ) (( \f: Rec X. X .((f (pred 0) ) (fix (\x: Bool . 1 )) ) ) (\a: Bool .\b: Bool .a))) ) (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Nat ] ({a = (let u = 1 in false) , b = (let u = true in u) }.b) )) in u))
((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (let u = (case <r = (let u = (((\x: Unit .\y: Bool .x) 1 ) true) in (let u = 1 in (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Rec X. X .a)))) > as Bool of < l = x > => x | < r = y > => y) in (let u = ({a = (if false then 1 else 1) , b = false }.b) in u)) ))
({a = (case <r = (fix (\x: Rec X. X . ({a = 0 , b = false }.b) )) > as Nat of < l = x > => x | < r = y > => y) , b = (( \f: Nat .((f (let u = ({a = false , b = 0 }.b) in ({a = 1 , b = (( \f: Bool .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.b)) ) ({a = (pred 1) , b = ({a = 1 , b = false }.b) , c = ({a = 1 , b = true }.a) }.c) ) ) (\a: Nat .\b: Nat .b)) }.b)
({a = (case <l = (fix (\x: Nat . (succ 1) )) > as Unit of < l = x > => x | < r = y > => y) , b = (( \f: Rec X. X .((f (let u = ({a = 0 , b = false , c =  0 }.b) in u) ) (let u = ({a = (case <l = (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Nat .b)) > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] true )) }.a) in (if (let u = 1 in true) then ({a = (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) , b = 1 }.a) else (let u = true in u))) ) ) (\a: Nat .\b: Unit .b)) }.a)
({a = (if (((\x: Rec X. X .\y: Nat .x) (( \f: Rec X. X .((f false ) true ) ) (\a: Nat .\b: Bool .a)) ) (unfold [ Rec X. X ] (fold [ Unit ] false ))) then (( \f: Bool .((f (pred (((\x: Bool .\y: Nat .x) ((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] 1 )) ) true)) ) ({a = (((\x: Rec X. X .\y: Nat .y) false ) true) , b = (succ ({a = false , b = 0 }.b)) }.b) ) ) (\a: Nat .\b: Bool .a)) else ({a = (let u = (unfold [ Unit ] (fold [ Bool ] 0 )) in u) , b = (fix (\x: Rec X. X . false )) }.a)) , b = (((\x: Nat .\y: Nat .x) (( \f: Rec X. X .((f (let u = 1 in ({a = 1 , b = false }.a)) ) ({a = false , b = (fix (\x: Bool . 1 )) }.b) ) ) (\a: Bool .\b: Rec X. X .a)) ) ({a = (( \f: Bool .((f ({a = 1 , b = false }.b) ) (let u = true in u) ) ) (\a: Unit .\b: Bool .b)) , b = (((\x: Rec X. X .\y: Nat .x) false ) false) }.b)) }.b)
(fix (\x: Bool . (( \f: Rec X. X .((f (let u = (unfold [ Nat ] (fold [ Unit ] true )) in ({a = true , b = ({a = 1 , b = 0 }.b) }.a)) ) (((\x: Nat .\y: Bool .y) (((\x: Unit .\y: Nat .y) (let u = true in u) ) false) ) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .a))) ) ) (\a: Bool .\b: Bool .a)) ))
({a = (if (iszero 1) then ({a = 0 , b = true }.a) else (((\x: Rec X. X .\y: Unit .x) 1 ) (iszero 1))) , b = ({a = (( \f: Nat .((f (let u = false in u) ) (let u = true in true) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (let u = ({a = 1 , b = true }.b) in u) }.b) }.a)
(((\x: Bool .\y: Nat .x) (let u = (((\x: Bool .\y: Bool .x) ({a = (( \f: Bool .((f true ) false ) ) (\a: Bool .\b: Rec X. X .a)) , b = (let u = 1 in 0) }.b) ) (case <r = false > as Unit of < l = x > => x | < r = y > => y)) in (( \f: Bool .((f ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] false )) ) ({a = (pred ({a = 1 , b = true }.a)) , b = ({a = 0 , b = false }.b) , c =  ({a = (if false then 1 else 0) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c = 1 }.c) }.b) ) ) (\a: Nat .\b: Nat .b))) ) (if (let u = (((\x: Rec X. X .\y: Unit .y) true ) false) in ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Nat ] true ))) then (let u = (( \f: Rec X. X .((f true ) true ) ) (\a: Bool .\b: Unit .b)) in (iszero 1)) else (let u = (( \f: Nat .((f 0 ) 0 ) ) (\a: Nat .\b: Unit .a)) in false)))
(let u = (( \f: Rec X. X .((f (fix (\x: Nat . 1 )) ) (((\x: Rec X. X .\y: Rec X. X .x) (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) ) (case <r = true > as Bool of < l = x > => x | < r = y > => y)) ) ) (\a: Nat .\b: Nat .a)) in (((\x: Unit .\y: Nat .x) (( \f: Nat .((f (fix (\x: Rec X. X . 0 )) ) (((\x: Nat .\y: Nat .y) true ) 1) ) ) (\a: Rec X. X .\b: Nat .a)) ) (if (((\x: Unit .\y: Nat .y) ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] true )) ) ({a = true , b = true }.b)) then (let u = ((\x: Unit . unfold [ Bool ] x) (fold [ Rec X. X ] false )) in (let u = 1 in true)) else (( \f: Nat .((f (fix (\x: Nat . true )) ) (let u = true in false) ) ) (\a: Bool .\b: Nat .b)))))
(let u = (( \f: Unit .((f (((\x: Bool .\y: Bool .x) ({a = (fix (\x: Bool . 0 )) , b = 1 }.b) ) (iszero (((\x: Bool .\y: Nat .x) 0 ) false))) ) (pred ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] 0 ))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) in (((\x: Bool .\y: Rec X. X .y) ({a = (unfold [ Rec X. X ] (fold [ Unit ] 1 )) , b = (( \f: Rec X. X .((f true ) true ) ) (\a: Unit .\b: Rec X. X .b)) , c =  (succ 0) }.b) ) (( \f: Unit .((f 0 ) 1 ) ) (\a: Bool .\b: Bool .b))))
(fix (\x: Rec X. X . (( \f: Rec X. X .((f (( \f: Rec X. X .((f (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false }.b) )) ) (fix (\x: Rec X. X . true )) ) ) (\a: Rec X. X .\b: Nat .a)) ) ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] (let u = 1 in true) )) ) ) (\a: Bool .\b: Rec X. X .b)) ))
({a = (fix (\x: Rec X. X . (pred (succ 1)) )) , b = (fix (\x: Rec X. X . (unfold [ Rec X. X ] (fold [ Rec X. X ] (if true then true else true) )) )) , c = (( \f: Nat .((f (let u = 0 in u) ) ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) ) ) (\a: Bool .\b: Bool .a)) }.c)
(let u = (succ (unfold [ Nat ] (fold [ Bool ] ({a = 0 , b = false }.a) ))) in (let u = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) in (( \f: Unit .((f true ) false ) ) (\a: Rec X. X .\b: Bool .b))))
(( \f: Rec X. X .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (pred ({a = 1 , b = true }.a)) )) ) (fix (\x: Rec X. X . (pred (if false then 1 else 0)) )) ) ) (\a: Rec X. X .\b: Unit .a))
((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = (let u = ({a = (((\x: Unit .\y: Bool .x) 1 ) false) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] true )) }.a) in (iszero (succ 1))) , b = (( \f: Bool .((f (let u = (unfold [ Rec X. X ] (fold [ Unit ] false )) in 1) ) (unfold [ Nat ] (fold [ Unit ] 0 )) ) ) (\a: Nat .\b: Nat .a)) }.b) ))
({a = ({a = (((\x: Rec X. X .\y: Bool .x) 0 ) (( \f: Bool .((f true ) true ) ) (\a: Unit .\b: Rec X. X .a))) , b = (let u = ({a = 1 , b = true , c = 1 }.c) in u) }.b) , b = (iszero (pred 1)) , c = (((\x: Unit .\y: Unit .x) (succ (((\x: Bool .\y: Rec X. X .x) (fix (\x: Rec X. X . 1 )) ) ({a = 0 , b = true }.b))) ) (((\x: Rec X. X .\y: Bool .x) (( \f: Nat .((f (let u = true in u) ) ({a = 0 , b = false , c =  1 }.b) ) ) (\a: Bool .\b: Rec X. X .b)) ) (let u = true in u))) }.c)
(fix (\x: Bool . ({a = (let u = (let u = 1 in true) in (unfold [ Unit ] (fold [ Bool ] (unfold [ Nat ] (fold [ Nat ] 0 )) ))) , b = ({a = ({a = 0 , b = true , c =  0 }.b) , b = ({a = true , b = 0 }.b) }.a) }.a) ))
(let u = (fix (\x: Nat . (case <l = (unfold [ Rec X. X ] (fold [ Bool ] (unfold [ Unit ] (fold [ Nat ] 0 )) )) > as Unit of < l = x > => x | < r = y > => y) )) in (case <l = (((\x: Unit .\y: Nat .x) (let u = false in 1) ) (if (let u = true in u) then (fix (\x: Unit . false )) else ({a = true , b = 0 }.a))) > as Nat of < l = x > => x | < r = y > => y))
(succ (( \f: Nat .((f ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Rec X. X ] (succ 0) )) ) ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = 0 , b = ({a = false , b = 0 }.a) }.a) )) ) ) (\a: Rec X. X .\b: Unit .a)))
({a = ({a = (let u = true in ({a = false , b = true }.b)) , b = ({a = (let u = true in 1) , b = 1 }.b) }.a) , b = ({a = (unfold [ Bool ] (fold [ Nat ] 1 )) , b = (case <r = ({a = true , b = 0 }.a) > as Rec X. X of < l = x > => x | < r = y > => y) , c =  (unfold [ Nat ] (fold [ Bool ] ({a = (let u = false in false) , b = (let u = true in 1) }.b) )) }.b) }.b)
(pred (( \f: Nat .((f (( \f: Nat .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Nat .\b: Bool .a)) ) 0 ) ) (\a: Bool .\b: Rec X. X .b)) ) (succ ({a = ({a = true , b = 1 }.b) , b = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] false )) , c = 1 }.c)) ) ) (\a: Nat .\b: Nat .b)))
({a = (iszero (succ (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) , b = (fix (\x: Rec X. X . ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (pred 1) )) )) }.b)
(let u = (let u = (iszero (if true then 0 else 0)) in u) in (let u = ({a = (fix (\x: Nat . ({a = false , b = 0 }.b) )) , b = ((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] false )) }.b) in u))
(((\x: Rec X. X .\y: Rec X. X .x) ({a = (((\x: Unit .\y: Bool .x) ({a = true , b = 1 }.b) ) (((\x: Bool .\y: Rec X. X .x) ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] false )) ) (fix (\x: Rec X. X . true )))) , b = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (succ ({a = false , b = 0 }.b)) )) }.b) ) (if (((\x: Rec X. X .\y: Unit .x) false ) true) then (let u = true in u) else (let u = (let u = true in (( \f: Rec X. X .((f false ) false ) ) (\a: Nat .\b: Rec X. X .a))) in u)))
(succ (pred (fix (\x: Nat . ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Bool ] (fix (\x: Nat . 0 )) )) ))))
(case <l = (case <l = (pred ({a = (( \f: Nat .((f false ) false ) ) (\a: Rec X. X .\b: Rec X. X .b)) , b = ({a = 0 , b = (pred 1) }.b) }.b)) > as Rec X. X of < l = x > => x | < r = y > => y) > as Nat of < l = x > => x | < r = y > => y)
(let u = (if ({a = 0 , b = ({a = 0 , b = true }.b) }.b) then (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) else (let u = (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) in u)) in u)
(iszero (let u = (unfold [ Bool ] (fold [ Rec X. X ] (let u = 0 in u) )) in ({a = (succ 1) , b = ({a = false , b = 1 }.b) }.b)))
(( \f: Nat .((f (( \f: Unit .((f (succ (case <l = (( \f: Bool .((f (let u = true in 0) ) (pred 1) ) ) (\a: Rec X. X .\b: Bool .b)) > as Nat of < l = x > => x | < r = y > => y)) ) (( \f: Nat .((f ({a = (iszero 1) , b = 0 }.b) ) ((\x: Unit . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .y) false ) 0) )) ) ) (\a: Rec X. X .\b: Unit .b)) ) ) (\a: Unit .\b: Bool .b)) ) ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = true in 1) , b = true }.b) )) , b = (fix (\x: Rec X. X . (let u = (if true then 1 else 0) in (let u = 1 in u)) )) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(let u = (iszero (( \f: Bool .((f ({a = true , b = (succ 0) }.b) ) (case <l = (( \f: Rec X. X .((f 0 ) (let u = 0 in 0) ) ) (\a: Nat .\b: Bool .a)) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Nat .\b: Bool .b))) in u)
({a = (( \f: Nat .((f (succ (( \f: Bool .((f 1 ) 1 ) ) (\a: Bool .\b: Bool .b))) ) ({a = (succ 1) , b = ({a = (((\x: Nat .\y: Bool .y) false ) true) , b = ({a = 1 , b = true }.a) }.a) }.a) ) ) (\a: Rec X. X .\b: Bool .b)) , b = ({a = (let u = (let u = false in true) in u) , b = (let u = (succ ({a = 1 , b = true }.a)) in u) }.b) }.b)
((\x: Nat . unfold [ Bool ] x) (fold [ Bool ] (((\x: Unit .\y: Bool .y) (if false then false else ({a = true , b = 0 }.a)) ) (let u = ({a = 1 , b = false , c =  0 }.b) in (case <l = 1 > as Nat of < l = x > => x | < r = y > => y))) ))
(( \f: Bool .((f ({a = (( \f: Nat .((f (iszero 0) ) (let u = (fix (\x: Bool . false )) in (let u = 1 in false)) ) ) (\a: Unit .\b: Nat .a)) , b = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (( \f: Rec X. X .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Unit .b)) )) }.b) ) (case <l = (((\x: Unit .\y: Unit .y) (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) ) (((\x: Nat .\y: Unit .x) 1 ) false)) > as Bool of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Unit .b))
(( \f: Bool .((f ({a = ({a = (fix (\x: Rec X. X . 1 )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] (case <r = false > as Nat of < l = x > => x | < r = y > => y) )) , c = (fix (\x: Nat . 1 )) }.c) , b = (fix (\x: Bool . (( \f: Unit .((f false ) true ) ) (\a: Rec X. X .\b: Unit .b)) )) , c =  (if ((\x: Nat . unfold [ Bool ] x) (fold [ Nat ] (unfold [ Bool ] (fold [ Unit ] false )) )) then (fix (\x: Nat . 0 )) else (succ 0)) }.b) ) (unfold [ Rec X. X ] (fold [ Bool ] (iszero ({a = 0 , b = 1 }.b)) )) ) ) (\a: Rec X. X .\b: Nat .b))
(let u = (if (((\x: Unit .\y: Nat .y) true ) (((\x: Bool .\y: Rec X. X .y) false ) false)) then (( \f: Nat .((f (let u = false in 1) ) (( \f: Nat .((f 1 ) 0 ) ) (\a: Unit .\b: Nat .b)) ) ) (\a: Rec X. X .\b: Nat .a)) else (pred (let u = 0 in u))) in (if (let u = (let u = (iszero 0) in u) in (if false then true else true)) then (succ (case <l = 0 > as Unit of < l = x > => x | < r = y > => y)) else (case <l = 1 > as Bool of < l = x > => x | < r = y > => y)))
((\x: Bool . unfold [ Unit ] x) (fold [ Nat ] (iszero ({a = ({a = false , b = ({a = 1 , b = true }.a) }.b) , b = (let u = 0 in false) , c = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Unit ] ({a = true , b = 1 }.b) )) }.c)) ))
({a = (let u = (iszero (let u = 1 in 0)) in u) , b = (((\x: Nat .\y: Bool .y) (let u = (fix (\x: Nat . 0 )) in ({a = true , b = 1 }.a)) ) (if ({a = (fix (\x: Unit . false )) , b = ({a = 0 , b = false , c =  0 }.b) }.b) then ({a = (let u = 1 in 0) , b = (if true then true else false) }.b) else (unfold [ Rec X. X ] (fold [ Nat ] (if true then true else true) )))) }.b)
({a = (let u = (fix (\x: Unit . false )) in u) , b = (((\x: Unit .\y: Bool .y) ({a = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) , b = false , c =  0 }.b) ) (let u = (succ 1) in u)) }.a)
(( \f: Rec X. X .((f ({a = (let u = (pred (let u = 0 in 0)) in (((\x: Rec X. X .\y: Unit .y) ({a = true , b = true }.b) ) ({a = false , b = 0 }.b))) , b = (unfold [ Unit ] (fold [ Unit ] (let u = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Unit .b)) in u) )) , c =  (fix (\x: Bool . 0 )) }.b) ) ({a = (((\x: Nat .\y: Unit .x) (pred 1) ) (let u = ({a = 0 , b = false }.b) in u)) , b = (((\x: Rec X. X .\y: Rec X. X .x) ({a = true , b = true }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Bool .b))) , c =  (let u = (let u = ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Unit ] false )) in 0) in ({a = 1 , b = ({a = 1 , b = true }.b) , c = 1 }.c)) }.b) ) ) (\a: Unit .\b: Unit .a))
(pred ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Nat ] ({a = (if false then false else true) , b = 0 }.b) )))
(fix (\x: Rec X. X . ({a = (if ({a = 1 , b = false , c =  1 }.b) then (let u = true in false) else ({a = false , b = false }.b)) , b = (let u = ({a = (unfold [ Bool ] (fold [ Bool ] (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Bool .a)) )) , b = (((\x: Rec X. X .\y: Unit .y) false ) 1) }.a) in (((\x: Bool .\y: Bool .y) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) true)) }.b) ))
(if (( \f: Bool .((f ({a = (if false then true else false) , b = (( \f: Nat .((f true ) (unfold [ Unit ] (fold [ Bool ] false )) ) ) (\a: Bool .\b: Nat .a)) }.b) ) (case <r = ({a = false , b = true }.b) > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) then (succ (if (unfold [ Bool ] (fold [ Bool ] (let u = 1 in true) )) then ({a = 0 , b = (let u = true in 0) }.b) else ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 1 )))) else (let u = (((\x: Nat .\y: Unit .x) ((\x: Nat . unfold [ Nat ] x) (fold [ Rec X. X ] 0 )) ) (( \f: Nat .((f true ) true ) ) (\a: Nat .\b: Unit .b))) in u))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Bool ] ({a = (let u = (fix (\x: Bool . false )) in (((\x: Bool .\y: Unit .x) (let u = 0 in u) ) ({a = true , b = 1 }.a))) , b = ({a = ({a = false , b = 0 }.a) , b = ({a = (((\x: Unit .\y: Nat .y) false ) 1) , b = ({a = 0 , b = true }.b) , c = ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] 1 )) }.c) }.a) , c =  (succ (unfold [ Bool ] (fold [ Bool ] (((\x: Nat .\y: Bool .y) true ) 0) ))) }.b) ))
({a = (if (let u = 0 in true) then (((\x: Nat .\y: Rec X. X .x) (case <l = (pred 0) > as Bool of < l = x > => x | < r = y > => y) ) (let u = 0 in true)) else (((\x: Nat .\y: Bool .x) 0 ) true)) , b = (case <r = (let u = ({a = (( \f: Rec X. X .((f (let u = 1 in true) ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) }.b) in (let u = (let u = true in u) in u)) > as Unit of < l = x > => x | < r = y > => y) }.a)
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Rec X. X .y) ({a = (( \f: Unit .((f false ) false ) ) (\a: Unit .\b: Unit .b)) , b = 1 }.a) ) (let u = true in true)) ) ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = 1 in true) ))) ))
(let u = (iszero (if (if false then true else false) then (succ (let u = false in 1)) else (((\x: Nat .\y: Unit .y) false ) 0))) in u)
(( \f: Unit .((f (let u = (( \f: Bool .((f ({a = ((\x: Unit . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) , b = (case <r = false > as Bool of < l = x > => x | < r = y > => y) , c =  0 }.b) ) (let u = 1 in true) ) ) (\a: Nat .\b: Bool .b)) in u) ) (if ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = false , b = true }.b) )) then ({a = ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Rec X. X ] false )) , b = 0 }.b) , b = (((\x: Rec X. X .\y: Rec X. X .y) true ) true) , c =  (unfold [ Bool ] (fold [ Bool ] 0 )) }.b) else (( \f: Unit .((f (( \f: Nat .((f false ) true ) ) (\a: Bool .\b: Bool .a)) ) (if true then false else true) ) ) (\a: Unit .\b: Unit .a))) ) ) (\a: Nat .\b: Rec X. X .a))
(let u = (if ({a = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , b = true }.b) then (( \f: Rec X. X .((f ({a = 1 , b = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] true )) }.b) ) ({a = (((\x: Rec X. X .\y: Unit .y) false ) 0) , b = true , c =  ({a = 0 , b = true , c = 1 }.c) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) else (( \f: Unit .((f false ) (let u = false in false) ) ) (\a: Bool .\b: Rec X. X .b))) in ({a = (let u = ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Nat ] (let u = 0 in (((\x: Nat .\y: Nat .y) false ) false)) )) in (iszero ({a = 0 , b = false }.a))) , b = (( \f: Unit .((f (( \f: Unit .((f (let u = 0 in false) ) (((\x: Bool .\y: Rec X. X .y) false ) true) ) ) (\a: Nat .\b: Unit .a)) ) (let u = (((\x: Bool .\y: Unit .x) false ) (((\x: Rec X. X .\y: Nat .x) false ) true)) in ({a = 1 , b = false , c =  0 }.b)) ) ) (\a: Nat .\b: Unit .a)) }.b))
(pred (( \f: Bool .((f (case <l = (let u = 0 in 0) > as Rec X. X of < l = x > => x | < r = y > => y) ) ({a = ({a = false , b = 1 }.b) , b = (let u = 1 in u) }.b) ) ) (\a: Unit .\b: Rec X. X .b)))
(let u = (((\x: Bool .\y: Nat .x) (((\x: Unit .\y: Rec X. X .y) ({a = 1 , b = false , c =  0 }.b) ) false) ) ({a = (((\x: Nat .\y: Nat .y) false ) 1) , b = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Nat .a)) }.b)) in ({a = (let u = (( \f: Unit .((f 0 ) 0 ) ) (\a: Unit .\b: Nat .a)) in (pred 1)) , b = (((\x: Rec X. X .\y: Unit .y) true ) 1) }.b))
({a = (unfold [ Bool ] (fold [ Nat ] ({a = 1 , b = (unfold [ Nat ] (fold [ Unit ] false )) }.a) )) , b = ({a = (let u = (pred 1) in (((\x: Nat .\y: Bool .y) false ) (unfold [ Unit ] (fold [ Nat ] false )))) , b = ({a = false , b = (((\x: Rec X. X .\y: Unit .y) true ) 1) }.b) }.b) }.b)
({a = (if (let u = (succ 0) in true) then (fix (\x: Rec X. X . (fix (\x: Nat . 0 )) )) else (((\x: Unit .\y: Unit .y) true ) 1)) , b = ({a = (((\x: Rec X. X .\y: Unit .y) ({a = 1 , b = false , c =  1 }.b) ) (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Nat .b))) , b = (iszero (fix (\x: Rec X. X . 1 ))) }.b) }.a)
(unfold [ Bool ] (fold [ Bool ] (unfold [ Nat ] (fold [ Rec X. X ] ({a = (unfold [ Bool ] (fold [ Bool ] 1 )) , b = (fix (\x: Rec X. X . (iszero 0) )) }.a) )) ))
(let u = (((\x: Unit .\y: Bool .y) (unfold [ Unit ] (fold [ Bool ] (( \f: Bool .((f false ) false ) ) (\a: Unit .\b: Unit .b)) )) ) (let u = (( \f: Bool .((f false ) true ) ) (\a: Rec X. X .\b: Rec X. X .a)) in (succ 1))) in ({a = (unfold [ Nat ] (fold [ Bool ] (case <r = true > as Nat of < l = x > => x | < r = y > => y) )) , b = (let u = (( \f: Unit .((f true ) true ) ) (\a: Nat .\b: Unit .b)) in (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Unit .b))) }.b))
(iszero (if ({a = (fix (\x: Unit . (let u = true in u) )) , b = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) )) }.a) then ({a = ({a = (( \f: Nat .((f ({a = 0 , b = 1 }.b) ) (case <l = 0 > as Rec X. X of < l = x > => x | < r = y > => y) ) ) (\a: Bool .\b: Rec X. X .a)) , b = (( \f: Bool .((f false ) true ) ) (\a: Unit .\b: Rec X. X .b)) , c = ({a = (pred 1) , b = false , c = ({a = 0 , b = true , c = 1 }.c) }.c) }.c) , b = (let u = (((\x: Nat .\y: Nat .x) false ) true) in u) }.a) else ({a = ({a = 0 , b = 0 }.b) , b = (( \f: Rec X. X .((f (let u = 0 in true) ) (let u = 0 in false) ) ) (\a: Unit .\b: Bool .a)) }.a)))
({a = (case <l = (unfold [ Nat ] (fold [ Bool ] ({a = 0 , b = false , c = 0 }.c) )) > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = (let u = (if (((\x: Rec X. X .\y: Bool .y) false ) false) then ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = false in 0) )) else (if true then (succ 1) else 1)) in (iszero ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Bool ] 1 )))) > as Unit of < l = x > => x | < r = y > => y) , c = (case <l = ({a = ({a = false , b = 0 }.b) , b = (((\x: Nat .\y: Bool .x) true ) true) }.a) > as Unit of < l = x > => x | < r = y > => y) }.c)
((\x: Bool . unfold [ Nat ] x) (fold [ Nat ] (((\x: Bool .\y: Rec X. X .x) (case <r = (let u = ((\x: Bool . unfold [ Unit ] x) (fold [ Rec X. X ] (if true then 0 else 0) )) in ({a = (iszero 1) , b = (pred 0) }.a)) > as Rec X. X of < l = x > => x | < r = y > => y) ) (((\x: Nat .\y: Bool .y) (let u = false in false) ) ({a = false , b = 0 }.a))) ))
({a = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (((\x: Nat .\y: Unit .y) ({a = (if false then 0 else 0) , b = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] true )) }.b) ) (let u = (unfold [ Bool ] (fold [ Nat ] false )) in (let u = 0 in 1))) )) , b = (( \f: Rec X. X .((f (let u = (succ ({a = false , b = (case <l = 1 > as Nat of < l = x > => x | < r = y > => y) }.b)) in ((\x: Nat . unfold [ Unit ] x) (fold [ Unit ] ({a = 0 , b = true , c = 1 }.c) ))) ) (unfold [ Unit ] (fold [ Unit ] (let u = true in 1) )) ) ) (\a: Unit .\b: Bool .b)) }.b)
(fix (\x: Bool . (iszero ({a = (case <l = 1 > as Bool of < l = x > => x | < r = y > => y) , b = (case <r = ({a = 0 , b = true , c =  0 }.b) > as Nat of < l = x > => x | < r = y > => y) }.a)) ))
(unfold [ Nat ] (fold [ Unit ] (( \f: Rec X. X .((f (let u = (iszero ({a = true , b = 1 }.b)) in u) ) ({a = (unfold [ Unit ] (fold [ Nat ] false )) , b = (fix (\x: Nat . (iszero 1) )) }.b) ) ) (\a: Rec X. X .\b: Unit .b)) ))
(let u = (let u = (pred ((\x: Bool . unfold [ Bool ] x) (fold [ Unit ] 1 ))) in u) in u)
({a = (( \f: Nat .((f ({a = (let u = 1 in false) , b = (case <l = 0 > as Bool of < l = x > => x | < r = y > => y) }.b) ) (if (unfold [ Nat ] (fold [ Nat ] (let u = 1 in true) )) then (( \f: Bool .((f ({a = 0 , b = (((\x: Rec X. X .\y: Rec X. X .x) 0 ) true) }.b) ) (if true then 1 else 0) ) ) (\a: Bool .\b: Nat .b)) else (let u = (pred 0) in (if true then 0 else 1))) ) ) (\a: Bool .\b: Nat .b)) , b = (case <r = (( \f: Nat .((f (((\x: Bool .\y: Rec X. X .y) true ) false) ) ({a = (let u = true in 0) , b = (( \f: Unit .((f false ) false ) ) (\a: Bool .\b: Unit .b)) }.b) ) ) (\a: Rec X. X .\b: Bool .b)) > as Unit of < l = x > => x | < r = y > => y) , c = ({a = (if ({a = 1 , b = (case <r = true > as Unit of < l = x > => x | < r = y > => y) , c =  (if false then 0 else 0) }.b) then (unfold [ Unit ] (fold [ Unit ] 0 )) else ({a = 0 , b = false }.a)) , b = ({a = (( \f: Unit .((f 0 ) 0 ) ) (\a: Bool .\b: Unit .a)) , b = false }.b) , c = (((\x: Bool .\y: Bool .x) (if (fix (\x: Bool . false )) then 0 else 1) ) ({a = false , b = 0 }.a)) }.c) }.c)
({a = (let u = (fix (\x: Nat . (unfold [ Nat ] (fold [ Rec X. X ] false )) )) in u) , b = ({a = (unfold [ Bool ] (fold [ Unit ] (let u = (((\x: Unit .\y: Unit .y) false ) false) in 1) )) , b = (let u = false in (( \f: Rec X. X .((f false ) false ) ) (\a: Unit .\b: Rec X. X .a))) }.a) }.b)
({a = (pred (unfold [ Unit ] (fold [ Bool ] (succ 1) ))) , b = (((\x: Nat .\y: Rec X. X .x) (((\x: Bool .\y: Nat .x) (succ 1) ) true) ) (let u = (let u = 0 in u) in (case <r = true > as Bool of < l = x > => x | < r = y > => y))) }.b)
(( \f: Rec X. X .((f (let u = (let u = (let u = (unfold [ Rec X. X ] (fold [ Bool ] true )) in false) in (let u = false in false)) in u) ) ({a = (unfold [ Nat ] (fold [ Unit ] (if true then 0 else 0) )) , b = (fix (\x: Unit . (if (if true then false else true) then (case <r = true > as Bool of < l = x > => x | < r = y > => y) else false) )) }.b) ) ) (\a: Rec X. X .\b: Unit .a))
(fix (\x: Rec X. X . (( \f: Unit .((f ({a = (fix (\x: Unit . 1 )) , b = (( \f: Nat .((f (fix (\x: Bool . false )) ) ({a = true , b = true }.b) ) ) (\a: Nat .\b: Nat .b)) }.a) ) (((\x: Rec X. X .\y: Bool .x) (succ 0) ) (((\x: Bool .\y: Unit .y) (if false then false else true) ) (let u = false in u))) ) ) (\a: Rec X. X .\b: Rec X. X .b)) ))
({a = (((\x: Unit .\y: Bool .y) (let u = (let u = true in u) in u) ) (unfold [ Rec X. X ] (fold [ Bool ] 1 ))) , b = (fix (\x: Rec X. X . ({a = ({a = 1 , b = true , c =  0 }.b) , b = (iszero 1) }.b) )) }.b)
(( \f: Bool .((f ({a = (( \f: Bool .((f (let u = 1 in u) ) ({a = 0 , b = false , c = 0 }.c) ) ) (\a: Nat .\b: Nat .a)) , b = ({a = 1 , b = false }.b) }.b) ) (if (iszero (let u = (let u = 0 in u) in u)) then ({a = (( \f: Bool .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Unit .a)) , b = (let u = ({a = false , b = 0 }.a) in u) , c =  (( \f: Nat .((f (let u = true in 1) ) (succ 1) ) ) (\a: Nat .\b: Nat .b)) }.b) else (if (let u = (((\x: Nat .\y: Nat .y) false ) (let u = false in true)) in (iszero 1)) then (let u = true in ({a = true , b = 1 }.a)) else (fix (\x: Nat . (let u = false in true) )))) ) ) (\a: Bool .\b: Nat .a))
(let u = (let u = ({a = ({a = 1 , b = 0 }.b) , b = (((\x: Rec X. X .\y: Bool .x) ({a = 0 , b = 1 }.b) ) false) }.b) in ({a = ({a = ({a = 0 , b = false }.a) , b = false }.b) , b = (((\x: Unit .\y: Unit .y) true ) false) }.b)) in (unfold [ Bool ] (fold [ Nat ] (case <l = ({a = 0 , b = 0 }.b) > as Unit of < l = x > => x | < r = y > => y) )))
(if ({a = (( \f: Unit .((f (( \f: Bool .((f true ) false ) ) (\a: Rec X. X .\b: Unit .a)) ) ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .b)) )) ) ) (\a: Nat .\b: Bool .a)) , b = ({a = (let u = (succ (((\x: Bool .\y: Rec X. X .y) false ) 0)) in u) , b = (fix (\x: Nat . ({a = false , b = true }.b) )) }.b) }.b) then (let u = (unfold [ Unit ] (fold [ Unit ] (let u = 1 in true) )) in u) else (((\x: Unit .\y: Nat .x) ({a = (pred ({a = 0 , b = false }.a)) , b = ({a = (((\x: Bool .\y: Nat .y) (((\x: Rec X. X .\y: Bool .x) true ) false) ) 0) , b = (unfold [ Bool ] (fold [ Unit ] false )) , c =  (fix (\x: Bool . 0 )) }.b) }.b) ) ({a = ({a = 0 , b = false , c = 0 }.c) , b = ({a = (unfold [ Rec X. X ] (fold [ Bool ] 0 )) , b = (iszero 1) }.b) , c =  (pred 1) }.b)))
({a = ({a = ({a = (( \f: Bool .((f (fix (\x: Bool . 0 )) ) (let u = 1 in 1) ) ) (\a: Rec X. X .\b: Nat .b)) , b = (((\x: Rec X. X .\y: Bool .y) true ) true) }.a) , b = ({a = (fix (\x: Nat . ({a = 0 , b = true }.b) )) , b = (let u = 0 in 1) }.a) }.b) , b = (( \f: Bool .((f (let u = ({a = 0 , b = false , c = 0 }.c) in u) ) (fix (\x: Unit . (( \f: Bool .((f (( \f: Bool .((f 0 ) (let u = 0 in u) ) ) (\a: Bool .\b: Unit .a)) ) (let u = true in 0) ) ) (\a: Unit .\b: Bool .b)) )) ) ) (\a: Unit .\b: Nat .b)) }.a)
(( \f: Rec X. X .((f (let u = (let u = (if true then 1 else 0) in (case <r = false > as Unit of < l = x > => x | < r = y > => y)) in ({a = ({a = 1 , b = false }.a) , b = (((\x: Bool .\y: Unit .x) false ) true) , c = (case <l = 1 > as Rec X. X of < l = x > => x | < r = y > => y) }.c)) ) (((\x: Nat .\y: Rec X. X .y) (case <r = true > as Rec X. X of < l = x > => x | < r = y > => y) ) (let u = 1 in 1)) ) ) (\a: Unit .\b: Rec X. X .a))
(let u = (unfold [ Bool ] (fold [ Bool ] (let u = ({a = 1 , b = false , c = (((\x: Unit .\y: Rec X. X .x) 0 ) true) }.c) in u) )) in u)
(let u = (pred (if (( \f: Rec X. X .((f ({a = 0 , b = false }.b) ) false ) ) (\a: Bool .\b: Nat .b)) then (if true then 0 else 1) else (let u = ({a = 0 , b = true , c = 1 }.c) in u))) in (pred ({a = ({a = 0 , b = true , c = 1 }.c) , b = ({a = 1 , b = false }.b) , c = ({a = 1 , b = (succ 1) }.b) }.c)))
({a = (succ (( \f: Unit .((f ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 0 )) ) ({a = 0 , b = false }.a) ) ) (\a: Nat .\b: Rec X. X .b))) , b = (let u = (((\x: Unit .\y: Nat .y) (iszero 0) ) (fix (\x: Rec X. X . false ))) in u) }.b)
(succ (let u = ({a = (let u = false in (let u = false in 0)) , b = ({a = false , b = (unfold [ Rec X. X ] (fold [ Unit ] false )) }.b) , c = (((\x: Unit .\y: Nat .y) (unfold [ Rec X. X ] (fold [ Nat ] false )) ) (let u = 0 in u)) }.c) in u))
({a = ({a = ({a = (let u = false in (let u = false in 1)) , b = (let u = true in u) }.b) , b = (if (fix (\x: Nat . false )) then ({a = true , b = 1 }.b) else (let u = 0 in 1)) }.a) , b = ({a = (( \f: Bool .((f true ) false ) ) (\a: Nat .\b: Rec X. X .b)) , b = (if (((\x: Bool .\y: Bool .x) false ) ({a = 0 , b = true }.b)) then (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) else (fix (\x: Unit . 1 ))) }.b) }.b)
({a = (fix (\x: Unit . (unfold [ Unit ] (fold [ Nat ] (( \f: Unit .((f (unfold [ Unit ] (fold [ Rec X. X ] 1 )) ) (let u = true in (( \f: Nat .((f 0 ) 1 ) ) (\a: Unit .\b: Rec X. X .b))) ) ) (\a: Unit .\b: Nat .a)) )) )) , b = (let u = ({a = (let u = ({a = false , b = 0 }.b) in u) , b = ((\x: Nat . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = true , b = false }.b) )) }.b) in u) }.b)
(case <l = (let u = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Unit ] 1 )) in ({a = 0 , b = true , c =  0 }.b)) in (let u = (( \f: Bool .((f (succ 1) ) (( \f: Unit .((f 1 ) 0 ) ) (\a: Bool .\b: Rec X. X .a)) ) ) (\a: Bool .\b: Bool .a)) in u)) > as Bool of < l = x > => x | < r = y > => y)
(let u = (let u = (( \f: Rec X. X .((f (((\x: Unit .\y: Nat .x) false ) true) ) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Bool .a)) ) ) (\a: Rec X. X .\b: Unit .a)) in (( \f: Bool .((f (succ 1) ) 1 ) ) (\a: Bool .\b: Bool .a))) in (pred (case <l = (let u = 0 in 1) > as Nat of < l = x > => x | < r = y > => y)))
(pred (case <l = (( \f: Bool .((f (if ({a = true , b = 1 }.a) then ({a = false , b = 0 }.b) else 1) ) (pred 0) ) ) (\a: Unit .\b: Unit .b)) > as Unit of < l = x > => x | < r = y > => y))
(( \f: Unit .((f (fix (\x: Nat . (((\x: Bool .\y: Bool .x) 0 ) false) )) ) ({a = (pred (fix (\x: Rec X. X . ({a = 1 , b = 1 }.b) ))) , b = (( \f: Unit .((f (let u = 1 in u) ) (fix (\x: Rec X. X . 0 )) ) ) (\a: Bool .\b: Bool .b)) }.b) ) ) (\a: Rec X. X .\b: Rec X. X .b))
(((\x: Bool .\y: Rec X. X .x) (iszero (pred (succ ({a = false , b = 0 }.b)))) ) ({a = (case <l = (succ 0) > as Nat of < l = x > => x | < r = y > => y) , b = (let u = (let u = (let u = false in 1) in 0) in ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (if (let u = true in u) then ({a = false , b = 1 }.a) else false) ))) , c =  (succ (case <l = (let u = 0 in 1) > as Rec X. X of < l = x > => x | < r = y > => y)) }.b))
({a = (let u = (fix (\x: Bool . (( \f: Nat .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) )) in ({a = (let u = 0 in 1) , b = (if (if true then false else true) then 1 else 1) }.b)) , b = ({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (succ ({a = true , b = 1 }.b)) )) , b = (if ({a = true , b = false }.b) then (if ((\x: Nat . unfold [ Unit ] x) (fold [ Nat ] false )) then true else true) else (( \f: Rec X. X .((f (iszero 0) ) false ) ) (\a: Rec X. X .\b: Nat .a))) , c =  (((\x: Nat .\y: Nat .x) (fix (\x: Nat . 0 )) ) (((\x: Nat .\y: Nat .x) (iszero 0) ) true)) }.b) , c = ({a = ({a = true , b = 1 }.b) , b = ({a = (( \f: Bool .((f (((\x: Nat .\y: Rec X. X .y) false ) 1) ) ({a = false , b = 0 }.b) ) ) (\a: Nat .\b: Rec X. X .a)) , b = (((\x: Bool .\y: Nat .x) true ) false) , c =  (let u = 0 in 0) }.b) , c = (unfold [ Nat ] (fold [ Rec X. X ] ({a = 0 , b = false }.a) )) }.c) }.c)
(unfold [ Bool ] (fold [ Rec X. X ] ({a = (((\x: Nat .\y: Nat .x) (((\x: Rec X. X .\y: Bool .x) 1 ) false) ) (((\x: Bool .\y: Nat .x) (( \f: Rec X. X .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) (((\x: Bool .\y: Rec X. X .x) true ) false))) , b = (let u = (unfold [ Unit ] (fold [ Bool ] true )) in ((\x: Unit . unfold [ Unit ] x) (fold [ Rec X. X ] ({a = 0 , b = true }.b) ))) }.b) ))
(let u = (((\x: Unit .\y: Unit .y) ({a = (unfold [ Nat ] (fold [ Unit ] (pred 0) )) , b = (let u = false in u) }.b) ) (( \f: Rec X. X .((f ({a = true , b = false }.b) ) (case <r = true > as Unit of < l = x > => x | < r = y > => y) ) ) (\a: Unit .\b: Nat .b))) in (fix (\x: Nat . (unfold [ Rec X. X ] (fold [ Unit ] ({a = (unfold [ Unit ] (fold [ Bool ] false )) , b = (let u = 1 in u) }.b) )) )))
({a = (if (fix (\x: Rec X. X . false )) then (let u = (( \f: Rec X. X .((f 1 ) 0 ) ) (\a: Nat .\b: Nat .a)) in 1) else (( \f: Bool .((f ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] 0 )) ) (succ 0) ) ) (\a: Rec X. X .\b: Bool .a))) , b = (iszero (if (if (if false then true else true) then true else false) then ({a = 0 , b = (((\x: Unit .\y: Bool .y) true ) false) , c = ({a = true , b = 1 }.b) }.c) else (unfold [ Nat ] (fold [ Bool ] 0 )))) }.a)
(((\x: Rec X. X .\y: Nat .y) (let u = ({a = (let u = 1 in 1) , b = (let u = ({a = false , b = false }.b) in true) }.b) in (iszero ({a = (let u = false in 1) , b = ({a = 0 , b = true }.a) }.b))) ) (( \f: Nat .((f ({a = ((\x: Bool . unfold [ Bool ] x) (fold [ Bool ] true )) , b = (let u = ({a = 1 , b = false }.a) in ({a = 0 , b = true , c = 1 }.c)) }.a) ) (let u = ({a = (( \f: Nat .((f false ) false ) ) (\a: Unit .\b: Unit .a)) , b = (unfold [ Unit ] (fold [ Bool ] 1 )) }.a) in u) ) ) (\a: Unit .\b: Bool .a)))
((\x: Bool . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (fix (\x: Rec X. X . (pred 0) )) in ({a = (if true then 1 else (((\x: Unit .\y: Bool .x) 0 ) false)) , b = (unfold [ Bool ] (fold [ Unit ] true )) , c = (let u = false in 1) }.c)) ))
(( \f: Nat .((f (unfold [ Unit ] (fold [ Rec X. X ] (case <l = (let u = 1 in u) > as Nat of < l = x > => x | < r = y > => y) )) ) ({a = (pred (((\x: Rec X. X .\y: Rec X. X .y) false ) 0)) , b = (((\x: Nat .\y: Nat .x) ({a = true , b = (let u = true in u) }.b) ) (if true then (fix (\x: Bool . true )) else (let u = false in true))) }.a) ) ) (\a: Nat .\b: Nat .b))
((\x: Unit . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ((\x: Nat . unfold [ Bool ] x) (fold [ Unit ] ({a = 1 , b = true , c =  0 }.b) )) , b = (( \f: Rec X. X .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Unit .b)) }.a) ))
(unfold [ Unit ] (fold [ Nat ] ({a = (((\x: Bool .\y: Nat .x) (unfold [ Unit ] (fold [ Nat ] 0 )) ) (iszero ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Bool ] 0 )))) , b = (((\x: Nat .\y: Nat .x) (fix (\x: Unit . false )) ) false) }.b) ))
(( \f: Nat .((f (let u = (fix (\x: Rec X. X . (let u = false in u) )) in (let u = (unfold [ Unit ] (fold [ Rec X. X ] 1 )) in (let u = 0 in true))) ) (let u = (((\x: Rec X. X .\y: Rec X. X .x) ({a = 1 , b = true , c = 0 }.c) ) ({a = 0 , b = false , c =  0 }.b)) in (if ({a = 0 , b = true , c =  0 }.b) then (((\x: Unit .\y: Unit .y) false ) (fix (\x: Unit . true ))) else (let u = false in false))) ) ) (\a: Nat .\b: Nat .a))
(case <l = (( \f: Unit .((f (pred ({a = 1 , b = true }.a)) ) (if ({a = (pred 1) , b = ({a = (let u = false in u) , b = (( \f: Unit .((f true ) true ) ) (\a: Unit .\b: Nat .b)) }.b) , c =  (let u = (iszero 0) in 1) }.b) then (succ 0) else (pred ({a = 0 , b = 1 }.b))) ) ) (\a: Unit .\b: Rec X. X .a)) > as Bool of < l = x > => x | < r = y > => y)
(let u = ((\x: Rec X. X . unfold [ Bool ] x) (fold [ Unit ] (let u = (succ 1) in (succ 1)) )) in u)
({a = (case <l = (fix (\x: Nat . (let u = (case <r = true > as Bool of < l = x > => x | < r = y > => y) in ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Unit ] 1 ))) )) > as Rec X. X of < l = x > => x | < r = y > => y) , b = (pred ((\x: Rec X. X . unfold [ Nat ] x) (fold [ Rec X. X ] 0 ))) }.b)
(if (( \f: Unit .((f (((\x: Rec X. X .\y: Nat .x) true ) (let u = true in u)) ) (case <r = (let u = false in false) > as Nat of < l = x > => x | < r = y > => y) ) ) (\a: Rec X. X .\b: Unit .a)) then (((\x: Nat .\y: Nat .x) (unfold [ Bool ] (fold [ Nat ] (case <r = true > as Bool of < l = x > => x | < r = y > => y) )) ) (case <r = (((\x: Bool .\y: Unit .x) true ) true) > as Unit of < l = x > => x | < r = y > => y)) else (( \f: Nat .((f (unfold [ Unit ] (fold [ Bool ] (( \f: Unit .((f true ) false ) ) (\a: Unit .\b: Rec X. X .a)) )) ) (((\x: Bool .\y: Unit .y) ({a = (((\x: Nat .\y: Unit .x) false ) true) , b = false }.b) ) (iszero 1)) ) ) (\a: Nat .\b: Nat .a)))
(let u = (((\x: Unit .\y: Bool .y) (((\x: Bool .\y: Bool .y) (let u = true in u) ) (let u = true in false)) ) (let u = (case <l = ({a = 1 , b = false }.a) > as Nat of < l = x > => x | < r = y > => y) in (if true then false else false))) in u)
({a = ((\x: Unit . unfold [ Bool ] x) (fold [ Unit ] (pred (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) )) , b = (fix (\x: Rec X. X . ({a = (( \f: Unit .((f (((\x: Rec X. X .\y: Unit .y) true ) 1) ) 1 ) ) (\a: Bool .\b: Nat .a)) , b = (let u = (let u = ((\x: Nat . unfold [ Rec X. X ] x) (fold [ Rec X. X ] 1 )) in 1) in ({a = 0 , b = ({a = true , b = true }.b) , c =  0 }.b)) }.b) )) , c =  ({a = (case <l = (fix (\x: Unit . 1 )) > as Unit of < l = x > => x | < r = y > => y) , b = ((\x: Bool . unfold [ Nat ] x) (fold [ Rec X. X ] ({a = ({a = 1 , b = false }.b) , b = (pred 1) }.b) )) }.b) }.b)
(((\x: Unit .\y: Rec X. X .x) (case <r = (( \f: Bool .((f ({a = false , b = (((\x: Rec X. X .\y: Bool .x) true ) false) }.b) ) (let u = (( \f: Nat .((f false ) false ) ) (\a: Bool .\b: Rec X. X .a)) in (((\x: Bool .\y: Bool .x) false ) false)) ) ) (\a: Bool .\b: Nat .b)) > as Bool of < l = x > => x | < r = y > => y) ) (if (fix (\x: Unit . ({a = false , b = 0 }.a) )) then (((\x: Nat .\y: Unit .x) (let u = true in true) ) (unfold [ Nat ] (fold [ Nat ] true ))) else (if (( \f: Unit .((f false ) true ) ) (\a: Unit .\b: Bool .a)) then (let u = (( \f: Rec X. X .((f false ) false ) ) (\a: Bool .\b: Nat .b)) in u) else (unfold [ Bool ] (fold [ Bool ] false )))))
(( \f: Nat .((f ({a = (fix (\x: Nat . (let u = (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Bool .\b: Rec X. X .b)) in u) )) , b = (let u = ({a = 0 , b = true }.b) in (iszero 1)) , c =  (case <l = (if false then 0 else 1) > as Bool of < l = x > => x | < r = y > => y) }.b) ) (if (let u = ({a = 1 , b = true , c = 0 }.c) in (let u = 0 in (let u = true in true))) then (case <r = (if (( \f: Bool .((f false ) false ) ) (\a: Bool .\b: Nat .a)) then (let u = 0 in false) else (if ({a = false , b = true }.b) then ({a = 0 , b = false }.b) else (if true then true else true))) > as Bool of < l = x > => x | < r = y > => y) else ({a = (unfold [ Rec X. X ] (fold [ Nat ] (let u = (((\x: Rec X. X .\y: Rec X. X .y) false ) 0) in (iszero 0)) )) , b = (((\x: Nat .\y: Unit .x) 0 ) true) }.a)) ) ) (\a: Unit .\b: Bool .a))
((\x: Nat . unfold [ Nat ] x) (fold [ Unit ] (((\x: Rec X. X .\y: Nat .x) (if (let u = false in u) then (let u = true in u) else ({a = 1 , b = false , c =  0 }.b)) ) ({a = ({a = (let u = false in 0) , b = true }.a) , b = ({a = ((\x: Bool . unfold [ Rec X. X ] x) (fold [ Nat ] true )) , b = ({a = 1 , b = false , c = 0 }.c) }.a) , c =  (let u = 1 in 1) }.b)) ))
({a = (fix (\x: Bool . (pred (fix (\x: Rec X. X . 1 ))) )) , b = ({a = (((\x: Nat .\y: Rec X. X .x) ({a = 1 , b = 0 }.b) ) (let u = 0 in true)) , b = ({a = (let u = false in u) , b = (case <l = (succ 1) > as Unit of < l = x > => x | < r = y > => y) }.a) , c =  ((\x: Bool . unfold [ Nat ] x) (fold [ Bool ] (case <l = ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Nat ] 1 )) > as Bool of < l = x > => x | < r = y > => y) )) }.b) }.a)
(pred ({a = (let u = (if false then (( \f: Rec X. X .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Bool .b)) else (((\x: Nat .\y: Unit .y) true ) 1)) in u) , b = (case <r = (unfold [ Bool ] (fold [ Rec X. X ] false )) > as Nat of < l = x > => x | < r = y > => y) , c = (pred (if false then 1 else (pred 0))) }.c))
(case <r = ({a = ({a = ({a = 1 , b = true }.a) , b = ({a = 1 , b = true , c =  1 }.b) }.a) , b = (((\x: Nat .\y: Bool .y) (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) ) ({a = (( \f: Unit .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .b)) , b = (unfold [ Rec X. X ] (fold [ Rec X. X ] true )) , c =  (( \f: Unit .((f 0 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) }.b)) }.b) > as Bool of < l = x > => x | < r = y > => y)
({a = (let u = (let u = ({a = 1 , b = (succ 1) }.b) in (( \f: Bool .((f true ) false ) ) (\a: Unit .\b: Rec X. X .b))) in (succ ({a = false , b = 1 }.b))) , b = (iszero (let u = 0 in u)) }.b)
(((\x: Unit .\y: Unit .x) ({a = (if (let u = false in true) then ({a = 1 , b = false }.a) else (((\x: Rec X. X .\y: Bool .y) (let u = true in u) ) ({a = true , b = 1 }.b))) , b = (( \f: Bool .((f (let u = false in false) ) false ) ) (\a: Unit .\b: Nat .a)) }.a) ) (if (fix (\x: Nat . (fix (\x: Unit . false )) )) then ({a = (( \f: Nat .((f true ) false ) ) (\a: Unit .\b: Nat .b)) , b = 0 }.a) else (unfold [ Rec X. X ] (fold [ Unit ] (((\x: Nat .\y: Bool .x) false ) false) ))))
(((\x: Unit .\y: Nat .y) ({a = (((\x: Unit .\y: Rec X. X .x) (let u = 0 in 0) ) (( \f: Unit .((f true ) false ) ) (\a: Nat .\b: Rec X. X .a))) , b = (let u = (iszero (unfold [ Rec X. X ] (fold [ Rec X. X ] 0 ))) in (let u = true in u)) , c =  (succ (pred 1)) }.b) ) ({a = (unfold [ Unit ] (fold [ Nat ] ({a = false , b = 0 }.a) )) , b = (let u = (( \f: Bool .((f 1 ) 0 ) ) (\a: Unit .\b: Rec X. X .a)) in (((\x: Unit .\y: Unit .y) true ) 0)) }.a))
(let u = (unfold [ Unit ] (fold [ Rec X. X ] (unfold [ Unit ] (fold [ Unit ] ({a = 0 , b = false , c =  ({a = 1 , b = true , c = 1 }.c) }.b) )) )) in ({a = (( \f: Unit .((f (pred 0) ) ({a = 1 , b = true }.a) ) ) (\a: Bool .\b: Bool .b)) , b = ({a = (( \f: Nat .((f 1 ) 0 ) ) (\a: Rec X. X .\b: Nat .a)) , b = (((\x: Rec X. X .\y: Nat .y) false ) true) }.b) , c =  (let u = (case <l = 0 > as Unit of < l = x > => x | < r = y > => y) in (( \f: Unit .((f 1 ) 1 ) ) (\a: Rec X. X .\b: Nat .a))) }.b))
(let u = (succ ({a = ({a = (if (( \f: Rec X. X .((f true ) true ) ) (\a: Nat .\b: Bool .a)) then true else false) , b = (if false then (let u = 0 in 1) else 0) }.b) , b = (let u = (iszero 0) in u) }.a)) in u)
(case <r = ({a = (let u = 0 in (unfold [ Rec X. X ] (fold [ Nat ] 0 ))) , b = (let u = (fix (\x: Nat . true )) in (let u = true in (((\x: Nat .\y: Bool .x) false ) false))) }.b) > as Rec X. X of < l = x > => x | < r = y > => y)
(fix (\x: Unit . (fix (\x: Nat . (((\x: Nat .\y: Rec X. X .y) (((\x: Rec X. X .\y: Rec X. X .y) false ) false) ) (((\x: Bool .\y: Bool .x) (if true then 1 else 1) ) (let u = false in u))) )) ))
((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] (let u = (iszero (((\x: Bool .\y: Bool .x) 1 ) false)) in (unfold [ Nat ] (fold [ Nat ] ({a = 1 , b = true , c = 1 }.c) ))) ))
(unfold [ Rec X. X ] (fold [ Rec X. X ] ({a = (unfold [ Rec X. X ] (fold [ Unit ] ((\x: Rec X. X . unfold [ Unit ] x) (fold [ Rec X. X ] (let u = (((\x: Bool .\y: Nat .x) 0 ) true) in u) )) )) , b = (unfold [ Unit ] (fold [ Nat ] ((\x: Rec X. X . unfold [ Rec X. X ] x) (fold [ Rec X. X ] ({a = 0 , b = false , c =  1 }.b) )) )) , c = (fix (\x: Unit . ({a = (( \f: Bool .((f true ) true ) ) (\a: Rec X. X .\b: Nat .b)) , b = (succ 1) }.b) )) }.c) ))
(iszero (((\x: Nat .\y: Bool .x) ({a = 1 , b = (( \f: Nat .((f true ) true ) ) (\a: Unit .\b: Nat .b)) , c = 0 }.c) ) (( \f: Rec X. X .((f (( \f: Unit .((f false ) true ) ) (\a: Nat .\b: Nat .a)) ) false ) ) (\a: Rec X. X .\b: Nat .a))))
(( \f: Rec X. X .((f (let u = (iszero ({a = 0 , b = 1 }.b)) in (let u = false in 1)) ) ({a = (( \f: Unit .((f (( \f: Bool .((f 0 ) 1 ) ) (\a: Rec X. X .\b: Rec X. X .a)) ) (if true then 1 else 0) ) ) (\a: Rec X. X .\b: Nat .a)) , b = ({a = (let u = 1 in u) , b = (((\x: Rec X. X .\y: Nat .y) true ) 1) }.b) }.b) ) ) (\a: Nat .\b: Unit .b))
(let u = (( \f: Bool .((f (unfold [ Rec X. X ] (fold [ Unit ] (let u = 1 in ({a = 0 , b = true }.b)) )) ) ({a = ({a = true , b = 1 }.b) , b = (( \f: Rec X. X .((f (case <r = (fix (\x: Rec X. X . true )) > as Rec X. X of < l = x > => x | < r = y > => y) ) (fix (\x: Bool . false )) ) ) (\a: Bool .\b: Unit .b)) , c =  (if (let u = 1 in false) then (((\x: Nat .\y: Bool .y) ({a = true , b = 0 }.a) ) 1) else (pred 0)) }.b) ) ) (\a: Rec X. X .\b: Nat .b)) in (succ ({a = (let u = (((\x: Unit .\y: Rec X. X .x) false ) true) in 0) , b = (((\x: Nat .\y: Nat .x) true ) false) , c = (fix (\x: Rec X. X . (( \f: Nat .((f 0 ) 1 ) ) (\a: Nat .\b: Unit .b)) )) }.c)))
